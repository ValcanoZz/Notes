<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/Notes/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/Notes/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/Notes/css/style.css">

  
    
<link rel="stylesheet" href="/Notes/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.1.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/Notes/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/Notes/">Home</a>
        
          <a class="main-nav-link" href="/Notes/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/Notes/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-算法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/Notes/2022/04/14/%E7%AE%97%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2022-04-14T06:55:35.314Z" itemprop="datePublished">2022-04-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/Notes/2022/04/14/%E7%AE%97%E6%B3%95/">算法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><h4 id="X-amp-X"><a href="#X-amp-X" class="headerlink" title="X &amp; -X"></a>X &amp; -X</h4><p><strong>X &amp; -X 得到 二进制数的LowBit</strong>（其二进制最低位的1，其余位均为0）：</p>
<p>-X的值，是在X的基础上进行按位取反之后再加1得到的，</p>
<ul>
<li>当X为偶数时，~X为奇数，奇数加上1会发生进位，最低位的连续的1都会变为0，所以X和 ~X的低位都为0，高位都相反，只有得到进位的那个位置都为1，即X的最右边的1相等，所以，<strong>当一个偶数与它的负值相与时， 结果是能整除这个偶数的最大的2的幂, 即： m &#x3D; n &amp; -n , 则 n % m &#x3D; 0, 且 m &#x3D; 2^k^</strong></li>
<li><strong>当X为奇数时</strong>，因为奇数取反后为偶数，偶数加1并不会影响进位，所以<strong>此时 X &amp; -X 结果一定为1</strong>（奇数最低位的1就在二进制数的末尾）</li>
</ul>
<h2 id="双指针-Two-Pointers"><a href="#双指针-Two-Pointers" class="headerlink" title="双指针   Two Pointers"></a><strong>双指针   Two Pointer</strong>s</h2><h4 id="141：判断链表中是否有环："><a href="#141：判断链表中是否有环：" class="headerlink" title="141：判断链表中是否有环："></a><strong>141：</strong>判断链表中是否有环<strong>：</strong></h4><p>(快慢指针)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LinkList;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">hasCycle</span><span class="params">(<span class="keyword">struct</span> listNode *head)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">slow</span> =</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">fast</span> =</span> head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fast == <span class="literal">NULL</span> || fast-&gt;next == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="344：反转字符串"><a href="#344：反转字符串" class="headerlink" title="344：反转字符串"></a>344：反转字符串</h4><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。</p>
<p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p>
<p>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">char</span> *a, <span class="type">char</span> *b)</span> &#123;</span><br><span class="line">    <span class="type">char</span> t = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span> *s, <span class="type">int</span> sSize)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> left = <span class="number">0</span>, right = sSize - <span class="number">1</span>; left &lt; right; ++left, --right) &#123;</span><br><span class="line">        swap(s + left, s + right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="881：救生艇"><a href="#881：救生艇" class="headerlink" title="881：救生艇"></a>881：救生艇</h4><p>第 i 个人的体重为 people[i]，每艘船可以承载的最大重量为 limit。</p>
<p>每艘船最多可同时载两人，但条件是这些人的重量之和最多为 limit。</p>
<p>返回载到每一个人所需的最小船数。(保证每个人都能被船载)。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：people = [1,2], limit = 3</span><br><span class="line">输出：1</span><br><span class="line">解释：1 艘船载 (1, 2)</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果最重的人可以与最轻的人共用一艘船，那么就这样安排。否则，最重的人无法与任何人配对，那么他们将自己独自乘一艘船。</span></span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *a,<span class="type">const</span> <span class="type">void</span> *b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">int</span>*)a - *(<span class="type">int</span>*)b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">numRescueBoats</span><span class="params">(<span class="type">int</span>* people, <span class="type">int</span> peopleSize, <span class="type">int</span> limit)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(peopleSize == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    qsort(people,peopleSize,<span class="keyword">sizeof</span>(<span class="type">int</span>),cmp);</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>,right = peopleSize - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; left &lt; right; right--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(people[left] + people[right] &lt;= limit)&#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left == right)&#123;</span><br><span class="line">        right--;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="二分查找法-Binary-Search"><a href="#二分查找法-Binary-Search" class="headerlink" title="二分查找法   Binary Search"></a><strong>二分查找法   Binary Search</strong></h2><p>二分査找也称折半査找，其优点是查找速度快，缺点是要求所要査找的数据必须是有序序列。</p>
<p>该算法的基本思想是将所要査找的序列的中间位置的数据与所要査找的元素进行比较，如果相等，则表示査找成功，否则将以该位置为基准将所要査找的序列分为左右两部分。接下来根据所要査找序列的升降序规律及中间元素与所查找元素的大小关系，，对其采用同样的方法进行査找，直至能够确定所要查找的元素是否存在。</p>
<h4 id="704：二分查找"><a href="#704：二分查找" class="headerlink" title="704：二分查找"></a>704：二分查找</h4><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>,right = numsSize - <span class="number">1</span>,mid;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">/* 1: mid = (left + right) / 2</span></span><br><span class="line"><span class="comment">         * 2: mid = left + (right - left) / 2</span></span><br><span class="line"><span class="comment">         * 第2种可以防止(left + right)直接相加数值过大越界的问题</span></span><br><span class="line"><span class="comment">         */</span>        </span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) right = mid - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target) left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="35：搜索插入的位置"><a href="#35：搜索插入的位置" class="headerlink" title="35：搜索插入的位置"></a>35：搜索插入的位置</h4><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>你可以假设数组中无重复元素。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = numsSize - <span class="number">1</span>, mid;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; nums[mid]) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; nums[mid]) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="162：寻找峰值"><a href="#162：寻找峰值" class="headerlink" title="162：寻找峰值"></a>162：寻找峰值</h4><p>峰值元素是指其值大于左右相邻值的元素。</p>
<p>给你一个输入数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。</p>
<p>你可以假设 nums[-1] &#x3D; nums[n] &#x3D; -∞ 。</p>
<p>解：（巧用二分法）</p>
<p>我们可以将 nums 数组中的任何给定序列视为交替的升序和降序序列。</p>
<p>在简单的二分查找中，我们处理的是一个有序数列，并通过在每一步减少搜索空间来找到所需要的数字。在本例中，我们对二分查找进行一点修改。首先从数组 numsnums 中找到中间的元素 midmid。若该元素恰好位于降序序列或者一个局部下降坡度中（通过将 nums[i]nums[i] 与右侧比较判断)，则说明峰值会在本元素的左边。于是，我们将搜索空间缩小为 midmid 的左边(包括其本身)，并在左侧子数组上重复上述过程。</p>
<p>若该元素恰好位于升序序列或者一个局部上升坡度中（通过将 nums[i]nums[i] 与右侧比较判断)，则说明峰值会在本元素的右边。于是，我们将搜索空间缩小为 midmid 的右边，并在右侧子数组上重复上述过程。</p>
<p>就这样，我们不断地缩小搜索空间，直到搜索空间中只有一个元素，该元素即为峰值元素。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">findPeakElement</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span>&#123;</span><br><span class="line">    <span class="type">int</span> Left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> Right = numsSize - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> Mid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(Left &lt; Right)</span><br><span class="line">    &#123;</span><br><span class="line">        iMid = (Left + Right) / <span class="number">2</span>;  </span><br><span class="line">        <span class="keyword">if</span>(nums[Mid] &gt; nums[Mid + <span class="number">1</span>])&#123;</span><br><span class="line">            Right = Mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            Left = Mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="74：搜索二维矩阵"><a href="#74：搜索二维矩阵" class="headerlink" title="74：搜索二维矩阵"></a>74：搜索二维矩阵</h4><p>在m * n矩阵中，搜索是否存在一个目标值。</p>
<p>该矩阵有如下特点：</p>
<ul>
<li><p>每行中的整数从左到右按升序排列；</p>
</li>
<li><p>每行的第一个整数大于前一行的最后一个整数；</p>
<p>示例：</p>
</li>
</ul>
<p><img src="https://assets.leetcode.com/uploads/2020/10/05/mat.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p>两次二分查找：</p>
<p>我们可以对矩阵的第一列的元素二分查找，找到最后一个不大于目标值的元素，然后在该元素所在行中二分查找目标值是否存在。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binarySearchFirstColumn</span><span class="params">(<span class="type">int</span>** matrix, <span class="type">int</span> matrixSize, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> low = <span class="number">-1</span>, high = matrixSize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (high - low + <span class="number">1</span>) / <span class="number">2</span> + low;</span><br><span class="line">        <span class="keyword">if</span> (matrix[mid][<span class="number">0</span>] &lt;= target) &#123;</span><br><span class="line">            low = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">binarySearchRow</span><span class="params">(<span class="type">int</span>* row, <span class="type">int</span> rowSize, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> low = <span class="number">0</span>, high = rowSize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (high - low) / <span class="number">2</span> + low;</span><br><span class="line">        <span class="keyword">if</span> (row[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (row[mid] &gt; target) &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">searchMatrix</span><span class="params">(<span class="type">int</span>** matrix, <span class="type">int</span> matrixSize, <span class="type">int</span>* matrixColSize, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> rowIndex = binarySearchFirstColumn(matrix, matrixSize, target);</span><br><span class="line">    <span class="keyword">if</span> (rowIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> binarySearchRow(matrix[rowIndex], matrixColSize[rowIndex], target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>一次二分查找：</p>
<p>若将矩阵每一行拼接在上一行的末尾，则会得到一个升序数组，我们可以在该数组上二分找到目标元素。</p>
<p>代码实现时，可以二分升序数组的下标，将其映射到原矩阵的行和列上。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">searchMatrix</span><span class="params">(<span class="type">int</span>** matrix, <span class="type">int</span> matrixSize, <span class="type">int</span>* matrixColSize, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">    <span class="type">int</span> m = matrixSize, n = matrixColSize[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = m * n - <span class="number">1</span>,mid;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> a = matrix[mid / n][mid % n];</span><br><span class="line">        <span class="keyword">if</span>(a == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a &gt; target)&#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a &lt; target)&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="滑动窗口-Sliding-Window"><a href="#滑动窗口-Sliding-Window" class="headerlink" title="滑动窗口  Sliding Window"></a><strong>滑动窗口  Sliding Window</strong></h2><h4 id="209：长度最小的子数组"><a href="#209：长度最小的子数组" class="headerlink" title="209：长度最小的子数组"></a>209：长度最小的子数组</h4><p>给定一个含有 n 个正整数的数组和一个正整数 target 。</p>
<p>找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 7, nums = [2,3,1,2,4,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：子数组 [4,3] 是该条件下的长度最小的子数组。</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>,minSize = <span class="number">0</span>, sum = <span class="number">0</span>,ans = INT_MAX;</span><br><span class="line">    <span class="keyword">if</span>(numsSize == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;right &lt; numsSize; right++)&#123;</span><br><span class="line">        sum += nums[right];</span><br><span class="line">        <span class="keyword">while</span>(sum &gt;= target)&#123;</span><br><span class="line">            minSize = right - left + <span class="number">1</span>;</span><br><span class="line">            ans = minSize &lt; ans ? minSize : ans;</span><br><span class="line">            sum -= nums[left];</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans == INT_MAX ? <span class="number">0</span>:ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1456：定长子串中元音的最大数目"><a href="#1456：定长子串中元音的最大数目" class="headerlink" title="1456：定长子串中元音的最大数目"></a>1456：定长子串中元音的最大数目</h4><p>给你字符串 s 和整数 k 。</p>
<p>请返回字符串 s 中长度为 k 的单个子字符串中可能包含的最大元音字母数。</p>
<p>英文中的 元音字母 为（a, e, i, o, u）。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abciiidef&quot;, k = 3</span><br><span class="line">输出：3</span><br><span class="line">解释：子字符串 &quot;iii&quot; 包含 3 个元音字母。</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">maxVowels</span><span class="params">(<span class="type">char</span> *s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, sum = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (s[right] != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[right] == <span class="string">&#x27;a&#x27;</span> || s[right] == <span class="string">&#x27;e&#x27;</span> || s[right] == <span class="string">&#x27;i&#x27;</span> || s[right] == <span class="string">&#x27;o&#x27;</span> || s[right] == <span class="string">&#x27;u&#x27;</span>) &#123;</span><br><span class="line">            sum++;</span><br><span class="line">            ans = sum &gt; ans ? sum : ans;</span><br><span class="line">        &#125;</span><br><span class="line">        right++;</span><br><span class="line">        <span class="keyword">if</span> (right - left + <span class="number">1</span> &gt; k) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (s[left] == <span class="string">&#x27;a&#x27;</span> || s[left] == <span class="string">&#x27;e&#x27;</span> || s[left] == <span class="string">&#x27;i&#x27;</span> || s[left] == <span class="string">&#x27;o&#x27;</span> || s[left] == <span class="string">&#x27;u&#x27;</span>) &#123;</span><br><span class="line">                sum--;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="递归-Recursion"><a href="#递归-Recursion" class="headerlink" title="递归  Recursion"></a><strong>递归  Recursion</strong></h2><h4 id="344：反转字符串-1"><a href="#344：反转字符串-1" class="headerlink" title="344：反转字符串"></a>344：反转字符串</h4><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。</p>
<p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p>
<p>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">char</span> *a, <span class="type">char</span> *b)</span> &#123;</span><br><span class="line">    <span class="type">char</span> t = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">recursion</span><span class="params">(<span class="type">char</span> *s,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    recursion(s,left + <span class="number">1</span>,right - <span class="number">1</span>);</span><br><span class="line">    swap(&amp;s[left],&amp;s[right]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span> *s, <span class="type">int</span> sSize)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(sSize == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    recursion(s,<span class="number">0</span>,sSize - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="206：反转一个单链表。"><a href="#206：反转一个单链表。" class="headerlink" title="206：反转一个单链表。"></a>206：反转一个单链表。</h4><p><strong>示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">reverseList</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">newHead</span> =</span> reverseList(head-&gt;next);</span><br><span class="line">    head-&gt;next-&gt;next = head;</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191708769.png" alt="image-20210402193739408"></p>
<h4 id="687-最长同值路径"><a href="#687-最长同值路径" class="headerlink" title="687:最长同值路径"></a>687:最长同值路径</h4><p>给定一个二叉树，找到最长的路径，这个路径中的每个节点具有相同值。 这条路径可以经过也可以不经过根节点。</p>
<p>注意：两个节点之间的路径长度由它们之间的边数表示。</p>
<p>示例 1:</p>
<p>输入:</p>
<pre><code>          5
         / \
        4   5
       / \   \
      1   1   5
</code></pre>
<p>输出:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>

<p>输入：</p>
<pre><code>          1
         / \
        4   5
       / \   \
      4   4   5
</code></pre>
<p>输出:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>

<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestUnivaluePath</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> dfs(node.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> dfs(node.right);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">arrowLeft</span> <span class="operator">=</span> <span class="number">0</span>, arrowRight = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(node.left != <span class="literal">null</span> &amp;&amp; node.left.val == node.val)</span><br><span class="line">            arrowLeft += left + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="literal">null</span> &amp;&amp; node.left.val == node.val)</span><br><span class="line">            arrowRight += right +  <span class="number">1</span>;</span><br><span class="line">        ans = Math.max(ans, arrowLeft + arrowRight);</span><br><span class="line">        <span class="keyword">return</span> Math.max(arrowLeft, arrowRight);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(a, b) ((a) &gt; (b) ? (a) : (b))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Dfs</span><span class="params">(<span class="keyword">struct</span> TreeNode *root, <span class="type">int</span> *maxDep, <span class="type">int</span> value)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 进入最底层的节点，从下往上计算 */</span></span><br><span class="line">    <span class="type">int</span> leftDep = Dfs(root-&gt;left, maxDep, root-&gt;val);</span><br><span class="line">    <span class="type">int</span> rightDep = Dfs(root-&gt;right, maxDep, root-&gt;val);</span><br><span class="line"></span><br><span class="line">    *maxDep = MAX(*maxDep, leftDep + rightDep); </span><br><span class="line">    <span class="comment">// 从下往上遍历需要时刻更新最大值</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val == value) &#123;</span><br><span class="line">        <span class="keyword">return</span> MAX(leftDep, rightDep) + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">longestUnivaluePath</span><span class="params">(<span class="keyword">struct</span> TreeNode *root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> maxDep = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    Dfs(root, &amp;maxDep, root-&gt;val);</span><br><span class="line">    <span class="keyword">return</span> maxDep;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="分治法-Divide-amp-Conquer"><a href="#分治法-Divide-amp-Conquer" class="headerlink" title="分治法   Divide &amp; Conquer"></a><strong>分治法   Divide &amp; Conquer</strong></h2><p>分治法所能解决的问题一般具有以下几个特征：</p>
<ol>
<li><p>该问题的规模缩小到一定的程度就可以容易地解决</p>
</li>
<li><p>该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。(前提)</p>
</li>
<li><p>利用该问题分解出的子问题的解可以合并为该问题的解；（分治的关键，如果不具备，可以考虑贪心算法和动态规划）</p>
</li>
<li><p>该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。（关系分治的效率，如果要反复求解公共子问题，用动态规划较好）</p>
</li>
</ol>
<p><strong>分治法在每一层递归上都有三个步骤：</strong></p>
<p><strong>step1 分解</strong>：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题；</p>
<p><strong>step2 解决</strong>：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题</p>
<p><strong>step3 合并</strong>：将各个子问题的解合并为原问题的解。</p>
<p><strong>分治法的复杂性分析</strong></p>
<p>一个分治法将<strong>规模为n</strong>的问题分成<strong>k个规模为n／m</strong>的子问题去解。设分解阀值n0&#x3D;1，且adhoc解规模为1的问题耗费1个单位时间。再设将原问题分解为k个子问题以及用merge将k个子问题的解**合并为原问题的解需用f(n)**个单位时间。用T(n)表示该分治法解规模为|P|&#x3D;n的问题所需的计算时间，则有：</p>
<p><strong>T（n）&#x3D; k T(n&#x2F;m)+f(n)</strong></p>
<h3 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169.多数元素"></a>169.多数元素</h3><p>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n&#x2F;2 ⌋ 的元素。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<p><strong>思路：</strong></p>
<p>如果数 a 是数组 nums 的众数，如果我们将 nums 分成两部分，那么 a 必定是至少一部分的众数。</p>
<p>这样以来，我们就可以使用分治法解决这个问题：将数组分成左右两部分，分别求出左半部分的众数 a1 以及右半部分的众数 a2，随后在 a1 和 a2 中选出正确的众数。</p>
<p><strong>算法：</strong></p>
<p>我们使用分治算法递归求解，直到所有的子问题都是长度为 1 的数组。长度为 1 的子数组中唯一的数显然是众数，直接返回即可。如果回溯后某区间的长度大于 1，我们必须将左右子区间的值合并。如果它们的众数相同，那么显然这一段区间的众数是它们相同的值。否则，我们需要比较两个众数在整个区间内出现的次数来决定该区间的众数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">countInRange</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> num, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lo; i &lt;= hi; i++) </span><br><span class="line">            <span class="keyword">if</span> (nums[i] == num) </span><br><span class="line">                count++;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">majorityElementRec</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="comment">//大小为1的数组中唯一的元素是多数</span></span><br><span class="line">        <span class="keyword">if</span> (lo == hi) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[lo];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在这个切片的左右两半上递归。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (hi - lo) / <span class="number">2</span> + lo;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> majorityElementRec(nums, lo, mid);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> majorityElementRec(nums, mid + <span class="number">1</span>, hi);</span><br><span class="line">        <span class="comment">//如果两半在多数元素上达成一致，则返回它。</span></span><br><span class="line">        <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则，计算每个元素并返回“赢家”。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftCount</span> <span class="operator">=</span> countInRange(nums, left, lo, hi);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightCount</span> <span class="operator">=</span> countInRange(nums, right, lo, hi);</span><br><span class="line">        <span class="keyword">return</span> leftCount &gt; rightCount ? left : right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> majorityElementRec(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53.最大子序和"></a>53.最大子序和</h3><p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分治法</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态规划</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="number">0</span>, maxAns = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : nums) &#123;</span><br><span class="line">            pre = Math.max(pre + x, x);</span><br><span class="line">            maxAns = Math.max(maxAns, pre);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxAns;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="回溯法-Backtracking"><a href="#回溯法-Backtracking" class="headerlink" title="回溯法   Backtracking"></a><strong>回溯法   Backtracking</strong></h2><p>（这一类回溯算法的问题需要多练习，结合题目的意思进行编码，以下是一些提示：</p>
<ul>
<li>全排列问题，讲究顺序，因此已经选过的元素还有可能再次被选中放置在不同的位置上，构成不同的排列；</li>
<li>组合问题与子集问题，因为不计算元素顺序，一个元素选还是没有选过很重要，因此需要设置搜索起点，搜索起点之前的元素不再考虑，这样才能做到不重不漏；</li>
<li>不建议去记忆上面的规则，事实上应该根据问题的特点自行推导出来；</li>
<li>编码之前先根据具体的用例画出树形图，图和代码是一一对应的关系，先画图再编码是建议的方式；</li>
<li>如果不是很熟悉，不用苛求一下子写对，编写测试用例调试正确即可。</li>
</ul>
<p>这些问题不难，如果觉得比较混乱，时不时拿出来做一下，最好是都忘记了细节，能够根据题目意思一点一点推导出编码的逻辑）</p>
<h3 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22.括号生成"></a>22.括号生成</h3><p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p>
<p>有效括号组合需满足：左括号必须以正确的顺序闭合。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            getParenthesis(<span class="string">&quot;&quot;</span>,n,n);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">getParenthesis</span><span class="params">(String str,<span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(left == <span class="number">0</span> &amp;&amp; right == <span class="number">0</span> )&#123;</span><br><span class="line">                res.add(str);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(left == right)&#123;</span><br><span class="line">                <span class="comment">//剩余左右括号数相等，下一个只能用左括号</span></span><br><span class="line">                getParenthesis(str+<span class="string">&quot;(&quot;</span>,left-<span class="number">1</span>,right);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">                <span class="comment">//剩余左括号小于右括号，下一个可以用左括号也可以用右括号</span></span><br><span class="line">                <span class="keyword">if</span>(left &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    getParenthesis(str+<span class="string">&quot;(&quot;</span>,left-<span class="number">1</span>,right);</span><br><span class="line">                &#125;</span><br><span class="line">                getParenthesis(str+<span class="string">&quot;)&quot;</span>,left,right-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="77-组合"><a href="#77-组合" class="headerlink" title="77.组合"></a>77.组合</h3><p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p>
<p>你可以按 <strong>任何顺序</strong> 返回答案。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">4</span>, k = <span class="number">2</span></span><br><span class="line">输出：</span><br><span class="line">[[<span class="number">2</span>,<span class="number">4</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">4</span>],]</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//k1判断a中添加元素的个数，n1用于表示加入的值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(Deque&lt;Integer&gt; a, <span class="type">int</span> n, <span class="type">int</span> n1, <span class="type">int</span> k, <span class="type">int</span> k1)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (k1 == k) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(a));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; n1 &lt;= n; n1++) &#123;</span><br><span class="line">            a.add(n1);</span><br><span class="line">            backtrack(a, n, n1 + <span class="number">1</span>, k, k1 + <span class="number">1</span>);</span><br><span class="line">            a.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();	<span class="comment">//栈方便后进先出</span></span><br><span class="line">        backtrack(stack, n, <span class="number">1</span>, k, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="78-子集"><a href="#78-子集" class="headerlink" title="78.子集"></a>78.子集</h3><p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p>
<p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//n为nums长度，m为指示下标</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(Deque&lt;Integer&gt; a, <span class="type">int</span>[] nums, <span class="type">int</span> n, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (m &gt; n) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; m &lt;= n; m++) &#123;</span><br><span class="line">            a.add(nums[m]);</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(a));</span><br><span class="line">            backtrack(a, nums, n, m + <span class="number">1</span>);</span><br><span class="line">            a.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Deque&lt;Integer&gt; a = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(a));</span><br><span class="line">        backtrack(a, nums, n, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46.全排列"></a>46.全排列</h3><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <strong>所有可能的全排列</strong> 。你可以 <strong>按任意顺序</strong> 返回答案。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//a存储每一组答案， ind只放0和1，用来判断nums中的值是否被取过， n为nums长度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(Deque&lt;Integer&gt; a, <span class="type">int</span>[] nums, <span class="type">int</span>[] ind, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (a.size() == n) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(a));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ind[i] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            a.add(nums[i]);</span><br><span class="line">            ind[i] = <span class="number">1</span>;</span><br><span class="line">            backtrack(a, nums, ind, n);</span><br><span class="line">            ind[i] = <span class="number">0</span>;</span><br><span class="line">            a.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        Deque&lt;Integer&gt; a = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] ind = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        backtrack(a, nums, ind, n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="深度优先搜索（DFS）"><a href="#深度优先搜索（DFS）" class="headerlink" title="深度优先搜索（DFS）"></a><strong>深度优先搜索</strong>（DFS）</h2><p><strong>深度优先搜索属于图算法的一种，英文缩写为DFS即Depth First Search。其过程简要来说是对每一个可能的分支路径深入到不能再深入为止，再返回至最近的分支进行搜索，而且每个节点只能访问一次。</strong></p>
<p><strong>常用栈 或 递归 实现</strong></p>
<h4 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200.岛屿数量"></a>200.岛屿数量</h4><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向和&#x2F;或竖直方向上相邻的陆地连接形成。</p>
<p>此外，你可以假设该网格的四条边均被水包围。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]</span><br><span class="line">]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] grid, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> width, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        grid[i][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (j &gt; <span class="number">0</span>)</span><br><span class="line">            dfs(grid, i, j - <span class="number">1</span>, width, length);</span><br><span class="line">        <span class="keyword">if</span> (j &lt; length - <span class="number">1</span>)</span><br><span class="line">            dfs(grid, i, j + <span class="number">1</span>, width, length);</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>)</span><br><span class="line">            dfs(grid, i - <span class="number">1</span>, j, width, length);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; width - <span class="number">1</span>)</span><br><span class="line">            dfs(grid, i + <span class="number">1</span>, j, width, length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="literal">null</span> || grid.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> grid[<span class="number">0</span>].length, width = grid.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; width; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    ans += <span class="number">1</span>;</span><br><span class="line">                    dfs(grid, i, j, width, length);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">searchLand_DFS</span><span class="params">(<span class="type">char</span> **grid, <span class="type">int</span> rowSize, <span class="type">int</span> colSize,<span class="type">int</span> row, <span class="type">int</span> col)</span>&#123;</span><br><span class="line">    <span class="comment">//将搜索过的位置变为0</span></span><br><span class="line">    grid[row][col] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="comment">//向右搜索</span></span><br><span class="line">    <span class="keyword">if</span>((col + <span class="number">1</span> &lt; colSize) &amp;&amp; (grid[row][col + <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>))&#123;</span><br><span class="line">        searchLand_DFS(grid,rowSize,colSize,row,col + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//向下搜索</span></span><br><span class="line">    <span class="keyword">if</span>((row + <span class="number">1</span> &lt; rowSize) &amp;&amp; (grid[row + <span class="number">1</span>][col] == <span class="string">&#x27;1&#x27;</span>))&#123;</span><br><span class="line">        searchLand_DFS(grid, rowSize, colSize, row + <span class="number">1</span>, col);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//向上搜索</span></span><br><span class="line">    <span class="keyword">if</span>((row - <span class="number">1</span> &gt;= <span class="number">0</span>) &amp;&amp; (grid[row - <span class="number">1</span>][col] == <span class="string">&#x27;1&#x27;</span>))&#123;</span><br><span class="line">        searchLand_DFS(grid, rowSize, colSize, row - <span class="number">1</span>, col);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//向左搜索</span></span><br><span class="line">    <span class="keyword">if</span>((col - <span class="number">1</span> &gt;= <span class="number">0</span>) &amp;&amp; (grid[row][col - <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>))&#123;</span><br><span class="line">        searchLand_DFS(grid, rowSize,colSize, row, col - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>** grid, <span class="type">int</span> gridSize, <span class="type">int</span>* gridColSize)</span>&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; gridSize; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt;gridColSize[<span class="number">0</span>]; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                searchLand_DFS(grid,gridSize, gridColSize[<span class="number">0</span>],i,j);</span><br><span class="line">                result += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="938-二叉搜索树的范围和"><a href="#938-二叉搜索树的范围和" class="headerlink" title="938.二叉搜索树的范围和"></a>938.二叉搜索树的范围和</h4><p>给定二叉搜索树的根结点 <code>root</code>，返回值位于范围 <em><code>[low, high]</code></em> 之间的所有结点的值的和。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [10,5,15,3,7,null,18], low = 7, high = 15</span><br><span class="line">输出：32</span><br></pre></td></tr></table></figure>

<p>代码：(这里利用了递归实现深度优先搜索，下面两种代码一样)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rangeSumBST</span><span class="params">(<span class="keyword">struct</span> TreeNode *root, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;val &gt; high)&#123;</span><br><span class="line">        <span class="keyword">return</span> rangeSumBST(root-&gt;left,low,high);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;val &lt; low )&#123;</span><br><span class="line">        <span class="keyword">return</span> rangeSumBST(root-&gt;right,low,high);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  root-&gt;val + </span><br><span class="line">       		rangeSumBST(root-&gt;left,low,high) +</span><br><span class="line">        	rangeSumBST(root-&gt;right,low,high);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rangeSumBST</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="type">int</span> L, <span class="type">int</span> R)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sum = rangeSumBST(root -&gt;left,L,R) + rangeSumBST (root -&gt; right,L,R);</span><br><span class="line">    <span class="keyword">if</span>(root -&gt;val &lt;= R &amp;&amp; root -&gt;val &gt;= L)</span><br><span class="line">        sum += root -&gt;val;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="547-省份数量"><a href="#547-省份数量" class="headerlink" title="547.省份数量"></a>547.省份数量</h4><p>有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。</p>
<p>省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p>
<p>给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i] [j] &#x3D; 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i] [j] &#x3D; 0 表示二者不直接相连。</p>
<p>返回矩阵中 省份 的数量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">isConnected = [[1,1,0],[1,1,0],[0,0,1]]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findCircleNum</span><span class="params">(<span class="type">int</span>[][] isConnected)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> isConnected.length;</span><br><span class="line">        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">                dfs(isConnected, visited, n, i);</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] isConnected, <span class="type">boolean</span>[] visited, <span class="type">int</span> n, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (isConnected[i][j] == <span class="number">1</span> &amp;&amp; !visited[j])&#123;</span><br><span class="line">                visited[j] = <span class="literal">true</span>;</span><br><span class="line">                dfs(isConnected, visited, n, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="方格分割"><a href="#方格分割" class="headerlink" title="方格分割"></a>方格分割</h4><p>有一个6x6的方格，沿着格子的边线剪开成两部分。要求这两部分的形状完全相同。如：</p>
<img src="https://img-blog.csdn.net/20180203161615277?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTkVVUTUwZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" style="zoom:50%;" />

<p>注意：旋转对称的属于同一种分割法。</p>
<p>题解：<br>如果把样例图案剪开，发现有且只有两个点在边界上，且一定经过 （3,3）点<br>那么以（3,3）为起点进行深搜，深搜到一个点那么他的中心对称点相当于也搜过了，如果发现搜到了边界，那么它的中心对称点也到了边界 ，沿着已经搜过的点剪开，那么，剪开的两个图形为中心对称图形，但要注意最终的结果要除以4<br>例如 我们从（3,3）点出发一直向右到边界 ， 或一直向左，或一直向上，或一直向下，剪出来的图形是同一个。</p>
<p>我们从中心点开始搜索，每次可以走四个方向。搜索的过程要将中心对称点顺便标记</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="built_in">map</span>[<span class="number">7</span>][<span class="number">7</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">0</span> || y == <span class="number">0</span> || x == <span class="number">6</span> || y == <span class="number">6</span>)&#123;</span><br><span class="line">        ans++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)&#123;</span><br><span class="line">        <span class="type">int</span> xx = x + dx[i];</span><br><span class="line">        <span class="type">int</span> yy = y + dy[i];</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>[xx][yy] == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">map</span>[xx][yy] = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">map</span>[<span class="number">6</span>- xx][<span class="number">6</span> - yy] = <span class="number">1</span>;</span><br><span class="line">            DFS(xx,yy);</span><br><span class="line">            <span class="built_in">map</span>[xx][yy] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">map</span>[<span class="number">6</span> - xx][<span class="number">6</span> - yy] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">map</span>[<span class="number">3</span>][<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">    DFS(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans/<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="广度优先搜索（BFS）"><a href="#广度优先搜索（BFS）" class="headerlink" title="广度优先搜索（BFS）"></a><strong>广度优先搜索</strong>（BFS）</h2><h4 id="107-二叉树的层序遍历"><a href="#107-二叉树的层序遍历" class="headerlink" title="107.二叉树的层序遍历"></a>107.二叉树的层序遍历</h4><p>给定一个二叉树，返回其节点值自底向上的层序遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">例：给定二叉树 [3,9,20,null,null,15,7],</span><br><span class="line">返回结果：</span><br><span class="line">[</span><br><span class="line">  [15,7],</span><br><span class="line">  [9,20],</span><br><span class="line">  [3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line"></span><br><span class="line">        TreeNode() &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode(<span class="type">int</span> val) &#123;</span><br><span class="line">            <span class="built_in">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">            <span class="built_in">this</span>.val = val;</span><br><span class="line">            <span class="built_in">this</span>.left = left;</span><br><span class="line">            <span class="built_in">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Deque&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            List&lt;Integer&gt; tempNums = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                tempNums.add(temp.val);</span><br><span class="line">                <span class="keyword">if</span> (temp.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.add(temp.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (temp.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.add(temp.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ret.add(tempNums);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(ret);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="200-岛屿数量-1"><a href="#200-岛屿数量-1" class="headerlink" title="200.岛屿数量"></a>200.岛屿数量</h4><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向和&#x2F;或竖直方向上相邻的陆地连接形成。</p>
<p>此外，你可以假设该网格的四条边均被水包围。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]</span><br><span class="line">]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    bfs(grid, i, j);</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(<span class="type">char</span>[][] grid, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        Queue&lt;<span class="type">int</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123; i, j &#125;);</span><br><span class="line">        <span class="keyword">while</span>(!list.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span>[] cur = list.remove();</span><br><span class="line">            i = cur[<span class="number">0</span>]; j = cur[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">0</span> &lt;= i &amp;&amp; i &lt; grid.length &amp;&amp; <span class="number">0</span> &lt;= j &amp;&amp; j &lt; grid[<span class="number">0</span>].length &amp;&amp; grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                grid[i][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                list.add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123; i + <span class="number">1</span>, j &#125;);</span><br><span class="line">                list.add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123; i - <span class="number">1</span>, j &#125;);</span><br><span class="line">                list.add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123; i, j + <span class="number">1</span> &#125;);</span><br><span class="line">                list.add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123; i, j - <span class="number">1</span> &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="547-省份数量-1"><a href="#547-省份数量-1" class="headerlink" title="547.省份数量"></a>547.省份数量</h4><p>有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。</p>
<p>省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p>
<p>给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] &#x3D; 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] &#x3D; 0 表示二者不直接相连。</p>
<p>返回矩阵中 省份 的数量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">isConnected = [[1,1,0],[1,1,0],[0,0,1]]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayDeque;</span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findCircleNum</span><span class="params">(<span class="type">int</span>[][] isConnected)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> isConnected.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] visits = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Deque&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visits[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                q.add(i);</span><br><span class="line">                <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> q.poll();</span><br><span class="line">                    visits[j] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (isConnected[j][k] == <span class="number">1</span> &amp;&amp; visits[k] == <span class="number">0</span>)</span><br><span class="line">                            q.add(k);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h2 id="并查集-Union-Find"><a href="#并查集-Union-Find" class="headerlink" title="并查集  Union Find"></a><strong>并查集  Union Find</strong></h2><h4 id="200-岛屿数量-2"><a href="#200-岛屿数量-2" class="headerlink" title="200.岛屿数量"></a>200.岛屿数量</h4><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向和&#x2F;或竖直方向上相邻的陆地连接形成。</p>
<p>此外，你可以假设该网格的四条边均被水包围。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]</span><br><span class="line">]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="keyword">if</span> (rows == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cols</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span> (cols == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[][] directions = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> rows * cols;</span><br><span class="line">        <span class="comment">// 多开一个结点，把 &#x27;0&#x27; 都与最后这个结点连在一起</span></span><br><span class="line">        <span class="type">UnionFind</span> <span class="variable">unionFind</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnionFind</span>(size + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span>[] direction : directions) &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">newX</span> <span class="operator">=</span> i + direction[<span class="number">0</span>];</span><br><span class="line">                        <span class="type">int</span> <span class="variable">newY</span> <span class="operator">=</span> j + direction[<span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">if</span> (inArea(newX, newY, rows, cols) &amp;&amp; grid[newX][newY] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                            unionFind.union(getIndex(i, j, cols), getIndex(newX, newY, cols));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    unionFind.union(getIndex(i, j, cols), size);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> unionFind.getCount() - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span>[] parent;</span><br><span class="line">        <span class="comment">//连通分量个数</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">UnionFind</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">            count = n;</span><br><span class="line">            parent = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                parent[i] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (x != parent[x]) &#123;</span><br><span class="line">                <span class="comment">// 只实现了路径压缩，并且是隔代压缩</span></span><br><span class="line">                parent[x] = parent[parent[x]];</span><br><span class="line">                x = parent[x];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">rootX</span> <span class="operator">=</span> find(x);</span><br><span class="line">            <span class="type">int</span> <span class="variable">rootY</span> <span class="operator">=</span> find(y);</span><br><span class="line">            <span class="keyword">if</span> (rootX == rootY) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            parent[rootX] = rootY;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">inArea</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> rows, <span class="type">int</span> cols)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x &gt;= <span class="number">0</span> &amp;&amp; x &lt; rows &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; cols;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getIndex</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> cols)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x * cols + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="547-省份数量-2"><a href="#547-省份数量-2" class="headerlink" title="547.省份数量"></a>547.省份数量</h4><p>有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。</p>
<p>省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p>
<p>给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] &#x3D; 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] &#x3D; 0 表示二者不直接相连。</p>
<p>返回矩阵中 省份 的数量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">isConnected = [[1,1,0],[1,1,0],[0,0,1]]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//并查集</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findCircleNum</span><span class="params">(<span class="type">int</span>[][] isConnected)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> isConnected.length;</span><br><span class="line">        <span class="type">int</span>[] parent = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">                <span class="keyword">if</span> (isConnected[i][j] == <span class="number">1</span>)</span><br><span class="line">                    union(parent, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(parent[i] == i)</span><br><span class="line">                ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span>[] parent, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        parent[find(parent, i)] = find(parent, j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span>[] parent, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(parent[index] != index)</span><br><span class="line">            parent[index] = find(parent, parent[index]);</span><br><span class="line">        <span class="keyword">return</span> parent[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="721-账户合并"><a href="#721-账户合并" class="headerlink" title="721.账户合并"></a>721.账户合并</h4><p>给定一个列表 accounts，每个元素 accounts[i] 是一个字符串列表，其中第一个元素 accounts[i][0] 是 名称 (name)，其余元素是 emails 表示该账户的邮箱地址。</p>
<p>现在，我们想合并这些账户。如果两个账户都有一些共同的邮箱地址，则两个账户必定属于同一个人。请注意，即使两个账户具有相同的名称，它们也可能属于不同的人，因为人们可能具有相同的名称。一个人最初可以拥有任意数量的账户，但其所有账户都具有相同的名称。</p>
<p>合并账户后，按以下格式返回账户：每个账户的第一个元素是名称，其余元素是 按字符 ASCII 顺序排列 的邮箱地址。账户本身可以以 任意顺序 返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">输入：accounts = [</span><br><span class="line">    [<span class="string">&quot;John&quot;</span>, <span class="string">&quot;johnsmith@mail.com&quot;</span>, <span class="string">&quot;john00@mail.com&quot;</span>], </span><br><span class="line">    [<span class="string">&quot;John&quot;</span>, <span class="string">&quot;johnnybravo@mail.com&quot;</span>],</span><br><span class="line">    [<span class="string">&quot;John&quot;</span>, <span class="string">&quot;johnsmith@mail.com&quot;</span>, <span class="string">&quot;john_newyork@mail.com&quot;</span>], </span><br><span class="line">    [<span class="string">&quot;Mary&quot;</span>, <span class="string">&quot;mary@mail.com&quot;</span>]</span><br><span class="line">]</span><br><span class="line">输出：[</span><br><span class="line">    [<span class="string">&quot;John&quot;</span>, <span class="string">&#x27;john00@mail.com&#x27;</span>, <span class="string">&#x27;john_newyork@mail.com&#x27;</span>, <span class="string">&#x27;johnsmith@mail.com&#x27;</span>], </span><br><span class="line">    [<span class="string">&quot;John&quot;</span>, <span class="string">&quot;johnnybravo@mail.com&quot;</span>], </span><br><span class="line">    [<span class="string">&quot;Mary&quot;</span>, <span class="string">&quot;mary@mail.com&quot;</span>]</span><br><span class="line">]</span><br><span class="line">解释：</span><br><span class="line">第一个和第三个 John 是同一个人，因为他们有共同的邮箱地址 <span class="string">&quot;johnsmith@mail.com&quot;</span>。 </span><br><span class="line">第二个 John 和 Mary 是不同的人，因为他们的邮箱地址没有被其他帐户使用。</span><br><span class="line">（可以以任何顺序返回这些列表）</span><br></pre></td></tr></table></figure>

<p>根据题意可知：</p>
<ul>
<li>存在相同邮箱的账号一定属于同一个人</li>
<li>名称相同的账户不一定属于同一个人</li>
</ul>
<p><strong>思路：</strong><br>由于名称相同无法判断为同1人，所以只能<strong>使用邮箱是否相同来判断是否为同一人。</strong></p>
<p>这样建立并查集就比较简单了：</p>
<ul>
<li>先初始化每个账户为1个连通分量</li>
<li>遍历每个账户下的邮箱，判断该邮箱是否在其他账户下出现</li>
<li>如果未出现，继续</li>
<li>如果账户A、B下出现了相同的邮箱email，那么将账户A和账户B两个连通分量进行合并</li>
<li>最后遍历并查集中每个连通分量，将所有连通分量内部账户的邮箱全部合并(相同的去重，不同的合并)</li>
<li>结束</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">accountsMerge</span><span class="params">(List&lt;List&lt;String&gt;&gt; accounts)</span> &#123;</span><br><span class="line">        <span class="comment">// 作用：存储每个邮箱属于哪个账户 ，同时 在遍历邮箱时，判断邮箱是否出现过[去重]</span></span><br><span class="line">        <span class="comment">// 格式：&lt;邮箱，账户id&gt;</span></span><br><span class="line">        Map&lt;String, Integer&gt; emailToId = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> accounts.size();<span class="comment">//id个数</span></span><br><span class="line">        <span class="type">UnionFind</span> <span class="variable">myUnion</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnionFind</span>(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> accounts.get(i).size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; num; j++)&#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">curEmail</span> <span class="operator">=</span> accounts.get(i).get(j);</span><br><span class="line">                <span class="comment">//当前邮箱没有出现过</span></span><br><span class="line">                <span class="keyword">if</span>(!emailToId.containsKey(curEmail))&#123;</span><br><span class="line">                    emailToId.put(curEmail, i);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;<span class="comment">//当前邮箱已经出现过，那么代表这两个用户是同一个</span></span><br><span class="line">                    myUnion.union(i, emailToId.get(curEmail));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//进行完上面的步骤，同一个用户的所有邮箱已经属于同一个连通域了，但是就算在同一个连通域，不同的邮箱还是可能会对应不同的id</span></span><br><span class="line">        <span class="comment">// 作用： 存储每个账户下的邮箱</span></span><br><span class="line">        <span class="comment">// 格式： &lt;账户id, 邮箱列表&gt; &gt;</span></span><br><span class="line">        <span class="comment">// 注意：这里的key必须是账户id，不能是账户名称，名称可能相同，会造成覆盖</span></span><br><span class="line">        Map&lt;Integer, List&lt;String&gt;&gt; idToEmails = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//将同一个连通域内的邮箱对应到同一个id【也就是第一次出现的id，比如4、5在同一个连通域，那么这个连通域对应的id就是4】</span></span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;String, Integer&gt; entry : emailToId.entrySet())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> myUnion.find(entry.getValue());</span><br><span class="line">            List&lt;String&gt; emails = idToEmails.getOrDefault(id, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">            emails.add(entry.getKey());</span><br><span class="line">            idToEmails.put(id,emails);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//经过上面的步骤，已经做到了id和邮箱集合对应起来，接下来把用户名对应起来就可以了</span></span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer, List&lt;String&gt;&gt; entry : idToEmails.entrySet())&#123;</span><br><span class="line">            List&lt;String&gt; emails = entry.getValue();</span><br><span class="line">            Collections.sort(emails);</span><br><span class="line">            List&lt;String&gt; tmp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            tmp.add(accounts.get(entry.getKey()).get(<span class="number">0</span>));<span class="comment">//先添加用户名</span></span><br><span class="line">            tmp.addAll(emails);</span><br><span class="line">            res.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] parent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UnionFind</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> index1, <span class="type">int</span> index2)</span> &#123;</span><br><span class="line">        parent[find(index2)] = find(index1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (parent[index] != index) &#123;</span><br><span class="line">            parent[index] = find(parent[index]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h2 id="贪心算法-Greedy"><a href="#贪心算法-Greedy" class="headerlink" title="贪心算法   Greedy"></a><strong>贪心算法</strong>   Greedy</h2><h4 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55.跳跃游戏"></a>55.跳跃游戏</h4><p>给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的<strong>最大长度</strong>。</p>
<p>判断你是否能够到达最后一个下标。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">输入：nums = [2,3,1,1,4]</span><br><span class="line">输出：true</span><br><span class="line">解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。</span><br><span class="line"></span><br><span class="line">输入：nums = [3,2,1,0,4]</span><br><span class="line">输出：false</span><br><span class="line">解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实时维护 最远可以到达的位置。</span></span><br><span class="line"><span class="comment">// 对于当前遍历到的位置 i，如果它在 最远可以到达的位置 的范围内，那么我们就可以从起点通过若干次跳跃到达该位置，</span></span><br><span class="line"><span class="comment">// 因此我们可以用 i + nums[i] 更新最远可以到达的位置。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">far</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">//最远可到达距离必须大于当前位置，否则说明无法到达当前位置</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt;= far) &#123;</span><br><span class="line">                far = Math.max(far, nums[i] + i);</span><br><span class="line">                <span class="keyword">if</span> (far &gt;= n - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h2 id="记忆化搜索-Menory-Search"><a href="#记忆化搜索-Menory-Search" class="headerlink" title="记忆化搜索   Menory Search"></a><strong>记忆化搜索   Menory Search</strong></h2><h2 id="动态规划-Dynamic-Programming"><a href="#动态规划-Dynamic-Programming" class="headerlink" title="动态规划   Dynamic Programming"></a><strong>动态规划   Dynamic Programming</strong></h2><p><strong>动态规划</strong>：先将问题分解为子问题，并且对于这些分解的子问题自身是最优的才能在这个基础上得出我们要解决的问题的最优方案.<br><strong>与贪心算法不同之处</strong>在于，贪心算法是从局部最优来解决问题，而动态规划则是从全局最优来解决问题，当对情况及条件加以限制时，贪心算法会因目光短浅而得到错误答案。<br><strong>记忆化搜索</strong>&#x3D;搜索的形式+动态规划的思想<br>搜索过程中会有很多重复计算，通过记录一些状态的答案减少重复搜索量.<br>搜索过程中一个搜索结果必须可以建立在同类型问题的结果上</p>
<p><strong>联系</strong><br>记忆化搜索与递归一样，都是自顶向下的思路，而动态规划则是自底向上的思路。<br>在平常练习中，我们一般是只考虑一个问题，一般习惯于自顶向下正向思考，这也比较符合人类的逻辑习惯嘛，这便是记忆化搜索（ms）。如果逆向思考，自底向上递推求解，这便是动态规划（dp）了。</p>
<hr>
<p>dp和ms 原理都是相同的，只是实现方法不同<br>可以明显的发现有以下几点不同：</p>
<p>1、DP是从下向上，而记忆化搜索是从上向下的</p>
<p>2、DP是从下向上，为了求到最终结果需要把过程中所有的值都保存下来，以便下一步可能会使用，而因为记忆化搜索是从上向下的，所以求解过程求的都是需要的；也就是说不需要的值并没有求</p>
<p>3、记忆化搜索使用递归实现的；</p>
<p>如果一个dp[i] [j]的值已经求过，使用DP直接调用即可；而使用记忆化搜索则要进入递归</p>
<p>如果一个dp[i] [j]的值还未求过，使用DP直接求得，而使用记忆化搜索则要进入递归中去求，而这个递归很有可能是多重的</p>
<p>这样一来DP在时间上几乎总是优于记忆化搜索的</p>
<hr>
<h4 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322.零钱兑换"></a>322.零钱兑换</h4><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p>
<p>你可以认为每种硬币的数量是无限的。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：coins = [1, 2, 5], amount = 11</span><br><span class="line">输出：3 </span><br><span class="line">解释：11 = 5 + 5 + 1</span><br></pre></td></tr></table></figure>

<p>解答：</p>
<p>我们采用自下而上的方式进行思考。定义 F(i) 为组成金额 i 所需最少的硬币数量，假设在计算 F(i)之前，我们已经计算出 F(0) - F(i-1) 的答案。 则 F(i) 对应的转移方程应为</p>
<p>F(i) &#x3D; min [  F( i - cj )  ]  +  1</p>
<p>{cj 表示第 j 枚硬币的面值，即我们枚举最后一枚硬币时，需要从  i - cj  这个金额状态 F( i - cj ) 转移过来，也就是求出 F( i - cj )  所需的硬币数量，再加1}</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span> *coins, <span class="type">int</span> coinsSize, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">    <span class="comment">/* 1、确定base case */</span></span><br><span class="line">    <span class="type">int</span> dp[amount + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 2、从面值为1开始，计算其dp值 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; amount + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">/* 2.1、确定状态：当前面值的 dp 值为 amount + 1 */</span></span><br><span class="line">        dp[i] = amount + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/* 2.2、确定选择：即为硬币的面值</span></span><br><span class="line"><span class="comment">         * 依次计算当前dp值是否可以再分</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; coinsSize; j++) &#123;</span><br><span class="line">            <span class="comment">/* 判断条件是 i &gt; coins[j](1、2、5) */</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= coins[j]) &#123;</span><br><span class="line">                <span class="comment">/* dp(amount) = min(dp(amount - coins[1、2、5])) + 1 */</span></span><br><span class="line">                dp[i] = (dp[i - coins[j]] + <span class="number">1</span>) &lt; dp[i] ? (dp[i - coins[j]] + <span class="number">1</span>) : dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 3、若当前硬币不能被再分，则返回-1 */</span></span><br><span class="line">    <span class="keyword">return</span> dp[amount] &lt; amount + <span class="number">1</span> ? dp[amount] : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121.买卖股票的最佳时机"></a>121.买卖股票的最佳时机</h4><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p>
<p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>
<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[7,1,5,3,6,4]</span><br><span class="line">输出：5</span><br><span class="line">解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br></pre></td></tr></table></figure>

<p>假如计划在第 i 天卖出股票，那么最大利润的差值一定是在[0, i-1] 之间选最低点买入；所以遍历数组，依次求每个卖出时机的的最大差值，再从中取最大值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>* prices, <span class="type">int</span> pricesSize)</span>&#123;</span><br><span class="line">    <span class="type">int</span> minprice=<span class="number">0xFFFFFF</span>;</span><br><span class="line">    <span class="type">int</span> maxret =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;pricesSize;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices[i] &lt; minprice)&#123;</span><br><span class="line">            minprice = prices[i];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            maxret = (prices[i]-minprice)&gt;maxret ? prices[i]-minprice:maxret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70.爬楼梯"></a>70.爬楼梯</h4><p>假设你正在爬楼梯。需要 <em>n</em> 阶你才能到达楼顶。</p>
<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p><strong>注意：</strong>给定 <em>n</em> 是一个正整数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入： 2</span><br><span class="line">输出： 2</span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶</span><br><span class="line">2.  2 阶</span><br></pre></td></tr></table></figure>

<p>解题思路与斐波那契一致；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最少爬一阶</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>,c = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        a = b;</span><br><span class="line">        b = c;</span><br><span class="line">        c = a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62.不同路径"></a>62.不同路径</h4><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角。</p>
<p>问总共有多少条不同的路径？</p>
<p>动态规划转移方程：</p>
<p><strong>f(i, j) &#x3D; f(i-1, j) + f(i, j-1)</strong></p>
<p>注：网格的边界，它们的值均为 1。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="type">int</span> nums[m][n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) &#123;</span><br><span class="line">                nums[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> nums[i][j] = nums[i - <span class="number">1</span>][j] + nums[i][j - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="221-最大正方形"><a href="#221-最大正方形" class="headerlink" title="221.最大正方形"></a>221.最大正方形</h4><p>在一个由 <code>&#39;0&#39;</code> 和 <code>&#39;1&#39;</code> 组成的二维矩阵内，找到只包含 <code>&#39;1&#39;</code> 的最大正方形，并返回其面积。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [</span><br><span class="line">[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],</span><br><span class="line">[&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],</span><br><span class="line">[&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure>

<p>用<em>dp</em>( i , j ) 表示以 ( i, j ) 为右下角，且只包含 1 的正方形的边长最大值。</p>
<ul>
<li><p>如果该位置的值是 0，则dp( i , j )&#x3D;0，因为当前位置不可能在由 1 组成的正方形中；</p>
</li>
<li><p>如果该位置的值是 1，则 dp( i , j ) 的值由其上方、左方和左上方的三个相邻位置的dp( i , j ) 值决定。具体而言，当前位置的元素值等于三个相邻位置的元素中的最小值加 1，状态转移方程如下：</p>
<p><strong>dp(i, j)&#x3D;min( dp(i−1, j), dp(i−1, j−1), dp(i, j−1) )+1</strong></p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MIN(a,b,c) ((a)&lt;(b)?( (a)&lt;(c)?(a):(c) ):( (b)&lt;(c)?(b):(c) ))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">maximalSquare</span><span class="params">(<span class="type">char</span>** matrix, <span class="type">int</span> matrixSize, <span class="type">int</span>* matrixColSize)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(matrixSize == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j,k,ms = matrix[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;matrixSize;j++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;matrixColSize[j];k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[j][k]==<span class="string">&#x27;1&#x27;</span> &amp;&amp; j&gt;<span class="number">0</span> &amp;&amp; k&gt;<span class="number">0</span>) matrix[j][k] = MIN(matrix[j<span class="number">-1</span>][k],matrix[j][k<span class="number">-1</span>],matrix[j<span class="number">-1</span>][k<span class="number">-1</span>]) + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(matrix[j][k] &gt; ms) ms = matrix[j][k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (ms-<span class="string">&#x27;0&#x27;</span>)*(ms-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279.完全平方数"></a>279.完全平方数</h4><p>给定正整数 <em>n</em>，找到若干个完全平方数（比如 <code>1, 4, 9, 16, ...</code>）使得它们的和等于 <em>n</em>。你需要让组成和的完全平方数的个数最少。</p>
<p>给你一个整数 <code>n</code> ，返回和为 <code>n</code> 的完全平方数的 <strong>最少数量</strong> 。</p>
<p>（完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，<code>1</code>、<code>4</code>、<code>9</code> 和 <code>16</code> 都是完全平方数，而 <code>3</code> 和 <code>11</code> 不是。）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 12</span><br><span class="line">输出：3 </span><br><span class="line">解释：12 = 4 + 4 + 4</span><br></pre></td></tr></table></figure>

<p>这是完全背包问题的简单变形：</p>
<ul>
<li>背包大小即传入的参数<code>n</code></li>
<li>物品的重量是平方数的值<code>sqr</code></li>
<li>物品的价值是<code>1</code>，因为我们要求的是数字个数</li>
</ul>
<p>题目转换为，能用 [1,n]  里的共<code>m</code>个平方数（物品）刚好装满空间为<code>n</code>的背包的所有方法中，产生价值最少的装法。<br>完全背包问题模板：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">记 dp[<span class="number">0.</span>.capa + <span class="number">1</span>] 是备忘录数组</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span> to n</span><br><span class="line">    <span class="keyword">for</span> j = weight[i] to capa</span><br><span class="line">        dp[j] = max( dp[j] , dp[j - weight[i]] + val[i] )</span><br><span class="line">输出 dp[capa]</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &lt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">numSquares</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> *dp = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*(n + <span class="number">1</span>));</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        dp[i] = INT_MAX - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j*j &lt;= i; ++j)&#123;</span><br><span class="line">            dp[i] = min(dp[i],dp[i - j*j] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h4><p>（十一届蓝桥C++-B组）</p>
<p>把 1 ∼ 2020 放在 2 × 1010 的矩阵里。</p>
<p>要求同一行中右边的比左边大，同一列中下边的比上边的大。一共有多少种方案？</p>
<p>答案很大，你只需要给出方案数除以 2020 的余数即可。</p>
<p>题解：（动态规划）</p>
<p>用DP[i] [j]表示第一层有i个数，第二层有j个数有多少种方案</p>
<p>题目要求同一行中右边比左边大， 同一列中下边比上边的大，所以 j &lt;&#x3D; i</p>
<p>1.当j &lt; i 时， DP[i] [j]可以用此时少一个数的方案来表示，少一个数可以是DP[i - 1] [j]，也可以是DP[i] [j - 1]，所以：</p>
<p>DP[i] [j] &#x3D; DP[i - 1] [j] + DP[i] [j - 1]</p>
<p>2.当j &#x3D; i时， 因为要求，所以</p>
<p>DP[i] [j] &#x3D; DP[i] [j - 1]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> DP[<span class="number">1011</span>][<span class="number">1011</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> i, j;</span><br><span class="line">	DP[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">1010</span>; i++) DP[i][<span class="number">0</span>] = <span class="number">1</span>;	<span class="comment">//初始化</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">1010</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (i == j) DP[i][j] = DP[i][j - <span class="number">1</span>];</span><br><span class="line">			<span class="keyword">else</span> DP[i][j] = (DP[i - <span class="number">1</span>][j] + DP[i][j - <span class="number">1</span>]) % <span class="number">2020</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, DP[<span class="number">1010</span>][<span class="number">1010</span>]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;   <span class="comment">// 两行一个数字都不放，也是一种方案</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">1010</span>; i ++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i - <span class="number">1</span> &gt;= j)    <span class="comment">// 转移前的状态也要合法，即第一行的数量不小于第二行的数量</span></span><br><span class="line">            	f[i][j] += f[i - <span class="number">1</span>][j] % <span class="number">2020</span>;</span><br><span class="line">            <span class="keyword">if</span>(j - <span class="number">1</span> &gt;= <span class="number">0</span>)</span><br><span class="line">            	f[i][j] += f[i][j - <span class="number">1</span>] % <span class="number">2020</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



<h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a><strong>背包问题</strong></h3><p>背包问题可以描述为：给定一组物品，每种物品都有自己的<strong>重量</strong>和<strong>价值</strong>，在<strong>限定的总重量</strong>内，如何选择才能使得物品的<strong>总价值</strong>最高。<br>背包问题是典型的动态规划问题。</p>
<p>而背包问题还存在需要<strong>恰好装满</strong>背包和<strong>不需要恰好装满</strong>两种情况</p>
<ol>
<li>01背包问题（每种物品只有一件，放或者不放）</li>
<li>完全背包问题（每件物品有无限件可用）</li>
<li>多重背包问题（每件物品有n[i]件可用）</li>
</ol>
<h4 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h4><p>题目：</p>
<p>有N件物品和一个容量为V的背包。第i件物品的费用是weight[i]，价值是value[i]。求将哪些物品装入背包可使价值总和最大。</p>
<p>”01”的意思是：每种物品仅有一件，放为“1”，不放为“0”。<br>我们假定 f [i] [v] 为将前 i 件物品恰好放入一个容量为V的背包中可获得的最大价值。<br>则其状态转移方程是：</p>
<p><strong>f [i] [V]&#x3D;max{ f [i-1] [V] ,f [i-1] [V-weight[i] ]+value[i] }</strong></p>
<ul>
<li>公式中，即将前 i 件物品放入容量为V 的背包中：<ul>
<li>不放第 i 件：前 i - 1 件物品放入容量为V的背包中，价值为f [i - 1] [V] ;</li>
<li>放第 i 件：前 i - 1 件物品放入剩余容量为 V - weight[i] 的背包中，价值为f [i-1] [V-weight[i] ]+value[i]</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= M; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (weight[i] &lt;= j) &#123;</span><br><span class="line">                f[i][j] = max(f[i - <span class="number">1</span>][j], f[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>还可以将二维数组转化为一维数组，减少空间复杂度：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = V; j &gt;= weight[i]; --j)</span><br><span class="line">            f[j] = max(f[j], f[j - weight[i]] + value[i]);  </span><br></pre></td></tr></table></figure>

<p>具体代码：</p>
<p>（在输出的时候，只能输出最后的价值，不能知道选择的物品是哪个。为此，在这里我们定义一个数组x[i]，对于每一个物品，如果被选择置为“1”，否则为“0”。）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span>   </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  V  100  </span></span><br><span class="line"><span class="type">int</span> f[<span class="number">10</span>][V];<span class="comment">//全局变量，自动初始化为0  </span></span><br><span class="line"><span class="type">int</span> weight[<span class="number">10</span>];  </span><br><span class="line"><span class="type">int</span> value[<span class="number">10</span>];  </span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  max(x,y)   (x)&gt;(y)?(x):(y)  </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="type">int</span> N,M; </span><br><span class="line">    freopen(<span class="string">&quot;1.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,<span class="built_in">stdin</span>); </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;N,&amp;M);<span class="comment">//N物品个数 M背包容量  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N; i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;weight[i],&amp;value[i]); </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//动态规划分析</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=N; i++)  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>; j&lt;=M; j++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">if</span> (weight[i]&lt;=j)  </span><br><span class="line">            &#123;  </span><br><span class="line">                f[i][j]=max(f[i<span class="number">-1</span>][j],f[i<span class="number">-1</span>][j-weight[i]]+value[i]);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">else</span>  </span><br><span class="line">                f[i][j]=f[i<span class="number">-1</span>][j];  </span><br><span class="line">        &#125;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,f[N][M]);<span class="comment">//输出最优解</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">//输出选择的物品</span></span><br><span class="line">    <span class="type">int</span> j = M;</span><br><span class="line">    <span class="type">int</span> x[V];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=N; i&gt;<span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(f[i][j] &gt; f[i<span class="number">-1</span>][j])</span><br><span class="line">        &#123;</span><br><span class="line">            x[i<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">            j = j - weight[i<span class="number">-1</span>];<span class="comment">//装入第i-1个宝石后背包能装入的体积就只剩下j - V[i-1]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;N; ++i)  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, x[i]);  </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<h4 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h4><p>题目：</p>
<p>有N件物品和一个容量为V的背包。第i件物品的费用是weight[i]，价值是value[i]。每件物品可以无限选用，求将哪些物品装入背包可使价值总和最大。</p>
<p>完全背包问题不设定物品取用上限</p>
<p>对于算法的优化我们可以这样想：<br>在01背包问题中，我们要保证第i次循环中的f [i] [v]是由f [i-1] [ V-weight[i] ] 递推而来，每一次都是“加选出<strong>一个（即一种）</strong>物品”而这种方式同时也保证了每件物品只选一次。<br>而完全背包问题的特点刚好是每种物品可选无限件，所以在考虑“加选出<strong>一个（即一种）</strong>物品”时就是单纯的考虑“加选出<strong>一个（可能为同一种）</strong>物品”，这样我们就需要考虑选入的物品是已经选入的情况。相比来说，反而简化了代码。</p>
<p>同样，我们假定f [i] [v]为将前i件物品前恰好放入一个容量为V的背包中可获得的<strong>最大价值</strong><br>则其状态转移方程是：</p>
<p>*<em>f [i] [V]&#x3D;max{ f [i-1] [V]  ,  f [i-1] [ V-k</em>weight[i] ] + k <em>value[i] }</em>*</p>
<p>( 0&lt;&#x3D;k*weight[i]&lt;&#x3D;v，其中0&lt;&#x3D;k&lt;&#x3D;V&#x2F;weight[i+1]  )</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= M; ++j)</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k * weight[i] &lt;= j; ++k)</span><br><span class="line">           	f[i][j] = max(f[i][j], f[i - <span class="number">1</span>][j - k * weight[i]] + k * value[i]);</span><br></pre></td></tr></table></figure>

<p>一维数组：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> j = weight[i]; j &lt;= V; ++j)</span><br><span class="line">        f[j] = max(f[j], f[j - weight[i]] + value[i]); </span><br></pre></td></tr></table></figure>

<p>具体代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  V 1500  </span></span><br><span class="line"><span class="type">int</span> f[<span class="number">10</span>][V];<span class="comment">//全局变量，自动初始化为0  </span></span><br><span class="line"><span class="type">int</span> weight[<span class="number">10</span>];  </span><br><span class="line"><span class="type">int</span> value[<span class="number">10</span>];  </span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  max(x,y)   (x)&gt;(y)?(x):(y)  </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="comment">//f[i][v]=max&#123;f[i-1][v-k*c[i]]+k*w[i]|0&lt;=k*c[i]&lt;=v&#125;，其中0&lt;=k&lt;=V/weight[i+1]</span></span><br><span class="line">    <span class="comment">//f[j]=max(f[j],f[j-weight[i]]+value[i])    </span></span><br><span class="line">    <span class="type">int</span> N,M;  </span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    freopen(<span class="string">&quot;1.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,<span class="built_in">stdin</span>); </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;N,&amp;M);<span class="comment">//N物品个数 M背包容量  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N; i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;weight[i],&amp;value[i]); </span><br><span class="line">    &#125;  </span><br><span class="line">     <span class="comment">//动态规划</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= M; ++j)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k * weight[i] &lt;= j; ++k)</span><br><span class="line">            f[i][j] = max(f[i][j], f[i - <span class="number">1</span>][j - k * weight[i]] + k * value[i]);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,f[N][M]);<span class="comment">//输出最优解  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h4><p>题目：</p>
<p>有N件物品和一个容量为V的背包。第i件物品最多有n[i]个，每个的费用是weight[i]，价值是value[i]。每件物品最多可以选用相应的最大个数，求将哪些物品装入背包可使价值总和最大。<br>多重背包问题设定物品选择上限</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= V; ++j)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt;= num[i] &amp;&amp; k * weight[i] &lt;= j; ++k)</span><br><span class="line">                f[i][j] = max(f[i<span class="number">-1</span>][j], f[i - <span class="number">1</span>][j - k * weight[i]] + k * value[i]);</span><br></pre></td></tr></table></figure>

<p>一维：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> j = V; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= num[i] &amp;&amp; k * weight[i] &lt;= j; ++k)</span><br><span class="line">               f[j] = max(f[j], f[j - k * weight[i]] + k * value[i]);  </span><br></pre></td></tr></table></figure>

<p>具体代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  V 1500  </span></span><br><span class="line"><span class="type">int</span> f[<span class="number">10</span>][V];<span class="comment">//全局变量，自动初始化为0  </span></span><br><span class="line"><span class="type">int</span> weight[<span class="number">10</span>];  </span><br><span class="line"><span class="type">int</span> value[<span class="number">10</span>];   </span><br><span class="line"><span class="type">int</span> num[<span class="number">10</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  max(x,y)   (x)&gt;(y)?(x):(y)  </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="comment">//f[i][v]=max&#123;f[i-1][v-k*c[i]]+k*w[i]|0&lt;=k*c[i]&lt;=v&#125;，其中0&lt;=k&lt;=V/weight[i+1]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//f[j]=max(f[j],f[j-weight[i]]+value[i])    </span></span><br><span class="line">    <span class="type">int</span> N,M,cur;  </span><br><span class="line">    freopen(<span class="string">&quot;2.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,<span class="built_in">stdin</span>); </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;N,&amp;M);<span class="comment">//N物品个数 M背包容量  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N; i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;weight[i],&amp;value[i],&amp;num[i]); </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= V; ++j)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt;= num[i] &amp;&amp; k * weight[i] &lt;= j; ++k)</span><br><span class="line">                f[i][j] = max(f[i<span class="number">-1</span>][j], f[i - <span class="number">1</span>][j - k * weight[i]] + k * value[i]);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,f[N][M]);<span class="comment">//输出最优解</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h3><p>LCS ：longest common sequence</p>
<p>子序列与子串不同，子序列：将给定序列中零个或多个元素去掉之后得到的结果；子串：给定串中任意个连续的字符组成的子序列称为该串的子串</p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191708770.png"></p>
<p>此问题有最优子结构性质：</p>
<p>设序列S<del>1</del>&#x3D;{x<del>1</del>,x<del>2</del>,……x<del>n</del>}和S<del>2</del>&#x3D; {y<del>1</del>,y<del>2</del>,……y<del>m</del>}的最长公共子序列为S&#x3D;{z<del>1</del>,z<del>2</del>,……z<del>k</del>}，则：</p>
<p>1）若x<del>n</del>&#x3D;y<del>m</del>，那么zk&#x3D;xn&#x3D;ym 且S[k-1]是S1[n-1]和S2[m-1]的最长公共子序列</p>
<p>2）若x<del>n</del> !&#x3D; y<del>m</del>且z<del>k</del> !&#x3D; x<del>n</del>，则S[k]是S1[n-1]和S2[m]的最长公共子序列</p>
<p>2）若x<del>n</del> !&#x3D; y<del>m</del>且z<del>k</del>!&#x3D;y<del>m</del>，则S[k]是S1[n]和S2[m-1]的最长公共子序列</p>
<p>可见：两个序列的最长公共子序列包含了这两个序列的前缀的最长公共子序列。因此，最长公共子序列具有最优子结构性质，可以用动态规划求解。 </p>
<p><strong>递推公式：</strong></p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191708771.png" alt="image-20210409174359997"></p>
<p>为了求出LCS中具体的字符，再用一个表格b[i] [j] 表示dp[i] [j]与周边表格的关系（也可以使用dp[i] [j]来推，不必再建一个表格）。</p>
<p>即 S1[i] 和 S2[j] 值相等时dp[i] [j] 的值与右上的dp[i-1] [j-1]有关 ，用1表示 ，以此类推；</p>
<img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191708772.png" alt="image-20210409175042466" style="zoom: 67%;" />



<img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191708773.png" alt="image-20210409175548890" style="zoom:67%;" />













<h2 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h2><p>前缀和是一个数组的某项下标之前(包括此项元素)的所有数组元素的和。</p>
<p>一维数组的前缀和 : sum[i] &#x3D; sum[i-1] + a[i] </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">0</span>) y[i]=x[i];</span><br><span class="line">    <span class="keyword">else</span> y[i]=y[i<span class="number">-1</span>]+x[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二维数组前缀和：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/6857764-1012baa1001812bf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/755/format/webp" alt="img"></p>
<p>二维前缀和实际上就是一个矩阵内值的和，而矩阵又可以由两个行数或列数少一的子矩阵组合后，删去重合部分再加上右下角的值来构成，也就是以下式子：</p>
<p><img src="https://www.zhihu.com/equation?tex=b_%7Bx,y%7D=b_%7Bx-1,y%7D+b_%7Bx,y-1%7D-b_%7Bx-1,y-1%7D+a_%7Bx,y%7D" alt="[公式]"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/6857764-62f86f1fb7ead50b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/803/format/webp" alt="img"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> y=<span class="number">0</span>;y&lt;n;y++)<span class="comment">//n行</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>;x&lt;m;x++)<span class="comment">//m列</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">0</span>&amp;&amp;y==<span class="number">0</span>) b[y][x]=a[y][x];<span class="comment">//左上角的值</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">0</span>) b[y][x]=b[y<span class="number">-1</span>][x]+a[y][x];<span class="comment">//第一列</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(y==<span class="number">0</span>) b[y][x]=b[y][x<span class="number">-1</span>]+a[y][x];<span class="comment">//第一行</span></span><br><span class="line">        <span class="keyword">else</span> b[y][x]=b[y<span class="number">-1</span>][x]+b[y][x<span class="number">-1</span>]-b[y<span class="number">-1</span>][x<span class="number">-1</span>]+a[y][x];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>







<h2 id="前缀树-Trie"><a href="#前缀树-Trie" class="headerlink" title="前缀树   Trie"></a><strong>前缀树   Trie</strong></h2><p>Trie 是一颗非典型的多叉树模型，</p>
<p>多叉：即每个结点的分支数量可能为多个。</p>
<p>非典型：因为它和一般的多叉树不一样，尤其在结点的数据结构设计上，</p>
<p>比如一般的多叉树的结点是这样的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    VALUETYPE value;    <span class="comment">//结点值</span></span><br><span class="line">    TreeNode* children[NUM];    <span class="comment">//指向孩子结点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>而 Trie 的结点是这样的(假设只包含’a’~’z’中的字符)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TrieNode</span> &#123;</span></span><br><span class="line">    <span class="type">bool</span> isEnd; <span class="comment">//该结点是否是一个串的结束</span></span><br><span class="line">    TrieNode* next[<span class="number">26</span>]; <span class="comment">//字母映射表</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>TrieNode结点中并没有直接保存字符值的数据成员，而是用 字母映射表 next ，TrieNode* next[26]中保存了对当前结点而言下一个可能出现的所有字符的链接，因此我们可以通过一个父结点来预知它所有子结点的值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">    <span class="type">char</span> ch = <span class="string">&#x27;a&#x27;</span> + i;</span><br><span class="line">    <span class="keyword">if</span> (parentNode-&gt;next[i] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        说明父结点的后一个字母不可为 ch</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        说明父结点的后一个字母可以是 ch</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Trie代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Trie[] children;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> isEnd;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> &#123;</span><br><span class="line">        children = <span class="keyword">new</span> <span class="title class_">Trie</span>[<span class="number">26</span>];</span><br><span class="line">        isEnd = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">node</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; word.length(); i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> word.charAt(i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(node.children[index] == <span class="literal">null</span>)&#123;</span><br><span class="line">                node.children[index] = <span class="keyword">new</span> <span class="title class_">Trie</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        node.isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">node</span> <span class="operator">=</span> searchPrefix(word);</span><br><span class="line">        <span class="keyword">return</span> node != <span class="literal">null</span> &amp;&amp; node.isEnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> searchPrefix(prefix) != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Trie <span class="title function_">searchPrefix</span><span class="params">(String prefix)</span>&#123;</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">node</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; prefix.length(); i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> prefix.charAt(i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(node.children[index] == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="720-词典中最长的单词"><a href="#720-词典中最长的单词" class="headerlink" title="720.词典中最长的单词"></a>720.词典中最长的单词</h4><p>给出一个字符串数组words组成的一本英语词典。从中找出最长的一个单词，该单词是由words词典中其他单词逐步添加一个字母组成。若其中有多个可行的答案，则返回答案中字典序最小的单词。</p>
<p>若无答案，则返回空字符串。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">words = [&quot;w&quot;,&quot;wo&quot;,&quot;wor&quot;,&quot;worl&quot;, &quot;world&quot;]</span><br><span class="line">输出：&quot;world&quot;</span><br><span class="line">解释： </span><br><span class="line">单词&quot;world&quot;可由&quot;w&quot;, &quot;wo&quot;, &quot;wor&quot;, 和 &quot;worl&quot;添加一个字母组成。</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">words = [&quot;a&quot;, &quot;banana&quot;, &quot;app&quot;, &quot;appl&quot;, &quot;ap&quot;, &quot;apply&quot;, &quot;apple&quot;]</span><br><span class="line">输出：&quot;apple&quot;</span><br><span class="line">解释：</span><br><span class="line">&quot;apply&quot;和&quot;apple&quot;都能由词典中的单词组成。但是&quot;apple&quot;的字典序小于&quot;apply&quot;。</span><br></pre></td></tr></table></figure>

<p><strong>思路：</strong></p>
<p>将所有单词插入 <code>trie</code>，然后从 <code>trie</code> 进行深度优先搜索，每找到一个单词表示该单词的全部前缀均存在，我们选取长度最长的单词。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    Trie[] children;</span><br><span class="line">    <span class="type">boolean</span> isEnd;</span><br><span class="line">    String word; <span class="comment">// 用来保存当前遍历的 word</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> &#123;</span><br><span class="line">        children = <span class="keyword">new</span> <span class="title class_">Trie</span>[<span class="number">26</span>];</span><br><span class="line">        isEnd = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">Trie</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Trie</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestWord</span><span class="params">(String[] words)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            insert(word);</span><br><span class="line">        &#125;</span><br><span class="line">        getMaxLengthWord(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 调用 insert()insert() 方法时：</span></span><br><span class="line"><span class="comment">若遍历的当前字符串 word 中的某个字符所在字母表中的位置上在对应 children[26] 数组中没有节点，即 **node.children[c - &#x27;a&#x27;] == null**，则在该位置上定义一个新的 Trie 节点并且 node 指向新定义的节点，即 **node = node.children[c - &#x27;a&#x27;]**。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">当 word 全部遍历完成时，此时 node 为 word 中的最后一个位置上的节点，此时将 isEnd 设置为 true 表示该 word 已经遍历完并全部插入到 Trie 树中并将该 word 保存到最后一个节点上，即 **node.word = word**。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> word.length();</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">node</span> <span class="operator">=</span> <span class="built_in">this</span>.root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> word.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (node.children[c - <span class="string">&#x27;a&#x27;</span>] == <span class="literal">null</span>) &#123;</span><br><span class="line">                node.children[c - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> <span class="title class_">Trie</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        node.isEnd = <span class="literal">true</span>;</span><br><span class="line">        node.word = word;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 当调用 **getMaxLengthWord()** 方法时：</span></span><br><span class="line"><span class="comment">若当前传入的节点不是最后一个位置上节点而是中间某位置的节点，此时直接结束。</span></span><br><span class="line"><span class="comment">	若当前传入的节点的深度 deep &gt; maxLength，此时应该更新 maxLength的值并且将该节点对应的 word保存下来。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="comment">// 通过递归遍历 node 的 children 数组并且每遍历一次深度 deep 增加 1：DFS</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getMaxLengthWord</span><span class="params">(Trie node, <span class="type">int</span> deep)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (deep &gt; <span class="number">0</span> &amp;&amp; !node.isEnd) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span> (deep &gt; maxLength) &#123;</span><br><span class="line">            res = node.word;</span><br><span class="line">            maxLength = deep;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历当前传入节点的 children[26]children[26] 对每一个不为空的节点都进行深度搜索</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.children[i] != <span class="literal">null</span>) &#123;</span><br><span class="line">                getMaxLengthWord(node.children[i], deep + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="题目顺序"><a href="#题目顺序" class="headerlink" title="题目顺序"></a>题目顺序</h2><p><strong>leetcode</strong></p>
<ul>
<li>数组Arrary：485，283，27</li>
<li>链表Linked List: 203,206</li>
<li>队列Queue：933，225（用队列实现<strong>栈</strong>），622，64</li>
<li>栈Atack：20，496，232（用栈实现队列）</li>
<li>哈希表Hash Table：217，389，496</li>
<li>集合Set：217，705（设计哈希集合）</li>
<li>堆Heap：215，692</li>
<li>树&#x2F;图：各种算法</li>
<li>双指针算法Two Pointers：141，344，881</li>
<li>二分查找法Binary Search(模板）：704，35，162，74</li>
<li>滑动窗口Sliding Window：209，1456</li>
<li>递归算法Recursion（开始练习时用笔画）：509，206，344，687</li>
<li>分治算法Divide &amp; Conquer：169，53</li>
<li>回溯算法Backtracking：22，78，77，46（全部非常经典）</li>
<li>深度优先搜索DFS：200，547，721</li>
<li>宽度优先搜索BFS：102，107，200</li>
<li>并查集Union Find（模板）：200，547，<strong>721</strong></li>
<li>贪心算法Greedy：<strong>322</strong>，1217，55</li>
<li>记忆化搜索Memoization：509，322</li>
<li><strong>动态规划</strong>Bynamic Bogramming：509，62，121，70，279，221</li>
<li>拓扑排序Topologic Sort：207，210</li>
<li>前缀Trie：208（模板），<strong>720</strong>，692</li>
</ul>
<h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><p>判断闰年：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> m[<span class="number">13</span>]=&#123;<span class="number">0</span>,<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;;</span><br><span class="line"><span class="keyword">if</span>(year%<span class="number">400</span>==<span class="number">0</span>||year%<span class="number">4</span>==<span class="number">0</span>&amp;&amp;year%<span class="number">100</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">//是闰年，m[2]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反转数组：</p>
<p>Collections.reverse(ret);</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/04/14/%E7%AE%97%E6%B3%95/" data-id="cl1ynefme000bswtu09lihe7n" data-title="算法" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-数据结构" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/Notes/2022/04/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="article-date">
  <time class="dt-published" datetime="2022-04-14T06:55:35.306Z" itemprop="datePublished">2022-04-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/Notes/2022/04/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h2 id="欠缺"><a href="#欠缺" class="headerlink" title="欠缺"></a>欠缺</h2><p>数组：广义表</p>
<p>树：<del>层次遍历算法</del>，线索二叉树，<del>二叉搜索(排序)树BST，自平衡二叉树AVL（左旋右旋）</del>，<del>B树（多路平衡查找树）</del>，<del>B+树</del>，——红黑树</p>
<p>并查集：</p>
<p>图：</p>
<h2 id="数组-Arrarry"><a href="#数组-Arrarry" class="headerlink" title="数组  Arrarry"></a><strong>数组  Arrarry</strong></h2><p><a href="#java%E6%95%B0%E7%BB%84">java</a></p>
<p>C</p>
<ul>
<li>使用数组中的第 i + 1 个元素：1.数组名[i]  ;  或者使用指针*p &#x3D; &amp;数组：　*（p +ｉ）</li>
</ul>
<p>C 语言不允许返回一个完整的数组作为函数的参数。</p>
<p>想要从函数返回一个数组，需先声明一个返回指针的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * <span class="title function_">myFunction</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C 不支持在函数外返回局部变量的地址，除非定义局部变量为 <strong>static</strong> 变量。</p>
<p>示例（生成随机数，并用数组返回）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * <span class="title function_">getRandom</span><span class="params">( )</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span>  r[<span class="number">10</span>];</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 设置种子 */</span></span><br><span class="line">  srand( (<span class="type">unsigned</span>)time( <span class="literal">NULL</span> ) );</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)&#123;</span><br><span class="line">     r[i] = rand();</span><br><span class="line">     <span class="built_in">printf</span>( <span class="string">&quot;r[%d] = %d\n&quot;</span>, i, r[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 要调用上面定义函数的主函数 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span>&#123;</span><br><span class="line">   <span class="comment">/* 一个指向整数的指针 */</span></span><br><span class="line">   <span class="type">int</span> *p;</span><br><span class="line">   <span class="type">int</span> i;</span><br><span class="line"> </span><br><span class="line">   p = getRandom();</span><br><span class="line">   <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ ) &#123;</span><br><span class="line">       <span class="built_in">printf</span>( <span class="string">&quot;*(p + %d) : %d\n&quot;</span>, i, *(p + i));</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a name = "java数组">

<p> <strong>java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.数组创建</span></span><br><span class="line">        <span class="comment">//solution 1</span></span><br><span class="line">        <span class="type">int</span>[] a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;a: &quot;</span> + Arrays.toString(a));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//solution 2</span></span><br><span class="line">        <span class="type">int</span>[] b = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;b: &quot;</span> + Arrays.toString(b));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//solution 3</span></span><br><span class="line">        <span class="type">int</span>[] c = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            c[i] = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;c: &quot;</span> + Arrays.toString(c));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//solution 4</span></span><br><span class="line">        ArrayList&lt;Integer&gt; arr = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            arr.add(i + <span class="number">1</span>);<span class="comment">//add方法：括号内为(数组索引值,元素），索引值可以不加，则将元素插入到末尾</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;arr: &quot;</span> + arr.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.添加元素</span></span><br><span class="line">        arr.add(<span class="number">99</span>);        <span class="comment">//O(1)</span></span><br><span class="line">        arr.add(<span class="number">3</span>, <span class="number">88</span>);     <span class="comment">//O(N)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.访问元素 : O(1)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c1</span> <span class="operator">=</span> c[<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">arr1</span> <span class="operator">=</span> arr.get(<span class="number">1</span>);      <span class="comment">//()里为索引值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.更新元素 ：O(1)</span></span><br><span class="line">        c[<span class="number">1</span>] = <span class="number">11</span>;</span><br><span class="line">        arr.set(<span class="number">1</span>, <span class="number">11</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.删除元素 ： O(N)</span></span><br><span class="line">        arr.remove(<span class="number">1</span>);      <span class="comment">//删除下标为1处的元素</span></span><br><span class="line">        arr.remove(Integer.valueOf(<span class="number">4</span>));     <span class="comment">//删除第一个值为4的元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.size(); i++) &#123;      <span class="comment">//删除所有值为3的元素</span></span><br><span class="line">            <span class="keyword">if</span> (arr.get(i) == <span class="number">3</span>) &#123;</span><br><span class="line">                arr.remove(i--);        <span class="comment">//每删除一个元素后当前下标应-1，否则会漏掉下一个元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.数组长度 ：O(1)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cSize</span> <span class="operator">=</span> c.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">arrSize</span> <span class="operator">=</span> arr.size();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7.遍历数组 </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; c.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> c[i];</span><br><span class="line">            System.out.println(<span class="string">&quot;c at index &quot;</span> + i + <span class="string">&quot;: &quot;</span> + current);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.size(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> arr.get(i);</span><br><span class="line">            System.out.println(<span class="string">&quot;c at index &quot;</span> + i + <span class="string">&quot;: &quot;</span> + current);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//8.查找元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; c.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c[i] == <span class="number">99</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;we found 99 at int c!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">is99</span> <span class="operator">=</span> arr.contains(<span class="number">99</span>);    <span class="comment">//找到目标值则返回True</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//9. 数组排序 : O(N logN)</span></span><br><span class="line">        Arrays.sort(c);</span><br><span class="line">        Collections.sort(arr);  <span class="comment">//升序排列</span></span><br><span class="line">        Collections.sort(arr, Collections.reverseOrder());  <span class="comment">//降序排列</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组的时间复杂度"><a href="#数组的时间复杂度" class="headerlink" title="数组的时间复杂度"></a>数组的时间复杂度</h3><p>访问（Access）：O（1）</p>
<p>搜索（Search）：O（N)</p>
<p>插入（Insert）：O（N）</p>
<p>删除（Delete）：O（N）</p>
<h2 id="链表-Linked-List"><a href="#链表-Linked-List" class="headerlink" title="链表  Linked List"></a><strong>链表  Linked List</strong></h2><p><a href="#java%E9%93%BE%E8%A1%A8">java</a></p>
<p> <strong>C</strong></p>
<p>创建链表：</p>
<p>创建结构变量指针，使用前要先分配内存空间</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建链表</span></span><br><span class="line">LinkList *<span class="title function_">CreatList</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    LinkList *head = (LinkList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkList));</span><br><span class="line">    LinkList *temp = head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        LinkList *a = (LinkList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkList));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a-&gt;data);</span><br><span class="line">        a-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        temp-&gt;next = a;</span><br><span class="line">        temp = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改链表结点的值</span></span><br><span class="line">LinkList  <span class="title function_">changeList</span><span class="params">(LinkList *<span class="built_in">list</span>, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    LinkList *temp = <span class="built_in">list</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n &amp;&amp; temp != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(temp != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入要修改的值：&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;temp-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;结点不存在&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向链表的第n个位置插入数据</span></span><br><span class="line">LinkList *<span class="title function_">insert</span><span class="params">(LinkList *<span class="built_in">list</span>, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    LinkList *temp = <span class="built_in">list</span>;   <span class="comment">//temp用于表示插入位置的上一个结点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(temp ==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;插入位置无效\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp =  temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    LinkList  *in = (LinkList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkList));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;in-&gt;data);</span><br><span class="line">    in-&gt;next = temp-&gt;next;</span><br><span class="line">    temp-&gt;next = in;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除链表中第n个节点</span></span><br><span class="line">LinkList *<span class="title function_">delete</span><span class="params">(LinkList *<span class="built_in">list</span>, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    LinkList *temp = <span class="built_in">list</span>;    <span class="comment">//temp用于表示删除位置的上一个结点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    LinkList *del = temp-&gt;next;</span><br><span class="line">    temp-&gt;next = temp-&gt;next-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(del);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">display</span><span class="params">(LinkList *<span class="built_in">list</span>)</span>&#123;</span><br><span class="line">    LinkList *temp = <span class="built_in">list</span>;</span><br><span class="line">    <span class="keyword">while</span>(temp-&gt;next)&#123;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,temp-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="头插法和尾插法："><a href="#头插法和尾插法：" class="headerlink" title="头插法和尾插法："></a>头插法和尾插法：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">void</span> <span class="title function_">output</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span> *head)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾插法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">creat</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span> *head, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list</span> *<span class="title">p</span>, *<span class="title">q</span>;</span></span><br><span class="line">	head-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	p=head;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">		q=(<span class="keyword">struct</span> <span class="built_in">list</span>*)<span class="built_in">malloc</span>( <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <span class="built_in">list</span>) );</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q-&gt;data);</span><br><span class="line">		q-&gt;next = p-&gt;next;</span><br><span class="line">		p-&gt;next=q;</span><br><span class="line">		p=q;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//头插法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">creat_1</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span> *head, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list</span> *<span class="title">p</span>;</span></span><br><span class="line">	head-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">		p=(<span class="keyword">struct</span> <span class="built_in">list</span>*)<span class="built_in">malloc</span>( <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <span class="built_in">list</span>) );</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p-&gt;data);</span><br><span class="line">		p-&gt;next=head-&gt;next;</span><br><span class="line">		head-&gt;next=p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">output</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span> *head)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list</span> *<span class="title">p</span>=</span>head-&gt;next;</span><br><span class="line">	<span class="keyword">while</span>(p)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>, p-&gt;data);</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list</span> *<span class="title">head</span>;</span></span><br><span class="line">	head=(<span class="keyword">struct</span> <span class="built_in">list</span>*)<span class="built_in">malloc</span>( <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <span class="built_in">list</span>) );</span><br><span class="line">	creat(head, <span class="number">5</span>);</span><br><span class="line">	output(head);</span><br><span class="line"></span><br><span class="line">	creat_1(head, <span class="number">5</span>);</span><br><span class="line">	output(head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a name = "java链表">

<p><strong>java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建链表</span></span><br><span class="line">        LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.添加元素</span></span><br><span class="line">        list.add(<span class="number">1</span>);    <span class="comment">//O(1)</span></span><br><span class="line">        list.add(<span class="number">2</span>, <span class="number">99</span>); <span class="comment">//O(N)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.访问元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">element</span> <span class="operator">=</span> list.get(<span class="number">2</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4.搜索元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> list.indexOf(<span class="number">99</span>);   <span class="comment">//搜索元素值，然后返回索引值(下标)</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5.更新元素 : O(N)</span></span><br><span class="line">        list.set(<span class="number">2</span>,<span class="number">88</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//6.删除元素 : O(N)</span></span><br><span class="line">        list.remove(<span class="number">2</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//7.长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> list.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203.移除链表元素"></a>203.移除链表元素</h4><p>给你一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> ，请你删除链表中所有满足 <code>Node.val == val</code> 的节点，并返回 <strong>新的头节点</strong> 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,6,3,4,5,6], val = 6</span><br><span class="line">输出：[1,2,3,4,5]</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="comment">//设置哨兵节点，便于删除头节点</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        pre.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> pre;</span><br><span class="line">        <span class="keyword">while</span> (temp.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.next.val == val)&#123;</span><br><span class="line">                temp.next = temp.next.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        head.next = removeElements(head.next, val);</span><br><span class="line">        <span class="keyword">return</span> head.val == val ? head.next : head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//设置哨兵节点，便于删除链表头部节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">sentinel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);	<span class="comment">//sentinel：哨兵</span></span><br><span class="line">        sentinel.next = head;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> ans, curr = head;</span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curr.val == val)&#123;</span><br><span class="line">                prev.next = curr.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                prev = curr;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sentinel.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a>206.反转链表</h4><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5]</span><br><span class="line">输出：[5,4,3,2,1]</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="comment">//迭代</span></span><br><span class="line"> <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> curr.next;</span><br><span class="line">            curr.next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> reverseList(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>, curr = head;</span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> curr.next;</span><br><span class="line">            curr.next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="链表的时间复杂度"><a href="#链表的时间复杂度" class="headerlink" title="链表的时间复杂度"></a>链表的时间复杂度</h3><p>访问（Access）：O（N）</p>
<p>搜索（Search）：O（N)</p>
<p>插入（Insert）：O（1）</p>
<p>删除（Delete）：O（1）</p>
<h2 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列  Queue"></a><strong>队列  Queue</strong></h2><p><a href="#java%E9%98%9F%E5%88%97">java</a></p>
<p><strong>C</strong></p>
<p>判断队列是否为空：</p>
<ol>
<li>设置一个标志变量；</li>
<li>当队列满时，保留一个元素空间；设队列最大尺寸为QueueSize，则<strong>队列满的条件是：（rear+1）%QueueSize &#x3D;&#x3D; front</strong>。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> QuDataType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QListNode</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QListNode</span> *_<span class="title">next</span>;</span></span><br><span class="line">    QuDataType _data;</span><br><span class="line">&#125;QueueNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//队列的结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span>&#123;</span></span><br><span class="line">    QueueNode *_front;</span><br><span class="line">    QueueNode *_rear;</span><br><span class="line">&#125;Queue;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QueueInit</span><span class="params">(Queue *q)</span>;<span class="comment">//初始化队列</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QueuePush</span><span class="params">(Queue *q,QuDataType data)</span>;<span class="comment">//队尾入队列</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QueuePop</span><span class="params">(Queue *q)</span>;<span class="comment">//队头出队列</span></span><br><span class="line"></span><br><span class="line">QuDataType <span class="title function_">QueueFront</span><span class="params">(Queue* q)</span>;<span class="comment">// 获取队列头部元素</span></span><br><span class="line"></span><br><span class="line">QuDataType <span class="title function_">QueueBack</span><span class="params">(Queue* q)</span>;<span class="comment">// 获取队列队尾元素</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">QueueSize</span><span class="params">(Queue* q)</span>;<span class="comment">// 获取队列中有效元素个数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">QueueEmpty</span><span class="params">(Queue* q)</span>;<span class="comment">// 检测队列是否为空，如果为空返回非零结果，如果非空返回0</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QueueDestroy</span><span class="params">(Queue* q)</span>;<span class="comment">// 销毁队列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一个数据入队列必须要先创建节点</span></span><br><span class="line">QueueNode * <span class="title function_">BuyQueueNode</span><span class="params">(QuDataType x)</span>&#123;    <span class="comment">//创建节点并初始化此节点</span></span><br><span class="line">    QueueNode * cur = (QueueNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QueueNode));</span><br><span class="line">    cur-&gt;_data = x;</span><br><span class="line">    cur-&gt;_next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QueueInit</span><span class="params">(Queue* q)</span>&#123; <span class="comment">//初始化队列结构</span></span><br><span class="line">    q-&gt;_front = <span class="literal">NULL</span>;</span><br><span class="line">    q-&gt;_rear = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QueuePush</span><span class="params">(Queue* q, QuDataType x)</span> &#123; <span class="comment">//队列尾部入数据</span></span><br><span class="line">    QueueNode * cur = BuyQueueNode(x);  <span class="comment">//先把创建好的节点传过来</span></span><br><span class="line">    <span class="keyword">if</span> (q-&gt;_front == <span class="literal">NULL</span>)&#123;             <span class="comment">//若是队列本身为空，队列里就只有这一个节点，又为队列头又为队列尾</span></span><br><span class="line">        q-&gt;_front = q-&gt;_rear = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        q-&gt;_rear-&gt;_next = cur; <span class="comment">//否则，链表尾插操作</span></span><br><span class="line">        q-&gt;_rear = cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QueuePop</span><span class="params">(Queue* q)</span> &#123;    <span class="comment">//队列头部出数据</span></span><br><span class="line">    <span class="keyword">if</span> (q-&gt;_front == <span class="literal">NULL</span>)&#123;    <span class="comment">//本身队列为空，不做操作</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    QueueNode* tmp = q-&gt;_front-&gt;_next;   <span class="comment">//先保留下一个节点，防止断链</span></span><br><span class="line">    <span class="built_in">free</span>(q-&gt;_front);</span><br><span class="line">    q-&gt;_front = tmp;   <span class="comment">//更新对列头部</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QuDataType <span class="title function_">QueueFront</span><span class="params">(Queue* q)</span>&#123;   <span class="comment">//获取队列首部元素</span></span><br><span class="line">    <span class="keyword">return</span> q-&gt;_front-&gt;_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QuDataType <span class="title function_">QueueBack</span><span class="params">(Queue* q)</span>&#123;<span class="comment">//获取队列尾部元素</span></span><br><span class="line">    <span class="keyword">return</span> q-&gt;_rear-&gt;_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">QueueEmpty</span><span class="params">(Queue* q)</span>&#123;   <span class="comment">//判断队列是否为空</span></span><br><span class="line">    <span class="keyword">return</span> q-&gt;_front == <span class="literal">NULL</span>;   <span class="comment">//为空，返回1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">QueueSize</span><span class="params">(Queue* q)</span>&#123;  <span class="comment">//获取队列中的元素个数</span></span><br><span class="line">    QueueNode * cur;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (cur = q-&gt;_front; cur; cur = cur-&gt;_next)<span class="comment">//循环遍历，计数即可</span></span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QueueDestory</span><span class="params">(Queue* q)</span>  <span class="comment">//销毁队列</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;_front == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (q-&gt;_front)&#123;</span><br><span class="line">        QueuePop(q);<span class="comment">//对每一个元素迭代出队即可</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    Queue q;</span><br><span class="line">    QueueInit(&amp;q);</span><br><span class="line">    QueuePush(&amp;q, <span class="number">1</span>);</span><br><span class="line">    QueuePush(&amp;q, <span class="number">2</span>);</span><br><span class="line">    QueuePush(&amp;q, <span class="number">3</span>);</span><br><span class="line">    QueuePush(&amp;q, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, QueueFront(&amp;q)); <span class="comment">//1</span></span><br><span class="line">    QueuePop(&amp;q);<span class="comment">//出队列</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, QueueFront(&amp;q));<span class="comment">//2   此时队首为2</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, QueueBack(&amp;q));<span class="comment">//4  队尾为4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a name = "java队列">

<p><strong>java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.queue;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建队列</span></span><br><span class="line">        <span class="comment">//用LinkedList(链表)作为对象,插入和删除操作时间复杂度只有O(1)</span></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.添加元素 :O(1)</span></span><br><span class="line">        queue.add(<span class="number">1</span>);</span><br><span class="line">        queue.add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.获取即将出队的元素 ：O(1)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp1</span> <span class="operator">=</span> queue.peek();</span><br><span class="line">        System.out.println(temp1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.删除即将出队的元素 ：O(1)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp2</span> <span class="operator">=</span> queue.poll();   <span class="comment">//返回值，并将其删除 </span></span><br><span class="line">        System.out.println(temp2);</span><br><span class="line">        System.out.println(queue.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.判断队列是否为空 ：O(1)</span></span><br><span class="line">        System.out.println(queue.isEmpty());    <span class="comment">//队列空则返回True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.队列长度 ：O(1)</span></span><br><span class="line">        <span class="comment">//创建链表时会有一个变量，当加入一个元素时变量加1，获取长度时会直接返回这个变量值</span></span><br><span class="line">        System.out.println(queue.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7.遍历队列 :O(N)</span></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            System.out.print(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="933-最近的请求次数"><a href="#933-最近的请求次数" class="headerlink" title="933.最近的请求次数"></a>933.最近的请求次数</h4><p>写一个 RecentCounter 类来计算特定时间范围内最近的请求。</p>
<p>请你实现 RecentCounter 类：</p>
<p>RecentCounter() 初始化计数器，请求数为 0 。<br>int ping(int t) 在时间 t 添加一个新请求，其中 t 表示以毫秒为单位的某个时间，并返回过去 3000 毫秒内发生的所有请求数（包括新请求）。确切地说，返回在 [t-3000, t] 内发生的请求数。<br>保证 每次对 ping 的调用都使用比之前更大的 t 值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;RecentCounter&quot;, &quot;ping&quot;, &quot;ping&quot;, &quot;ping&quot;, &quot;ping&quot;]</span><br><span class="line">[[], [1], [100], [3001], [3002]]</span><br><span class="line">输出：</span><br><span class="line">[null, 1, 2, 3, 3]</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RecentCounter</span> &#123;</span><br><span class="line">    Queue&lt;Integer&gt; q;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">RecentCounter</span><span class="params">()</span> &#123;</span><br><span class="line">        q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">ping</span><span class="params">(<span class="type">int</span> t)</span> &#123;</span><br><span class="line">        q.add(t);</span><br><span class="line">        <span class="keyword">while</span>(q.peek() &lt; t - <span class="number">3000</span>)&#123;</span><br><span class="line">            q.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225.用队列实现栈"></a>225.用队列实现栈</h4><p>利用两个队列 来实现栈的基本操作：进栈，显示栈顶元素，删除栈顶元素，判空f</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue1;</span><br><span class="line">    Queue&lt;Integer&gt; queue2;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line">        queue1 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">        queue2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        queue2.add(x);</span><br><span class="line">        <span class="keyword">while</span> (!queue1.isEmpty())&#123;</span><br><span class="line">            queue2.add(queue1.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Integer&gt; temp = queue1;</span><br><span class="line">        queue1 = queue2;</span><br><span class="line">        queue2 = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue1.poll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue1.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue1.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="622-设计循环队列"><a href="#622-设计循环队列" class="headerlink" title="622.设计循环队列"></a>622.设计循环队列</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCircularQueue</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] queue;</span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line">    <span class="type">int</span> rear;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyCircularQueue</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">        capacity = k;</span><br><span class="line">        queue = <span class="keyword">new</span> <span class="title class_">int</span>[k + <span class="number">1</span>];</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        rear = <span class="number">0</span>;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">enQueue</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == capacity) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        queue[rear] = value;</span><br><span class="line">        rear = (rear + <span class="number">1</span>) % capacity;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">deQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            index = (index + <span class="number">1</span>) % capacity;</span><br><span class="line">            count--;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">Front</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> queue[index];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">Rear</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> queue[(rear + capacity - <span class="number">1</span>) % capacity];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">count</span> <span class="operator">=</span>= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">count</span> <span class="operator">=</span>= capacity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h4 id="Deque（双端队列）"><a href="#Deque（双端队列）" class="headerlink" title="Deque（双端队列）"></a>Deque（双端队列）</h4><p>Deque（java.util.Deque）接口代表着双向队列，意思就是可以从队列的两端增加或者删除元素，</p>
<ul>
<li>deque 是“double ended queue（双端队列）”的缩写，通常读为“deck”。</li>
</ul>
<p><strong>Deque的实现</strong>：<br>既然Deque是个接口所以初始化时就要用到其具体的实现，在 Collections API中有下面两种实现:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.util.LinkedList</span><br><span class="line">java.util.ArrayDeque</span><br></pre></td></tr></table></figure>


<p>LinkedList类是非常标准的Deque和Queue的实现，它在内部使用链接列表来建模queue或deque。</p>
<p>ArrayDeque类内部存储元素是数组，如果元素数超过数组中的空间，则分配一个新的数组，并移动所有元素，换句话说，ArrayDeque根据需要增长，即使它将元素存储在数组中。</p>
<p><strong>创建Deque</strong><br>在使用Deque之前首先要创建 Deque接口实现的实例，下面是创建 LinkedList实例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Deque deque = new LinkedList();</span><br></pre></td></tr></table></figure>


<p>创建 ArrayDeque实例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Deque deque = new ArrayDeque();</span><br></pre></td></tr></table></figure>

<p>Deque泛型<br>默认 Deque放入的Object对象，但是也可以用泛型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;MyObject&gt; deque = new LinkedList&lt;MyObject&gt;();</span><br></pre></td></tr></table></figure>


<p>这个Deque中只能添加 MyObject的实例对象，并且访问时不需要强制类型转换：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MyObject myObject = deque.remove();</span><br><span class="line"></span><br><span class="line">for(MyObject anObject : deque)&#123;</span><br><span class="line">   //do someting to anObject...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Deque中添加元素</strong><br>前面讲到可以在Deque 的两端增加元素，Deque 中有下面几种添加元素的方法：</p>
<p>add()<br>addLast()<br>addFirst()<br>offer()<br>offerFirst()<br>offerLast()<br>这些方法下面会一一讲解。</p>
<p>add()<br>可以使用add()方法在Deque 的尾部添加元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.add(&quot;element 1&quot;);</span><br></pre></td></tr></table></figure>


<p>如果元素不能插入到Deque，那么add()，方法将抛异常，而 offer()方法不一样，如果不能添加元素offer()方法将返回false。add()方法实际是继承Queue接口。</p>
<p>offer()<br>offer()方法可以在Deque的尾部添加元素，如果元素没满则添加成功返回true，否则返回false。这是和 add()抛异常方法不同的地方，下面是使用offer()方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.offer(&quot;element 1&quot;);</span><br></pre></td></tr></table></figure>

<p>push()<br>push()方法是在Deque的头部添加元素，如果Deque中的元素满了，则会抛异常，这和addFirst()方法比较相似：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.push(&quot;element 0&quot;);</span><br></pre></td></tr></table></figure>

<p><strong>获取元素：</strong></p>
<p>peek()<br>peekFirst()<br>peekLast()<br>getFirst()<br>getLast()<br>peek()<br>peek()返回Deque中的第一个元素并且不删除，如果Deque是空则返回null：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.add(&quot;first element&quot;);</span><br><span class="line">deque.add(&quot;last element&quot;);</span><br><span class="line"></span><br><span class="line">String firstElement = deque.peek();</span><br></pre></td></tr></table></figure>


<p>执行完代码后firstElement将指向Deque的第一个元素： “first element”。</p>
<p>getFirst()<br>getFirst()方法获取Deque的第一个元素并且不删除，如果Deque是空则抛异常：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.add(&quot;first element&quot;);</span><br><span class="line">deque.add(&quot;last element&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">String firstElement = deque.getFirst();</span><br></pre></td></tr></table></figure>


<p>执行完代码后firstElement的值是: “first element”。</p>
<p><strong>移除Deque中的元素</strong><br>以下几种方法可以移除Deque 中的元素：</p>
<p>remove()<br>removeFirst()<br>removeLast()<br>poll()<br>pollFirst()<br>pollLast()<br>remove()<br>remove()方法移除Deque中的第一个元素并返回：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.add(&quot;element 0&quot;);</span><br><span class="line"></span><br><span class="line">String removedElement = deque.remove();</span><br></pre></td></tr></table></figure>


<p>如果Deque 是空则抛异常，这一点和poll()返回null不一样。 </p>
<p>poll()<br>poll()方法移除Deque中的第一个元素，如果Deque为空则poll()返回null，这和remove()方法抛异常不一样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.add(&quot;element 0&quot;);</span><br><span class="line">deque.add(&quot;element 1&quot;);</span><br><span class="line">deque.add(&quot;element 2&quot;);</span><br><span class="line"></span><br><span class="line">String removedElement = deque.poll();</span><br></pre></td></tr></table></figure>




<p>pop()<br>pop()方法移除Deque的第一个元素，如果Deque是空则抛异常：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.push(&quot;element 0&quot;);</span><br><span class="line"></span><br><span class="line">String removedElement = deque.pop();</span><br></pre></td></tr></table></figure>

<p><strong>检查Deque是否包含某个元素</strong><br>可以用contains()方法检查Deque中是否包含某个元素，如果包含返回true否则返回false:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.add(&quot;first element&quot;);</span><br><span class="line"></span><br><span class="line">boolean containsElement1 = deque.contains(&quot;first element&quot;);</span><br><span class="line">boolean containsElement2 = deque.contains(&quot;second element&quot;);</span><br></pre></td></tr></table></figure>


<p>执行完代码后containsElement1的值是true ，containsElement2值是false。</p>
<p><strong>Deque的大小</strong><br>Deque的size()方法可以返回Deque中存储的元素个数： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.add(&quot;first element&quot;);</span><br><span class="line">deque.add(&quot;second element&quot;);</span><br><span class="line"></span><br><span class="line">int size = deque.size();</span><br></pre></td></tr></table></figure>


<p>执行完代码后size大小是2，因为Deque中包含两个元素。</p>
<p><strong>迭代Deque中的元素</strong><br>可以通过两种方法迭代Deque中的元素：</p>
<p>使用Iterator.<br>使用for-each循环.<br>具体使用哪一种迭代取决Deque的实现。</p>
<p>通过迭代器迭代Deque<br>第一种方法是获取Deque的Iterator，下面是代码： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.add(&quot;element 0&quot;);</span><br><span class="line">deque.add(&quot;element 1&quot;);</span><br><span class="line">deque.add(&quot;element 2&quot;);</span><br><span class="line"></span><br><span class="line">Iterator&lt;String&gt; iterator = deque.iterator();</span><br><span class="line">while(iterator.hasNext()&#123;</span><br><span class="line">  String element = iterator.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>通过For-Each循环迭代Deque<br>第二种方法是通过for-each循环迭代Deque：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.add(&quot;element 0&quot;);</span><br><span class="line">deque.add(&quot;element 1&quot;);</span><br><span class="line">deque.add(&quot;element 2&quot;);</span><br><span class="line"></span><br><span class="line">for(String element : deque) &#123;</span><br><span class="line">    System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="队列的时间复杂度"><a href="#队列的时间复杂度" class="headerlink" title="队列的时间复杂度"></a>队列的时间复杂度</h3><p>访问（Access）：O（N）</p>
<p>搜索（Search）：O（N)</p>
<p>插入（Insert）：O（1）</p>
<p>删除（Delete）：O（1）</p>
<h2 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈   Stack"></a><strong>栈   Stack</strong></h2><p><strong>java：</strong></p>
<p>（Java堆栈Stack已经过时，推荐使用Deque替代Stack。）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建栈</span></span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加元素 : O(1)</span></span><br><span class="line">        stack.push(<span class="number">1</span>);</span><br><span class="line">        stack.push(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取栈顶元素 : O(1)</span></span><br><span class="line">        stack.peek();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除栈顶元素 : O(1)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> stack.pop(); <span class="comment">//pop方法会删除元素并返回被删除的值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//栈的大小 : O(1)</span></span><br><span class="line">        stack.size();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//栈是否为空 : O(1)</span></span><br><span class="line">        stack.isEmpty();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//栈的遍历 : O(N)</span></span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><p>单调栈中存放的数据应该是有序的，所以单调栈也分为<strong>单调递增栈</strong>和<strong>单调递减栈</strong></p>
<ul>
<li>单调递增栈：单调递增栈就是从栈底到栈顶数据是从大到小</li>
<li>单调递减栈：单调递减栈就是从栈底到栈顶数据是从小到大</li>
</ul>
<p>假设：</p>
<p>现在有一组数10，3，7，4，12。从左到右依次入栈，则如果栈为空或入栈元素值小于栈顶元素值，则入栈；否则，如果入栈则会破坏栈的单调性，则需要把比入栈元素小的元素全部出栈。单调递减的栈反之。 </p>
<p>10入栈时，栈为空，直接入栈，栈内元素为10。</p>
<p>3入栈时，栈顶元素10比3大，则入栈，栈内元素为10，3。</p>
<p>7入栈时，栈顶元素3比7小，则栈顶元素出栈，此时栈顶元素为10，比7大，则7入栈，栈内元素为10，7。</p>
<p>4入栈时，栈顶元素7比4大，则入栈，栈内元素为10，7，4。</p>
<p>12入栈时，栈顶元素4比12小，4出栈，此时栈顶元素为7，仍比12小，栈顶元素7继续出栈，此时栈顶元素为10，仍比12小，10出栈，此时栈为空，12入栈，栈内元素为12。</p>
<p><strong>伪代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">stack</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">for</span> <span class="params">(遍历这个数组)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (栈空 || 栈顶元素大于等于当前比较元素)</span><br><span class="line">	&#123;</span><br><span class="line">		入栈;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (栈不为空 &amp;&amp; 栈顶元素小于当前元素)</span><br><span class="line">		&#123;</span><br><span class="line">			栈顶元素出栈;</span><br><span class="line">			更新结果;</span><br><span class="line">		&#125;</span><br><span class="line">		当前数据入栈;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20.有效的括号"></a>20.有效的括号</h3><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。</p>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;()[]&#123;&#125;&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Character, Character&gt; hash = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, Character&gt;();</span><br><span class="line">        hash.put(<span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">        hash.put(<span class="string">&#x27;]&#x27;</span>, <span class="string">&#x27;[&#x27;</span>);</span><br><span class="line">        hash.put(<span class="string">&#x27;&#125;&#x27;</span>, <span class="string">&#x27;&#123;&#x27;</span>);</span><br><span class="line">        </span><br><span class="line">        Deque&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Character&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (hash.containsKey(c)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (stack.isEmpty() || stack.peek() != hash.get(c)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                stack.push(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="496-下一个更大元素1"><a href="#496-下一个更大元素1" class="headerlink" title="496.下一个更大元素1"></a>496.下一个更大元素1</h3><p>给定两个<strong>没有重复元素</strong>的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。</p>
<p>请你找出 nums1 中每个元素在 nums2 中的下一个比其大的值。</p>
<p>nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1 。</p>
<p>示例 :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: nums1 = [4,1,2], nums2 = [1,3,4,2].</span><br><span class="line">输出: [-1,3,-1]</span><br><span class="line">解释:</span><br><span class="line">    对于 num1 中的数字 4 ，你无法在第二个数组中找到下一个更大的数字，因此输出 -1 。</span><br><span class="line">    对于 num1 中的数字 1 ，第二个数组中数字1右边的下一个较大数字是 3 。</span><br><span class="line">    对于 num1 中的数字 2 ，第二个数组中没有下一个更大的数字，因此输出 -1 。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] nextGreaterElement(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums1.length, m = nums2.length;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; nums2[i] &gt; stack.peek())&#123;</span><br><span class="line">                map.put(stack.pop(),nums2[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums2[i],-<span class="number">1</span>);</span><br><span class="line">            stack.push(nums2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            nums1[i] = map.get(nums1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232.用栈实现队列"></a>232.用栈实现队列</h3><p>只使用两个栈，实现一个先入先出的队列（push,pop,peek,empty)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    Deque&lt;Integer&gt; stack1;</span><br><span class="line">    Deque&lt;Integer&gt; stack2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        stack1 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        stack2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//stack1中的数据依次出栈并入栈stack2</span></span><br><span class="line">    <span class="comment">//数据进栈stack2</span></span><br><span class="line">    <span class="comment">//stack2中数据依次出栈并入栈stack1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!stack1.isEmpty())&#123;</span><br><span class="line">            stack2.push(stack1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        stack2.push(x);</span><br><span class="line">        <span class="keyword">while</span> (!stack2.isEmpty())&#123;</span><br><span class="line">            stack1.push(stack2.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stack1.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stack1.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stack1.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="栈的时间复杂度"><a href="#栈的时间复杂度" class="headerlink" title="栈的时间复杂度"></a>栈的时间复杂度</h3><p>访问（Access）：O（1）</p>
<p>搜索（Search）：O（N)</p>
<p>插入（Insert）：O（1）</p>
<p>删除（Delete）：O（1）</p>
<h2 id="字符串-String"><a href="#字符串-String" class="headerlink" title="字符串   String"></a><strong>字符串   String</strong></h2><p>字符串输入：</p>
<ol>
<li><p>数组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> arr[<span class="number">6</span>] = <span class="string">&quot;array&quot;</span>;</span><br><span class="line"><span class="type">char</span> arr[] = <span class="string">&quot;array&quot;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *p = <span class="string">&quot;pointer&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s %c %c&quot;</span>,p,*p,*(p + <span class="number">2</span>));   <span class="comment">//第一个输出字符串；第二个输出指针指向，即字符串的第一个字符；第三个输出字符串中 第三个字符</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>数组&#x2F;指针 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> arr1[<span class="number">6</span>];</span><br><span class="line">scang(<span class="string">&quot;%s\n&quot;</span>,arr1);</span><br><span class="line">gets(arr1);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *arr2 = (<span class="type">char</span>*)<span class="built_in">malloc</span>( <span class="number">100</span>*<span class="keyword">sizeof</span>(<span class="type">char</span>) );  <span class="comment">//记得为指针数组分配内存，否则会报错之类的</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s\n&quot;</span>,arr2);</span><br><span class="line">gets(arr2);</span><br></pre></td></tr></table></figure>

<p>（scanf只能输入一个单词，当遇到空格时会认为字符串结束；gets函数只知道数组的开始，并不知道数组的大小，如果输入过长容易溢出，并可能擦掉程序中的其他数据）</p>
</li>
<li><p>使用while完成多组测试，而不是在输入完一组数据后退出控制台</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> arr1[<span class="number">100</span>],arr2[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> a;   </span><br><span class="line"><span class="keyword">while</span>((a = <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>,arr1,arr2)) != EOF)&#123;     <span class="comment">//也可用while((a = getchar(arr1)) != &#x27;\n&#x27;)</span></span><br><span class="line">    pritnf(<span class="string">&quot;scanf返回l %d,s1是%s，s2是%s&quot;</span>，a,arr1,arr2);   <span class="comment">//这行输出后可以继续进行输入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="KMP模式匹配"><a href="#KMP模式匹配" class="headerlink" title="KMP模式匹配"></a>KMP模式匹配</h3><p>KMP算法实现过程接近人为模式匹配</p>
<ul>
<li>匹配失败后，模式串移动的距离和主串无关，只与模式串本身有关，模式串后移等价于指针j前移。</li>
</ul>
<p><img src="http://data.biancheng.net/uploads/allimg/181212/2-1Q212223I41Z.gif" alt="模式串后移等价于 j 前移"></p>
<p>因此，我们可以给每个模式串配备一个数组（例如 next[]），用于存储模式串中每个字符对应指针 j 重定向的位置（也就是存储模式串的数组下标），比如 j&#x3D;3，则该字符匹配失败后指针 j 指向模式串中第 3 个字符。</p>
<p>模式串中各字符对应 <strong>next 值</strong>的计算方式是，取该字符前面的字符串（不包含自己），其<strong>前缀字符串和后缀字符串相同字符的最大个数再 +1</strong> 就是该字符对应的 next 值。</p>
<p>（模式串中第一个字符对应的值为 0，第二个字符对应 1 ，这是固定不变的。）</p>
<h4 id="Next函数"><a href="#Next函数" class="headerlink" title="Next函数"></a>Next函数</h4><p>一般的Next函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Next</span><span class="params">(<span class="type">char</span>*T,<span class="type">int</span> *next)</span>&#123;</span><br><span class="line">    next[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    next[<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;<span class="built_in">strlen</span>(T)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j==<span class="number">0</span>||T[i<span class="number">-1</span>]==T[j<span class="number">-1</span>]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            next[i]=j;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            j=next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但这样可能会有多余的操作，如：</p>
<p><img src="http://data.biancheng.net/uploads/allimg/181212/2-1Q212224002945.gif" alt="Next函数的缺陷"></p>
<p>当匹配失败时，Next 函数会由图 10b) 开始继续进行模式匹配，但是从图中可以看到，这样做是没有必要的。</p>
<p>如此，问题在当 T[i-1]&#x3D;&#x3D;T[j-1] 成立时，没有继续对 i++ 和 j++ 后的 T[i-1] 和 T[j-1] 的值做判断。</p>
<p>因此改进后的Next函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Next</span><span class="params">(<span class="type">char</span>*T,<span class="type">int</span> *next)</span>&#123; </span><br><span class="line">    next[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    next[<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;<span class="built_in">strlen</span>(T)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j==<span class="number">0</span>||T[i<span class="number">-1</span>]==T[j<span class="number">-1</span>]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            <span class="keyword">if</span> (T[i<span class="number">-1</span>]!=T[j<span class="number">-1</span>]) &#123;</span><br><span class="line">               next[i]=j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                next[i]=next[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            j=next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="KMP实现"><a href="#KMP实现" class="headerlink" title="KMP实现"></a>KMP实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Next</span><span class="params">(<span class="type">char</span>*T,<span class="type">int</span> *next)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">    next[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;<span class="built_in">strlen</span>(T)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j==<span class="number">0</span>||T[i<span class="number">-1</span>]==T[j<span class="number">-1</span>]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            next[i]=j;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            j=next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">KMP</span><span class="params">(<span class="type">char</span> * S,<span class="type">char</span> * T)</span>&#123;</span><br><span class="line">    <span class="type">int</span> next[<span class="number">10</span>];</span><br><span class="line">    Next(T,next);<span class="comment">//根据模式串T,初始化next数组</span></span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;=<span class="built_in">strlen</span>(S)&amp;&amp;j&lt;=<span class="built_in">strlen</span>(T)) &#123;</span><br><span class="line">        <span class="comment">//j==0:代表模式串的第一个字符就和当前测试的字符不相等；S[i-1]==T[j-1],如果对应位置字符相等，两种情况下，指向当前测试的两个指针下标i和j都向后移</span></span><br><span class="line">        <span class="keyword">if</span> (j==<span class="number">0</span> || S[i<span class="number">-1</span>]==T[j<span class="number">-1</span>]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            j=next[j];<span class="comment">//如果测试的两个字符不相等，i不动，j变为当前测试字符串的next值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j&gt;<span class="built_in">strlen</span>(T)) &#123;<span class="comment">//如果条件为真，说明匹配成功</span></span><br><span class="line">        <span class="keyword">return</span> i-(<span class="type">int</span>)<span class="built_in">strlen</span>(T);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i=KMP(<span class="string">&quot;ababcabcacbab&quot;</span>,<span class="string">&quot;abcac&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h2 id="散列表（Hash）"><a href="#散列表（Hash）" class="headerlink" title="散列表（Hash）"></a><strong>散列表（Hash）</strong></h2><ul>
<li><p><strong>哈希表</strong>（hashtable），又叫散列表，是根据关键码（key）来进行访问的数据结构，通过哈希函数把key转成哈希值来定位数据存储的位置。通常是键-值对（即key-value）的结构，即用key算出的哈希值来定位存储位置，在该位置上存储内容为value。</p>
</li>
<li><p><strong>哈希集合</strong>（hashset），也是一种通过哈希值来定位存储位置的数据结构，只是它不是键-值对结构，而是储存key本身，相当于只有哈希表（hashtable）的key部分，即用key算出的哈希值来定位存储位置，在该位置上存储内容为key本身。<br>简单来说就是，哈希集合是不能存储重复元素的数据结构（集合），而哈希表是存储键-值对（key-value），其中键key不能重复。</p>
</li>
<li><p><strong>哈希映射</strong>（hashmap）是和哈希表（hashtable）相似的数据结构，也是键-值对存储，只是哈希映射是线程安全的，而哈希表是非线程安全的。所谓线程安全，就是多线程同时操作数据的时候，能确保在同一时刻只能有一个线程能访问同一个数据（也就是会给数据操作加锁）；如果不能确保这个，就是非线程安全。</p>
</li>
</ul>
<p>哈希表 可能存在特殊情况，就是通过不同的 Key，可能访问到同一个地址，这种现象叫作碰撞（Collision）。而通过某个 Key 一定会得到唯一的 Value 地址。</p>
<p>目前，这个哈希函数比较常用的实现方法比较多，通常需要考虑几个因素：关键字的长度、哈希表的大小、关键字的分布情况、记录的查找频率，等等。</p>
<p>下面简单<strong>介绍几种哈希函数</strong>。</p>
<ul>
<li>直接寻址法：取关键字或关键字的某个线性函数值为散列地址。</li>
<li>数字分析法：通过对数据的分析，发现数据中冲突较少的部分，并构造散列地址。例如同学们的学号，通常同一届学生的学号，其中前面的部分差别不太大，所以用后面的部分来构造散列地址。</li>
<li>平方取中法：当无法确定关键字里哪几位的分布相对比较均匀时，可以先求出关键字的平方值，然后按需要取平方值的中间几位作为散列地址。这是因为：计算平方之后的中间几位和关键字中的每一位都相关，所以不同的关键字会以较高的概率产生不同的散列地址。</li>
<li>取随机数法：使用一个随机函数，取关键字的随机值作为散列地址，这种方式通常用于关键字长度不同的场合。</li>
<li><strong>除留取余法</strong>：取关键字被某个不大于散列表的表长 n 的数 m 除后所得的余数 p 为散列地址。这种方式也可以在用过其他方法后再使用。该函数对 m 的选择很重要，一般取<strong>素数</strong>或者直接用 n。</li>
</ul>
<p><strong>对散列表函数产生冲突的解决办法</strong>：</p>
<p>​	有时不同的 Key 通过哈希函数可能会得到相同的地址，这在我们操作时可能会对数据造成覆盖、丢失。之所以产生冲突是由于哈希函数有时对不同的 Key 计算之后获得了相同的地址。</p>
<p>冲突的处理方式也有很多，下面介绍几种。</p>
<ul>
<li><strong>开放地址法</strong>（也叫<strong>线性探测</strong>）：实际上就是当需要存储值时，对Key哈希之后，发现这个地址已经有值了，这时该怎么办？不能放在这个地址，不然之前的映射会被覆盖。这时对计算出来的地址进行一个探测再哈希，比如往后移动一个地址，如果没人占用，就用这个地址。如果超过最大长度，则可以对总长度取余。这里移动的地址是产生冲突时的增列序量。(如  f（key) &#x3D; {  f(key + d)  } % m）</li>
<li><strong>再哈希法</strong>：在产生冲突之后，使用关键字的其他部分继续计算地址，如果还是有冲突，则继续使用其他部分再计算地址。这种方式的缺点是时间增加了。</li>
<li><strong>链地址法</strong>：链地址法其实就是对Key通过哈希之后落在同一个地址上的值，做一个链表。其实在很多高级语言的实现当中，也是使用这种方式处理冲突的，我们会在后面着重学习这种方式。</li>
<li><strong>建立一个公共溢出区</strong>：这种方式是建立一个公共溢出区，当地址存在冲突时，把新的地址放在公共溢出区里。</li>
</ul>
<h3 id="散列表实现"><a href="#散列表实现" class="headerlink" title="散列表实现"></a>散列表实现</h3><p><a href="java%E6%95%A3%E5%88%97%E8%A1%A8">java</a></p>
<p><strong>C：</strong></p>
<h5 id="实现简单的哈希表"><a href="#实现简单的哈希表" class="headerlink" title="实现简单的哈希表"></a>实现简单的哈希表</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SUCCESS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNSUCCESS 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HASHSIZE 12   <span class="comment">//定义散列表长为数组的长度</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULLKEY -32768</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> *elem;    <span class="comment">// 数据元素存储基址，动态分配数组</span></span><br><span class="line">    <span class="type">int</span> count;    <span class="comment">// 当前数据元素个数</span></span><br><span class="line">&#125; HashTable;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m = <span class="number">0</span>;   <span class="comment">//散列表表长，全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化散列表</span></span><br><span class="line">Status <span class="title function_">InterHashTable</span><span class="params">(HashTable *H)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    m = HASHSIZE;</span><br><span class="line">    H-&gt;count = m;</span><br><span class="line">    H-&gt;elem = (<span class="type">int</span> *) <span class="built_in">malloc</span>(m * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        H-&gt;elem[i] = NULLKEY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//散列函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Hash</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> key % m;     <span class="comment">//除留余数法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入关键字进散列表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IntertHash</span><span class="params">(HashTable *H, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> addr = Hash(key);   <span class="comment">//求散列地址</span></span><br><span class="line">    <span class="keyword">while</span> (H-&gt;elem[addr] != NULLKEY)    <span class="comment">//如果不为空，则冲突</span></span><br><span class="line">        addr = (addr + <span class="number">1</span>) % m;      <span class="comment">//开放地址法的线性探测</span></span><br><span class="line">    H-&gt;elem[addr] = key;        <span class="comment">//直到有空位后插入关键字</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//散列表查找关键字</span></span><br><span class="line">Status <span class="title function_">SearchHash</span><span class="params">(HashTable H, <span class="type">int</span> key, <span class="type">int</span> *addr)</span> &#123;</span><br><span class="line">    *addr = Hash(key);                 <span class="comment">//求散列地址</span></span><br><span class="line">    <span class="keyword">while</span> (H.elem[*addr] != key) &#123;        <span class="comment">//如果不为空，则冲突</span></span><br><span class="line">        *addr = (*addr + <span class="number">1</span>) % m;            <span class="comment">//开放地址法的线性探测</span></span><br><span class="line">        <span class="keyword">if</span> (H.elem[*addr] == NULLKEY || *addr == Hash(key)) &#123;     <span class="comment">//如果循环回到原点</span></span><br><span class="line">            <span class="keyword">return</span> UNSUCCESS;       <span class="comment">//则说明关键字不存在</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">12</span>] = &#123;<span class="number">12</span>, <span class="number">67</span>, <span class="number">56</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">37</span>, <span class="number">22</span>, <span class="number">29</span>, <span class="number">15</span>, <span class="number">47</span>, <span class="number">48</span>, <span class="number">34</span>&#125;;</span><br><span class="line">    HashTable H;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    InterHashTable(&amp;H);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        IntertHash(&amp;H, a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;插入之后的哈希表为：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d,&quot;</span>, H.elem[i]);</span><br><span class="line">    <span class="type">int</span> addr, j;</span><br><span class="line">    j = SearchHash(H, a[<span class="number">5</span>], &amp;addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;搜索到a[5]的地址是：%d&quot;</span>, j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="实现哈希集合"><a href="#实现哈希集合" class="headerlink" title="实现哈希集合"></a>实现哈希集合</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">List</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">List</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">listPush</span><span class="params">(<span class="keyword">struct</span> List *head, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">List</span> *<span class="title">tmp</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> List));</span><br><span class="line">    tmp-&gt;val = x;</span><br><span class="line">    tmp-&gt;next = head-&gt;next;</span><br><span class="line">    head-&gt;next = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">listDelete</span><span class="params">(<span class="keyword">struct</span> List *head, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">struct</span> List *it = head; it-&gt;next; it = it-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (it-&gt;next-&gt;val == x) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">List</span> *<span class="title">tmp</span> =</span> it-&gt;next;</span><br><span class="line">            it-&gt;next = tmp-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(tmp);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">&#125;&#125;&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">listContains</span><span class="params">(<span class="keyword">struct</span> List *head, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">struct</span> List *it = head; it-&gt;next; it = it-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (it-&gt;next-&gt;val == x) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">listFree</span><span class="params">(<span class="keyword">struct</span> List *head)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (head-&gt;next) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">List</span> *<span class="title">tmp</span> =</span> head-&gt;next;</span><br><span class="line">        head-&gt;next = tmp-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> base = <span class="number">769</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">hash</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> key % base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">List</span> *<span class="title">data</span>;</span></span><br><span class="line">&#125; MyHashSet;</span><br><span class="line"></span><br><span class="line">MyHashSet *<span class="title function_">myHashSetCreate</span><span class="params">()</span> &#123;</span><br><span class="line">    MyHashSet *ret = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MyHashSet));</span><br><span class="line">    ret-&gt;data = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> List) * base);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; base; i++) &#123;</span><br><span class="line">        ret-&gt;data[i].val = <span class="number">0</span>;</span><br><span class="line">        ret-&gt;data[i].next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">myHashSetAdd</span><span class="params">(MyHashSet *obj, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h = hash(key);</span><br><span class="line">    <span class="keyword">if</span> (!listContains(&amp;(obj-&gt;data[h]), key)) &#123;</span><br><span class="line">        listPush(&amp;(obj-&gt;data[h]), key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">myHashSetRemove</span><span class="params">(MyHashSet *obj, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h = hash(key);</span><br><span class="line">    listDelete(&amp;(obj-&gt;data[h]), key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">myHashSetContains</span><span class="params">(MyHashSet *obj, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h = hash(key);</span><br><span class="line">    <span class="keyword">return</span> listContains(&amp;(obj-&gt;data[h]), key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">myHashSetFree</span><span class="params">(MyHashSet *obj)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; base; i++) &#123;</span><br><span class="line">        listFree(&amp;(obj-&gt;data[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(obj-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="实现哈希映射"><a href="#实现哈希映射" class="headerlink" title="实现哈希映射"></a>实现哈希映射</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">List</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">List</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">listPush</span><span class="params">(<span class="keyword">struct</span> List* head, <span class="type">int</span> key, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">List</span>* <span class="title">tmp</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> List));</span><br><span class="line">    tmp-&gt;key = key;</span><br><span class="line">    tmp-&gt;val = val;</span><br><span class="line">    tmp-&gt;next = head-&gt;next;</span><br><span class="line">    head-&gt;next = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">listDelete</span><span class="params">(<span class="keyword">struct</span> List* head, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">struct</span> List* it = head; it-&gt;next; it = it-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (it-&gt;next-&gt;key == key) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">List</span>* <span class="title">tmp</span> =</span> it-&gt;next;</span><br><span class="line">            it-&gt;next = tmp-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(tmp);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> List* <span class="title function_">listFind</span><span class="params">(<span class="keyword">struct</span> List* head, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">struct</span> List* it = head; it-&gt;next; it = it-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (it-&gt;next-&gt;key == key) &#123;</span><br><span class="line">            <span class="keyword">return</span> it-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">listFree</span><span class="params">(<span class="keyword">struct</span> List* head)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (head-&gt;next) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">List</span>* <span class="title">tmp</span> =</span> head-&gt;next;</span><br><span class="line">        head-&gt;next = tmp-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> base = <span class="number">769</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">hash</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> key % base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">List</span>* <span class="title">data</span>;</span></span><br><span class="line">&#125; MyHashMap;</span><br><span class="line"></span><br><span class="line">MyHashMap* <span class="title function_">myHashMapCreate</span><span class="params">()</span> &#123;</span><br><span class="line">    MyHashMap* ret = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MyHashMap));</span><br><span class="line">    ret-&gt;data = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> List) * base);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; base; i++) &#123;</span><br><span class="line">        ret-&gt;data[i].key = <span class="number">0</span>;</span><br><span class="line">        ret-&gt;data[i].val = <span class="number">0</span>;</span><br><span class="line">        ret-&gt;data[i].next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myHashMapPut</span><span class="params">(MyHashMap* obj, <span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h = hash(key);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">List</span>* <span class="title">rec</span> =</span> listFind(&amp;(obj-&gt;data[h]), key);</span><br><span class="line">    <span class="keyword">if</span> (rec == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        listPush(&amp;(obj-&gt;data[h]), key, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        rec-&gt;val = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">myHashMapGet</span><span class="params">(MyHashMap* obj, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h = hash(key);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">List</span>* <span class="title">rec</span> =</span> listFind(&amp;(obj-&gt;data[h]), key);</span><br><span class="line">    <span class="keyword">if</span> (rec == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rec-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myHashMapRemove</span><span class="params">(MyHashMap* obj, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h = hash(key);</span><br><span class="line">    listDelete(&amp;(obj-&gt;data[h]), key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myHashMapFree</span><span class="params">(MyHashMap* obj)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; base; i++) &#123;</span><br><span class="line">        listFree(&amp;(obj-&gt;data[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(obj-&gt;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a neme = "java散列表">

<p><strong>java：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建哈希表</span></span><br><span class="line">        String[] hashTable = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">4</span>]; <span class="comment">//用数组创建</span></span><br><span class="line">        HashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(); <span class="comment">//用HashMap方法</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加元素 : O(1)</span></span><br><span class="line">        hashTable[<span class="number">1</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//更新元素 : O(1)</span></span><br><span class="line">        hashTable[<span class="number">1</span>] = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//删除元素 : O(1)</span></span><br><span class="line">        hashTable[<span class="number">1</span>] = <span class="string">&quot;&quot;</span>; <span class="comment">//将其改为不会用到的值</span></span><br><span class="line">        map.remove(<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取元素 : O(1)</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> hashTable[<span class="number">1</span>];</span><br><span class="line">        map.get(<span class="number">3</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//检查key是否存在 : O(1)</span></span><br><span class="line">        map.containsKey(<span class="number">3</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//长度，是否为空 : O(1)</span></span><br><span class="line">        map.size();</span><br><span class="line">        </span><br><span class="line">        map.isEmpty();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取指定key对应的value，如果找不到key，则返回设置的默认值。</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="散列表的特点"><a href="#散列表的特点" class="headerlink" title="散列表的特点"></a>散列表的特点</h3><p>散列表有两种用法：一种是 Key 的值与 Value 的值一样，一般我们称这种情况的结构为 Set（集合）；而如果 Key 和 Value 所对应的内容不一样时，那么我们称这种情况为 Map，也就是人们俗称的键值对集合。</p>
<p>根据散列表的存储结构，我们可以得出散列表的以下特点。</p>
<ol>
<li><strong>访问速度很快</strong></li>
</ol>
<p>由于散列表有散列函数，可以将指定的 Key 都映射到一个地址上，所以在访问一个 Key（键）对应的 Value（值）时，根本不需要一个一个地进行查找，可以直接跳到那个地址。所以我们在对散列表进行添加、删除、修改、查找等任何操作时，速度都很快。</p>
<ol start="2">
<li><strong>需要额外的空间</strong></li>
</ol>
<p>首先，散列表实际上是存不满的，如果一个散列表刚好能够存满，那么肯定是个巧合。而且当散列表中元素的使用率越来越高时，性能会下降，所以一般会选择扩容来解决这个问题。另外，如果有冲突的话，则也是需要额外的空间去存储的，比如链地址法，不但需要额外的空间，甚至需要使用其他数据结构。</p>
<p>这个特点有个很常用的词可以表达，叫作“空间换时间”，在大多数时候，对于算法的实现，为了能够有更好的性能，往往会考虑牺牲些空间，让算法能够更快些。</p>
<p><strong>3) 无序</strong></p>
<p>散列表还有一个非常明显的特点，那就是无序。为了能够更快地访问元素，散列表是根据散列函数直接找到存储地址的，这样我们的访问速度就能够更快，但是对于有序访问却没有办法应对。</p>
<p><strong>4) 可能会产生碰撞</strong></p>
<p>没有完美的散列函数，无论如何总会产生冲突，这时就需要采用冲突解决方案，这也使散列表更加复杂。通常在不同的高级语言的实现中，对于冲突的解决方案不一定一样。</p>
<h3 id="散列表的适用场景"><a href="#散列表的适用场景" class="headerlink" title="散列表的适用场景"></a>散列表的适用场景</h3><p>根据散列表的特点可以想到，散列表比较适合无序、需要快速访问的情况。</p>
<p><strong>缓存</strong></p>
<p>通常我们开发程序时，对一些常用的信息会做缓存，用的就是散列表，比如我们要缓存用户的信息，一般用户的信息都会有唯一标识的字段，比如 ID。这时做缓存，可以把 ID 作为 Key，而 Value 用来存储用户的详细信息，这里的 Value 通常是一个对象（高级语言中的术语，前面提到过），包含用户的一些关键字段，比如名字、年龄等。</p>
<p>在我们每次需要获取一个用户的信息时，就不用与数据库这类的本地磁盘存储交互了（其实在大多数时候，数据库可能与我们的服务不在一台机器上，还会有相应的网络性能损耗），可以直接从内存中得到结果。这样不仅能够快速获取数据，也能够减轻数据库的压力。</p>
<p>有时我们要查询一些数据，这些数据与其他数据是有关联的，如果我们进行数据库的关联查询，那么效率会非常低，这时可以分为两部分进行查询：将被关联的部分放入散列表中，只需要遍历一遍；对于另一部分数据，则通过程序手动关联，速度会很快，并且由于我们是通过散列表的 Key、Value 的对应关系对应数据的，所以性能也会比较好。</p>
<p><strong>快速查找</strong></p>
<p>这里说的查找，不是排序，而是在集合中找出是否存在指定的元素。</p>
<p>这样的场景很多，比如我们要在指定的用户列表中查找是否存在指定的用户，这时就可以使用散列表了。在这个场景下使用的散列表其实是在上面提到的 Set 类型，实际上不需要 Value 这个值。</p>
<p>还有一个场景，我们一般对网站的操作会有个IP地址黑名单，我们认为某些 IP 有大量的非法操作，于是封锁了这些 IP 对我们网站的访问。这个 IP 是如何存储的呢？就是用的散列表。当一个访问行为发送过来时，我们会获取其 IP，判断其是否存在于黑名单中，如果存在，则禁止其访问。这种情况也是使用的 Set。</p>
<p>当然，对于上面说的两个例子，用列表也是可以实现的，但是访问速度会受到很大的影响，尤其是列表越来越长时，查找速度会很慢，而散列表则不会。</p>
<h3 id="217-存在重复元素"><a href="#217-存在重复元素" class="headerlink" title="217.存在重复元素"></a>217.存在重复元素</h3><p>给定一个整数数组，判断是否存在重复元素。</p>
<p>如果存在一值在数组中出现至少两次，函数返回 <code>true</code> 。如果数组中每个元素都不相同，则返回 <code>false</code> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsDuplicate</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">	HashMap&lt;Integer, Integer&gt; hash = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">	<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i : nums) &#123;</span><br><span class="line">		<span class="keyword">if</span> (hash.containsKey(i)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line">			hash.put(i, <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="389-找不同"><a href="#389-找不同" class="headerlink" title="389.找不同"></a>389.找不同</h3><p>给定两个字符串 <strong>s</strong> 和 <em><strong>t</strong></em>，它们只包含小写字母。</p>
<p>字符串 <strong>t</strong> 由字符串 <strong>s</strong> 随机重排，然后在随机位置添加一个字母。</p>
<p>请找出在 <em><strong>t</strong></em> 中被添加的字母。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">findTheDifference</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length(), m = t.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            cnt[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> t.charAt(i);</span><br><span class="line">            cnt[c - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            <span class="keyword">if</span> (cnt[c - <span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

















<h3 id="哈希表的时间复杂度"><a href="#哈希表的时间复杂度" class="headerlink" title="哈希表的时间复杂度"></a>哈希表的时间复杂度</h3><p>访问（Access）：</p>
<p>搜索（Search）：O（1)</p>
<p>插入（Insert）：O（1）</p>
<p>删除（Delete）：O（1）</p>
<h2 id="集合-Set"><a href="#集合-Set" class="headerlink" title="集合   Set"></a><strong>集合   Set</strong></h2><ul>
<li><strong>无序，不重复</strong></li>
</ul>
<ol>
<li>检查元素是否存在</li>
<li>检查元素是否重复（原数据长度与集合长度是否相同）</li>
</ol>
<h3 id="java（哈希集合HashSet）"><a href="#java（哈希集合HashSet）" class="headerlink" title="java（哈希集合HashSet）"></a>java（哈希集合HashSet）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建</span></span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加元素 : O(1)</span></span><br><span class="line">        set.add(<span class="number">10</span>);</span><br><span class="line">        set.add(<span class="number">2</span>);</span><br><span class="line">        set.add(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//[10,2]</span></span><br><span class="line">        System.out.println(set.add(<span class="number">2</span>));	<span class="comment">//添加的元素已存在，会返回false，不存在则返回true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//搜索元素 : O(1)0</span></span><br><span class="line">        set.contains(<span class="number">2</span>);	<span class="comment">//存在则返回true</span></span><br><span class="line">        System.out.println(set.contains(<span class="number">2</span>));</span><br><span class="line">        <span class="comment">//删除元素 : O(1)</span></span><br><span class="line">        set.remove(<span class="number">2</span>);</span><br><span class="line">        System.out.println(set.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//长度</span></span><br><span class="line">        set.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="217-存在重复元素-1"><a href="#217-存在重复元素-1" class="headerlink" title="217.存在重复元素"></a>217.存在重复元素</h3><p>给定一个整数数组，判断是否存在重复元素。</p>
<p>如果存在一值在数组中出现至少两次，函数返回 <code>true</code> 。如果数组中每个元素都不相同，则返回 <code>false</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsDuplicate</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!set.add(x)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>









<h2 id="树-Tree"><a href="#树-Tree" class="headerlink" title="树   Tree"></a><strong>树   Tree</strong></h2><ul>
<li><p>树中有一个根结点，其余节点可以分成若干个互不相交的“子树”。</p>
</li>
<li><p>除了根节点，每个结点有且只有一个父节点；</p>
</li>
<li><p>一棵N个结点的树有N - 1条边；</p>
</li>
</ul>
<p>结点的度：结点的子树个数；</p>
<p>树的度：树中所有结点中最大的度；</p>
<p>叶结点：度为0的结点；</p>
<p>兄弟结点：具有同一父结点的各个结点；</p>
<p>路径和路径结点：从结点N到结点Nk的路径，其路径结点为路径中结点个数 - 1，即路径中所包含的边的个数；</p>
<p>祖先结点：从某一结点，到根结点的所有节点，都是这个结点的祖先节点；</p>
<p>子孙结点：某一结点的子树中的所有节点，都是这个结点的子孙；</p>
<p>层次：规定根结点  在0&#x2F;1层，其他结点的层数是其父结点的层数+1；</p>
<p>深度：从上往下数，等于层；高度：从下往上数</p>
<h3 id="二叉树："><a href="#二叉树：" class="headerlink" title="二叉树："></a>二叉树：</h3><p><strong>普通二叉树</strong>：每个结点最多两个子结点</p>
<p><strong>满二叉树</strong>：除了叶结点，每个结点都有两个子结点，并且所有叶结点都在同一层上；</p>
<blockquote>
<p>满二叉树的深度为k，则该树一共有 2^k^ - 1 个节点。</p>
</blockquote>
<p><strong>完全二叉树</strong>：从树的根结点出发，从上到下，从左到右，依次填满结点形成的二叉树</p>
<p>（满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树）</p>
<p><strong>二叉树的遍历：</strong></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>前</strong>序遍历</td>
<td><strong>根节点</strong>-&gt;左子树-&gt;右子树</td>
</tr>
<tr>
<td><strong>中</strong>序遍历</td>
<td>左子树-&gt;<strong>根节点</strong>-&gt;右子树</td>
</tr>
<tr>
<td><strong>后</strong>序遍历</td>
<td>左子树-&gt;右子树-&gt;<strong>根子树</strong></td>
</tr>
<tr>
<td>层次遍历</td>
<td>从上到下，从左到右</td>
</tr>
</tbody></table>
<p>（层次遍历需要用到 队列 ）</p>
<h4 id="二叉树实现"><a href="#二叉树实现" class="headerlink" title="二叉树实现"></a>二叉树实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span>    <span class="comment">//创建树的结点</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">right</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>    <span class="comment">//创建树根</span></span><br><span class="line">    Node *root;</span><br><span class="line">&#125; Tree;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(Tree *tree, <span class="type">int</span> value)</span> &#123;     <span class="comment">//创建树</span></span><br><span class="line">    Node *node = (Node *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));<span class="comment">//创建一个结点</span></span><br><span class="line">    node-&gt;data = value;</span><br><span class="line">    node-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (tree-&gt;root == <span class="literal">NULL</span>) tree-&gt;root = node;  <span class="comment">//判断树是不是空树</span></span><br><span class="line">    <span class="keyword">else</span> &#123;      <span class="comment">//不是空树</span></span><br><span class="line">        Node *temp = tree-&gt;root;    <span class="comment">//从树根开始</span></span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value &lt; temp-&gt;data)&#123;    <span class="comment">//小于就进左儿子</span></span><br><span class="line">                <span class="keyword">if</span> (temp-&gt;left == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    temp-&gt;left = node;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;    <span class="comment">//继续判断</span></span><br><span class="line">                    temp = temp-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;    <span class="comment">//否则进右儿子</span></span><br><span class="line">                <span class="keyword">if</span> (temp-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    temp-&gt;right = node;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;    <span class="comment">//继续判断</span></span><br><span class="line">                    temp = temp-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//树的中序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">inorder</span><span class="params">(Node *node)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        inorder(node-&gt;left);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,node-&gt;data);</span><br><span class="line">        inorder(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//树的前序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">inorder</span><span class="params">(Node *node)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,node-&gt;data);</span><br><span class="line">    inorder(node-&gt;left);</span><br><span class="line">    inorder(node-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//树的后序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">inorder</span><span class="params">(Node *node)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    inorder(node-&gt;left);</span><br><span class="line">    inorder(node-&gt;right);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,node-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除结点；</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Deleteer</span><span class="params">(Node *node, <span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *L,*LL;    <span class="comment">//在删除左右子树都有的结点时使用；</span></span><br><span class="line">    Node *p=node;</span><br><span class="line">    Node *parent=node;</span><br><span class="line">    <span class="type">int</span> child=<span class="number">0</span>;  <span class="comment">//0表示左子树，1表示右子树；</span></span><br><span class="line">    <span class="keyword">if</span>(!node)    <span class="comment">//如果排序树为空，则退出；</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">while</span>(p)  <span class="comment">//二叉排序树有效；</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data == value)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!p-&gt;left &amp;&amp; !p-&gt;right)  <span class="comment">//叶结点(左右子树都为空)；</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(p == node)  <span class="comment">//被删除的结点只有根结点；</span></span><br><span class="line">                    <span class="built_in">free</span>(p);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(child==<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    parent-&gt;left=<span class="literal">NULL</span>;  <span class="comment">//设置父结点左子树为空；</span></span><br><span class="line">                    <span class="built_in">free</span>(p);   <span class="comment">//释放结点空间；</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>   <span class="comment">//父结点为右子树；</span></span><br><span class="line">                &#123;</span><br><span class="line">                    parent-&gt;right=<span class="literal">NULL</span>;  <span class="comment">//设置父结点右子树为空；</span></span><br><span class="line">                    <span class="built_in">free</span>(p);  <span class="comment">//释放结点空间；</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!p-&gt;left)  <span class="comment">//左子树为空，右子树不为空；</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(child==<span class="number">0</span>)    <span class="comment">//是父结点的左子树；</span></span><br><span class="line">                    parent-&gt;left=p-&gt;right;</span><br><span class="line">                <span class="keyword">else</span>      <span class="comment">//是父结点的右子树；</span></span><br><span class="line">                    parent-&gt;right=p-&gt;right;</span><br><span class="line">                <span class="built_in">free</span>(p);  <span class="comment">//释放被删除的结点；</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!p-&gt;right)  <span class="comment">//右子树为空，左子树不为空；</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(child==<span class="number">0</span>)  <span class="comment">//是父结点的左子树；</span></span><br><span class="line">                    parent-&gt;left=p-&gt;left;</span><br><span class="line">                <span class="keyword">else</span>      <span class="comment">//是父结点的右子树；</span></span><br><span class="line">                    parent-&gt;right=p-&gt;left;</span><br><span class="line">                <span class="built_in">free</span>(p);  <span class="comment">//释放被删除的结点；</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                LL=p;  <span class="comment">//保存左子树的结点；</span></span><br><span class="line">                L=p-&gt;right;  <span class="comment">//从当前结点的右子树进行查找；</span></span><br><span class="line">                <span class="keyword">if</span>(L-&gt;left)  <span class="comment">//左子树不为空；</span></span><br><span class="line">                &#123;</span><br><span class="line">                    LL=L;</span><br><span class="line">                    L=L-&gt;left;   <span class="comment">//查找左子树；</span></span><br><span class="line">                    p-&gt;data=L-&gt;data;  <span class="comment">//将左子树的数据保存到被删除结点；</span></span><br><span class="line">                    LL-&gt;left=L-&gt;left;  <span class="comment">//设置父结点的左子树指针为空；</span></span><br><span class="line">                    <span class="keyword">for</span>(; L-&gt;left; L=L-&gt;left);</span><br><span class="line">                    L-&gt;left=p-&gt;left;</span><br><span class="line">                    p-&gt;left=<span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    p-&gt;data=L-&gt;data;</span><br><span class="line">                    LL-&gt;right=L-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            p=<span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(value &lt; p-&gt;data)  <span class="comment">//需删除记录的关键字小于结点的数据；</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//要删除的结点p是parent的左子树；</span></span><br><span class="line">            child=<span class="number">0</span>;  <span class="comment">//标记在当前结点左子树；</span></span><br><span class="line">            parent=p;<span class="comment">//保存当前结点作为父结点；</span></span><br><span class="line">            p=p-&gt;left;  <span class="comment">//查找左子树；</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">//需删除记录的关键字大于结点的数据；</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//要删除的结点p是parent的右子树；</span></span><br><span class="line">            child=<span class="number">1</span>;  <span class="comment">//标记在当前结点右子树查找；</span></span><br><span class="line">            parent=p;  <span class="comment">//保存当前结点作为父结点；</span></span><br><span class="line">            p=p-&gt;right;  <span class="comment">//查找右子树；</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Tree tree;</span><br><span class="line">    tree.root = <span class="literal">NULL</span>;  <span class="comment">//创建一个空树</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;     <span class="comment">//输入n个数并创建这个树</span></span><br><span class="line">        <span class="type">int</span> temp;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;temp);</span><br><span class="line">        insert(&amp;tree, temp);</span><br><span class="line">    &#125;</span><br><span class="line">    inorder(tree.root);</span><br><span class="line">    Deleteer(tree.root,<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><h3 id="二叉搜索树BST"><a href="#二叉搜索树BST" class="headerlink" title="二叉搜索树BST"></a>二叉搜索树BST</h3><p>二又排序树、二叉查找树（BST, Binary Search Tree）<br>是一棵二叉树或者是空二叉树，或者是具有如下性质的二叉树：</p>
<ul>
<li>左子树上所有结点的关键字均小于根结点的关键字</li>
<li>右子树上所有结点的关键字均大于根结点的关键字</li>
<li>左子树和右子树又各是一棵二又排序树。</li>
</ul>
<blockquote>
<p>左子树结点值 &lt; 根结点值 &lt; 右子树结点值；</p>
<p>进行中序遍历，可以得到一个递增的有序序列。</p>
</blockquote>
<p><strong>查找：</strong>时间复杂度 O(h)，若排序树很平衡，则h接近log<del>2</del>n，若非常不平衡，则h会接近n。</p>
<p><strong>插入：</strong>时间复杂度 O(h)</p>
<p>若原二叉排序树为空，则直接插入结点；否则，若关键字k小于 根结点值，则插入到左子树，若关键字k大于根结点值，则插入到右子树。</p>
<p><strong>删除：</strong></p>
<p>先搜索找到目标结点：</p>
<ul>
<li>①若被删除结点z是叶结点，则直接删除，不会破坏二又排序树的性质。</li>
<li>②若结点z只有一棵左子树或右子树，则让z的子树成为z父结点的子树，替代z的位置。</li>
<li>③若结点z有左、右两棵子树，则令z的直接后继（或直接前驱）替代z，然后从二叉排序树中删去这个直接后继（或直接前驱），这样就转换成了第一或第二种情况。</li>
</ul>
<h3 id="自平衡二叉树AVL"><a href="#自平衡二叉树AVL" class="headerlink" title="自平衡二叉树AVL"></a>自平衡二叉树AVL</h3><p>平衡二叉树( Balanced Binary Tree)，简称平衡树(AVL树)ー一树上任一结点的左子树和右子树的<strong>高度之差不超过1</strong>。</p>
<p>结点的平衡因子 &#x3D; 左子树高 - 右子树高。</p>
<ul>
<li>平衡二叉树结点的平衡因子的值只可能是-1、0或1。否则就不是平衡二叉树了。</li>
</ul>
<p>查找：时间复杂度不超过O(h) 、O(log<del>2</del>n)</p>
<p><strong>插入</strong>：</p>
<p><img src="D:/Note/Typora_picture/image-20211228111813606.png" alt="image-20211228111813606"></p>
<p><strong>调整</strong>最小不平衡子树A（从插入点找到的第一个不平衡点为根的子树）：</p>
<ul>
<li><p><strong>LL</strong>：在A的左孩子的左子树中插入导致不平衡；<br>调整：A的左孩子结点<strong>右上旋</strong>；</p>
</li>
<li><p><strong>RR</strong> ：在A的右孩子的右子树中插入导致不平衡；</p>
<p>调整：A的右孩子结点<strong>左上旋</strong>；</p>
</li>
<li><p><strong>LR</strong> ：在A的左孩子的右子树中插入导致不平衡；<br>调整：A的左孩子的右孩子<strong>先左上旋再右上旋</strong>；</p>
</li>
<li><p><strong>RL</strong> ：在A的右孩子的左子树中插入导致不平衡；<br>调整：A的右孩子的左孩子<strong>先右上旋后左上旋</strong>；</p>
</li>
</ul>
<h3 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h3><p><strong>结点的带权路径长度：</strong></p>
<blockquote>
<p>树的每一个结点，都可以拥有自己的“权重”（Weight），权重在不同的算法当中可以起到不同的作用。结点的带权路径长度，是指树的根结点到该结点的路径长度，和该结点权重的乘积。</p>
</blockquote>
<p><strong>树的带权路径长度</strong></p>
<blockquote>
<p>在一棵树中，所有叶子结点的带权路径长度之和，被称为树的带权路径长度，也被简称为WPL。</p>
</blockquote>
<p><strong>而哈夫曼树（Huffman Tree）是在叶子结点和权重确定的情况下，带权路径长度最小的二叉树，也被称为最优二叉树。</strong></p>
<p><strong>一颗有n个叶子结点的的哈夫曼树共有2n-1个结点</strong></p>
<p>原则上，我们应该让权重小的叶子结点远离树根，权重大的叶子结点靠近树根。</p>
<p>思路：</p>
<blockquote>
<p>借助辅助队列，将权值最小的两个叶子节点挑出来，并根据这两个结点生成一个新的父结点，父节点的权值是这两个结点权值之和；从队列中移除已选择的节点，把新的父结点加入队列；</p>
<p>重复这一步骤，直到所有结点组成一颗完整二叉树</p>
<p>（如果是构造<strong>k叉哈夫曼树</strong>，且节点数无法严格构成k叉树，则需要补充几个<strong>权值为0的 “假节点”</strong>）</p>
</blockquote>
<img src="D:/Note/Typora_picture/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91.png" style="zoom: 33%;" />

<img src="D:/Note/Typora_picture/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%912.png" style="zoom:33%;" />

<img src="D:/Note/Typora_picture/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%913.png" style="zoom:33%;" />

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span> weight;         <span class="comment">// 结点权值?</span></span><br><span class="line">    <span class="type">int</span> parent, lc, rc; <span class="comment">// 双亲结点和左 右子节点</span></span><br><span class="line">&#125; HTNode, *HuffmanTree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Select</span><span class="params">(HuffmanTree &amp;HT, <span class="type">int</span> n, <span class="type">int</span> &amp;s1, <span class="type">int</span> &amp;s2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> minum;      <span class="comment">// 定义一个临时变量保存最小值?</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;     <span class="comment">// 以下是找到第一个最小值</span></span><br><span class="line">        <span class="keyword">if</span> (HT[i].parent == <span class="number">0</span>) &#123;</span><br><span class="line">            minum = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (HT[i].parent == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> (HT[i].weight &lt; HT[minum].weight)</span><br><span class="line">                minum = i;</span><br><span class="line">    &#125;</span><br><span class="line">    s1 = minum;</span><br><span class="line">    <span class="comment">// 以下是找到第二个最小值，且与第一个不同</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (HT[i].parent == <span class="number">0</span> &amp;&amp; i != s1) &#123;</span><br><span class="line">            minum = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (HT[i].parent == <span class="number">0</span> &amp;&amp; i != s1)</span><br><span class="line">            <span class="keyword">if</span> (HT[i].weight &lt; HT[minum].weight)</span><br><span class="line">                minum = i;</span><br><span class="line">    &#125;</span><br><span class="line">    s2 = minum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreatHuff</span><span class="params">(HuffmanTree &amp;HT, <span class="type">int</span> *w, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m, s1, s2;</span><br><span class="line">    m = n * <span class="number">2</span> - <span class="number">1</span>;  <span class="comment">// 总结点的个数</span></span><br><span class="line">    HT = <span class="keyword">new</span> HTNode[m + <span class="number">1</span>]; <span class="comment">// 分配空间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123; <span class="comment">// 1 - n 存放叶子结点，初始化</span></span><br><span class="line">        HT[i].weight = w[i];</span><br><span class="line">        HT[i].parent = <span class="number">0</span>;</span><br><span class="line">        HT[i].lc = <span class="number">0</span>;</span><br><span class="line">        HT[i].rc = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n + <span class="number">1</span>; i &lt;= m; i++) &#123;  <span class="comment">// 非叶子结点的初始化</span></span><br><span class="line">        HT[i].weight = <span class="number">0</span>;</span><br><span class="line">        HT[i].parent = <span class="number">0</span>;</span><br><span class="line">        HT[i].lc = <span class="number">0</span>;</span><br><span class="line">        HT[i].rc = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nthe HuffmanTree is: \n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n + <span class="number">1</span>; i &lt;= m; i++)     <span class="comment">// 创建非叶子节点，建哈夫曼树</span></span><br><span class="line">    &#123;   <span class="comment">// 在HT[1]~HT[i-1]的范围内选择两个parent为0且weight最小的两个结点，其序号分别赋值给 s1 s2</span></span><br><span class="line">        <span class="built_in">Select</span>(HT, i - <span class="number">1</span>, s1, s2);</span><br><span class="line">        HT[s1].parent = i;  <span class="comment">// 删除这两个结点</span></span><br><span class="line">        HT[s2].parent = i;</span><br><span class="line">        HT[i].lc = s1;      <span class="comment">// 生成新的树，左右子节点是 s1和s2</span></span><br><span class="line">        HT[i].rc = s2;</span><br><span class="line">        HT[i].weight = HT[s1].weight + HT[s2].weight;   <span class="comment">// 新树的权�?</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d (%d, %d)\n&quot;</span>, HT[i].weight, HT[s1].weight, HT[s2].weight);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HuffmanTree HT;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> *w, n, wei;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;input the number of node\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    w = <span class="keyword">new</span> <span class="type">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\ninput the %dth node of value\n&quot;</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;wei);</span><br><span class="line">        w[i] = wei;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CreatHuff</span>(HT, w, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h4><p>哈夫曼编码：对一棵具有n个叶子的哈夫曼树，若对树中的每个左分支赋0，右分支赋1，则从根到每个叶子的路径上，各分支的赋值分别构成一个二进制串，该二进制串就称为哈夫曼编码。</p>
<p>哈夫曼编码的基本思想是：为出现次数较多的字符编以较短的编码，在压缩原理中有重要作用。</p>
<h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><p>B树，又称<strong>多路平衡查找树</strong>。</p>
<p>B树中所有结点的孩子个数的最大值称为B树的阶，通常用m表示。一棵m阶B树或为空树，或为满足如下特性的<strong>m叉树</strong>：</p>
<ol>
<li>树中每个结点<strong>至多有m棵子树</strong>，即<strong>至多含有m-1个关键字</strong></li>
<li>若<strong>根结点不是终端结点，则至少有两棵子树</strong>。</li>
<li>除根结点外的所有<strong>非叶结点至少有 m&#x2F;2 棵子树</strong>，即至少含有 (m&#x2F;2) -1 个关键字。</li>
<li><strong>所有的叶结点都出现在同一层次上，并且不帯信息</strong>（可以视为外部结点或类似于折半查找判定树的查找失败结点，实际上这些结点不存在，指向这些结点的指针为空）。</li>
</ol>
<p><img src="D:/Note/Typora_picture/image-20211227205412747.png" alt="image-20211227205412747"></p>
<p><strong>m阶B树的核心特性</strong></p>
<ol>
<li>根节点的子树数∈[2,m], 关键字数∈[1, m-1]<br>其他结点的子树数∈ [(m&#x2F;2), m] ;关键字数∈[(m&#x2F;2)-1, m-1]</li>
<li>对任一结点，其所有子树高度都相同</li>
<li>关键字的值：子树0 &lt; 关键字1 &lt; 子树1 &lt;关键字2 &lt; 子树2 &lt;. (类比二叉査找树左&lt;中&lt;右)</li>
</ol>
<blockquote>
<p>注：算B树高度时，不用包括叶子节点&#x2F;失败节点；</p>
<p>n个关键字的B树必有n+1个叶子节点。（相当于在n个关键字中插入木板，两边也插，则插了n+1个木板）</p>
</blockquote>
<p><strong>B树的插入</strong></p>
<p><strong>新元素一定是插入到最底层“终端节点”</strong>，用“查找”来确定插入位置。</p>
<p>在插入key后，若导致原结点关键字数超过上限，则从中间位置( [m&#x2F;2] )将其中的关键字分为两部分，左部分包含的关键字放在原结点中，右部分包含的关键字放到新结点中，中间位置( [m&#x2F;2] )的结点插入原结点的父结点。 </p>
<p>若此时导致其父结点的关键字个数也超过了上限，则继续进行这种分裂操作，直至这个过程传到根结点为止，进而导致B树高度增。</p>
<p><img src="D:/Note/Typora_picture/image-20211227210741287.png" alt="image-20211227210741287"></p>
<hr>
<p><strong>B树的删除</strong></p>
<ul>
<li><p>若被删除关键字在<strong>终端节点</strong>，则<strong>直接删除</strong>该关键字（要注意节点关键字个数是否低于下限 [m&#x2F;2] - 1 )</p>
</li>
<li><p>若被删除关键字在<strong>非终端节点</strong>，则用<strong>直接前驱或直接后继</strong>来<strong>替代</strong>被删除的关键字（直接前驱：当前关键字左侧指针所指子树中“最右下”的元素）——对非终端结点关键字的删除，必然可以转化为对终端结点的删除操作</p>
</li>
</ul>
<p><img src="D:/Note/Typora_picture/image-20211227211302810.png" alt="image-20211227211302810"></p>
<ul>
<li><p>若删除关键字所在节点删除后，<strong>关键字低于下限</strong>：</p>
<ul>
<li><p>如果<strong>兄弟节点关键字充足</strong>，可以调整该节点、兄弟节点、父节点来达到”<strong>借关键字</strong>“的目的。</p>
<p><img src="D:/Note/Typora_picture/image-20211227211924677.png" alt="image-20211227211924677"></p>
</li>
<li><p>如果<strong>兄弟节点关键字不足</strong>，可以调整该节点、兄弟节点、父节点来达到”<strong>合并</strong>“的目的。</p>
<p><img src="D:/Note/Typora_picture/image-20211227212543467.png" alt="image-20211227212543467"></p>
</li>
</ul>
</li>
</ul>
<h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p>B+树 可以类比分块查找。</p>
<p>分块查找：</p>
<p><img src="D:/Note/Typora_picture/image-20211227212836480.png" alt="image-20211227212836480"></p>
<p>B+树：</p>
<p><img src="D:/Note/Typora_picture/image-20211227212949012.png" alt="image-20211227212949012"></p>
<p>一棵<strong>m阶的B+树</strong>需满足下列条件：</p>
<ol>
<li>每个分支结点最多有m棵子树（孩子结点）。</li>
<li>非叶根结点至少有两棵子树，其他每个分支结点至少有 m&#x2F;2 棵子树。</li>
<li><strong>结点的子树个数与关键字个数相等</strong>。（区别于B树，因为B+树的关键字和子树是一一对应的）</li>
<li>所有<strong>叶结点包含全部关键字及指向相应记录的指针</strong>，叶结点中将关键字按大小顺序排列，并且<strong>相邻叶结点按大小顺序相互链接起来</strong>。（支持顺序查找）</li>
<li>所有<strong>分支结点</strong>中仅包含它的各个子结点中<strong>关键字的最大值</strong>及指向其子结点的指针。</li>
</ol>
<p><strong>B+的查找：</strong></p>
<p><strong>无论查找成功与否，最终一定要走到最下面一层节点。</strong>因为只有叶子节点存放了所需记录。</p>
<hr>
<p><strong>B树和B+树的对比：</strong></p>
<p><img src="D:/Note/Typora_picture/image-20211227213649466.png" alt="image-20211227213649466"></p>
<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><h4 id="概念性质"><a href="#概念性质" class="headerlink" title="概念性质"></a>概念性质</h4><p>红黑树的概念模型是<strong>2-3-4树</strong>，以<strong>二叉树为基础</strong>，在二叉树属性中加入<strong>颜色属性</strong>来表示2-3-4树中不同的节点。</p>
<p>红黑树的<strong>五大定义</strong>：</p>
<ol>
<li><strong>节点颜色只能为红或黑；</strong></li>
<li><strong>根节点是黑色；</strong></li>
<li><strong>每个叶子节点是黑色的（这里的叶子节点其实是空节点）</strong></li>
<li><strong>不能出现连续的红色节点；</strong></li>
<li><strong>从任意节点到它的每个子节点的所有路径都包含相同的黑色节点；</strong></li>
</ol>
<p>这5条定义确保了红黑树的关键特性：</p>
<ul>
<li><strong>从根到叶子节点的最长路径，不会超过最短路径的两倍</strong>；</li>
<li>这棵树<strong>基本是平衡</strong>的；</li>
<li>虽然不是绝对平衡，但可以保证<strong>最坏情况下，红黑树依然是高效的</strong>；</li>
</ul>
<p>为什么能做到最长路径不超过最短路径的两倍？</p>
<blockquote>
<p>性质4规定了路径上不能有两个相连的红节点，因此，最长路径一定是红色节点和黑节点交替而成；</p>
<p>性质2和3规定了根节点和叶子节点都是黑色，所以最短路径的黑节点一定多于红节点（可能全部为黑）；</p>
<p>性质5规定每条路径黑节点的数目相同；</p>
<p>因此，没有路径的长能多于其他任何路径两倍。</p>
</blockquote>
<p>红黑树的<strong>三种变换：变色，左旋转，右旋转</strong></p>
<p>红黑树<strong>插入的新节点为红色</strong>的：</p>
<blockquote>
<p>因为插入红节点，不会违反红黑树的规则，虽然可能会红红相连，不过可以通过变色和旋转来调整；而插入黑色节点，必然会导致一条路径上多一个黑节点（难以调整）。</p>
</blockquote>
<hr>
<p><strong>左旋转</strong>：以当前节点X为根，逆时针旋转二叉树，使得<strong>父节点原来的位置被右子节点替代，左子节点的位置被父节点替代</strong>。同时，节点Y的<strong>左子树</strong> b 向<strong>左平移</strong>成为了节点X的<strong>右子树</strong></p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BA%A2%E9%BB%91%E6%A0%91/2.png" alt="image-20200303132706061"></p>
<p>旋转之后仍然是二叉搜索树：</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BA%A2%E9%BB%91%E6%A0%91/3.png" alt="image-20200303132617108"></p>
<p><strong>右旋转</strong>：以节点X为根，<strong>顺时针</strong>旋转二叉搜索树，使得父节点原来的位置被自己的左子节点替代，右子节点的位置被父节点替代；</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BA%A2%E9%BB%91%E6%A0%91/4.png" alt="image-20200303132529476"></p>
<h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><h4 id="2-3树-到-红黑树"><a href="#2-3树-到-红黑树" class="headerlink" title="2-3树 到 红黑树"></a>2-3树 到 红黑树</h4><p>2-3-4树中的2节点对应红黑树中的黑色节点，而非2节点以红节点+黑节点的方式表示，黑色父节点+一个红色子节点表示3节点，黑色父节点+左右两个红色子节点表示4节点；</p>
<blockquote>
<p>2-3-4树 ：是一颗阶数为4的B树，它可能会存在2节点，3节点，4节点（2节点就是普通的二叉树节点；3节点：由2个属性X和Y，3个子节点，分别是小于X的，大于X小于Y的，大于Y的；4节点跟3节点类似）</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/img_convert/9f7961f77546c8f13448372625282335.png" alt="B树到红黑树的转化"></p>
<p>下面是以较为简单的 2-3树和左倾红黑树 为例，理解两者的转化关系</p>
<blockquote>
<p>2-3树不用考虑2-3-4树中复杂的4节点分裂；</p>
<p>左倾红黑树规定了红色节点只能在左子树，这个限制减少了原本红黑树的调平难度，更容易理解；</p>
</blockquote>
<hr>
<p>2-3树 和 左倾红黑树 ：把左倾红黑树中的红色节点<strong>顺时针方向旋转45°</strong>使其与黑父平行，然后再将它们看作一个整体，可以近似得到一颗2-3树。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/5a84b9872980c9a8761d3b84315d5931.png" alt="B树到红黑树的转化"></p>
<p>从2-3树来看，红黑树的红节点和黑节点是绑定的，因为在2-3树中它们本来就在同一层，所有只有黑节点在2-3树中体现树的高度</p>
<hr>
<p><strong>对于2-3树的插入：</strong></p>
<p>我们的插入操作需要遵循一个<strong>原则</strong>：先将这个元素尝试性地放在<strong>已经存在的节点中</strong>（即插入一个红色节点），如果要存放的节点是2节点，那么插入后会变成3节点，如果要存放的节点是3节点，那么插入后会变成4节点（<strong>临时</strong>）。然后，我们对可能生成的临时4节点进行分裂处理，使得临时4节点消失。</p>
<p>如图：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/02050b1461f4b891a92052f41139c567.png" alt="2-3树的插入"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/706a4ae059ebd3b6cfd8dfef6a3f05e4.png" alt="2-3-4树的插入"></p>
<p>在2-3树中如果待插入节点是个2节点，而2节点对应着红黑树中的黑色父节点；所以向2节点插入元素，即在黑色父节点下面增加一个红色儿子，</p>
<p>3节点插入元素，即已经有一个黑色父节点和一个红色子节点，则再给黑色父节点一个红色子节点</p>
<hr>
<p><strong>对于2-3树的删除：</strong></p>
<p>2-3树的删除我们主要要考虑待删除元素在2节点这种情况，因为如果待删除元素在3节点，那么可以直接将这个元素删除，而不会破坏2-3树的任何性质（删除这个元素不会引起高度的变化）。</p>
<p>当待删除元素在2节点的时候，由于删除这个元素会导致2节点失去自己<strong>唯一的元素</strong>，引发2节点自身的删除，会使得树中某条路径的<strong>高度发生变化</strong>，树变得<strong>不平衡</strong>。</p>
<p>对此有两种方案：</p>
<ol>
<li>先删除这个2节点，再对树进行平衡调整；</li>
<li>想办法让被删除元素不可能出现在2节点中；</li>
</ol>
<p>这里看第二种方案，我们在搜索到这个节点的路径中，不断地判断当前节点是否为2节点，如果是，就从它的兄弟节点或者它的父节点借一个元素，使得当前节点由2节点成为一个3节点或者一个临时4节点。</p>
<p>这种操作会产生一种结果：除非当前节点是根节点，否则当前节点的父节点一定是一个非2节点（因为搜索的路径是自上而下，父节点已经进行过了这种操作，所以不可能是2节点），那么我们可以保证到达叶子节点的时候，也能顺利的从父节点或者兄弟节点处借到元素，使得自己成为非2节点。从而能够直接删除某个元素<br><img src="https://img-blog.csdnimg.cn/img_convert/9f2f0ebec960203ecafac6bf91462be2.png" alt="2-3树的删除"></p>
<p>插入和删除操作的父子节点上下浮动和删除里借元素的做法，就是红黑树的调整（变色，旋转）；</p>
<p>看左倾红黑树的 插入和删除（图示）：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/4947b64375651e3b2072ecd09d3fad7b.png" alt="左倾红黑树的插入"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/03f56fa81ffaee6bfe4fd68d25b6bc63.png" alt="左倾红黑树的插入"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/162498f17b4122405b0ef04cefe55368.png" alt="左倾红黑树的插入"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/28d7b36542a54750935418950da5d8eb.png" alt="左倾红黑树的插入"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/cd622250cc9453c634658ae934defc88.png" alt="左倾红黑树的删除"></p>
<p>删除之后需要一些调整（左倾红黑树不允许出现右倾）</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/711d441a7e05c4843237ac5e6f424f26.png" alt="左倾红黑树的删除"></p>
<h2 id="堆-Heap"><a href="#堆-Heap" class="headerlink" title="堆   Heap"></a><strong>堆   Heap</strong></h2><p>性质：</p>
<ol>
<li>结构性：用<strong>数组表示</strong>的<strong>完全二叉树</strong>。</li>
<li>有序性：任意结点的关键字（权值）是其子树所有结点的最小值&#x2F;最大值<br>1. 父结点大于子结点：最大堆&#x2F;大根堆（MaxHeap）<br>            2. 父结点小于子结点：最小堆&#x2F;小根堆（MinHeap）</li>
</ol>
<p>应用：</p>
<ol>
<li>优先队列：是一种特殊的“队列”，从队列中取出元素的顺序是依照元素的关键字（权值&#x2F;数值）大小，而不是元素进入队列的先后顺序。</li>
<li>堆排序</li>
</ol>
<h3 id="最小堆操作与实现："><a href="#最小堆操作与实现：" class="headerlink" title="最小堆操作与实现："></a>最小堆操作与实现：</h3><p>对于任意最多有MaxSize个元素的最小堆H ∈ MinHeap 元素，item ∈</p>
<p> ElementType主要操作有：</p>
<ul>
<li>MinHeap Create(int Maxsize): 创建一个空的最小堆。</li>
<li>void Destroy(MinHeap)：释放堆的空间。</li>
<li>Boolean IsFull(MinHeap H): 判断最小堆是否已满。</li>
<li>Boolean IsEmpty(MinHeap H): 判断最小堆是否为空。</li>
<li>void Insert(MinHeap H,ElementType item): 将元素item插入最小堆H。</li>
<li>ElementType DeleteMin(MinHeap H): 返回最小堆H中最小元素（高优先级）。</li>
<li>MinHeap BuildMinHeap(ElementType *Element,int Size,int MaxSize)：创建一个非空的最小堆</li>
</ul>
<p><strong>数组下标为0</strong>的位置放一个比所有堆中元素都要小的元素（可以是ElementType的最小值），称为“<strong>哨兵</strong>”。从下标为1的位置开始存放堆中元素。因为是完全二叉树，所以父亲节点与其左右子节点下标满足一些关系。</p>
<p><strong>由子节点找父节点：父节点下标&#x3D;子节点下标 &#x2F; 2</strong><br><strong>由父节点找左子节点：左子节点下标&#x3D;父节点下标 * 2</strong><br><strong>由父节点找右子节点：右子节点下标&#x3D;父节点下标 * 2 + 1</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElementType int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HeapStruct</span> &#123;</span></span><br><span class="line">    ElementType *Elenment;      <span class="comment">//存储堆元素的数组</span></span><br><span class="line">    <span class="type">int</span> Size;       <span class="comment">//堆的当前元素个数（最后一个元素的下标）</span></span><br><span class="line">    <span class="type">int</span> MaxSize;        <span class="comment">//堆存储空间的大小</span></span><br><span class="line">&#125; HeapStruct, *MinHeap;</span><br><span class="line"></span><br><span class="line">MinHeap <span class="title function_">Create</span><span class="params">(<span class="type">int</span> MaxSize)</span> &#123;</span><br><span class="line">    MinHeap H = (MinHeap) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> HeapStruct));     <span class="comment">//分配堆结构空间</span></span><br><span class="line">    H-&gt;Elenment = (ElementType *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ElementType) * (MaxSize + <span class="number">1</span>));    <span class="comment">//分配储存堆元素的数组的空间</span></span><br><span class="line">    H-&gt;Size = <span class="number">0</span>;</span><br><span class="line">    H-&gt;MaxSize = MaxSize;</span><br><span class="line">    H-&gt;Elenment[<span class="number">0</span>] = <span class="number">-2020</span>;</span><br><span class="line">    <span class="keyword">return</span> H;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放堆申请的空间</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Destroy</span><span class="params">(MinHeap H)</span> &#123;</span><br><span class="line">    <span class="built_in">free</span>(H-&gt;Elenment);     <span class="comment">//先释放堆节点的数组空间</span></span><br><span class="line">    <span class="built_in">free</span>(H);        <span class="comment">//再释放堆节点的空间</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断最小堆是否已满</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsFull</span><span class="params">(MinHeap H)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (H-&gt;Size == H-&gt;MaxSize); <span class="comment">//判断最小堆中元素个数size是否等于最大容量MaxSize</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断最小堆是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(MinHeap H)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (H-&gt;Size == <span class="number">0</span>);  <span class="comment">//判断堆中元素个数是否等于0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将元素item插入最小堆H</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Inset</span><span class="params">(MinHeap H, ElementType item)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//判断堆H是否已满</span></span><br><span class="line">    <span class="keyword">if</span> (IsFull(H)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Heap is full\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  如果H未满，将item放入堆最后一个元素，查看它的父节点，如果它的父节点比它大，将它和它的父节点互换位置循环此过程，直至它的父节点小于它。可能它比所有它的父节点都要小，但是一定会比哨兵大（数组中下标为0的位置），所以一定最后它的下标一定大于哨兵的下标0。这就是哨兵的意义。</span></span><br><span class="line">    H-&gt;Size++;</span><br><span class="line">    <span class="keyword">for</span> (i = H-&gt;Size; H-&gt;Elenment[i / <span class="number">2</span>] &gt; item; i = i / <span class="number">2</span>) &#123;</span><br><span class="line">        H-&gt;Elenment[i] = H-&gt;Elenment[i / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;Elenment[i] = item;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回最小堆H中最小元素（高优先级）</span></span><br><span class="line"><span class="comment">//将堆根结点元素取出，并将堆元素重新排序</span></span><br><span class="line">ElementType <span class="title function_">Delete</span><span class="params">(MinHeap H)</span>&#123;</span><br><span class="line">    <span class="type">int</span> parent = <span class="number">0</span>,child = <span class="number">0</span>;</span><br><span class="line">    ElementType item, temp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断堆是否已经空了</span></span><br><span class="line">    <span class="keyword">if</span> (IsEmpty(H))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Heap is Empty\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> H-&gt;Elenment[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//堆没有空，将根节点返回，最后一个叶子节点放到根节点位置，然后比较它与它的左右子节点中最小节点的大小，如果它比较大，则将它和它的较小的子节点互换位置，重复此过程，直至他比两个子节点都小或者它不在有子节点</span></span><br><span class="line">    item = H-&gt;Elenment[<span class="number">1</span>];</span><br><span class="line">    temp = H-&gt;Elenment[H-&gt;Size];</span><br><span class="line">    H-&gt;Size--;</span><br><span class="line">    <span class="keyword">for</span>(parent = <span class="number">1</span>; parent * <span class="number">2</span> &lt;= H-&gt;Size; parent = child)&#123;</span><br><span class="line">        child = parent*<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//找出左右子结点最小的那个</span></span><br><span class="line">        <span class="keyword">if</span>(child != H-&gt;Size &amp;&amp; (H-&gt;Elenment[child] &gt; H-&gt;Elenment[child +<span class="number">1</span>]))&#123;</span><br><span class="line">            child ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp &gt; H-&gt;Elenment[child])&#123;</span><br><span class="line">            H-&gt;Elenment[parent] = H-&gt;Elenment[child];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;Elenment[parent] = temp;</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个非空的堆</span></span><br><span class="line"><span class="comment">//可以先建一个空堆，再用Insert函数将元素一个一个插入；另一种方法是：将数组复制到堆结点的Element，再进行排序第二种方法时间复杂度更低</span></span><br><span class="line"><span class="comment">//已知一个数组，创建一个由数组元素组成的最小堆</span></span><br><span class="line">MinHeap <span class="title function_">BuildMinHeap</span><span class="params">(ElementType *Element,<span class="type">int</span> Size,<span class="type">int</span> MaxSize)</span>&#123;</span><br><span class="line">    MinHeap H = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, parent = <span class="number">0</span>, child = <span class="number">0</span>;</span><br><span class="line">    ElementType Temp;</span><br><span class="line"></span><br><span class="line">    H = Create(MaxSize);    <span class="comment">//创建一个空最小堆</span></span><br><span class="line">    <span class="keyword">if</span> (Size &gt; H-&gt;MaxSize)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;堆储存空间不足\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//复制数组元素</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;Size; i++)&#123;</span><br><span class="line">        H-&gt;Elenment[i + <span class="number">1</span>] = Element[i];</span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;Size = Size;</span><br><span class="line">    <span class="comment">//给最小堆排序</span></span><br><span class="line">    <span class="comment">//最后一个节点的父节点的左右指针都指向一个堆，将最后一个节点的父节点和它的两个子节点排序（方法类似与删除节点的操作），使得最后一个节点、其父节点和其兄弟节点形成一个堆。循环操作，从最后一个节点的父节点往上依次执行这个操作，最后使得整个树都是一个堆。</span></span><br><span class="line">    <span class="keyword">for</span> (parent = H-&gt;Size/<span class="number">2</span>; parent &gt;= <span class="number">1</span>; parent--)&#123;</span><br><span class="line">        Temp = H-&gt;Elenment[parent];</span><br><span class="line">        <span class="keyword">for</span>(; parent * <span class="number">2</span> &lt;= H-&gt;Size; parent = child)&#123;</span><br><span class="line">            child = parent * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果左右子树都存在，将child作为两者较小者的下标</span></span><br><span class="line">            <span class="keyword">if</span>(child != H-&gt;Size &amp;&amp; (H-&gt;Elenment[child] &gt; H-&gt;Elenment[child + <span class="number">1</span>]))&#123;</span><br><span class="line">                child ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//比较parent和child分别指向的结点的大小，parent较大则互换位置</span></span><br><span class="line">            <span class="keyword">if</span>(Temp &gt; H-&gt;Elenment[child])&#123;</span><br><span class="line">                H-&gt;Elenment[parent] = H-&gt;Elenment[child];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        H-&gt;Elenment[parent] = Temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> H;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>Heapsort是利用堆所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质，即子结点的键值总小于（或大于）它的父结点。它有两种方法来排序：</p>
<ol>
<li>大顶堆：每个结点的值都大于或等于其他子结点的值，在堆排序中可用于升序排序。（因为其中每一次排序都会先将堆顶的元素交换到后面）</li>
<li>小顶堆：每个结点的值都小于或等于其他子结点的值，在堆排序中可用于降序排序。</li>
</ol>
<p>堆排序的平均时间复杂度是O（nlogn）</p>
<h4 id="堆排序操作与实现"><a href="#堆排序操作与实现" class="headerlink" title="堆排序操作与实现"></a>堆排序操作与实现</h4><ol>
<li>创建一个堆；</li>
<li>把堆首与堆尾互换；</li>
<li>把堆的尺寸缩小1，并调用heapify（堆化）将堆重新调整好；</li>
<li>重复步骤2、3，直到堆的尺寸为1。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> *b)</span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = *b;</span><br><span class="line">    *b = *a;</span><br><span class="line">    *a = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">max_heapify</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> start, <span class="type">int</span> end)</span>&#123;</span><br><span class="line">    <span class="comment">//建立父结点指标和子结点指标</span></span><br><span class="line">    <span class="type">int</span> parent = start;</span><br><span class="line">    <span class="type">int</span> child = parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(child &lt;= end)&#123;    <span class="comment">//子结点指标在范围内才做比较</span></span><br><span class="line">        <span class="keyword">if</span>(child + <span class="number">1</span> &lt;= end &amp;&amp; arr[child] &lt; arr[child + <span class="number">1</span>])     <span class="comment">//选择两个子结点中较大的</span></span><br><span class="line">            child ++;</span><br><span class="line">        <span class="keyword">if</span>(arr[parent] &gt; arr[child])     <span class="comment">//如果父结点较大，则表示调整完毕，直接跳出</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;       <span class="comment">//否则交换父子结点内容，再继续子结点和孙结点比较</span></span><br><span class="line">            swap(&amp;arr[parent],&amp;arr[child]);</span><br><span class="line">            parent = child;</span><br><span class="line">            child = parent *<span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">heap_dort</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> len)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">//初始化，i从最后一个父结点开始调整</span></span><br><span class="line">    <span class="keyword">for</span>(i = len / <span class="number">2</span> <span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        max_heapify(arr, i ,len - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//先将第一个元素和已经排好的元素前一位交换，再重新调整</span></span><br><span class="line">    <span class="keyword">for</span>(i = len - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i)&#123;</span><br><span class="line">        swap(&amp;arr[<span class="number">0</span>],&amp;arr[i]);</span><br><span class="line">        max_heapify(arr, <span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//因为除了交换的两个元素，其他已经堆化好了，所以从上往下只经过一条路径即可</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123; <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len = (<span class="type">int</span>) <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(*arr);</span><br><span class="line">    heap_sort(arr, len);</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="215-数组中的第k个最大元素"><a href="#215-数组中的第k个最大元素" class="headerlink" title="215.数组中的第k个最大元素"></a>215.数组中的第k个最大元素</h3><p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>k</code> 个最大的元素。</p>
<p><strong>示例 :</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,1,5,6,4] 和 k = 2</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure>

<p>（可以自行构造最大堆或最小堆，加深对堆的认识）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; maxheap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(Collections.reverseOrder());</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            maxheap.add(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            maxheap.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxheap.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最小堆实现（只需k个元素在堆里）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 对前k个元素建成小根堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            swim(nums, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 剩下的元素与堆顶比较，若大于堆顶则去掉堆顶，再将其插入</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[<span class="number">0</span>]) &#123;</span><br><span class="line">                swap(nums[<span class="number">0</span>], nums[i]);</span><br><span class="line">                sink(nums, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 结束后第k个大的数就是小根堆的堆顶</span></span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 若v1比v2优先度高，返回true</span></span><br><span class="line">    bool <span class="title function_">priorityThan</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span> &#123; <span class="keyword">return</span> v1 &lt; v2; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上浮 从下到上调整堆</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heap, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; priorityThan(heap[i], heap[(i - <span class="number">1</span>) / <span class="number">2</span>])) &#123;</span><br><span class="line">            swap(heap[i], heap[(i - <span class="number">1</span>) / <span class="number">2</span>]);</span><br><span class="line">            i = (i - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下沉 从下到上调整堆</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sink</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heap, <span class="type">int</span> i, <span class="type">int</span> N)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span> * i + <span class="number">1</span> &lt;= N) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">1</span> &lt;= N &amp;&amp; priorityThan(heap[j + <span class="number">1</span>], heap[j])) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (priorityThan(heap[i], heap[j])) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(heap[i], heap[j]);</span><br><span class="line">            i = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="692-前k个高频单词"><a href="#692-前k个高频单词" class="headerlink" title="692.前k个高频单词"></a>692.前k个高频单词</h3><p>给一非空的单词列表，返回前 <em>k</em> 个出现次数最多的单词。</p>
<p>返回的答案应该按单词出现频率由高到低排序。如果不同的单词有相同出现频率，按字母顺序排序。</p>
<p>示例 ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;the&quot;, &quot;day&quot;, &quot;is&quot;, &quot;sunny&quot;, &quot;the&quot;, &quot;the&quot;, &quot;the&quot;, &quot;sunny&quot;, &quot;is&quot;, &quot;is&quot;], k = 4</span><br><span class="line">输出: [&quot;the&quot;, &quot;is&quot;, &quot;sunny&quot;, &quot;day&quot;]</span><br><span class="line">解析: &quot;the&quot;, &quot;is&quot;, &quot;sunny&quot; 和 &quot;day&quot; 是出现次数最多的四个单词，</span><br><span class="line">    出现次数依次为 4, 3, 2 和 1 次。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个小根优先队列。</span></span><br><span class="line"><span class="comment">//将每一个字符串插入到优先队列中，如果优先队列的大小超过了 k，那么我们就将优先队列顶端元素弹出。这样最终优先队列中剩下的 kk 个元素就是前 kk 个出现次数最多的单词。</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">topKFrequent</span><span class="params">(String[] words, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">//用哈希表存储字符串和出现次数</span></span><br><span class="line">        Map&lt;String, Integer&gt; cnt = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            cnt.put(word, cnt.getOrDefault(word, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//一个PriorityQueue对象：将key-value转为entry对象，放入优先队列（堆）中，（自定义）排序（构造最小堆）</span></span><br><span class="line">        PriorityQueue&lt;Map.Entry&lt;String, Integer&gt;&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;Map.Entry&lt;String, Integer&gt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Map.Entry&lt;String, Integer&gt;&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Map.Entry&lt;String, Integer&gt; entry1, Map.Entry&lt;String, Integer&gt; entry2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> entry1.getValue() == entry2.getValue() ? entry2.getKey().compareTo(entry1.getKey()) : entry1.getValue() - entry2.getValue();	<span class="comment">//注意这里 entry2.compareTo(entry1) 中entry1与entry2在数组中的位置，entry2表示后加进来的元素，entry1表示原来的元素.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//将哈希表中的key-value依次放入最小堆中</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : cnt.entrySet()) &#123;</span><br><span class="line">            pq.offer(entry);</span><br><span class="line">            <span class="keyword">if</span> (pq.size() &gt; k) &#123;    <span class="comment">//大小超过k后，去掉堆顶元素（去掉最小值，因为题目要求最大的k个）</span></span><br><span class="line">                pq.poll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">            ret.add(pq.poll().getKey());</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(ret);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//哈希表 + 排序</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">topKFrequent</span><span class="params">(String[] words, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        HashMap&lt;String, Integer&gt; hash = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String s : words) &#123;</span><br><span class="line">            hash.put(s, hash.getOrDefault(s, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将每一组value变为一个entry对象存入list数组</span></span><br><span class="line">        List&lt;String&gt; rec = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : hash.entrySet()) &#123;</span><br><span class="line">            rec.add(entry.getKey());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Collections.sort(rec, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> hash.get(word1).equals(hash.get(word2)) ? word1.compareTo(word2) : hash.get(word2) - hash.get(word1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> rec.subList(<span class="number">0</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="要素"><a href="#要素" class="headerlink" title="要素"></a>要素</h3><p>G（ V , E ）：图由顶点集合V（G）和边集合E（G）构成；</p>
<p><strong>端点：</strong></p>
<p>无向图：一条边（i，j） ，它的顶点 i 和 j 叫<strong>端点</strong>，它们互为<strong>邻接点</strong>；</p>
<p>有向图：一条边&lt; i , j &gt;  ，它的顶点 i 为 起始端点 （起点），j 为终止端点 （终点），它们互为邻接点；</p>
<p><strong>度</strong>：</p>
<p>以某点为端点的 边的数量 叫该顶点的<strong>度</strong></p>
<p>入度：进入该点的边数；</p>
<p>出度：从该点出发的边数</p>
<p><strong>完全图：</strong></p>
<p>完全无向图：n( n - 1 ) &#x2F; 2 条边</p>
<p>完全有向图：n( n - 1) 条边</p>
<p>当一个图接近完全图时，称为<strong>稠密图</strong>，反之，则为<strong>稀疏图</strong>；</p>
<p><strong>路径：</strong></p>
<p>路径长度：一条路径上经过的边的数目；</p>
<p>简单路径：除开始点和结束点可以相同，其它顶点均不同；</p>
<p>环&#x2F;回路：一条路径上开始点和结束点为同一顶点；</p>
<p><strong>连通：</strong>指从 i 到 j 有路径，则 i 和 j 连通；</p>
<p>连通图：无向图中任意两点连通；</p>
<p>强连通图：有向图中任意两点连通；</p>
<p>连通分量：指无向图G中的极大连通子图；</p>
<p>强连通分量：指有向图G中的极大连通子图；</p>
<p>（强连通图的连通分量只有一个，非连通图有多个连通分量）（强连通图也一样）</p>
<p><strong>权：</strong>边上附加的一个数值，可以表示从一个顶点到另一个顶点的距离或代价；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">问：</span><br><span class="line">设有一个图G=（V，E），取V的子集V&#x27;，E的子集E&#x27;。那么，（V&#x27;，E）一定是G的子图吗？</span><br><span class="line"></span><br><span class="line">答：</span><br><span class="line">如果对顶点的子集和边的子集不加限定的话，(V&#x27;,E&#x27;)不一定构成一个图。</span><br><span class="line">假如边集对应的顶点包含在所取的顶点集中，则(V&#x27;,E&#x27;)构成G的子图</span><br><span class="line">如果所取的顶点集不能包含s取的边集所对应的所有顶点，则(V&#x27;,E&#x27;)不构成G的子图。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>邻接矩阵 存储类型：</strong></p>
<p><img src="D:/Note/Typora_picture/image-20211227214212034.png" alt="image-20211227214212034"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#define MAXV &lt;最大顶点个数&gt;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//声明 顶点 类型    </span></span><br><span class="line">typedef struct&#123;</span><br><span class="line">	<span class="type">int</span> no;		<span class="comment">//顶点编号</span></span><br><span class="line">	InfoType info;	<span class="comment">//顶点其他信息</span></span><br><span class="line">&#125;VertexType;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明 邻接矩阵 类型</span></span><br><span class="line">typedef struct&#123;</span><br><span class="line">    <span class="type">int</span> edges[MAXV][MAXV];</span><br><span class="line">    <span class="type">int</span> n, e;</span><br><span class="line">    VertexType vexs[MAXV];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>邻接表 存储类型：</strong></p>
<p><img src="D:/Note/Typora_picture/image-20211227214032490.png" alt="image-20211227214032490"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明 边节点 类型</span></span><br><span class="line">typedef struct ANode&#123;</span><br><span class="line">    <span class="type">int</span> adjvex;		<span class="comment">//该边的终点编号</span></span><br><span class="line">    struct ANode *next;	<span class="comment">//指向下一条边</span></span><br><span class="line">    InfoType info;	<span class="comment">//该边的权值等信息</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明 邻接表头节点 类型</span></span><br><span class="line">typedef struct Vnode&#123;</span><br><span class="line">    vertex data;	<span class="comment">//顶点信息</span></span><br><span class="line">    ArcNode *firstArc;<span class="comment">//指向第一条边</span></span><br><span class="line">&#125;VNode;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//声明 邻接表 类型</span></span><br><span class="line">typedef struct&#123;</span><br><span class="line">    VNode adjList[MAXV];<span class="comment">//邻接表</span></span><br><span class="line">    <span class="type">int</span> n, e;	<span class="comment">//图中顶点数n和边数e</span></span><br><span class="line">&#125;AdjGraph;</span><br></pre></td></tr></table></figure>

<p><strong>邻接矩阵 和 邻接表 对比：</strong></p>
<p><img src="D:/Note/Typora_picture/image-20211227214112779.png" alt="image-20211227214112779"></p>
<p><strong>十字链表（有向图）</strong></p>
<p><img src="D:/Note/Typora_picture/image-20211227214400091.png" alt="image-20211227214400091"></p>
<p>找顶点出边： 顺着绿色线找</p>
<p>找顶点入边：顺着橙色线找</p>
<hr>
<p><strong>邻接多重表（无向图）</strong></p>
<p><img src="D:/Note/Typora_picture/image-20211227214717843.png" alt="image-20211227214717843"></p>
<hr>
<p><strong>四种存储方式 对比</strong></p>
<p><img src="D:/Note/Typora_picture/image-20211227214851706.png" alt="image-20211227214851706"></p>
<h3 id="一些基本操作"><a href="#一些基本操作" class="headerlink" title="一些基本操作"></a>一些基本操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建图的邻接表</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createAdj</span><span class="params">(AdjGraph *G, <span class="type">int</span> a[MAXV][MAXV], <span class="type">int</span> n, <span class="type">int</span> e)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    ArcNode *p;</span><br><span class="line">    G = (AdjGraph *) malloc(sizeof(AdjGraph));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        G-&gt;adjList[i].firstArc = NULL;      <span class="comment">//所有头节点的指针域赋初值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i][j] != <span class="number">0</span> &amp;&amp; a[i][j] != INF) &#123;        <span class="comment">//这条边存在</span></span><br><span class="line">                p = (ArcNode *) malloc(sizeof(ArcNode));</span><br><span class="line">                p-&gt;adjvex = j;                  <span class="comment">//存放邻接点</span></span><br><span class="line">                p-&gt;weight = a[i][j];            <span class="comment">//存放 权</span></span><br><span class="line">                p-&gt;next = G-&gt;adjList[i].firstArc;   <span class="comment">//头插法插入节点</span></span><br><span class="line">                G-&gt;adjList[i].firstArc = p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    G-&gt;n = n;</span><br><span class="line">    G-&gt;e = n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出邻接表G</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">displayAdj</span><span class="params">(AdjGraph *G)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    ArcNode *p;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;n; ++i) &#123;</span><br><span class="line">        p = G-&gt;adjList[i].firstArc;</span><br><span class="line">        printf(<span class="string">&quot;%d:&quot;</span>, i);</span><br><span class="line">        <span class="keyword">while</span> (p != NULL) &#123;</span><br><span class="line">            printf(<span class="string">&quot;%d[%d]-&gt;&quot;</span>, p-&gt;adjvex, p-&gt;weight);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(<span class="string">&quot;^\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁邻接表</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">destory</span><span class="params">(AdjGraph *G)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    ArcNode *pre, *p;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;n; ++i) &#123;</span><br><span class="line">        pre = G-&gt;adjList[i].firstArc;</span><br><span class="line">        <span class="keyword">if</span> (pre != NULL) &#123;</span><br><span class="line">            p = pre-&gt;next;</span><br><span class="line">            <span class="keyword">while</span> (p != NULL) &#123; <span class="comment">//释放第i个单链表的所有节点</span></span><br><span class="line">                free(pre);</span><br><span class="line">                pre = p;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            free(pre);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    free(G);    <span class="comment">//释放头节点数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//邻接矩阵g 转化成 邻接表G （时间复杂度：O(n^2)）</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">MatToList</span><span class="params">(MatGraph g, AdjGraph *G)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    ArcNode *p;</span><br><span class="line">    G = (AdjGraph *) malloc(sizeof(AdjGraph));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g.n; ++i) &#123;</span><br><span class="line">        G-&gt;adjList[i].firstArc = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g.n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &gt;= <span class="number">0</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (g.edges[i][j] != <span class="number">0</span> &amp;&amp; g.edges[i][j] != INF) &#123;</span><br><span class="line">                p = (ArcNode *) malloc(sizeof(ArcNode));</span><br><span class="line">                p-&gt;adjvex = j;</span><br><span class="line">                p-&gt;weight = g.edges[i][j];</span><br><span class="line">                p-&gt;next = G-&gt;adjList[i].firstArc;</span><br><span class="line">                G-&gt;adjList[i].firstArc = p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    G-&gt;n = g.n;</span><br><span class="line">    G-&gt;e = g.e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将邻接表G转换成邻接矩阵g</span></span><br><span class="line"><span class="comment">//时间复杂度：无向图为O(n+2e)，有向图为O(n+e)，e为边数</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">ListToMat</span><span class="params">(AdjGraph *G, MatGraph g)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    ArcNode *p;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;n; i++)<span class="comment">//扫描所有的单链表</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = G-&gt;adjList[i].firstArc;<span class="comment">//p指向第i个单链表的首结点while(p！=NULL)//扫描第i个单链表</span></span><br><span class="line">        <span class="keyword">while</span> (p != NULL) &#123;</span><br><span class="line">            g.edges[i][p-&gt;adjvex] = p-&gt;weight;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        g.n = G-&gt;n;</span><br><span class="line">        g.e = G-&gt;e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> visited[MAXV] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//深度优先搜索: O(n+e)</span></span><br><span class="line"><span class="comment">//用栈 或 递归</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">DFS</span><span class="params">(AdjGraph *G, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">    ArcNode *p;</span><br><span class="line">    <span class="type">int</span> w;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MAXV; i++) &#123;</span><br><span class="line">        visited[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[v] = <span class="number">1</span>;</span><br><span class="line">    printf(<span class="string">&quot;%d &quot;</span>, v);</span><br><span class="line">    p = G-&gt;adjList[v].firstArc;</span><br><span class="line">    <span class="keyword">while</span> (p != NULL) &#123;</span><br><span class="line">        w = p-&gt;adjvex;</span><br><span class="line">        <span class="keyword">if</span> (visited[w] == <span class="number">0</span>)</span><br><span class="line">            DFS(G, w);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//广度优先搜索: O(n+e)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">BFS</span><span class="params">(AdjGraph *G, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">    <span class="type">int</span> w, i;</span><br><span class="line">    ArcNode *p;</span><br><span class="line">    SqQueue *qu;    <span class="comment">//定义环形队列指针</span></span><br><span class="line">    IntiQueue(qu);      <span class="comment">//初始化队列</span></span><br><span class="line">    <span class="type">int</span> visit[MAXV];    <span class="comment">//顶点访问标记数组</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;n; i++) &#123;</span><br><span class="line">        visit[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(<span class="string">&quot;%2d&quot;</span>, v); <span class="comment">//输出被访问的顶点 编号</span></span><br><span class="line">    visit[v] = <span class="number">1</span>;   <span class="comment">//此点 已访问</span></span><br><span class="line">    EnQueue(qu, v);</span><br><span class="line">    <span class="keyword">while</span> (!QueueEmpty(qu))&#123;</span><br><span class="line">        DeQuenu(qu, w);     <span class="comment">//出队一个顶点w</span></span><br><span class="line">        p = G-&gt;adjList[w].firstArc; <span class="comment">//指向w的第一个邻接点</span></span><br><span class="line">        <span class="keyword">while</span> (p != NULL) &#123; <span class="comment">//查找w的所有邻接点</span></span><br><span class="line">            <span class="keyword">if</span>(visit[p-&gt;adjvex] == <span class="number">0</span>)&#123;</span><br><span class="line">                printf(<span class="string">&quot;%2d&quot;</span>, p-&gt;adjvex);</span><br><span class="line">                visit[p-&gt;adjvex] = <span class="number">1</span>;</span><br><span class="line">                EnQueue(qu, p-&gt;adjvex);<span class="comment">//该点进队</span></span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;next;<span class="comment">//找下一个点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="生成树"><a href="#生成树" class="headerlink" title="生成树"></a>生成树</h3><p>一个<strong>连通图的生成树</strong>是一个<strong>极小连通子图</strong>，它含有图中<strong>全部n个顶点</strong>和构成一棵树的（<strong>n - 1</strong> ）条边。</p>
<p>遍历方法得到生成树：深度优先生成树，广度~~树</p>
<p>（所以一个连通图的生成树不一定唯一）</p>
<p><strong>最小生成树</strong></p>
<p>对 带权连通图G （权 均为大于0的实数），其权值之和最小的生成树 即 图的最小生成树。</p>
<h4 id="普里姆-prim-算法"><a href="#普里姆-prim-算法" class="headerlink" title="普里姆(prim)算法"></a><strong>普里姆(prim)算法</strong></h4><p>（从顶点 考虑）</p>
<ol>
<li>选择初始点 把图中的顶点分成两个不同的顶点集S(生成树的顶点集)，V-S</li>
<li>在横跨两个不同顶点集的边中选择一条权值最小的边加入到生成树中</li>
<li>将该边的另一个顶点加入到顶点集S中，并从V-S中删除</li>
<li>重复步骤2，3，知道V-S为空集</li>
</ol>
<img src="D:/Note/Typora_picture/prim%E7%AE%97%E6%B3%951.png" style="zoom: 50%;" />

<img src="D:/Note/Typora_picture/prim2.png" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">prim</span><span class="params">(MatGraph g, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">    <span class="type">int</span> lowcost[MAXV];				<span class="comment">//lowcost存储到未标顶点的最小权值</span></span><br><span class="line">    <span class="type">int</span> min;</span><br><span class="line">    <span class="type">int</span> closest[MAXV], i, j, k;		<span class="comment">//closest存储最小权值对应的顶点</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g.n; ++i) &#123;         <span class="comment">//赋初值</span></span><br><span class="line">        lowcost[i] = g.edges[v][i];		</span><br><span class="line">        closest[i] = v;				<span class="comment">//此时生成树只有一个顶点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; g.n; i++) &#123;     <span class="comment">//输出（n - 1）条边</span></span><br><span class="line">        min = INF;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; g.n; j++)   <span class="comment">//在( V - U )中找出离U最近的顶点k</span></span><br><span class="line">            <span class="keyword">if</span> (lowcost[j] != <span class="number">0</span> &amp;&amp; lowcost[j] &lt; min) &#123;</span><br><span class="line">                min = lowcost[j];</span><br><span class="line">                k = j;      <span class="comment">//k记录最近的顶点编号</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;边（%d, %d）权为：%d\n&quot;</span>, closest[k], k, min);</span><br><span class="line">        lowcost[k] = <span class="number">0</span>;     <span class="comment">//标记k已经加入U</span></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; g.n; j++)        <span class="comment">//修改数组lowcost和cloest</span></span><br><span class="line">            <span class="keyword">if</span> (lowcost[j] != <span class="number">0</span> &amp;&amp; g.edges[k][j] &lt; lowcost[j])&#123;</span><br><span class="line">                lowcost[j] = g.edges[k][j];		<span class="comment">//更新S和V-S之间最小权值</span></span><br><span class="line">                closest[j] = k;					<span class="comment">//最小权值对应的 在Sz</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="克鲁斯卡尔（kruskal-算法"><a href="#克鲁斯卡尔（kruskal-算法" class="headerlink" title="克鲁斯卡尔（kruskal)算法"></a><strong>克鲁斯卡尔（kruskal)算法</strong></h4><p>（从边 考虑）</p>
<ol>
<li>把图中的顶点看成n个不同的顶点集，每个顶点集都只含1个顶点</li>
<li>每次都在<strong>横跨不同顶点集的边</strong>中选择一条权值最小的边加入到最小生成树中</li>
<li>直到图中所有的顶点都在同一个顶点集为止</li>
</ol>
<img src="D:/Note/Typora_picture/kruskal%E7%AE%97%E6%B3%951.png" style="zoom: 80%;" />

<img src="D:/Note/Typora_picture/kruskal%E7%AE%97%E6%B3%952.png" style="zoom: 67%;" />

<p>思路：连通图的边按照权值从小到大进行排列；依次检查它的每条边对应的两个端点是否分别属于两个不同的顶点集，是，则加入生成树中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><p><img src="D:/Note/Typora_picture/image-20211227204922551.png" alt="image-20211227204922551"></p>
<h4 id="狄克斯特拉-Dijkstra-算法"><a href="#狄克斯特拉-Dijkstra-算法" class="headerlink" title="狄克斯特拉(Dijkstra)算法"></a><strong>狄克斯特拉(Dijkstra)算法</strong></h4><p>只适用 有向无环图，图中存在负权重、环 时，无法使用狄克斯特拉算法</p>
<img src="D:/Note/Typora_picture/Dijkstra%E7%AE%97%E6%B3%95.png" style="zoom:67%;" />

<p>过程如下:</p>
<p>从起点开始，起点到其所有邻居的距离2和6是初始值，其他不相邻的节点的距离为无穷大，</p>
<p>然后从{2,6,无穷大}中找到最小值2,2对应的节点是B，然后从B开始遍历B的所有邻居{A,终点}，计算起点-&gt;B-&gt;A的距离为2+3&#x3D;5，比之前的距离6要小，所以更新A的记录为5，继续计算起点-&gt;B-&gt;终点的距离为2+5&#x3D;7，比之前的距离无穷大要小，所以更新终点的记录为7，至此B的所有相邻节点遍历完毕，故划去B，</p>
<p>之后继续从{2,5,7}中寻找最小值，由于2对应的B节点已经被划去，所以只要从{5,7}中找最小值，最小值为5，5对应于节点A，然后从A开始遍历A的所有邻居{终点}，计算起点-&gt;A-&gt;终点的距离6，比之前的距离7要小，故更新终点的记录为6，至此A的所有邻居遍历完毕，故划去A，</p>
<p>最后只剩下终点这个节点，由于终点没有邻居，故图中的所有邻居遍历完毕。至此得出从起点到终点的最短距离是6。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//狄克斯特拉(Dijkstra)算法：O(n^2)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Dijkstra</span><span class="params">(MatGraph g, <span class="type">int</span> v)</span> &#123;  <span class="comment">//v为源点</span></span><br><span class="line">    <span class="type">int</span> dist[MAXV], path[MAXV]; <span class="comment">//dist[]存放到某点的最短路径长度，path[]存放最短路径</span></span><br><span class="line">    <span class="type">int</span> s[MAXV];    <span class="comment">//标记顶点是否访问过</span></span><br><span class="line">    <span class="type">int</span> mindis, u;      <span class="comment">//mindis为最短距离，u为新考虑的中间点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g.n; i++) &#123; <span class="comment">//初始化dist和path</span></span><br><span class="line">        dist[i] = g.edges[v][i];    <span class="comment">//距离初始化，即v点到其余点的距离</span></span><br><span class="line">        s[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (g.edges[v][i] &lt; INF)</span><br><span class="line">            path[i] = v;</span><br><span class="line">        <span class="keyword">else</span> path[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s[v] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g.n; i++) &#123;</span><br><span class="line">        mindis = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; g.n; j++)       <span class="comment">//找最小路径长度的顶点u</span></span><br><span class="line">            <span class="keyword">if</span> (s[j] == <span class="number">0</span> &amp;&amp; dist[j] &lt; mindis) &#123;</span><br><span class="line">                u = j;</span><br><span class="line">                mindis = dist[j];</span><br><span class="line">            &#125;</span><br><span class="line">        s[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; g.n; j++)   <span class="comment">//修改未考虑的顶点的距离</span></span><br><span class="line">            <span class="keyword">if</span> (s[j] == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> (g.edges[u][j] &lt; INF &amp;&amp; dist[u] + g.edges[u][j] &lt; dist[j]) &#123;</span><br><span class="line">                    dist[j] = dist[u] + g.edges[u][j];</span><br><span class="line">                    path[j] = u;</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Dispath(dist, path, s, g.n, v); <span class="comment">//输出最短路径</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h4 id="弗洛伊德-Floyd）算法"><a href="#弗洛伊德-Floyd）算法" class="headerlink" title="弗洛伊德(Floyd）算法"></a><strong>弗洛伊德(Floyd）算法</strong></h4><p>基本思想：<br>弗洛伊德算法定义了两个二维矩阵：</p>
<p>矩阵D记录顶点间的最小路径<br>例如D[0q0] [3]&#x3D; 10，说明顶点0 到 3 的最短路径为10；</p>
<p>矩阵P记录顶点间最小路径中的中转点<br>例如P[0] [3]&#x3D; 1 说明，0 到 3 的最短路径轨迹为：0 -&gt; 1 -&gt; 3。</p>
<p>它通过3重循环，k为中转点，v为起点，w为终点，循环比较D[v] [w] 和 D[v] [k] + D[k] [w] 最小值，如果D[v] [k] + D[k] [w] 为更小值，则把D[v] [k] + D[k] [w] 覆盖保存在D[v] [w]中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> pathmatirx[MAXV][MAXV];<span class="comment">//记录对应点的最小路径的前驱点，例如p(1,3) = 2 说明顶点1到顶点3的最小路径要经过2</span></span><br><span class="line"><span class="type">int</span> shortPath[MAXV][MAXV];<span class="comment">//记录顶点间的最小路径值</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">short_path_floyd</span><span class="params">(MatGraph G, <span class="type">int</span> P[MAXV][MAXV], <span class="type">int</span> D[MAXV][MAXV])</span> &#123;</span><br><span class="line">    <span class="type">int</span> v, w, k;</span><br><span class="line">    <span class="comment">//初始化floyd算法的两个矩阵</span></span><br><span class="line">    <span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; G.n; v++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; G.n; w++) &#123;</span><br><span class="line">            D[v][w] = G.edges[v][w];</span><br><span class="line">            P[v][w] = w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里是弗洛伊德算法的核心部分</span></span><br><span class="line">    <span class="comment">//k为中间点</span></span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; G.n; k++) &#123;</span><br><span class="line">        <span class="comment">//v为起点</span></span><br><span class="line">        <span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; G.n; v++) &#123;</span><br><span class="line">            <span class="comment">//w为终点</span></span><br><span class="line">            <span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; G.n; w++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (D[v][w] &gt; (D[v][k] + D[k][w])) &#123;</span><br><span class="line">                    D[v][w] = D[v][k] + D[k][w];<span class="comment">//更新最小路径</span></span><br><span class="line">                    P[v][w] = P[v][k];<span class="comment">//更新最小路径中间顶点</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n初始化的D矩阵\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; G.n; v++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; G.n; w++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, D[v][w]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n初始化的P矩阵\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; G.n; v++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; G.n; w++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, P[v][w]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    v = <span class="number">0</span>;</span><br><span class="line">    w = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">//求 0 到 3的最小路径</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n%d -&gt; %d 的最小路径为：%d\n&quot;</span>, v, w, D[v][w]);</span><br><span class="line">    k = P[v][w];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;path: %d&quot;</span>, v);<span class="comment">//打印起点</span></span><br><span class="line">    <span class="keyword">while</span> (k != w) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-&gt; %d&quot;</span>, k);<span class="comment">//打印中间点</span></span><br><span class="line">        k = P[k][w];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-&gt; %d\n&quot;</span>, w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>AOV网（Activity On Vertex NetWork）：用顶点表示活动的网。每个AOV网都有一个或多个拓扑排序序列。</p>
<blockquote>
<p>AOV网有且仅有一个入度为0的开始点，出度为0的结束点。</p>
</blockquote>
<p>拓扑排序：在有向无环图中，找出做事的先后顺序。</p>
<p><strong>规则</strong>：</p>
<ul>
<li>图中每个顶点只出现<code>一次</code>。</li>
<li>A在B前面，则不存在B在A前面的路径。(<code>不能成环！！！！</code>)</li>
<li>顶点的顺序是<strong>保证所有指向它的下个节点在被指节点前面</strong>！(例如A—&gt;B—&gt;C那么A一定在B前面，B一定在C前面)。所以，这个核心规则下只要满足即可，<strong>所以拓扑排序序列不一定唯一</strong>！</li>
</ul>
<p>使用拓扑排序时，一般是稀疏图，所以用邻接表，</p>
<p><strong>代码思想为：</strong></p>
<p>新建node类，包含节点数值和它的指向；</p>
<p>一个数组包含node(这里默认编号较集中)。初始化，添加每个节点指向的时候同时被指的节点入度+1！(A—&gt;C)那么C的入度+1；<br>扫描一遍所有node。将所有<strong>入度为0的点</strong>加入一个栈(队列)。</p>
<p>当<strong>栈(队列)不空的时候，抛出其中任意一个node</strong>(栈就是尾，队就是头，顺序无所谓，上面分析了只要同时入度为零可以随便选择顺序)。将node输出，并且<strong>node指向的所有元素入度减一</strong>。如果某个<strong>点的入度被减为0，那么就将它加入栈</strong>(队列)。</p>
<p>重复上述操作，直到栈为空。</p>
<h3 id="210-课程表"><a href="#210-课程表" class="headerlink" title="210.课程表"></a>210.课程表</h3><p>现在你总共有 <strong>numCourses</strong> 门课需要选，记为 0 到 numCourses - 1。给你一个数组 <strong>prerequisites</strong> ，其中 <strong>prerequisites[i] &#x3D; [ai, bi]</strong> ，表示在选修课程 ai 前 必须 先选修 bi 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如，想要学习课程 <span class="number">0</span> ，你需要先完成课程 <span class="number">1</span> ，我们用一个匹配来表示：[<span class="number">0</span>,<span class="number">1</span>]。</span><br></pre></td></tr></table></figure>

<p>返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回 任意一种 就可以了。如果不可能完成所有课程，返回 一个空数组。</p>
<p><strong>题解：</strong></p>
<p>本题是一道经典的「拓扑排序」问题。</p>
<ul>
<li><p>我们将每一门课看成一个节点；</p>
</li>
<li><p>如果想要学习课程 A 之前必须完成课程 B，那么我们从 B 到 A 连接一条有向边。这样以来，在拓扑排序中，B一定出现在 A 的前面。</p>
</li>
</ul>
<p>求出该图的拓扑排序，就可以得到一种符合要求的课程学习顺序。</p>
<p><strong>方法一，深度优先搜索</strong></p>
<p>对于一个节点 u，如果它的所有相邻节点都已经搜索完成，那么在搜索回溯到 u 的时候，u本身也会变成一个已经搜索完成的节点。这里的「相邻节点」指的是从 u 出发通过一条有向边可以到达的所有节点。</p>
<p>对于图中的任意一个节点，它在搜索的过程中有三种状态，即：</p>
<ul>
<li><p>「未搜索」：我们还没有搜索到这个节点；</p>
</li>
<li><p>「搜索中」：我们搜索过这个节点，但还没有回溯到该节点，即该节点还没有入栈，还有相邻的节点没有搜索完成）；</p>
</li>
<li><p>「已完成」：我们搜索过并且回溯过这个节点，即该节点已经入栈，并且所有该节点的相邻节点都出现在栈的更底部的位置，满足拓扑排序的要求。</p>
</li>
</ul>
<p>通过上述的三种状态，我们就可以给出使用深度优先搜索得到拓扑排序的算法流程，在每一轮的搜索搜索开始时，我们任取一个「未搜索」的节点开始进行深度优先搜索。</p>
<ul>
<li><p>我们将当前搜索的节点 u 标记为「搜索中」，遍历该节点的每一个相邻节点 v：</p>
</li>
<li><p>如果 v 为「未搜索」，那么我们开始搜索 v，待搜索完成回溯到 u；</p>
</li>
<li><p>如果 v 为「搜索中」，那么我们就找到了图中的一个环，因此是不存在拓扑排序的；</p>
</li>
<li><p>如果 v 为「已完成」，那么说明 v 已经在栈中了，而 u 还不在栈中，因此 u 无论何时入栈都不会影响到 (u, v)(u,v) 之前的拓扑关系，所以不用进行任何操作。</p>
</li>
<li><p>当 u 的所有相邻节点都为「已完成」时，我们将 u 放入栈中，并将其标记为「已完成」。</p>
</li>
</ul>
<p>在整个深度优先搜索的过程结束后，如果我们没有找到图中的环，那么栈中存储这所有的 n 个节点，从栈顶到栈底的顺序即为一种拓扑排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 存储有向图</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; edges;</span><br><span class="line">    <span class="comment">// 标记每个节点的状态：0=未搜索，1=搜索中，2=已完成</span></span><br><span class="line">    <span class="type">int</span>[] visited;</span><br><span class="line">    <span class="comment">// 用数组来模拟栈，下标 n-1 为栈底，0 为栈顶</span></span><br><span class="line">    <span class="type">int</span>[] result;</span><br><span class="line">    <span class="comment">// 判断有向图中是否有环</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">valid</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 栈下标</span></span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findOrder(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites) &#123;</span><br><span class="line">        edges = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            edges.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        visited = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">        result = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">        index = numCourses - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] info : prerequisites) &#123;</span><br><span class="line">            edges.get(info[<span class="number">1</span>]).add(info[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每次挑选一个「未搜索」的节点，开始进行深度优先搜索</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses &amp;&amp; valid; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                dfs(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!valid) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没有环，那么就有拓扑排序</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u)</span> &#123;</span><br><span class="line">        <span class="comment">// 将节点标记为「搜索中」</span></span><br><span class="line">        visited[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 搜索其相邻节点</span></span><br><span class="line">        <span class="comment">// 只要发现有环，立刻停止搜索</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v: edges.get(u)) &#123;</span><br><span class="line">            <span class="comment">// 如果「未搜索」那么搜索相邻节点</span></span><br><span class="line">            <span class="keyword">if</span> (visited[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                dfs(v);</span><br><span class="line">                <span class="keyword">if</span> (!valid) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果「搜索中」说明找到了环</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (visited[v] == <span class="number">1</span>) &#123;</span><br><span class="line">                valid = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将节点标记为「已完成」</span></span><br><span class="line">        visited[u] = <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 将节点入栈</span></span><br><span class="line">        result[index--] = u;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度: **O(n+m)**，其中 n 为课程数，m 为先修课程的要求数。这其实就是对图进行深度优先搜索的时间复杂度。</p>
</li>
<li><p>空间复杂度: **O(n+m)**。题目中是以列表形式给出的先修课程关系，为了对图进行深度优先搜索，我们需要存储成邻接表的形式，空间复杂度为 O(n+m)。在深度优先搜索的过程中，我们需要最多 O(n) 的栈空间（递归）进行深度优先搜索，并且还需要若干个 O(n)的空间存储节点状态、最终答案等。</p>
</li>
</ul>
<p><strong>方法二：广度优先搜索</strong></p>
<p>我们使用一个队列来进行广度优先搜索。开始时，所有入度为 0 的节点都被放入队列中，它们就是可以作为拓扑排序最前面的节点，并且它们之间的相对顺序是无关紧要的。</p>
<p>在广度优先搜索的每一步中，我们取出队首的节点 u：</p>
<p>我们将 u 放入答案中；</p>
<p>我们移除 u 的所有出边，也就是将 u 的所有相邻节点的入度减少 1。如果某个相邻节点 v 的入度变为 0，那么我们就将 v 放入队列中。</p>
<p>在广度优先搜索的过程结束后。如果答案中包含了这 n 个节点，那么我们就找到了一种拓扑排序，否则说明图中存在环，也就不存在拓扑排序了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 存储有向图</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; edges;</span><br><span class="line">    <span class="comment">// 存储每个节点的入度</span></span><br><span class="line">    <span class="type">int</span>[] indeg;</span><br><span class="line">    <span class="comment">// 存储答案</span></span><br><span class="line">    <span class="type">int</span>[] result;</span><br><span class="line">    <span class="comment">// 答案下标</span></span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findOrder(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites) &#123;</span><br><span class="line">        edges = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            edges.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        indeg = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">        result = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] info : prerequisites) &#123;</span><br><span class="line">            edges.get(info[<span class="number">1</span>]).add(info[<span class="number">0</span>]);</span><br><span class="line">            ++indeg[info[<span class="number">0</span>]];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">// 将所有入度为 0 的节点放入队列中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indeg[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                queue.offer(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 从队首取出一个节点</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="comment">// 放入答案中</span></span><br><span class="line">            result[index++] = u;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> v: edges.get(u)) &#123;</span><br><span class="line">                --indeg[v];</span><br><span class="line">                <span class="comment">// 如果相邻节点 v 的入度为 0，就可以选 v 对应的课程了</span></span><br><span class="line">                <span class="keyword">if</span> (indeg[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                    queue.offer(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index != numCourses) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="内排序"><a href="#内排序" class="headerlink" title="内排序"></a>内排序</h2><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/sort.png" alt="img"></p>
<p><img src="https://www.runoob.com/wp-content/uploads/2019/03/0B319B38-B70E-4118-B897-74EFA7E368F9.png" alt="img"></p>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>也称为缩小增量（递减增量）算法，是<strong>插入排序的改进</strong>。</p>
<p>希尔排序需要一个增量序列（增量会递减）,一般用len&#x2F;2，如：len为11，则增量分别为5，2，1，进行三次循环。</p>
<p>每次循环排序只排 间隔 为增量值的数，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShellSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shellSort</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len / <span class="number">2</span>; i &gt; <span class="number">0</span>; i /= <span class="number">2</span>) &#123;      <span class="comment">//i为增量,初始化为len/2</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; len; j++) &#123;       <span class="comment">//j用于每次更改增量后遍历一次数组</span></span><br><span class="line">                <span class="type">int</span> k;          <span class="comment">//k用于对第j个元素进行插入排序，比较的是前面间隔为i的元素</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[j];</span><br><span class="line">                <span class="keyword">for</span> (k = j; k &gt;= i &amp;&amp; temp &lt; nums[k - i]; k -= i) &#123;</span><br><span class="line">                    nums[k] = nums[k - i];</span><br><span class="line">                &#125;</span><br><span class="line">                nums[k] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">7</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ShellSort</span>().shellSort(nums);</span><br><span class="line">        System.out.println(Arrays.toString(nums));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>将数据不断分半，直到只剩下一个元素，然后从以分半的两段数据，逐个选出最小的元素移入临时数组的末尾。（归并排序需要用到临时数组）</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2018/09/Merge-sort-example-300px.gif" alt="img"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//合并操作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> tempArr[],<span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">    <span class="comment">//标记左半区第一个未排序的元素</span></span><br><span class="line">    <span class="type">int</span> l_pos = left;</span><br><span class="line">    <span class="comment">//标记右半曲第一个未排序的元素</span></span><br><span class="line">    <span class="type">int</span> r_pos = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//临时变量元素的下标</span></span><br><span class="line">    <span class="type">int</span> pos = left;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (l_pos &lt;= mid &amp;&amp;r_pos &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[l_pos] &lt; arr[r_pos])     <span class="comment">//左半区剩余第一个元素更小</span></span><br><span class="line">            tempArr[pos++] = arr[l_pos++];</span><br><span class="line">        <span class="keyword">else</span>                            <span class="comment">//右半区剩余第一个元素更小</span></span><br><span class="line">            tempArr[pos++] = arr[r_pos++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(l_pos &lt;= mid)&#123;       <span class="comment">//合并左半区剩余元素（右半区合并完了）</span></span><br><span class="line">        tempArr[pos++] = arr[l_pos++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(r_pos &lt;= right)&#123;      <span class="comment">//合并右半区剩余元素（左半区合并完了）</span></span><br><span class="line">        tempArr[pos++] = arr[r_pos++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将临时数组中合并后的元素复制到原来的数组</span></span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        arr[left] = tempArr[left];</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">msort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> tempArr, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">    <span class="comment">//如果只有一个元素，那么不需要继续划分</span></span><br><span class="line">    <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//递归划分左右半区</span></span><br><span class="line">        msort(arr,tempArr, left, mid);</span><br><span class="line">        msort(arr, tempArr, mid + <span class="number">1</span>, right);</span><br><span class="line">        merge(arr, tempArr, left, mid , right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//归并排序入口</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">merge_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="comment">//分配一个辅助数组</span></span><br><span class="line">    <span class="type">int</span> *tempArr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span>(tempArr)&#123;    <span class="comment">//辅助数组分配成功</span></span><br><span class="line">        msort(arr, tempArr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">free</span>(tempArr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error: failed to allocate memory&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>在区间中挑选一个元素作基准，将小于基准的元素放在基准之前，大于基准的元素放在基准之后，再分别对小数区与大数区进行同样操作。直到各个分区只有一个数时为止。</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2019/03/quickSort.gif" alt="img"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里以第一个元素作为基准</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">quicksort</span><span class="params">(<span class="type">int</span> *s, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="type">int</span> i = start, j = end, x = s[start];     <span class="comment">//以第一个元素作为基准，后面用了类似挖坑的写法，临时存储这个元素，遇到第一个需要交换的元素，直接赋值给基准处。</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;     <span class="comment">//一边交换后，换另一边比较</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; s[j] &gt;= x) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">                s[i++] = s[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; s[i] &lt; x) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">                s[j--] = s[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s[i] = x;</span><br><span class="line">        quicksort(s, start, i - <span class="number">1</span>);</span><br><span class="line">        quicksort(s, i + <span class="number">1</span>, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">quick_sort_recursive</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = arr[end];</span><br><span class="line">    <span class="type">int</span> i = start, j = end - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (arr[i] &lt; mid &amp;&amp; i &lt; j)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">while</span> (arr[j] &gt;= mid &amp;&amp; i &lt; j)</span><br><span class="line">            j--;</span><br><span class="line">        swap(&amp;arr[i], &amp;arr[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] &gt;= arr[end])</span><br><span class="line">        swap(&amp;arr[i], &amp;arr[end]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        i++;</span><br><span class="line">    <span class="keyword">if</span> (i)</span><br><span class="line">        quick_sort_recursive(arr, start, i - <span class="number">1</span>);</span><br><span class="line">    quick_sort_recursive(arr, i + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">quick_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    quick_sort_recursive(arr, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h3 id="堆排序-1"><a href="#堆排序-1" class="headerlink" title="堆排序"></a>堆排序</h3><p>（堆积是一个近似完全二叉树的结构，并同时满足堆积的性质）</p>
<p>堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：</p>
<ul>
<li><p>大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；</p>
</li>
<li><p>小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；</p>
</li>
</ul>
<p>算法步骤：</p>
<ol>
<li>创建一个堆</li>
<li>把堆首（最大值）和堆尾互换；</li>
<li>把堆的尺寸减少1，并调用上浮&#x2F;下沉操作，把新的最大值调整到堆首；</li>
<li>重复步骤2，3，直到堆的尺寸为1；</li>
</ol>
<p><img src="https://www.runoob.com/wp-content/uploads/2019/03/heapSort.gif" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HeapSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] arr)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        buildMaxHeap(arr, len);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            swap(arr, <span class="number">0</span>, i);</span><br><span class="line">            len--;</span><br><span class="line">            heapify(arr, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildMaxHeap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (<span class="type">int</span>) Math.floor(len / <span class="number">2</span>); i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            heapify(arr, i, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">largest</span> <span class="operator">=</span> i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123;</span><br><span class="line">            largest = left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123;</span><br><span class="line">            largest = right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">            swap(arr, i, largest);</span><br><span class="line">            heapify(arr, largest, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。</p>
<p>作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>
<p>当输入的元素是 n 个 0 到 k 之间的整数时，它的运行时间是 Θ(n + k)。</p>
<p>由于<strong>用来计数的数组C的长度取决于待排序数组中数据的范围</strong>（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。例如：计数排序是用来排序0到100之间的数字的最好的算法，但是它不适合按字母顺序排序人名。但是，计数排序可以用在基数排序中的算法来排序数据范围很大的数组。</p>
<p>算法的步骤如下：</p>
<ol>
<li><p>找出待排序的数组中最大和最小的元素</p>
</li>
<li><p>统计数组中每个值为i的元素出现的次数，存入数组C的第i项</p>
</li>
<li><p>反向填充目标数组：将每个元素 i 放在新数组的第C(i)项，每放一个元素就将C(i)减去1</p>
</li>
</ol>
<p><img src="https://www.runoob.com/wp-content/uploads/2019/03/countingSort.gif" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CountingSort</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] arr)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> getMaxValue(arr);</span><br><span class="line">        <span class="keyword">return</span> countingSort(arr, maxValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] countingSort(<span class="type">int</span>[] arr, <span class="type">int</span> maxValue) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">bucketLen</span> <span class="operator">=</span> maxValue + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] bucket = <span class="keyword">new</span> <span class="title class_">int</span>[bucketLen];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> value : arr) &#123;</span><br><span class="line">            bucket[value]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">sortedIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; bucketLen; j++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (bucket[j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                arr[sortedIndex++] = j;</span><br><span class="line">                bucket[j]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getMaxValue</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> value : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxValue &lt; value) &#123;</span><br><span class="line">                maxValue = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><p>排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：</p>
<ol>
<li>在额外空间充足的情况下，<strong>尽量增大桶的数量</strong></li>
<li>使用的映射函数能够将输入的 <strong>N 个数据均匀的分配到 K 个桶中</strong></li>
</ol>
<p>同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。</p>
<p>最快的情况：当输入的数据可以均匀的分配到每一个桶中。</p>
<p>最慢的情况：当输入的数据被分配到了同一个桶中。</p>
<p>示例：</p>
<p>元素分布在桶中：</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2019/03/Bucket_sort_1.svg_.png" alt="img"></p>
<p>然后，元素在每个桶中排序：</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2019/03/Bucket_sort_2.svg_.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BucketSort</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">        <span class="keyword">return</span> bucketSort(arr, <span class="number">5</span>);  <span class="comment">//桶大小是5</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] bucketSort(<span class="type">int</span>[] arr, <span class="type">int</span> bucketSize)&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> arr;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//选出最大值和最小值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">minValue</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> value : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value &lt; minValue) &#123;</span><br><span class="line">                minValue = value;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; maxValue) &#123;</span><br><span class="line">                maxValue = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">bucketCount</span> <span class="operator">=</span> (<span class="type">int</span>) Math.floor((maxValue - minValue) / bucketSize) + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[][] buckets = <span class="keyword">new</span> <span class="title class_">int</span>[bucketCount][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 利用映射函数将数据分配到各个桶中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (<span class="type">int</span>) Math.floor((arr[i] - minValue) / bucketSize);</span><br><span class="line">            buckets[index] = arrAppend(buckets[index], arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">arrIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] bucket : buckets) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bucket.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 对每个桶进行排序，这里的XxxSort根据情况而定</span></span><br><span class="line">            bucket = XxxSort.sort(bucket);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> value : bucket) &#123;</span><br><span class="line">                arr[arrIndex++] = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//（自动扩容）将元素加入到桶中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arrAppend(<span class="type">int</span>[] arr, <span class="type">int</span> value) &#123;</span><br><span class="line">        arr = Arrays.copyOf(arr, arr.length + <span class="number">1</span>);</span><br><span class="line">        arr[arr.length - <span class="number">1</span>] = value;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>基数排序是一种非比较型整数排序算法，其原理是<strong>将整数按位数切割成不同的数字，然后按每个位数分别比较</strong>。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p>
<p>下面三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p>
<ul>
<li>基数排序：根据键值的每位数字来分配桶；</li>
<li>计数排序：每个桶只存储单一键值；</li>
<li>桶排序：每个桶存储一定范围的数值；</li>
</ul>
<p><img src="https://www.runoob.com/wp-content/uploads/2019/03/radixSort.gif" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RadixSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxDigit</span> <span class="operator">=</span> getMaxDigit(arr);</span><br><span class="line">        <span class="keyword">return</span> radixSort(arr, maxDigit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取最高位数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getMaxDigit</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> getMaxValue(arr);</span><br><span class="line">        <span class="keyword">return</span> getNumLenght(maxValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取最大值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getMaxValue</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> value : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxValue &lt; value) &#123;</span><br><span class="line">                maxValue = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取位数</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">getNumLenght</span><span class="params">(<span class="type">long</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lenght</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">temp</span> <span class="operator">=</span> num; temp != <span class="number">0</span>; temp /= <span class="number">10</span>) &#123;</span><br><span class="line">            lenght++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lenght;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] radixSort(<span class="type">int</span>[] arr, <span class="type">int</span> maxDigit) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">dev</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; maxDigit; i++, dev *= <span class="number">10</span>, mod *= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="comment">// 考虑负数的情况，这里扩展一倍队列数，其中 [0-9]对应负数，[10-19]对应正数 (bucket + 10)</span></span><br><span class="line">            <span class="type">int</span>[][] counter = <span class="keyword">new</span> <span class="title class_">int</span>[mod * <span class="number">2</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">bucket</span> <span class="operator">=</span> (arr[j] % mod) / dev;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; <span class="number">0</span>)     <span class="comment">//考虑正负数</span></span><br><span class="line">                    bucket += <span class="number">10</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    bucket = -bucket;</span><br><span class="line">                counter[bucket] = arrayAppend(counter[bucket], arr[j]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span>[] bucket : counter) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> value : bucket) &#123;</span><br><span class="line">                    arr[pos++] = value;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自动扩容，并保存数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arrayAppend(<span class="type">int</span>[] arr, <span class="type">int</span> value) &#123;</span><br><span class="line">        arr = Arrays.copyOf(arr, arr.length + <span class="number">1</span>);</span><br><span class="line">        arr[arr.length - <span class="number">1</span>] = value;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="外排序"><a href="#外排序" class="headerlink" title="外排序"></a>外排序</h2><p>对磁盘中的数据进行排序。</p>
<h3 id="归并排序-1"><a href="#归并排序-1" class="headerlink" title="归并排序"></a>归并排序</h3><p>最少只需要在内存中开辟2个输入缓冲区和一个输出缓冲区，每次将磁盘的数据块 输入到输入缓冲区，然后按 归并排序的规则，从2个输入缓冲区 每次跳出最小的数 放到输出缓冲区，当有输入缓冲区为空了，应该立刻将和它排好序的下一个数据块放到输入缓冲区中。当输出缓冲区满时，写出外存。</p>
<p>减少时间开销：进行<strong>K路归并排序</strong>，需要在内存中分配k个输入缓冲区和一个输出缓冲区。</p>
<blockquote>
<p>因为读写磁盘时间开销大，所以多几路可以提高效率，但也不能太多，因为需要在内存中开多个缓冲区，且每次比较都要比较这k个缓冲区的最小值</p>
</blockquote>
<p>时间开销：读写外存时间+内部排序时间+内部归并时间</p>
<p>优化：</p>
<ul>
<li><strong>增加归并路数k</strong><ul>
<li>代价1：需要增加相应的输入缓冲区</li>
<li>代价2：每次从k个归并段总选一个最小值需要（k-1）次比较。——<strong>可用败者树减少关键字比较次数</strong></li>
</ul>
</li>
<li><strong>减少初始归并段数量r</strong><ul>
<li>若有N个记录，内存工作区可放L个记录，则初始归并段数量 r &#x3D; N &#x2F; L ——<strong>可用 置换-选择排序 减少初始归并段</strong></li>
</ul>
</li>
</ul>
<h3 id="败者树"><a href="#败者树" class="headerlink" title="败者树"></a>败者树</h3><p>败者树解决的问题：使用多路平衡归并可減少归并趟数，但是用老土方法从k个归并段选出一个最小&#x2F;最大元素需要对比关键字k-1次，构造败者树可以使关键字对比次数减少到 log<del>2</del>k。</p>
<p>败者树可视为一棵<strong>完全二又树（多了一个在根节点之上的头节点</strong>）。<strong>k个叶结点</strong>分别对应<strong>k个归并段</strong>中当前参加比较的元素，<strong>非叶子结点</strong>用来记忆<strong>左右子树中的“失败者”</strong>，而让胜者往上继续进行比较，一直到根结点。</p>
<p><img src="D:/Note/Typora_picture/image-20211227202553354.png" alt="image-20211227202553354"></p>
<p><img src="D:/Note/Typora_picture/image-20211227202243956.png" alt="image-20211227202243956"></p>
<h3 id="置换-选择排序"><a href="#置换-选择排序" class="headerlink" title="置换-选择排序"></a>置换-选择排序</h3><p>设初始待排文件为FI,初始归并段输出文件为FO,内存工作区为WA，FO和WA的初始状态为空，WA可容纳w个记录。置換-选择算法的步骤如下：</p>
<ol>
<li>从FI输入w个记录到工作区WA</li>
<li>从WA中选出其中关键字取最小值的记录，记为 MIINIMAX记录。(MIINIMAX指不断选出的最小指中的最大值)</li>
<li>将 MINIMAX记录输出到FO中去。</li>
<li>若FI不空，则从FI输入下一个记录到WA中。</li>
<li>从WA中所有关键字比 MIINIMAX记录的关键字大的记录中选出最小关键字记录，作为新的MINIMAX记录。</li>
<li>重复(3)~(5),直至在WA中选不出新的 MINIMAX记录为止，由此得到一个初始归并段，输出一个归并段的结束标志到FO中去。</li>
<li>重复(2)~(6),直至WA为空。由此得到全部初始归并段。</li>
</ol>
<p><img src="D:/Note/Typora_picture/image-20211227203606666.png" alt="image-20211227203606666"></p>
<p><img src="D:/Note/Typora_picture/image-20211227203540414.png" alt="image-20211227203540414"></p>
<h1 id="试题"><a href="#试题" class="headerlink" title="试题"></a>试题</h1><h2 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a>选择题</h2><ol>
<li><p>设指针变量p指向单链表中结点A，若删除单链表中结点A，则需要修改指针的操作序列为（ ）。<br>(A) q&#x3D;p-&gt;next；p-&gt;data&#x3D;q-&gt;data；p-&gt;next&#x3D;q-&gt;next；free(q)；<br>(B) q&#x3D;p-&gt;next；q-&gt;data&#x3D;p-&gt;data；p-&gt;next&#x3D;q-&gt;next；free(q)；<br>(C) q&#x3D;p-&gt;next；p-&gt;next&#x3D;q-&gt;next；free(q)；<br>(D) q&#x3D;p-&gt;next；p-&gt;data&#x3D;q-&gt;data；free(q)；</p>
<blockquote>
<p>答案：A</p>
<p>先用指针变量q指向结点A的后继结点B，然后将结点B的值复制到结点A中，最后删除结点B。</p>
</blockquote>
</li>
<li><p>设有n个待排序的记录关键字，则在堆排序中需要（ ）个辅助记录单元。</p>
<blockquote>
<p>答案：1个。</p>
<p>堆排序只需一个辅助空间，用来记录当前操作的二叉树上的根节点的数字，来与其左右孩子节点比较。</p>
</blockquote>
</li>
<li><p>设某二叉树中度数为0的结点数为N0，度数为1的结点数为Nl，度数为2的结点数为N2，则下列等式成立的（ ）。</p>
<blockquote>
<p>答案：N<del>0</del> &#x3D; N<del>2</del> + 1</p>
</blockquote>
</li>
<li><p>设有序顺序表中有n个数据元素，则利用二分查找法查找数据元素X的最多比较次数不超过（ ）。</p>
<blockquote>
<p>答案：log<del>2</del>n + 1</p>
</blockquote>
</li>
<li><p>1、数据的最小单位是（ A ）。<br>(A) 数据项<br>(B) 数据类型<br>(C) 数据元素<br>(D) 数据变量</p>
</li>
<li><p>设一棵m叉树中度数为0的结点数为N0，度数为1的结点数为N1，……，度数为m的结点数为Nm，则N0 &#x3D;（ B ）。<br>(A) Nl+N2+……+Nm<br>(B) <strong>1+N2+2N3+3N4+……+(m-1)Nm</strong><br>(C) N2+2N3+3N4+……+(m-1)Nm<br>(D) 2Nl+3N2+……+(m+1)Nm</p>
</li>
<li><p>设在一棵度数为3的树中，度数为3的结点数有2个，度数为2的结点数有1个，度数为1的结点数有2个，那么度数为0的结点数有（ ）个。 </p>
<blockquote>
<p>解：6个</p>
<p>除了根节点外，其他节点均为孩子节点，而孩子节点等于总的分支数，即 孩子节点 &#x3D;  1 * n<del>1</del> + 2 * n<del>2</del>+3 * n<del>3</del> &#x3D; 10；</p>
<p>所以总节点数 &#x3D; 10 + 1 &#x3D; 11（1是指根节点），度数为0的节点数 &#x3D; 11 - n<del>1</del> - n<del>2</del> - n<del>3</del> &#x3D; 6;</p>
</blockquote>
</li>
<li><p>设顺序表的长度为n，则顺序查找的平均比较次数为（）。</p>
<blockquote>
<p>解：（n+1）&#x2F; 2</p>
<p>若第一个为查找元素，则查找次数为1，。。。。。所以 平均查找次数为 (1+2+3 + ….+ n) &#x2F; n&#x3D; (1+n) &#x2F; 2； </p>
</blockquote>
</li>
<li></li>
</ol>
<h2 id="填空题"><a href="#填空题" class="headerlink" title="填空题"></a>填空题</h2><ol>
<li><p>通常从四个方面评价算法的质量：<u>正确性、易读性、强壮性、高效性</u>。</p>
</li>
<li><p>数据结构从逻辑上划分为三种基本类型：线性结构，树型结构，图型结构。</p>
</li>
<li><p>用链表存储二叉树，则有n个节点的二叉树共有 2n 个指针域，其中 n-1 个存放了地址，剩下的是空指针（n+1个）。</p>
</li>
<li><p>AOV网是一种 <u>有向无回路</u> 的图。</p>
</li>
<li><p>对于具有n个顶点和e条边的有向图和无向图，其对应的邻接表中，所含边节点分别有 e 和 2e 个。</p>
</li>
<li><p>在一个具有n个顶点的无向完全图中，包含有 n(n-1)&#x2F;2 条边，有n个顶点的有向完全图中，包含有 n(n-1) 条边。</p>
</li>
<li><p>设某二叉树中度数为0的节点数为 N，度数为1的节点数为 M，可得该二叉树中度数为2的节点数为 <u>N - 1</u> ，。</p>
</li>
<li><p>数据的物理结构主要包括 顺序存储结构 和 链式存储结构。</p>
</li>
<li><p>设满二叉树的深度为k， 则该树的节点数为 2^k^ - 1； 若用二叉链表作为二叉树的存储结构，设该树有 n 个节点，则一共有 n + 1个空指针域。</p>
</li>
<li><p>一个序列，经过栈的作用可以得到 C^n^<del>2n</del>&#x2F; (n+1) 中不同的输出序列。（卡特兰数）</p>
</li>
</ol>
<blockquote>
<p>如：序列有3个数，则有5中不同的输出序列。</p>
</blockquote>
<ol start="11">
<li><p>设哈夫曼树有n个节点，则该树有 0 个度数为1的节点。</p>
</li>
<li><p>设有n个结点的完全二叉树，如果按照从自上到下、从左到右从1开始顺序编号，则第 i 个结点的双亲结点编号为 i &#x2F; 2 ;  右孩子结点的编号为 2i + 1。</p>
</li>
<li><p>设一组初始记录关键字为(72，73，71，23，94，16，5)，则以记录关键字72为基准的一趟快速排序结果为 </p>
<blockquote>
<p>答案：(5，16，71，23，72，94，73)</p>
<p>两个指针，从左开始，和从右开始，先从右开始选第一个遇到的小于基准的数，和基准数换位；换 从左开始，遇到的第一个大于基准的数，和基准换位；再从右继续……循环，直至小于基准的在左边，大于基准的在右边。</p>
</blockquote>
</li>
<li><p>在二叉排序树中插入一个结点的时间复杂度为 O(n)，如果该排序树即不平衡，需要遍历n个节点，如果该树很平衡，则只需log<del>2</del>n。</p>
</li>
<li><p>设初始记录关键字序列为(K1，K2，…，Kn)，则用筛选法思想建堆必须从第 <em><strong>n&#x2F;2</strong></em> 个元素开始进行筛选。</p>
</li>
<li><p>设哈夫曼树中共有99个结点，则该树中有<u>50</u> 个叶子结点；若采用二叉链表作为存储结构，则该树中有_<u>100</u>_个空指针。</p>
</li>
<li><p>设有一个顺序循环队列中有M个存储单元，则该循环队列中最多能够存储______m-1个队列元素；当前实际存储_____(R - F + M) % M_个队列元素（设头指针F指向当前队头元素的前一个位置，尾指针指向当前队尾元素的位置）。</p>
</li>
<li><p>设顺序线性表中有n个数据元素，则第i个位置上插入一个数据元素需要移动表中 <em><strong><u>n-i+1</u></strong></em> 个数据元素；删除第i个位置上的数据元素需要移动表中 <u>n-i</u> 个元素。</p>
</li>
<li><p>根据二叉树的<u>先序和中序</u>遍历、或<u>中序和后序</u>遍历，可以唯一确定二叉树的形状。</p>
</li>
<li><p>筛选法建初始堆必须从第 n &#x2F; 2 个元素开始进行筛选。</p>
</li>
<li><p>快速排序在序列基本有序时为 O(n^2^)，在序列基本无序时为 O(nlog<del>2</del>n)。</p>
</li>
<li><p>设一棵m叉树的结点数为n，用多重链表表示其存储结构，则该树中有 <u>n(m-1)+1</u> 个空指针域。</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/04/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" data-id="cl1ynefm6000aswtu2r4o0557" data-title="数据结构" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-设计模式" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/Notes/2022/04/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time class="dt-published" datetime="2022-04-14T06:55:35.298Z" itemprop="datePublished">2022-04-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/Notes/2022/04/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/04/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" data-id="cl1ynefmh000fswtu1p1laoiu" data-title="设计模式" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-快捷键" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/Notes/2022/04/14/%E5%BF%AB%E6%8D%B7%E9%94%AE/" class="article-date">
  <time class="dt-published" datetime="2022-04-14T06:55:35.290Z" itemprop="datePublished">2022-04-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/Notes/2022/04/14/%E5%BF%AB%E6%8D%B7%E9%94%AE/">快捷键</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Win-10-快捷键"><a href="#Win-10-快捷键" class="headerlink" title="Win 10 快捷键"></a>Win 10 快捷键</h1><p>win + shift + s  截图</p>
<h1 id="fvimium快捷键"><a href="#fvimium快捷键" class="headerlink" title="fvimium快捷键"></a>fvimium快捷键</h1><h3 id="页面操作"><a href="#页面操作" class="headerlink" title="页面操作"></a>页面操作</h3><p>j: 向下移动。<br>k：向上移动。（不明白默认的<c-y>表示是啥用法，使用了c-y这三个键没有效果）<br>h：向左移动。<br>l：向右移动。<br>zH：一直移动到左部。<br>zL:一直移动到右部。<br>gg：跳转到页面的顶部。<br>G：跳转到页面的底部。<br>d：向下翻页（相当于PageDown被按下了）<br>u：向上翻页（相当于PageUp被按下了）<br>r：重新载入该页（相当于F5刷新页面）<br>gs：查看页面源代码<br>yy：拷贝当前页面的URL到剪贴板<br>yf：拷贝某一个URL到剪贴板（实际上是相当于输入了f，然后出现很多编码的URL，选择某个之后，相当于拷贝了某个，因为一个页面中可能有很多超链接）<br>gu：跳转到父页面（比如<a target="_blank" rel="noopener" href="http://www.douban.com/group/vim/%EF%BC%8C%E8%BE%93%E5%85%A5%E5%90%8E%E8%B7%B3%E8%BD%AC%E5%88%B0%E7%88%B6%E9%A1%B5%E9%9D%A2%E5%8D%B3http://www.douban.com/group/%EF%BC%8C%E6%89%80%E4%BB%A5%E4%B8%8D%E5%90%8C%E4%BA%8EH%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%98%AF%E5%9B%9E%E5%88%B0%E4%B8%8A%E4%B8%AA%E5%8E%86%E5%8F%B2%E9%A1%B5%E9%9D%A2%EF%BC%89">http://www.douban.com/group/vim/，输入后跳转到父页面即http://www.douban.com/group/，所以不同于H的快捷键是回到上个历史页面）</a></p>
<p>i：输入模式（如果发现命令不起作用，可能是进入输入模式了，此时按Esc回到命令模式）<br>gi：将焦点集中到第一个输入框（输入gNi则焦点集中到第N个输入框）<br>f：在当前的页面打开一个新的链接。<br>F：在新的页面打开一个新的链接。<br><a-f>:在当前页面打开多个链接（没感觉使用到了多个标签，不过表示的是输入af）<br>b：在当前页打开一个书签。（输入部分网址会自动进行搜索）<br>B：在新的标签页打开一个书签<br>gf：循环到当前页面的下一个框层（可能跟页面制作有关，目前没用到）</p>
<h3 id="查找模式：（和Vim相似）"><a href="#查找模式：（和Vim相似）" class="headerlink" title="查找模式：（和Vim相似）"></a>查找模式：（和Vim相似）</h3><p>&#x2F; : 查找<br>n: 向下查找匹配内容<br>N：向上查找匹配内容</p>
<h3 id="导航历史："><a href="#导航历史：" class="headerlink" title="导航历史："></a>导航历史：</h3><p>H：回退上一个历史页面（相当于浏览器中的向左箭头）<br>L：回到下一个历史页面（相当于浏览器的向右箭头）</p>
<h3 id="标签页操作："><a href="#标签页操作：" class="headerlink" title="标签页操作："></a>标签页操作：</h3><p>K，gt：跳转到右边的一个标签页<br>J，gT：跳转到左边的一个标签页<br>t：创建一个新的标签页<br>x：关闭当前的标签页<br>X：恢复刚刚关闭的标签页、<br>？：显示命令的帮助提示（再按一次关闭）<br>(红色为常用的命令)</p>
<p>另外，在当前的标签页直接输入一个新的网址，按F6就OK了。</p>
<h1 id="VS快捷键"><a href="#VS快捷键" class="headerlink" title="VS快捷键"></a>VS快捷键</h1><h1 id="CLion"><a href="#CLion" class="headerlink" title="CLion"></a>CLion</h1><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>CTRL+N  查找类</p>
<p>CIRL+B  找变量的来源</p>
<p>CTRL+G  定位行</p>
<p>CTRL+F  在当前窗口查找文本</p>
<p>CTRL+R  在 当前窗口替换文本</p>
<p>ALT+SHIFT+C 查找修改的文件</p>
<p>ALT+SHIFT+C 查找修改的文件</p>
<p>CTRL+E  最 近打开的文件</p>
<p>F4  查找变量来源</p>
<p>CTRL+ALT+F7 选 中的字符 查找工程出现的地方</p>
<h3 id="码字"><a href="#码字" class="headerlink" title="码字"></a>码字</h3><p>CTRL+ALT+L 格式化代码</p>
<p>ALT+SHIFT+C 最近更改的代码</p>
<p>CTRL+F  选中的文字,高亮显示</p>
<p>SHIFT+F2 高亮错误或警告快速定位</p>
<p>CTRL+&#x2F;  注释&#x2F;&#x2F; </p>
<p>CTRL+SHIFT+&#x2F; 注释&#x2F;<em>…</em>&#x2F;</p>
<p>CTRL+W  选中代码，连续按会 有其他效果</p>
<p>CTRL+B  快速打开光标处的类或方法</p>
<p>ALT+ ←&#x2F;→ 切换代码视图</p>
<p>CTRL+ALT ←&#x2F;→ 返回上次编辑的位置</p>
<p>ALT+ ↑&#x2F;↓ 在方法间快速移动定位</p>
<p>SHIFT+F6 重构-重命名</p>
<p>CTRL+H  显 示类结构图</p>
<p>CTRL+Q  显示注释文档</p>
<p>ALT+1  快速打开或隐藏工程面板</p>
<p>CTRL+SHIFT+UP&#x2F;DOWN 代码 向上&#x2F;下移动。</p>
<p>CTRL+UP&#x2F;DOWN 光标跳转到第一行或最后一行下</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/04/14/%E5%BF%AB%E6%8D%B7%E9%94%AE/" data-id="cl1ynefm30008swtu244ren07" data-title="快捷键" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-面试相关" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/Notes/2022/04/14/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/" class="article-date">
  <time class="dt-published" datetime="2022-04-14T06:55:35.290Z" itemprop="datePublished">2022-04-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/Notes/2022/04/14/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/">面试相关</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>四要素：</p>
<p>简历，面经，知己知彼，录音设备</p>
<ol>
<li><p>简历：</p>
<p>（不会的东西不要写，趋利避害，自己框个考试范围；可以自己先维护一份理想中的简历，并面向简历去学习）</p>
<p>（跳槽相关，准备一份没有期望薪资的 简历，给技术面试官）</p>
</li>
<li><p>面经：</p>
</li>
<li><p>知己知彼：了解公司主要业务，主打产品，公司发展历程，准备一个跟公司业务相关的问题</p>
</li>
<li><p>录音：弄懂面试中不懂的问题，吸取经验；可以发现一些不易察觉的问题，如表达方式，用词习惯，语速，音量（沟通能力，表达能力在工作中可能比技术更重要）</p>
</li>
<li><p>自我介绍环节：尽量亲和</p>
<p>自我介绍三要素：秀优势（避免面试官忽略你的优势），套近乎（将收集到的公司情报用两三句话组织一下，自然点），摆技术（擅长的，如果能和面试官聊起来，成功率会上升，同时将自己不会的问题引导到自己较擅长的）</p>
</li>
<li><p>问完技术后，可能会问项目（能简单但详细阐明项目的主要业务，自己觉的项目亮点在哪，遇到什么问题，如何解决，学到什么，项目细节也要注意</p>
</li>
<li><p>hr：职业生涯规划打算，表示自己对当前职业，公司，城市有长久打算。</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/04/14/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/" data-id="cl1ynefme000cswtu8zlc3e8x" data-title="面试相关" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-计算机组成原理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/Notes/2022/04/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2022-04-14T06:55:35.282Z" itemprop="datePublished">2022-04-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/Notes/2022/04/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">计算机组成原理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="一、计算机组成概论"><a href="#一、计算机组成概论" class="headerlink" title="一、计算机组成概论"></a>一、计算机组成概论</h1><h3 id="硬件组成"><a href="#硬件组成" class="headerlink" title="硬件组成"></a>硬件组成</h3><h4 id="早期冯诺依曼机"><a href="#早期冯诺依曼机" class="headerlink" title="早期冯诺依曼机"></a>早期冯诺依曼机</h4><ul>
<li>由五大部件组成；</li>
<li>指令和数据以同等地位存储于存储器，可按地址寻访；</li>
<li>指令和数据用二进制表示；</li>
<li>指令由操作码和地址码组成；</li>
<li>提前把程序放到存储器中；</li>
<li>以运算器为中心；（输入&#x2F;输出设备与存储器之间的数据传送通过运算器完成）</li>
</ul>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191722854.png" alt="image-20220107160155158"></p>
<blockquote>
<p>在计算机系统中，软件和硬件在逻辑上是等效的。<br>例如：对于乘法运算，可以设计一个专门的硬件电路实现乘法运算，也可以用软件的方式，执行多次加法运算来实现。</p>
</blockquote>
<h4 id="现代计算机"><a href="#现代计算机" class="headerlink" title="现代计算机"></a>现代计算机</h4><ul>
<li>以存储器为中心，CPU &#x3D; 运算器+控制器；</li>
</ul>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191722753.png" alt="image-20220107160853468"></p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191733507.png" alt="image-20220107160814200"></p>
<h2 id="CPU、存储器及工作过程"><a href="#CPU、存储器及工作过程" class="headerlink" title="CPU、存储器及工作过程"></a>CPU、存储器及工作过程</h2><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><ul>
<li><p><strong>运算器</strong></p>
<ul>
<li><p><strong>ALU：算数逻辑单元</strong>（Arithmetic and Logic Unit）(组合逻辑)，通过内部复杂的电路实现算数运算、逻辑运算；</p>
</li>
<li><p>MQ：乘商寄存器（Multiple-Quotient Register），在乘除运算时，用于存放操作数或运算结果；</p>
</li>
<li><p>ACC：累加寄存器（Accumulator），用于存放操作数，或运算结果；</p>
</li>
<li><p>X：通用寄存器（有很多个，X只是指在用其中某一个），用于存放操作数；</p>
</li>
<li><p>PSW：程序状态寄存器，存放状态信息和控制信息（Program Status Word）</p>
</li>
<li><p>MQ, ACC, X主要存放计算的中间结果：</p>
<table>
<thead>
<tr>
<th></th>
<th>加</th>
<th>减</th>
<th>乘</th>
<th>除</th>
</tr>
</thead>
<tbody><tr>
<td>ACC</td>
<td>被加数，和</td>
<td>被减数，差</td>
<td>乘积高位</td>
<td>被除数，余数</td>
</tr>
<tr>
<td>MQ</td>
<td></td>
<td></td>
<td>乘数，乘积低位</td>
<td>商</td>
</tr>
<tr>
<td>X</td>
<td>加数</td>
<td>减数</td>
<td>被乘数</td>
<td>除数</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p><strong>控制器</strong></p>
<ul>
<li><strong>CU：控制单位</strong>，分析指令，给出控制信号（Control Unit）(时序逻辑)</li>
<li>IR：指令寄存器，存放当前执行的指令（Instruction Register）</li>
<li>PC：指令地址，存放下一条指令地址，可以自动加1</li>
</ul>
</li>
</ul>
<h3 id="主存储器"><a href="#主存储器" class="headerlink" title="主存储器"></a>主存储器</h3><ul>
<li>存储体：数据在存储体内按地址存储；每个地址对应一个存储单位(存储字)</li>
<li>MAR：地址寄存器</li>
<li>MDR：数据寄存器</li>
</ul>
<p>注：MAR位数反映存储单元的个数，MAR&#x3D;4位：总共有2^4^个存储单位</p>
<p>MDR位数&#x3D;存储字长，MDR&#x3D;16位：每个存储单元可存放16bit，一个存储字(word)&#x3D;16bit； 易混淆：1个字节(Byte)&#x3D;8bit，1B&#x3D;1个字节，1b&#x3D;1bit</p>
<h3 id="计算机工作过程—取数指令"><a href="#计算机工作过程—取数指令" class="headerlink" title="计算机工作过程—取数指令"></a>计算机工作过程—取数指令</h3><p>（这里用M表示主存中某存储单元）</p>
<p>M(MAR)：根据MAR的数据访问存储体中的数据</p>
<p>(ACR)：取相应寄存器中的数据</p>
<p>指令：操作码+地址码； </p>
<p> OP(IR)：取操作码；  Ad(IR)：取地址码</p>
<p><strong>过程演示：取指令—分析指令—执行指令（指令周期）</strong></p>
<p>1  <strong>(PC) —&gt; MAR</strong>：将PC(指令地址) 中的指令地址放到MDR(地址寄存器)中；</p>
<p>2,3  <strong>M(MAR)—&gt;MDR</strong>：根据MAR中的地址，访问存储体中的数据，再将数据放入MDR(数据寄存器)（这里的数据是一条指令）；</p>
<p>4  <strong>(MDR) —&gt; IR</strong>：将MDR拿到的指令放到 IR(指令寄存器)；（到这里取指令阶段结束）</p>
<p>5  <strong>OP(IR) —&gt;CU</strong>：从IR中取出操作码，放入CU(控制单元) ，CU会分析指令；（分析指令阶段结束）</p>
<p>6 <strong>Ad(IR) —&gt; MAR</strong>：从IR中取出地址码，放入MAR；</p>
<p>7,8  <strong>M(MAR) —&gt;MDR</strong>：根据MAR中的地址，访问存储体中的数据，再将数据放入MDR(数据寄存器)（这里的数据是要进行操作的数据）；</p>
<p>9  <strong>MDR—&gt;(运算器中的寄存器)</strong> ：将MDR拿到的数据放到运算器中的对应的寄存器中（指令执行阶段结束）</p>
<p>注：CPU<strong>区分MDR中取出的是指令还是数据的依据：指令周期的不同阶段</strong></p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191733007.png" alt="image-20211121101940553"></p>
<h2 id="计算机的层次结构"><a href="#计算机的层次结构" class="headerlink" title="计算机的层次结构"></a>计算机的层次结构</h2><p>从高到低依次为：</p>
<ul>
<li>软件<ul>
<li>虚拟机器M4（高级语言机器）：用编译程序翻译成汇编语言程序</li>
<li>虚拟机器M3（汇编语言机器）：用汇编程序翻译成机器语言程序</li>
<li>虚拟机器M2（操作系统机器）：向上提供“广义指令”（即系统调用）</li>
</ul>
</li>
<li>硬件<ul>
<li>传统机器M1（机器语言机器）：执行二进制机器指令</li>
<li>微程序机器M0（微指令系统）：用硬件直接执行微指令</li>
</ul>
</li>
</ul>
<h2 id="计算机的性能指标"><a href="#计算机的性能指标" class="headerlink" title="计算机的性能指标"></a>计算机的性能指标</h2><h4 id="存储器的性能指标"><a href="#存储器的性能指标" class="headerlink" title="存储器的性能指标"></a>存储器的性能指标</h4><p>存储器&#x3D;存储体+MAR+MDR</p>
<p>其中MAR位数反映存储单元的个数（最多存多少个），MDR位数&#x3D;存储字长&#x3D;每个存储单元的大小</p>
<p><strong>总容量 &#x3D; 存储单位个数 * 存储字长(bit)</strong></p>
<p>例：MAR为32位，MDR为8位，则总容量 &#x3D; 2^32^ * 8 bit &#x3D; 4GB</p>
<hr>
<h4 id="CPU的性能指标"><a href="#CPU的性能指标" class="headerlink" title="CPU的性能指标"></a>CPU的性能指标</h4><p><strong>CPU时钟周期</strong>：又称震荡周期，是计算机中最基本的，最小的时间单位。在一个时钟周期内，CPU仅能完成一个最基本的动作。单位：微秒、纳秒</p>
<p><strong>CPU主频（时钟频率）</strong>：1 &#x2F; CPU时钟周期， 单位：赫兹，Hz</p>
<p><strong>CPI</strong>（Clock cycle Per Instruction）：执行一条指令所需的时钟周期数。不同指令或相同指令的CPI都可能不同</p>
<p><strong>执行一条指令的耗时</strong> &#x3D; CPI * CPU时钟周期</p>
<p><strong>CPU执行时间</strong> &#x3D; CPU时钟周期数 &#x2F; 主频 &#x3D; （指令条数 * CPI）&#x2F; 主频</p>
<p><strong>IPS</strong>（Instructions Per Second）：每秒执行多少条指令 （KIPS, MIPS….）</p>
<p><strong>IPS &#x3D; 主频 &#x2F; 平均CPI</strong></p>
<p><strong>FLOPS</strong>（Floating-point Operations Per Second）：每秒执行多少次浮点数运算（KFLOPS, MFLOPS, GFLOPS, TFLOPS….）</p>
<hr>
<h4 id="系统整体的性能指标"><a href="#系统整体的性能指标" class="headerlink" title="系统整体的性能指标"></a>系统整体的性能指标</h4><p>数据通路带宽：数据总线一次所能并行传递信息的位数；</p>
<p>吞吐量：系统在单位时间内处理请求的数量（主要取决于主存的存取周期）；</p>
<p>响应时间：指从用户向计算机发送一个请求，到系统对该请求做出响应并获得所需结果的等待时间；</p>
<hr>
<h1 id="二、数据的表示和运算"><a href="#二、数据的表示和运算" class="headerlink" title="二、数据的表示和运算"></a>二、数据的表示和运算</h1><h2 id="进位计数制"><a href="#进位计数制" class="headerlink" title="进位计数制"></a>进位计数制</h2><p>r进制：使用<strong>符号</strong> 和 <strong>符号所在的位置</strong>也反映权重。</p>
<ul>
<li>基数：每个位所能使用的不同符号个数，r进制的基数为r；</li>
</ul>
<blockquote>
<p>计算机采用二进制：</p>
<ul>
<li>数值的每个位，可以使用具有两个稳定状态的物理器件表示；</li>
<li>0，1正好对应逻辑值 真&#x2F;假，方便实现逻辑运算；</li>
<li>可利用逻辑门电路实现算术运算；</li>
</ul>
</blockquote>
<p>进制转换：</p>
<ul>
<li><p>r进制 到 十进制：</p>
<p>r 进制的数值 &#x3D; 各数码位与位权的乘积之和。</p>
</li>
<li><p>二进制 到 八进制：</p>
<p>每3个二进制位 对应一个八进制位；</p>
</li>
<li><p>二进制 到 十六进制：</p>
<p>每4个二进制位 对应一个八进制位；</p>
</li>
<li><p>十进制 到 r进制：</p>
<p>整数部分：除基取余法（先取得的“余”是整数的低位）</p>
<p>小数部分：乘基取整法（先取得的“整”是小数的高位）</p>
</li>
</ul>
<hr>
<p>真值：符合人类习惯，实际的带正负号的数字；</p>
<p>机器数：数字实际存到机器里的形式，正负号需要被“数字化”；</p>
<h2 id="BCD码"><a href="#BCD码" class="headerlink" title="BCD码"></a>BCD码</h2><h3 id="8421码"><a href="#8421码" class="headerlink" title="8421码"></a>8421码</h3><p>用二进制编码的十进制（Binary-Coded Decimal），使用 四位二进制 表示 十进制的 0 ~ 9，冗余6位，</p>
<p>BCD码的加法： 如果加法运算后，得到的十进制数为10 ~ 18，不在映射表内，即超过0~9的范围，则再加上6，即二进制的0110，则二进制数一定会前进一位，之后在前补3个0，则可以得到二个 四位二进制表示的数。</p>
<p>例：5 + 8 &#x3D; 13 —&gt; 0101 + 1000 &#x3D; 1101，超出范围，则再加6，得到 1 0011，在前面补0得到 0001 0011，即13</p>
<p>除了8421码，还有余3码，2421码也是用二进制编码表示十进制</p>
<h2 id="字符与字符串"><a href="#字符与字符串" class="headerlink" title="字符与字符串"></a>字符与字符串</h2><p>在<strong>ASCII码</strong>中， <strong>32~126为可印刷字符，其余为控制或通信字符（ASCII共128个）</strong></p>
<p>数字0~9：48（0011<strong>0000</strong>） ~ 57（0011<strong>1001</strong>）</p>
<p>大写字母：65（0100<strong>0001</strong>）~ 90（0101<strong>1010</strong>）</p>
<p>小写字母：97（0110<strong>0001</strong>）~ 122（0111<strong>1010</strong>）</p>
<p><strong>CB</strong> 2312-80码：汉字+各种符号共7445个</p>
<ul>
<li><strong>区位码</strong>：<strong>94个区，每个区94个位置</strong>，如 汉字“啊”的区位码：10H	01H</li>
<li><strong>国标码</strong>：在区位码的两个标号上加上<strong>20H</strong>，防止信息交换时，与ASCII码的“控制&#x2F;通信字符”冲突</li>
<li><strong>汉字内码</strong>：在国标码的两个标号上加上<strong>80H</strong>，即加上128，保证高位为1，与ASCII区分</li>
</ul>
<p>输入：<strong>输入编码</strong>； </p>
<p>输出：<strong>汉字字形码</strong></p>
<p><strong>字符串存储</strong></p>
<p>字母用一个字节存储，<strong>汉字用两个字节</strong>存储，</p>
<p>汉字的存储又分为大端模式和小端模式，<strong>大端模式是将数据的最高有效字节存放在低地址单元中，小端模式放在高地址单元中</strong></p>
<h2 id="校验码"><a href="#校验码" class="headerlink" title="校验码"></a>校验码</h2><h3 id="奇偶校验码"><a href="#奇偶校验码" class="headerlink" title="奇偶校验码"></a>奇偶校验码</h3><p>奇校验码：整个校验码（有效信息位和校验位）中的“1”的个数为奇数；</p>
<p>偶校验码：整个校验码（有效信息位和校验位）中的“1”的个数为偶数；</p>
<p>奇偶校验码分为<strong>1位的奇偶校验位</strong>和n位的有效信息位，奇偶校验位是为了让“1”的个数维持想要的奇数或偶数。</p>
<p>偶校验位的硬件实现：<strong>各信息进行异或（模2加）运算，得到的结果即为偶校验位</strong></p>
<p>进行<strong>偶校验</strong>：<strong>所有位进行异或，如果结果为1说明出错</strong></p>
<p>偶校验只能发现奇数位错误，且无法确定哪一位出错。</p>
<h3 id="海明码"><a href="#海明码" class="headerlink" title="海明码"></a>海明码</h3><p>将信息位分组进行偶校验，即设立多个校验位，可以标注出出错位置</p>
<p>需要设立多少个校验位？</p>
<blockquote>
<p>设信息位有n位，校验位有k位，而k个校验位一共能表示2^k^种状态， 所以 2^k^ - 1 &gt;&#x3D; n + k（减1是因为有一个是正确的状态，没出错）</p>
</blockquote>
<p>n与k的关系部分关系表：</p>
<table>
<thead>
<tr>
<th>n</th>
<th>1</th>
<th>2~4</th>
<th>5~11</th>
<th>12~26</th>
<th>27~57</th>
<th>58~120</th>
</tr>
</thead>
<tbody><tr>
<td>k</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
</tr>
</tbody></table>
<p>校验位的分布：<strong>校验位 P<del>i</del></strong> 应放在海明位号为 <strong>2^i-1^ 的位置</strong>上，其他位放有效信息。</p>
<p>求校验位的值：设各信息所在的位数 的二进制表示为x，第一个校验位等于 所有 x 的第一位(最低位)为1的 信息位值 的异或运算 结果；第二个校验位等于 所有 x 的第二位(最低第二位)为1的 信息位值 的异或运算 结果。。。</p>
<p>纠错：将第 i 个校验位值 和  x 的第i位(最低第 i 位)为1的 信息位值 进行异或运算，如果所有 运算后都得到0，则没有出错，如果有 结果为1 的情况出现，则说明出错，将所有校验位 拼成一个二进制表示，其值就是出错的位数。 </p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191733184.png" alt="image-20211118185904877"></p>
<p>海明码检错能力：1位， 纠错能力 ： 2位，此时海明码没办法区分 是一个bit位出错还是两个bit位出错，为此，需加上全校验位，对全体再进行一次偶校验，才能识别是一位错还是两位错。</p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191733454.png" alt="image-20211118185817499"></p>
<h3 id="循环冗余校验码-CRC"><a href="#循环冗余校验码-CRC" class="headerlink" title="循环冗余校验码(CRC)"></a>循环冗余校验码(CRC)</h3><p>CRC (Cyclic Redundancy Check)</p>
<ol>
<li><p>确定K, R, 生成多项式对应的二进制码</p>
<p>首先，需要先约定好 生成多项式 G(x) &#x3D; x^n^ + x^n-1^+ ….. + x^0^，</p>
<p>然后确定 信息位的长度K &#x3D; 信息码的长度， 校验位的长度 R &#x3D; 生成多项式最高次幂n，整个校验码位数&#x3D; K + R；</p>
<p>根据生成多项式里各项的常数部分，生成对应二进制码</p>
</li>
<li><p>移位</p>
<p>将信息码左移R位，低位补0，</p>
</li>
<li><p>相除</p>
<p>对<strong>移位后的信息码</strong>，用<strong>生成多项式的二进制码</strong> 进行<strong>模2除法</strong>，<strong>产生的余数</strong> 即为校验位信息</p>
<p>模2除，模2减（异或运算）：</p>
</li>
<li><p>检错和纠错</p>
<p>对接收的数据，用约定好的生成多项式的二进制码 进行模2除，得到余数为R位全为0，说明没有出错；余数不为0，说明出错，余数是多少，就是多少位出错。</p>
<p>CRC可检测出：所有奇数个错误；所有双比特错误；所有小于等于校验位长度的连续错误</p>
<p>CRC码中的信息位太多，会使纠错得到的余数无法表示太高位，如果满足2^R^-1&gt;&#x3D;K+R，则CRC可纠正1位错，不过CRC通常用于网络传输，只发挥检错功能（网络传输一次会发送较多bit）</p>
</li>
</ol>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191733238.png" alt="image-20211118190033659"></p>
<h2 id="定点数表示"><a href="#定点数表示" class="headerlink" title="定点数表示"></a>定点数表示</h2><h3 id="原、补、移码"><a href="#原、补、移码" class="headerlink" title="原、补、移码"></a>原、补、移码</h3><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191733031.png" alt="image-20211118190147440"></p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191734022.png" alt="image-20211118190157729"></p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191734970.png" alt="image-20211118190229297"></p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191734242.png" alt="image-20211118190237631"></p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191734504.png" alt="image-20211118190244928"></p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191734382.png" alt="image-20211118190252353"></p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191734443.png" alt="image-20211118190302522"></p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191734164.png" alt="image-20211118190314258"></p>
<p><strong>使用补码的意义：让减法操作转变为加法操作，节省硬件成本。</strong>（涉及求模运算的意义）</p>
<p>因为计算机是固定字长的，所以在进行运算时会舍去溢出的位，这相当于 直接对结果进行了求模运算（%2^n^）。</p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191734109.png" alt="image-20211118190348822"></p>
<h3 id="符号拓展"><a href="#符号拓展" class="headerlink" title="符号拓展"></a>符号拓展</h3><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191734958.png" alt="image-20211118191549313"></p>
<h2 id="定点数运算"><a href="#定点数运算" class="headerlink" title="定点数运算"></a>定点数运算</h2><h3 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h3><h4 id="算数移位"><a href="#算数移位" class="headerlink" title="算数移位"></a>算数移位</h4><p> <img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191734222.png" alt="image-20211118190446667"></p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191734150.png" alt="image-20211118190500971"></p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191734904.png" alt="image-20211118190508649"></p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191734438.png" alt="image-20211118190521365"></p>
<h4 id="逻辑移位"><a href="#逻辑移位" class="headerlink" title="逻辑移位"></a>逻辑移位</h4><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191734790.png" alt="image-20211118190549711"></p>
<h4 id="循环移位"><a href="#循环移位" class="headerlink" title="循环移位"></a>循环移位</h4><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191734286.png" alt="image-20211118190557099"></p>
<h3 id="加减运算"><a href="#加减运算" class="headerlink" title="加减运算"></a>加减运算</h3><p>补码的加减运算：运算同源码一样，求出结果后再转为原码</p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191734956.png" alt="image-20211118190803498"></p>
<p>对于补码的加减运算出现 溢出情况的判断，有三种判断方式：</p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191734873.png" alt="image-20211118191231755"></p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191734424.png" alt="image-20211118191321945"></p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191735427.png" alt="image-20211118191330388"></p>
<h3 id="乘法运算"><a href="#乘法运算" class="headerlink" title="乘法运算"></a>乘法运算</h3><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191735150.png" alt="image-20211118191717510"></p>
<p>计算机 的乘法运算 可以对比平时 手算乘法时列的竖式公式，其本质是利用r进制的位权。</p>
<p>计算机实现 <strong>原码</strong>的乘法运算：<strong>先加法，再移位，重复n次</strong>（左移位相当于手算时的错位）</p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191736943.png" alt="image-20211118192237385"></p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191736326.png" alt="image-20211118192245580"></p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191736434.png" alt="image-20211118192252905"></p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191736419.png" alt="image-20211118192305905"></p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191736449.png" alt="image-20211118192328486"></p>
<p>补码的乘法运算：</p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191736406.png" alt="image-20211118192428730"></p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191736350.png" alt="image-20211118192540200"></p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191736233.png" alt="image-20211118192547837"></p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191736060.png" alt="image-20211118192558787"></p>
<h3 id="除法运算"><a href="#除法运算" class="headerlink" title="除法运算"></a>除法运算</h3><p>根据手算除法的过程，计算机 实现原码的除法运算：<strong>看当前位的商为0&#x2F;1，得到余数，余数末尾补0，得到的余数当作新的被除数。</strong></p>
<p>（<strong>定点小数除法</strong> 规定 <strong>被除数一定要小于除数</strong>，不然结果会大于1，而定点小数无法表示大于1的数）</p>
<h4 id="原码—恢复余数法"><a href="#原码—恢复余数法" class="headerlink" title="原码—恢复余数法"></a>原码—恢复余数法</h4><p>计算机不会去判断当前被除数和除数谁打谁小，而是直接将当前商位置为1(MQ里操作)，计算得到余数（ 余数 &#x3D; 被除数 + [-|y|]<del>补码</del> ），如果余数为负，说明商为1是错的，所以会将商位置为0，让余数重新加上除数，即让余数恢复为被除数，然后再计算商为0时应得的余数。</p>
<p><img src="D:/Note/Typora_picture/image-20211118192659788.png" alt="image-20211118192659788"></p>
<p><img src="D:/Note/Typora_picture/image-20211118193424237.png" alt="image-20211118193424237"></p>
<p><img src="D:/Note/Typora_picture/image-20211118193444434.png" alt="image-20211118193444434"></p>
<p><img src="D:/Note/Typora_picture/image-20211118193453852.png" alt="image-20211118193453852"></p>
<h4 id="原码—加减交替法"><a href="#原码—加减交替法" class="headerlink" title="原码—加减交替法"></a>原码—加减交替法</h4><p>恢复余数法中的一些步骤可以合并，根据恢复余数法前后的结果，可以算出：如果商位置1是错的（即得到余数为负），则商位置1，然后让余数左移一位（乘2），再加上|除数|，这样可以直接将错误的余数转化为正确的余数。</p>
<p><img src="D:/Note/Typora_picture/image-20211118193510093.png" alt="image-20211118193510093"></p>
<p><img src="D:/Note/Typora_picture/image-20211118194222167.png" alt="image-20211118194222167"></p>
<p><img src="D:/Note/Typora_picture/image-20211118194232160.png" alt="image-20211118194232160"></p>
<h4 id="补码—加减交替法"><a href="#补码—加减交替法" class="headerlink" title="补码—加减交替法"></a>补码—加减交替法</h4><p>补码的加减交替法，与原码不同在于：补码除法的<strong>符号位会参与运算</strong>（求补码时不会先求绝对值），数据采用<strong>双符号位</strong>。</p>
<p>补码除法<strong>求余数</strong>时，余数不会直接等于（被除数 + [-|y|]<del>补码</del> ），而是：<strong>1. 如果被除数和除数同号，则被除数减去除数，2. 如果异号，则被除数加上除数。</strong></p>
<p>对于<strong>商位是1还是0</strong>：<strong>1. 余数和除数同号，则商为1，然后余数左移一位，减去除数；2. 余数和除数异号，商为0，余数左移一位，加上除数。过程重复n次。</strong></p>
<p>最后，<strong>末尾商会恒置为1</strong>，这样可以不考虑最后算出的余数是否需要恢复余数，省去额外电路的设计，且这样做<strong>精度误差是不超过 2^-n^</strong> 的。</p>
<p><img src="D:/Note/Typora_picture/image-20211118194241590.png" alt="image-20211118194241590"></p>
<p><img src="D:/Note/Typora_picture/image-20211118194251001.png" alt="image-20211118194251001"></p>
<h2 id="数据存储-边界对齐"><a href="#数据存储-边界对齐" class="headerlink" title="数据存储|边界对齐"></a>数据存储|边界对齐</h2><p><img src="D:/Note/Typora_picture/image-20211120184018313.png" alt="image-20211120184018313"></p>
<h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><h3 id="IEEE-754标准"><a href="#IEEE-754标准" class="headerlink" title="IEEE 754标准"></a>IEEE 754标准</h3><p>IEEE读作 i triple e ：triple是三倍的意思</p>
<p><img src="D:/Note/Typora_picture/image-20211120184237269.png" alt="image-20211120184237269"></p>
<p><img src="D:/Note/Typora_picture/image-20211120184326877.png" alt="image-20211120184326877"></p>
<p><img src="D:/Note/Typora_picture/image-20211120184331950.png" alt="image-20211120184331950"></p>
<p><img src="D:/Note/Typora_picture/image-20211120184336345.png" alt="image-20211120184336345"></p>
<h3 id="浮点数的加减运算"><a href="#浮点数的加减运算" class="headerlink" title="浮点数的加减运算"></a>浮点数的加减运算</h3><p><img src="D:/Note/Typora_picture/image-20211120184152834.png" alt="image-20211120184152834"></p>
<p><img src="D:/Note/Typora_picture/image-20211120184617835.png" alt="image-20211120184617835"></p>
<p>强制类型转换</p>
<p><img src="D:/Note/Typora_picture/image-20211120184633939.png" alt="image-20211120184633939"></p>
<h3 id="ALU大致原理"><a href="#ALU大致原理" class="headerlink" title="ALU大致原理"></a>ALU大致原理</h3><p>电路基础知识</p>
<p><img src="D:/Note/Typora_picture/image-20211120184649625.png" alt="image-20211120184649625"></p>
<p><img src="D:/Note/Typora_picture/image-20211120184653982.png" alt="image-20211120184653982"></p>
<p><img src="D:/Note/Typora_picture/image-20211120184658348.png" alt="image-20211120184658348"></p>
<p><img src="D:/Note/Typora_picture/image-20211120184706787.png" alt="image-20211120184706787"></p>
<p>加法器的实现</p>
<p><img src="D:/Note/Typora_picture/image-20211120184713453.png" alt="image-20211120184713453"></p>
<p><img src="D:/Note/Typora_picture/image-20211120184718342.png" alt="image-20211120184718342"></p>
<p><img src="D:/Note/Typora_picture/image-20211120184732882.png" alt="image-20211120184732882"></p>
<p>加法器、ALU改进</p>
<p><img src="D:/Note/Typora_picture/image-20211120184739339.png" alt="image-20211120184739339"></p>
<p><img src="D:/Note/Typora_picture/image-20220111095619918.png" alt="image-20220111095619918"></p>
<p><img src="D:/Note/Typora_picture/image-20220111095547417.png" alt="image-20220111095547417"></p>
<h1 id="三、存储系统"><a href="#三、存储系统" class="headerlink" title="三、存储系统"></a>三、存储系统</h1><h2 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h2><p>功能：存放二进制信息。</p>
<p>层次：</p>
<ul>
<li>高速缓冲存储器（cache）</li>
<li>主存储器（主存、内存）</li>
<li>辅助存储器（辅存、外存）</li>
</ul>
<blockquote>
<p>Cache解决CPU和主存之间速度不匹配的问题，由硬件自动完成；</p>
<p>辅存解决主存容量不够的问题，需要硬件和操作系统配合完成。</p>
</blockquote>
<h3 id="存储器模型"><a href="#存储器模型" class="headerlink" title="存储器模型"></a>存储器模型</h3><p><img src="D:/Note/Typora_picture/image-20211120185413723.png" alt="image-20211120185413723"></p>
<ul>
<li>存储矩阵：由大量相同的位存储单元阵列构成。</li>
<li>译码驱动：将来自地址总线的地址信号翻译成对应存储单元的选通信号，该信号在读写电路的配合下完成对被选中单元的读&#x2F;操作。</li>
<li>读写电路：包括读出放大器和写入电路，用来完成读&#x2F;写操作。</li>
<li>读&#x2F;写控制线：决定芯片进行读&#x2F;写操作。</li>
<li>片选线：确定哪个存储芯片被选中。可用于容量扩充。</li>
<li>地址线：是单向输入的，其位数与存储字的个数有关。</li>
<li>数据线：是双向的，其位数与读出或写入的数据位数有关。</li>
<li>数据线数和地址线数共同反映存储芯片容量的大小；如地址线10根，数据线8根，则芯片容量-&#x3D;20×8-8K位。</li>
</ul>
<h3 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h3><p>有多种方式：可按 字节、字、半字、双字 寻址；</p>
<p>多字节存放方式：</p>
<ul>
<li>大端方式：数值的高位放在地址的低位；</li>
<li>小端方式：数值的低位放在地址的低位；</li>
</ul>
<h3 id="随机存取器RAM"><a href="#随机存取器RAM" class="headerlink" title="随机存取器RAM"></a>随机存取器RAM</h3><p><strong>SRAM（Static Random Access Memory ）：静态随机存储器</strong></p>
<p><strong>DRAM（Dynamic Random Access Memory）：动态随机存取器</strong></p>
<blockquote>
<p>两者都是以电信号的形式存储0和1，断点就丢失信息，所以也叫易失性存储器。</p>
</blockquote>
<p><strong>SRAM：</strong></p>
<ul>
<li>存储信息（0、1）：使用<strong>触发器——双稳态</strong>；</li>
<li><strong>非破坏性读出</strong>：读——查看触发器状态；写——改变触发器状态；</li>
<li><strong>不需刷新</strong>：触发器能保持两种稳定的状态；</li>
<li><strong>同时送行列式地址</strong>；</li>
<li><strong>运行速度 快</strong></li>
<li><strong>集成度 低</strong>：6个逻辑元件；</li>
<li><strong>发热量 大</strong></li>
<li><strong>存储成本 高</strong></li>
</ul>
<p><strong>DRAM：</strong></p>
<ul>
<li>存储信息（0、1）：使用<strong>电容——充放电</strong>；</li>
<li><strong>破坏性读出</strong>：读——连接电容，检测电流变化，读出后需要重新充电；写——给电容充&#x2F;放电</li>
<li><strong>需刷新</strong>：电容上的电荷只能维持2ms；</li>
<li><strong>分两次送行列式地址</strong>：地址分成相同位的行列地址，地址线可以复用，线数减半；</li>
<li><strong>运行速度 慢</strong></li>
<li><strong>集成度 高</strong>：1或3个逻辑元件；</li>
<li><strong>发热量 小</strong></li>
<li><strong>存储成本 低</strong></li>
</ul>
<blockquote>
<p>由于SRAM速度快，成本高，所以常用作Cache；而DRAM常用作主存；</p>
<p>SDRAM：同步动态随机存储器，是DRAM的发展变形</p>
</blockquote>
<hr>
<hr>
<p><strong>DRAM的刷新</strong></p>
<p>刷新周期：一般2ms</p>
<p>每次刷新：以行为单位，每次刷新一行存储单元</p>
<blockquote>
<p>为什么使用行列地址？</p>
<p>因为如果采用一维模式的话，2^n^个存储单元需要2^n^根选通线；如果使用行列地址，将一个地址分成两半，则每一半地址只需2^n&#x2F;2^根线，一共需要2 * 2^n&#x2F;2^ 根线。</p>
<p>如：2^8^ &#x3D; 256根选通线，只需2 * 2^4^&#x3D; 32根选通线</p>
</blockquote>
<p>如何刷新：有硬件支持，读出一行的信息后重新写入，占用一个读&#x2F;写周期；</p>
<p>刷新时机：</p>
<ul>
<li><p>分散刷新：</p>
<p>每次读写完都刷新一行，这样系统的存取周期会翻倍。</p>
</li>
<li><p>集中刷新：</p>
<p>在刷新周期内集中安排一段时间用于刷新全部行，这段时间内无法访问存储器，称为访存“死区”。</p>
</li>
<li><p>异步刷新：</p>
<p>在刷新周期内刷新1次即可，即刷新请求在刷新周期内均匀分布，”死区“会被平均分散。</p>
</li>
</ul>
<h3 id="只读存储器ROM"><a href="#只读存储器ROM" class="headerlink" title="只读存储器ROM"></a>只读存储器ROM</h3><p>（Read-Only Memory）</p>
<blockquote>
<p>ROM是非易失性存储器</p>
</blockquote>
<p>类型：</p>
<ul>
<li><p>膜式只读存储器(MROM)：</p>
<p>存储内容由半导体制造厂按用户提出的要求<br>在芯片的生产过程中直接写入，无法修改。</p>
</li>
<li><p>一次可编程只读存储器（PROM）：</p>
<p>存储内容由用户用专门的设备（编程器）一次性写入，之后无法修改。</p>
</li>
<li><p>可擦除可编程只读存储器( EPROM)：</p>
<p>修改次数有限，写入时间很长；类型有 紫外线擦除（UVEPROM）、电擦除（EEPROM）。</p>
</li>
<li><p>闪速存储器（Flash Memory）：</p>
<p>如U盘，写入速度较快。</p>
</li>
<li><p>固态硬盘( Solid State Drives)：</p>
<p>控制单元 + FLASH芯片</p>
</li>
</ul>
<h2 id="主存与CPU连接"><a href="#主存与CPU连接" class="headerlink" title="主存与CPU连接"></a>主存与CPU连接</h2><p><img src="D:/Note/Typora_picture/image-20220110112634686.png" alt="image-20220110112634686"></p>
<p><strong>连接原理：</strong></p>
<ul>
<li>主存储器通过数据总线、地址总线和控制总线与CPU连接；</li>
<li>（数据总线的位数 * 工作频率 ）正比于数据传输速率；</li>
<li>地址总线的位数决定了可寻址的最大内存空间；</li>
<li>控制总线（读&#x2F;写）指出总线周期的类型 和 本次输入&#x2F;输出操作完成的时刻；</li>
</ul>
<p><strong>主存容量的扩展：</strong></p>
<p>由于单个存储芯片的容量有限，在字数或字长方面与实际的要求都有差距，因此需要在<strong>字</strong>和<strong>位</strong>两方面进行扩展。</p>
<ul>
<li><p><strong>位扩展法</strong></p>
<p>CPU的数据线数与存储芯片的数据位数不一定相等，此时必须对存储芯片扩位，使其数据位数与CPU的数据线数相等。<br>位扩展的连接方式是将多个存储芯片的地址端、片选端和读写控制端相应并联，数据端分别引出。</p>
<p><img src="D:/Note/Typora_picture/image-20220110113624661.png" alt="image-20220110113624661"></p>
</li>
<li><p><strong>字扩展法</strong></p>
<p>字扩展是指增加存储器中字的数量，而位数不变。字扩展将芯片的地址线、数据线、读写控制线相应并联，而由片选信号来区分各芯片的地址范围。</p>
</li>
<li><p><strong>字位同时扩展法</strong></p>
<p>实际上，存储器往往需要同时扩充字和位。字位同时扩展是指既增加存储字的数量，又增加存储字长。</p>
<p><img src="D:/Note/Typora_picture/image-20220110113930006.png" alt="image-20220110113930006"></p>
<p><img src="D:/Note/Typora_picture/image-20220110113939759.png" alt="image-20220110113939759"></p>
</li>
</ul>
<hr>
<p><strong>存储芯片的地址分配和片选</strong></p>
<p>CPU对存储器的访问：先片选 再字选。</p>
<ol>
<li>片选：选择存储器芯片；<ul>
<li>线选法：用除片内寻址外的高位地址线分别接至各个存储芯片的片选。（线路简单，地址不连续，一条线只产生一个选片信号）</li>
<li><strong>译码片选法</strong>：用除片内寻址外的高位地址线通过地址译码器芯片产生片选信号。（电路复杂，地址空间连续，可增加逻辑设计，n条线可产生2^n^个选片信号）</li>
</ul>
</li>
<li>字选：对选中的芯片，依据地址码 进行数据存取；</li>
</ol>
<h2 id="双口RAM和多模块存储器"><a href="#双口RAM和多模块存储器" class="headerlink" title="双口RAM和多模块存储器"></a>双口RAM和多模块存储器</h2><p>提高CPU访问存储器的速度：</p>
<ul>
<li>双端口存储器：空间并行；</li>
<li>多模块存储器：时间并行。</li>
</ul>
<p><strong>双端口RAM：</strong></p>
<p>双端口RAM是指同一个存储器有左、右两个独立的端口，分别具有两组相互独立的地址线、数据线和读写控制线，允许两个独立的控制器同时异步地访问存储单元。</p>
<p>注：当两个端口同时对存储器的同一地址进行修改时，可能会发生数据错误或读取错误；</p>
<p><img src="D:/Note/Typora_picture/image-20220110115750687.png" alt="image-20220110115750687"></p>
<p>存取周期：</p>
<p><img src="D:/Note/Typora_picture/image-20220111085521860.png" alt="image-20220111085521860"></p>
<p><strong>多模块存储器：</strong></p>
<p>常用的有：单体多字存储器 ，多体低位交叉存储器。</p>
<ul>
<li><p>单体多字存储器：</p>
<p>单体多字系统的特点是存储器中只有一个存储体，每个存储单元存储m个字，总线宽度也为m个字。一次并行读出m个字，地址必须顺序排列并处于同一存储单元。<br>单体多字系统在一个存取周期内，从同一地址取出m条指令，然后将指令逐条送至CPU执行，即每隔1&#x2F; m 存取周期，CPU向主存取一条指令。显然，这増大了存储器的带宽，提高了单体存储器的工作速度。</p>
<p>缺点：指令和数据在主存内必须是连续存放的，一旦遇到转移指令，或操作数不能连续存放，这种方法的效果就不明显。</p>
</li>
<li><p><strong>多体并行存储器：</strong></p>
<p>多体并行存储器由多体模块组成。每个模块都有相同的容量和存取速度，各模块都有独立的读写控制电路、地址寄存器和数据寄存器。它们既能并行工作，又能交叉工作。<br>多体并行存储器分为 高位交叉编址（顺序方式）和低位交又编址（交又方式）两种。</p>
<ul>
<li><p>高位交叉编制：</p>
<p>高位地址表示体号，低位地址表示体内地址；总是会把低位的体内地址送到由高位体号确定的模块内进行译码。</p>
<p>访问一个连续主存块时，总是先在一个模块内访问，等到该模块访问完才转到下一个模块访问，CPU总是按顺序访问存储模块，存储模块不能被并行访问，因而不能提高存储器的吞吐率。</p>
<blockquote>
<p>模块内的地址是连续的，存取方式仍是串行存取，因此这种存储器仍是顺序存储器</p>
</blockquote>
<p><img src="D:/Note/Typora_picture/image-20220110120657545.png" alt="image-20220110120657545"></p>
</li>
<li><p><strong>低位交叉编制：</strong></p>
<p>低位地址为体号，高位地址为体内地址。</p>
<p>低位交叉编址方式下，总是把高位的体内地址送到由低位体号确定的模块内进行译码。程序连续存放在相邻模块中，因此称采用此编址方式的存储器为交叉存储器。</p>
<p>采用低位交叉编址后，可在不改变每个模块存取周期的前提下，采用流水线的方式并行存取，提高存储器的带宽。</p>
<p><img src="D:/Note/Typora_picture/image-20220110120837771.png" alt="image-20220110120837771"></p>
<p><img src="D:/Note/Typora_picture/image-20220110120848340.png" alt="image-20220110120848340"></p>
</li>
</ul>
</li>
</ul>
<h2 id="高速缓冲存储器Cache"><a href="#高速缓冲存储器Cache" class="headerlink" title="高速缓冲存储器Cache"></a>高速缓冲存储器Cache</h2><p>提高整个存储系统的工作速度。</p>
<p>程序访问的局部性原理：</p>
<ul>
<li><strong>时间局部性</strong>：在最近的未来要用到的信息，很可能是现在正在使用的信息，因为程序中存在循环。</li>
<li><strong>空间局部性</strong>：在最近的未来要用到的信息，很可能与现在正在使用的信息在存储空间上是邻近的，因为指令通常是顺序存放、顺序执行的，数据一般也是以向量、数组等形式簇聚地存储在一起的。</li>
</ul>
<p><strong>高速缓冲</strong>技术就是利用程序访问的局部性原理，把<strong>程序中正在使用的部分</strong>存放在一个<strong>高速的、容量较小的 Cache</strong>中，使CPU的访存操作大多数针对 Cache进行，从而大大提高程序的执行速度。</p>
<hr>
<hr>
<p><strong>Cache基本工作原理：</strong></p>
<p>Cache位于存储器层次结构的顶层，通常由SRAM构成，其基本结构如图：</p>
<p><img src="D:/Note/Typora_picture/image-20220111090254388.png" alt="image-20220111090254388"></p>
<p>为了便于交换信息，Cache和主存都被划分为相等的块，Cache块也叫Cache行，每块的长度称为块长（Cache行长）；</p>
<p>由于Cache的容量远小于主存的容量，因此它只保存主存中最活跃的若干块的副本。</p>
<ul>
<li>当CPU发出读请求时，若访存地址在Cache中命中，则将该地址转化为Cache地址，对Cache进行读操作，与主存无关。若Cache未命中，则仍需要访问主存，将该字所在的块一次性从主存调入Cache，若Cache已满，则需要根据某替换算法，将Cache中的某块替换掉。</li>
<li>当CPU发出写请求时，若 Cache命中，有可能会遇到 Cache与主存中的内容不一致的问题。例如，由于CPU写 Cache，把 Cache某单元中的内容从X修改成了Y，而主存对应单元中的内容仍然是X，没有改变。所以若 Cache命中，需要按照一定的写策略处理，常见的处理方法有全写法和写回法。</li>
</ul>
<blockquote>
<p>数据交换单位：CPU与主存间以字为单位，Cache与主存间以Cache块为单位。</p>
<p>注：某些计算机也采用同时访问 Cache和主存的方式，若Cach命中，则主存访问终止。</p>
</blockquote>
<hr>
<hr>
<p><strong>Cache和主存的映射关系</strong></p>
<p>Cache行中的信息是主存中某个块的副本，地址映射是指把主存地址空间映射到 Cache地址空间，即把存放在主存中的信息按照某种规则装入 Cache.<br>由于 Cache行数比主存块数少得多，因此主存中只有一部分块的信息可放在 Cache中，因此在 Cache中要为每块加一个标记，指明它是主存中哪一块的副本。该标记的内容相当于主存中块的编号。为了说明 Cache行中的信息是否有效，每个 Cache行需要一个有效位。</p>
<ul>
<li><p>直接映射</p>
<p>主存中的每一块只能装入 Cache中的唯一位置。若这个位置已有内容，则产生块冲突，原来的块将无条件地被替换出去（无须使用替换算法）。</p>
<p>直接映射实现简单，但不够灵活，即使Cache的其他许多地址空着也不能占用，这使得直接映射的块冲突概率最高，空间利用率最低。</p>
</li>
<li><p>全相联映射</p>
<p>主存中的每一块可以装入 Cache中的任何位置，每行的标记用于指出该行取自主存的哪一块，所以CPU访存时需要与所有 Cache行的标记进行比较。</p>
<p>全相联映射方式的优点是比较灵活， Cache块的冲突概率低，空间利用率高，命中率也高；缺点是标记的比较速度较慢，实现成本较高，通常需采用昂贵的按内容寻址的相联存储器进行地址映射。</p>
</li>
<li><p>组相联映射</p>
<p>将 Cache空间分成大小相同的组，主存的一个数据块可以装入一组内的任何一个位置，即组间采取直接映射，而组内采取全相联映射。它是对直接映射和全相联映射的一种折中。</p>
</li>
</ul>
<hr>
<hr>
<p><strong>Cache块的替换算法</strong></p>
<ul>
<li><p>随机算法（RAND）</p>
</li>
<li><p>先进先出算法（FIFO）</p>
</li>
<li><p>近期最少使用算法（LRU）</p>
<p>LRU算法对每个 Cache行设置一个计数器，用计数值来记录主存块的使用情况，并根据计数值选择淘汰某个块。</p>
</li>
<li><p>最不经常使用算法（LFU）</p>
</li>
</ul>
<hr>
<hr>
<p><strong>Cache写策略</strong></p>
<p>因为 Cache中的内容是主存块副本，当对 Cache中的内容进行更新时，就需选用写操作策略使 Cache内容和主存内容保持一致。此时分两种情况。</p>
<ul>
<li><p>对于 Cache写命中( write hit)，有两种处理方法。</p>
<ul>
<li><p>全写法（写直通法、wite- through）：</p>
<p>当CPU对 Cache写命中时，必须把数据同时写入Cache和主存；当某一块需要替换时，不必把这一块写回主存，用新调入的块直接覆盖即可。</p>
<p>这种方法实现简单，能随时保持主存数据的正确性。缺点是增加了访存次数，降低了 Cache的效率。</p>
<blockquote>
<p>写缓冲：为减少全写法直接写入主存的时间损耗，在 Cache和主存之间加一个写缓冲( Write Buffer)。</p>
<p>CPU同时写数据到 Cache和写缓冲中，写缓冲再控制将内容写入主存。写缓冲是一个FIFO队列，写缓冲可以解决速度不匹配的问题。但若出现频繁写时，会使写缓冲饱和溢出。</p>
</blockquote>
</li>
<li><p>写回法( write-back)：</p>
<p>当CPU对 Cache写命中时，只修改 Cache的内容，而不立即写入主存，只有当此块被换出时才写回主存。这种方法减少了访存次数，但存在不一致的隐患。采用这种策略时，每个 Cache行必须设置一个标志位（脏位），以反映此块是否被CPU修改过。</p>
</li>
</ul>
</li>
<li><p>对于 Cache写不命中，也有两种处理方法。</p>
<ul>
<li><p>写分配法(wite- allocate)：</p>
<p>加载主存中的块到 Cache中，然后更新这个Cache块。它试图利用程序的空间局部性，但缺点是每次不命中都需要从主存中读取一块。</p>
</li>
<li><p>非写分配法(not- write- allocate)法：</p>
<p>只写入主存，不进行调块。</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>非写分配法通常与全写法合用，写分配法通常和写回法合用。</p>
<p>现代计算机的 Cache通常设立多级 Cache(通常为3级)，按离CPU的远近可各自命名为L1 Cache、L2 Cache、L3 Cache，离CPU越远，访问速度越慢，容量越大。<br>指令 Cache与数据 Cache分离一般在L1级，此时通常为写分配法与写回法合用。</p>
</blockquote>
<h2 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h2><p>提高存储系统的容量。</p>
<p>虚拟存储器将主存或辅存的地址空间统一编址，形成一个庞大的地址空间。虚拟存储器具有主存的速度和辅存的容量，提高了存储系统的性价比。</p>
<ul>
<li>虚地址、逻辑地址：用户编程所涉及的地址，虚地址对应的存储空间称为虚拟空间或逻辑空间。</li>
<li>实地址、物理地址：对应的是主存地址空间，也称实地址空间。虚地址要比实地址大得多。</li>
</ul>
<p>CPU使用虚地址时，由辅助硬件找出虚地址和实地址之间的对应关系，并判断这个虚地址对应的存储单元内容是否已装入主存。——若已在主存中，则通过地址变换，CPU可直接访问主存指示的实际单元；——若不在主存中，则把包含这个字的一页或一段调入主存后再由CPU访问。——若主存已满，则采用替换算法置换主存中的一页或一段。</p>
<blockquote>
<p>在实际的物理存储层次上，所编程序和数据在操作系统管理下，先送入磁盘，然后操作系统将当前运行所需要的部分调入主存，供CPU使用，其余暂不运行的部分则留在磁盘中。</p>
</blockquote>
<hr>
<p><strong>页式虚拟存储器</strong></p>
<p>虚拟空间和主存空间被划分为同样大小的页，主存的页叫实页，虚存的页叫虚页。</p>
<p>虚拟地址 被分为两个子段：虚页号和页内地址；虚拟地址到物理地址的转换由页表完成。</p>
<blockquote>
<p>页表</p>
<p>是一张存放在主存中的虚页号和实页号的对照表，一般长久地保存在内存中。</p>
<p>页表组成：</p>
<ul>
<li>有效位：也叫装入位，表示页面是否已调入主存；</li>
<li>脏位：也叫修改位，表示页面是否被修改过；虚存机制中使用回写策略。</li>
<li>引用位：也称使用位，用来配合替换策略进行设置。</li>
<li>物理地址：该页对应的物理地址指向。</li>
</ul>
</blockquote>
<p>CPU执行指令时，需要先将虚拟地址转换为主存物理地址。每个进程都有一个页表基址寄存器，存放该进程的页表首地址，然后根据虚拟地址高位部分的虚拟页号找到对应的页表项，若装入位为1,则取出物理页号，和虚拟地址低位部分的页内地址拼接，形成实际物理地址；若装入位<br>为0,则说明缺页，需要操作系统进行缺页处理。</p>
<p>页式虚拟存储器的优点是，页面的长度固定，页表简单，调入方便。缺点是，程序的最后一页经常会有浪费，并且页不是逻辑上独立的实体，所以在处理、保护和共享都不如段式虚拟存储器方便。</p>
<blockquote>
<p>由地址转换过程可知，访存时先访问一次主存去査页表，再访问主存才能取得数据。如果缺页，那么还要进行页面替换、页面修改等，因此采用虚拟存储机制后，访问主存的次数更多了。依据程序执行的局部性原理，在一段时间内总是经常访问某些页时，若把这些页对应的页表项存放在高速缓冲器组成的快表(TLB)中，则可以明显提高效率。相应地把放在主存中的页表称为慢表(Page)。在地址转换时，首先査找快表，若命中，则无须访问主存中的页表。</p>
</blockquote>
<p><strong>段式虚拟存储器</strong></p>
<p>段式虚拟存储器中的段是按程序的逻辑结构划分的，各个段的长度因程序而异。</p>
<p>把虚拟地址分为两部分：段号和段内地址。虚拟地址到实地址之间的变换是由段表来实现的。</p>
<blockquote>
<p>段表</p>
<p>是程序的逻辑段和在主存中存放位置的对照表。段表的每行记录与某个段对应的段号、装入位、段起点和段长等信息。由于段的长度可变，所以段表中要给出各段的起始地址与段的长度。</p>
</blockquote>
<p>段式虚拟存储器的优点是，段的分界与程序的自然分界相对应，因而具有逻辑独立性，使得它易于编译、管理、修改和保护也便于多道程序的共享；</p>
<p>缺点是因为段长度可变，分配空间不便，容易在段间留下碎片，不好利用，造成浪费。</p>
<hr>
<p><strong>段页式虚拟存储器</strong></p>
<p>把程序按逻辑结构分段，每段再划分为固定大小的页，主存空间也划分为大小相等的页，程序对主存的调入、调出仍以页为基本传送单位，这样的虚拟存储器称为段页式虚拟存储器。</p>
<p>在段页式虚拟存储器中，每个程序对应一个段表，每段对应一个页表，段的长度必须是页长的整数倍，段的起点必须是某一页的起点。</p>
<p>虚地址分为段号、段内页号、页内地址三部分。CPU根据虚地址访存时，首先根据段号得到段表地址；然后从段表中取出该段的页表起始地址，与虚地址段内页号合成，得到页表地址；最后从页表中取出实页号，与页内地址拼接形成主存实地址。</p>
<p>段页式虚拟存储器的优点是，兼具页式和段式虚拟存储器的优点，可以按段实现共享和保护抑。缺点是在地址变换过程中需要两次查表，系统开销较大。</p>
<hr>
<p><strong>虚拟存储器 与 Cache 的比较</strong>：</p>
<p>相同处：</p>
<ul>
<li>最终目标都是为了提高系统性能，两者都有容量、速度、价格的梯度。</li>
<li>都把数据划分为小信息块，并作为基本的传递单位，虚存系统的信息块更大</li>
<li>都有地址的映射、替换算法、更新策略等问题。</li>
<li>依据程序的局部性原理应用“快速缓存的思想”，将活跃的数据放在相对高速的部件中</li>
</ul>
<p>不同处：</p>
<ul>
<li><p>Cache主要解决系统速度，而虚拟存储器是为了解决主存容量。</p>
</li>
<li><p>Cache全由硬件实现，是硬件存储器，对所有程序员透明。</p>
<p>而虚拟存储器由OS和硬件共同实现，是逻辑上的存储器，对系统程序员不透明，但对应用程序员透明。</p>
</li>
<li><p>对于不命中性能影响，因为CPU的速度约为 Cache的10倍，主存的速度为硬盘的100倍以上，因此虛拟存储器系统不命中时对系统性能影响更大。</p>
</li>
<li><p>CPU与 Cache和主存都建立了直接访问的通路，而辅存与CPU没有直接通路。也就是说在 Cache不命中时主存能和CPU直接通信，同时将数据调入 Cache；而虚拟存储器系统不命中时，只能先由硬盘调入主存，而不能直接和CPU通信。</p>
</li>
</ul>
<h1 id="四、指令系统"><a href="#四、指令系统" class="headerlink" title="四、指令系统"></a>四、指令系统</h1><h2 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h2><blockquote>
<p>如何用二进制码表示指令</p>
</blockquote>
<p>指令（机器指令）是指示计算机执行某种操作的命令。一条指令就是机器语言的一个语句，是一组有意义的二进制代码。</p>
<p>指令系统：一台计算机的所有指令的集合，也称指令集。指令系统是计算机的主要属性，位于硬件和软件的中间。</p>
<p><strong>格式： 操作码字段 + 地址码字段</strong></p>
<ul>
<li><p>操作码：</p>
<p>指出指令中该指令应该执行什么性质的操作以及具有何种功能。</p>
<p>操作码是识别指令、了解指令功能 以及 区分操作数地址内容的组成和使用方法等的关键信息。例如，指出是算术加运算还是算术减运算，是程序转移还是返回操作。</p>
</li>
<li><p>地址码：</p>
<p>给出被操作的信息（指令或数据）的地址，包括参加运算的一个或多个操作数所在的地址、运算结果的保存地址、程序的转移地址、被调用的子程序的入口地址等。</p>
</li>
</ul>
<p>指令长度：指一条指令中所包含的二进制代码的位数。</p>
<ul>
<li><p>定长操作码指令格式</p>
<p>在指令字的最高位 分配固定的若干位（定长）表示操作码。</p>
<p>定长操作码有利于简化计算机硬件设计，提高指令译码和识别速度。</p>
</li>
<li><p>拓展操作码指令格式</p>
<p>为了在指令字长有限的前提下仍保持比较丰富的指令种类，可采取可变长度操作码，即操作码字段的位数不固定，且分散地放在指令字的不同位置。</p>
<p>最常见的变长操作码方法是 拓展操作码，它使操作码的长度随地址码的减少而增加。</p>
<p>会增加指令译码和分析的难度，使控制器的设计复杂化。</p>
</li>
</ul>
<p>根据指令中的 <strong>地址码的数目不同</strong>，可以将指令分为以下几种格式：</p>
<ul>
<li><p>零地址指令： OP</p>
<p>只给出操作码OP，没有显式地址。这种指令只有两种可能：</p>
<ul>
<li>不需要操作数的指令，如空操作指令、停机指令、关中断指令等。</li>
<li>零地址的运算类指令仅用在堆栈计算机中。通常参与运算的两个操作数隐含地从栈顶和次栈顶弹出，送到运算器进行运算，运算结果再隐含地压入堆栈。</li>
</ul>
</li>
<li><p>一地址指令： OP + A<del>1</del></p>
<ul>
<li><p>只有目的操作数的单操作数指令，按A<del>1</del>地址读取操作数，进行OP操作后，结果存回原地址。</p>
<p>指令含义：OP(A<del>1</del>)→A<del>1</del><br>如操作码含义是加1、减1、求反、求补等。</p>
</li>
<li><p>隐含约定目的地址的双操作数指令，按指令地址A<del>1</del>可读取源操作数，指令可隐含约定另一个操作数由ACC（累加器）提供，运算结果也将存放在AC中。<br>指令含义：(ACC)OP(A<del>1</del>)→ACC</p>
</li>
</ul>
<blockquote>
<p>若指令字长为32位，操作码占8位，1个地址码字段占24位，则指令操作数的直接寻址范围为2^24^&#x3D;16M。</p>
</blockquote>
</li>
<li><p>二地址指令： OP + A<del>1</del> + A<del>2</del></p>
<p>指令含义：(A<del>1</del>)OP(A<del>2</del>)→A<del>1</del></p>
<p>对于常用的算术和逻辑运算指令，往往要求使用两个操作数，需分别给出目的操作数和源操作数的地址，其中目的操作数地址还用于保存本次的运算结果。</p>
<blockquote>
<p>若指令字长为32位，操作码占8位，两个地址码字段各占12位，则指令操作数的直接寻址范围为2^12^&#x3D;4K</p>
</blockquote>
</li>
<li><p>三地址指令： OP + A<del>1</del> + A<del>2</del> + A<del>3</del>(结果) </p>
<p>指令含义：(A<del>1</del>)OP(A<del>2</del>)→A<del>3</del></p>
<blockquote>
<p>若指令字长为32位，操作码占8位，3个地址码字段各占8位，则指令操作数的直接寻址范围为28&#x3D;256。</p>
<p>若地址字段均为主存地址，则完成一条三地址需要4次访问存储器（取指令1次，取两个操作数2次，存放结果1次)</p>
</blockquote>
</li>
<li><p>四地址指令： OP + A<del>1</del> + A<del>2</del> + A<del>3</del>(结果) + A<del>4</del>(下址)</p>
<p>指令含义：(A<del>1</del>)OP(A<del>2</del>)→A<del>3</del>，A<del>4</del>&#x3D;下一条将要执行指令的地址。</p>
<blockquote>
<p>若指令字长为32位，操作码占8位，4个地址码字段各占6位，则指令操作数的直接寻址<br>范围为2^6^&#x3D;64</p>
</blockquote>
</li>
</ul>
<hr>
<p><strong>指令的功能分类：</strong></p>
<ul>
<li><p><strong>数据传送</strong></p>
<p>传送指令通常有 寄存器之间的传送(MOV)、从内存单元读取数据到CPU寄存器(LOAD)、从CPU寄存器写数据到内存单元 (STORE)等。</p>
</li>
<li><p><strong>算术和逻辑运算</strong></p>
<p>这类指令主要有加(ADD)、减(SUB)、比较(CMP)、乘(MUL)、除(DIV)、加1 (INC)、减1(DEC)、与(AND)、或(OR)、取反(NOT)、异或(XOR)等。</p>
</li>
<li><p><strong>移位操作</strong></p>
<p>移位指令主要有算法移位、逻辑移位、循环移位等。</p>
</li>
<li><p><strong>转移操作</strong></p>
<p>转移指令主要有无条件转移(JMP)、条件转移(BRANCH)、调用(CALL)、返回(RET)、陷阱(TRAP)等。无条件转移指令在任何情况下都执行转移操作，而条件转移指令仅在特定条件满足时才执行转移操作，转移条件一般是某个标志位的值，或两个或两个以上的标志位组合。</p>
<p>调用指令和转移指令的区别：执行调用指令时必须保存下一条指令的地址（返回地址），当子程序执行结束时，根据返回地址返回到主程序继续执行；而转移指令则不返回执行。</p>
</li>
<li><p><strong>输入输出操作</strong></p>
<p>这类指令用于完成CPU与外部设备交换数据或传送控制命令及状态信息。</p>
</li>
</ul>
<h2 id="指令寻址方式"><a href="#指令寻址方式" class="headerlink" title="指令寻址方式"></a>指令寻址方式</h2><blockquote>
<p>给出下一条指令的地址，给出要操作的对象的地址</p>
</blockquote>
<p>寻址方式就是寻找 指令或操作数 有效地址的方式，寻址方式分为 指令寻址 和 数据寻址 两大类。</p>
<blockquote>
<p>指令中的地址码字段并不代表操作数的真实地址，这种地址称为形式地址(A)。形式地址结合寻址方式，可以计算出操作数在存储器中的真实地址，也叫有效地址(EA)。</p>
</blockquote>
<ul>
<li><p><strong>指令寻址</strong></p>
<ul>
<li><p>顺序寻址：</p>
<p>通过程序计数器(PC) 加1（1个指令字长），自动形成下一条指令的地址。</p>
</li>
<li><p>跳跃寻址：</p>
<p>通过转移指令实现。跳跃是指下一条指令的地址码不是由程序计数器给出，而是由本指令给出下一条指令地址的计算方式。</p>
</li>
</ul>
</li>
<li><p><strong>数据寻址</strong></p>
<p>在指令中表示 一个操作数的地址。由于数据寻址的方式较多，为加以区分，通常在指令字中设一个字段，用来表示属于哪种寻址方式，则指令格式变为：操作码 + 寻址特征 + 形式地址；</p>
</li>
</ul>
<hr>
<p><strong>常见的数据寻址方式：</strong></p>
<ul>
<li><p><strong>隐含</strong>寻址</p>
<p>不明显给出操作数的地址。如：单地址指令就 不指出第二操作数的地址，而规定累加器(ACC)作为第二操作数地址。</p>
<p>优点：利于缩短指令字长；缺点：需增加存储操作数或隐含地址的硬件。</p>
</li>
<li><p><strong>立即数</strong>寻址</p>
<p>地址字段 指出的不是操作数的地址，而是操作数本身，又称立即数。</p>
<p>优点：指令在执行阶段不访问主存，指令执行时间最短；缺点：地址字段的位数限制了立即数的范围。</p>
</li>
<li><p><strong>直接</strong>寻址</p>
<p>地址字段 就是操作数的真实地址。</p>
<p>优点：简单，只访问依次主存；缺点：地址字段限制了寻址范围，且操作数的地址不易修改。</p>
</li>
<li><p><strong>间接</strong>寻址</p>
<p>相对直接寻址，指令的地址字段 给出的形式地址是操作数的有效地址所在的存储单元的地址，即 操作数地址的地址。</p>
<p>优点：扩大了寻址范围，便于编制程序（方便子程序返回）；缺点：指令在执行阶段要多次访存。——由于访问速度过慢，所以问到扩大寻址范围时，通常指的是 寄存器间接寻址。</p>
</li>
<li><p><strong>寄存器</strong>寻址</p>
<p>在指令中直接给出操作数所在的寄存器编号。即EA&#x3D;R<del>i</del>，操作数存放在R<del>i</del>所指的寄存器中。</p>
<p>优点：不用访存，执行速度快；缺点：寄存器数量少，数量有限。</p>
</li>
<li><p><strong>寄存器间接</strong>寻址</p>
<p>寄存器间接寻址是指在寄存器 R<del>i</del> 中给出的不是一个操作数，而是操作数所在主存单元的地址，即EA&#x3D;(R<del>i</del>)。</p>
<p>比一般间接寻址快，但因为操作数在主存中，仍需访问一次主存。</p>
</li>
<li><p><strong>相对</strong>寻址</p>
<p>把程序计数器(PC)的内容加上指令中的形式地址A而形成的操作数的有效地址，即EA &#x3D; (PA) + A，其中A是相对与当前指令的位移量。</p>
<p>优点：操作数的地址不是固定的，而是随PC值的变化而变化，且与指令地址总是相差一个固定值，便于程序浮动。</p>
</li>
<li><p><strong>基址</strong>寻址</p>
<p>基址寻址是指将CPU中基址寄存器(BR) 的内容加上指令格式中的形式地址A而形成操作数的有效地址，即EA&#x3D;(BR)+A。其中基址寄存器既可采用专用寄存器，又可采用通用寄存器。</p>
<blockquote>
<p>基址寄存器是面向操作系统的，其内容由操作系统或管理程序确定，主要解决程序逻辑空间 与 物理空间的无关性。</p>
</blockquote>
<p>优点：可扩大寻址范围（基址寄存器的位数大于形式地址A的位数），用户不必考虑自己的程序存于主存的哪个空间区域，所以也有利于多道程序设计，并可用于编制浮动程序，但偏移量（A）的位数较短。</p>
</li>
<li><p><strong>变址</strong>寻址</p>
<p>变址寻址是指有效地址EA 等于指令字中的形式地址A与变址寄存器IX的内容之和，即 EA&#x3D;(IX)+A，其中 IX为变址寄存器（专用），也可用通用寄存器作为变址寄存器。</p>
<blockquote>
<p>变址寄存器是面向用户的，在程序执行过程中，变址寄存器的内容可由用户改变（作为偏移量），形式地址A不变（作为基地址）。</p>
</blockquote>
<p>优点：可扩大寻址范围（变址寄存器的位数大于形式地址A的位数）；在数组处理过程中，可设定A为数组的首地址，不断改变变址寄存器IX的内容，便可很容易形成数组中任一数据的地址，特别适合编制循环程序。偏移量(变址寄存器IX) 的位数足以表示整个存储空间。</p>
</li>
<li><p><strong>堆栈</strong>寻址</p>
<p>堆栈是存储器（或专用寄存器组）中一块特定的、按后进先出(LIFO)原则管理的存储区，该存储区中读&#x2F;写单元的地址是用一个特定的寄存器给出的，该寄存器称为堆機指针(SP)。</p>
<p>堆栈可分为硬堆栈与软堆栈两种。</p>
<p>硬堆栈：指寄存器堆栈，成本高，不适合做大容量的堆栈；</p>
<p>软堆栈：从主存中划出一段区域 用来做堆栈，合算，也是最常用的。</p>
</li>
</ul>
<h2 id="CISC和RISC"><a href="#CISC和RISC" class="headerlink" title="CISC和RISC"></a>CISC和RISC</h2><blockquote>
<p>两种设计方向</p>
</blockquote>
<p><strong>CISC——复杂指令系统计算机</strong>——增强原有指令的功能，设置更为复杂的新指令实现软件功能的硬化；如采用X86架构的计算机。</p>
<p><strong>RISC——精简指令系统计算机</strong>——减少指令种类和简化指令功能，提供指令的指令速度；如ARM，MIPS架构的计算机。</p>
<hr>
<p>CISC的主要特点如下：</p>
<ol>
<li>指令系统复杂庞大，指令数目一般为200条以上。</li>
<li>指令的长度不固定，指令格式多，寻址方式多。</li>
<li>可以访存的指令不受限制。</li>
<li>各种指令使用频度相差很大。</li>
<li>各种指令执行时间相差很大，大多数指令需多个时钟周期才能完成。</li>
<li>控制器大多数采用微程序控制。有些指令非常复杂，以至于无法采用硬连线控制。</li>
<li>难以用优化编译生成高效的目标代码程序。</li>
</ol>
<p>RISC的中心思想是要求指令系统简化，尽量使用寄存器-寄存器操作指令，指令格式力求一致。RISC的主要特点如下：</p>
<ol>
<li>选取使用频率最高的一些简单指令，复杂指令的功能由简单指令的组合来实现。</li>
<li>指令长度固定，指令格式种类少，寻址方式种类少。</li>
<li>只有 Load&#x2F;Store（取数存数）指令访存，其余指令的操作都在寄存器之间进行。</li>
<li>CPU中通用寄存器的数量相当多。</li>
<li>RISC一定采用指令流水线技术，大部分指令在一个时钟周期内完成。</li>
<li>以硬布线控制为主，不用或少用微程序控制</li>
<li>特别重视编译优化工作，以减少程序执行时间</li>
</ol>
<blockquote>
<p>值得注意的是，从指令系统兼容性看，CISC大多能实现软件兼容，即高档机包含了低档机的全部指令，并可加以扩充。但RISC简化了指令系统，指令条数少，格式也不同于老机器，因此大多数RISC机不能与老机器兼容。</p>
<p>虽然RISC具有更强的实用性，看起来应该是未来处理器的发展方向。但事实上，早期很多软件都是根据CISC设计的，单纯的RISC将无法兼容。此外，现代CISC结构的CPU已经融合了很多RISC的成分，其性能差距已经越来越小。CISC可以提供更多的功能，这是程序设计所需要的。</p>
</blockquote>
<h1 id="五、中央处理器"><a href="#五、中央处理器" class="headerlink" title="五、中央处理器"></a>五、中央处理器</h1><h2 id="CPU的功能和结构"><a href="#CPU的功能和结构" class="headerlink" title="CPU的功能和结构"></a>CPU的功能和结构</h2><p>中央处理器(CPU)由运算器和控制器组成。</p>
<ul>
<li>控制器：负责协调并控制计算机各部件执行程序的指令序列，包括取指令、分析指令和执行指令；</li>
<li>运算器：对数据进行加工。</li>
</ul>
<p><strong>CPU功能：</strong></p>
<ul>
<li>指令控制。完成取指令、分析指令和执行指令的操作，即程序的顺序控制</li>
<li>操作控制。一条指令的功能往往由若干操作信号的组合来实现。CPU管理并产生由内存取出的每条指令的操作信号，把各种操作信号送往相应的部件，从而控制这些部件按指令的要求进行动作。</li>
<li>时间控制。对各种操作加以时间上的控制。时间控制要为每条指令按时间顺序提供应有的控制信号。</li>
<li>数据加工。对数据进行算术和逻辑运算。</li>
<li>中断处理。对计算机运行过程中出现的异常情况和特殊请求进行处理。</li>
</ul>
<hr>
<p><strong>运算器组成：</strong></p>
<ol>
<li><p>**算术逻辑单元(ALU)**。主要功能是进行算术&#x2F;逻辑运算；</p>
</li>
<li><p><strong>暂存寄存器</strong>。用于暂存从主存读来的数据，该数据不能存放在通用寄存器中，否则会破坏其原有内容。暂存寄存器对应用程序员是透明的。</p>
</li>
<li><p>**累加寄存器(ACC)**。它是一个通用寄存器，用于暂时存放ALU运算的结果信息，可以作为加法运算的一个输入端。</p>
</li>
<li><p><strong>通用寄存器组</strong>。如AX、BX、CX、DX、SP等，用于存放操作数（包括源操作数、目的操作数及中间结果）和各种地址信息等。SP是堆栈指针，用于指示栈顶的地址。</p>
</li>
<li><p>**程序状态字寄存器(PAW)**。保留由算术逻辑运算指令或测试指令的结果而建立的各种状态信息，如溢出标志(OF)、符号标志(SF)、零标志(ZF)、进位标志(CF)等。PSW中的这些位参与并决定微操作的形成。</p>
</li>
<li><p><strong>移位器</strong>。对操作数或运算结果进行移位运算。</p>
</li>
<li><p>**计数器(CT)**。控制乘除运算的操作步数。</p>
</li>
</ol>
<p><strong>控制器组成：</strong></p>
<ol>
<li>**程序计数器(PC)**。用于指出下一条指令在主存中的存放地址。CPU根据PC的内容去主存中取指令。因程序中指令通常是顺序执行的，所以PC有自增功能。</li>
<li>**指令寄存器(IR)**。用于保存当前正在执行的那条指令。</li>
<li><strong>指令译码器</strong>。仅对操作码字段进行译码，向控制器提供特定的操作信号。</li>
<li>**存储器地址寄存器(MAR)**。用于存放要访问的主存单元的地址。</li>
<li>**存储器数据寄存器(MDR)**。用于存放向主存写入的信息或从主存读出的信息。</li>
<li><strong>时序系统</strong>。用于产生各种时序信号，它们都由统一时钟 ( CLOCK ) 分频得到。</li>
<li><strong>微操作信号发生器</strong>。根据R的内容（指令）、PSW的内容（状态信息）及时序信号，产生控制整个计算机系统所需的各种控制信号，其结构有组合逻辑型和存储逻辑型两种。</li>
</ol>
<p><img src="D:/Note/Typora_picture/image-20220125162850050.png" alt="image-20220125162850050"></p>
<h2 id="指令执行过程"><a href="#指令执行过程" class="headerlink" title="指令执行过程"></a>指令执行过程</h2><blockquote>
<p>指令周期、数据流、指令执行方案</p>
</blockquote>
<p><strong>指令周期：</strong>CPU从主存中取出并执行一条指令的时间。（不同指令的指令周期可能不同）</p>
<p>指令周期 常用若干机器周期来表示，一个机器周期又包含若干时钟周期。</p>
<p>完整的指令周期组成：取指周期 + 间址周期 + 执行周期 + 中断周期</p>
<blockquote>
<p>这4个工作周期都有CPU访存操作，只是访存的目的不同。</p>
<p>取指周期是为了取指令，间址周期是为了取有效地址，执行周期是为了取操作数，中断周期是为了保存程序断点。</p>
</blockquote>
<p>为了区别不同的工作周期，在CPU内设置了4个标志触发器：FE， IND， EX， INT，分别对应取指，间址，执行，中断周期，并以“1”状态表示有效。</p>
<hr>
<p><strong>数据流</strong></p>
<p>数据流是根据指令要求依次访问的数据序列。</p>
<p>取指周期的数据流：</p>
<p><img src="D:/Note/Typora_picture/image-20220111202414358.png" alt="image-20220111202414358"></p>
<p>间址周期的数据流：</p>
<p><img src="D:/Note/Typora_picture/image-20220111202549519.png" alt="image-20220111202549519"></p>
<p>执行周期的任务是具体的，没有统一的数据流向。</p>
<p>中断周期的数据流：</p>
<p><img src="D:/Note/Typora_picture/image-20220111202701385.png" alt="image-20220111202701385"></p>
<hr>
<p><strong>指令执行方案</strong></p>
<p>一个指令周期通常要包括几个时间段（执行步骤），每个步骤完成指令的一部分功能，几个依次执行的步骤完成这条指令的全部功能。</p>
<p>出于性能和硬件成本等考虑，可以选用3种不同的方案来安排指令的执行步骤。</p>
<ul>
<li><p><strong>单指令周期</strong><br>对所有指令都选用相同的执行时间来完成，称为单指令周期方案。</p>
<p>此时每条指令都在固定的时钟周期内完成，指令之间串行执行，即下一条指令只能在前一条指令执行结束后才能启动。因此，指令周期取决于执行时间最长的指令的执行时间。对于那些本来可以在更短时间内<br>完成的指令，要使用这个较长的周期来完成，会降低整个系统的运行速度。</p>
</li>
<li><p><strong>多指令周期</strong><br>对不同类型的指令选用不同的执行步骤来完成，称为多指令周期方案。</p>
<p>指令之间串行执行，即下一条指令只能在前一条指令执行结束后才能启动。但可选用不同个数的时钟周期来L完成不同指令的执行过程，指令需要几个周期就为其分配几个周期，而不再要求所有指令占用相同的执行时间。</p>
</li>
<li><p><strong>流水线方案</strong><br>指令之间可以并行执行的方案，称为流水线方案，其追求的目标是力争在每个时钟脉冲周期完成一条指令的执行过程（只在理想情况下才能达到该效果）。</p>
<p>这种方案通过在每个时钟周期启动一条指令，尽量让多条指令同时运行，但各自处在不同的执行步骤中。</p>
</li>
</ul>
<h2 id="数据通路"><a href="#数据通路" class="headerlink" title="数据通路"></a>数据通路</h2><blockquote>
<p>设置部件间的连接路径，描述指令执行过程中信号和数据在这些路径上的传输</p>
</blockquote>
<p><strong>数据通路：指在功能部件之间传送的路径。</strong>这些部件称为<strong>数据通路部件</strong>，如ALU，通用寄存器，状态寄存器，异常和中断处理逻辑等。其中专门进行数据运算的部件称为 <strong>执行部件&#x2F; 功能部件</strong>。</p>
<p>数据通路描述了信息从什么地方开始，中间经过哪个寄存器或多路开关，最后传送到哪个寄存器，这些都需要加以控制。</p>
<p><strong>数据通路的基本结构：</strong></p>
<ul>
<li><p>CPU内部单总线方式</p>
</li>
<li><p>CPU内部多总线方式</p>
<p>将所有寄存器的输入端和输出端都连接到多条公共通路上。相比之下，单总线中一个时钟内只允许传一个数据，指令执行效率很低，因此采用多总线方式，同时在多个总线上传送不同的数据，提高效率。</p>
</li>
<li><p>专用数据通路方式</p>
<p>根据指令执行过程中的数据和地址的流动方向安排连接线路，避免使用共享的总线，性能较高，但硬件量大。</p>
</li>
</ul>
<blockquote>
<p>注意：</p>
<p>内部总线是指同一部件之间的总线，如CPU内部连接各寄存器及运算部件之间的总线；</p>
<p>系统总线是指同一台计算机系统的各部件之间互相连接的总线，如CPU、内存、通道和各类IO接口之间相互连接的总线。</p>
</blockquote>
<h2 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h2><blockquote>
<p>控制器怎么指挥整个系统的工作？</p>
</blockquote>
<p>控制器是计算机系统的指挥中心，主要功能有：</p>
<ol>
<li>从主存中取出一条指令，并指出下一条指令在主存中的位置。</li>
<li>对指令进行译码或测试，产生相应的操作控制信号，以便启动规定的动作。</li>
<li>指挥并控制CPU、主存、输入和输出设备之间的数据流动方向。</li>
</ol>
<p>根据控制器产生微操作控制信号的方式的不同，控制器可分为<u>硬布线控制器</u>和<u>微程序控制器</u>，两类控制器中的PC和IR是相同的，但确定和表示指令执行步骤的办法以及给出控制各部件运行所需要的控制信号的方案是不同的。</p>
<hr>
<p><strong>硬布线控制器</strong></p>
<p>硬布线控制器的基本原理是根据指令的要求、当前的时序及外部和内部的状态，按时间的顺序发送一系列微操作控制信号。</p>
<p>它由复杂的组合逻辑门电路和一些触发器构成，因此又称组合逻辑控制器。(主要涉及电路设计)</p>
<hr>
<p><strong>微程序控制器</strong></p>
<p>将每条机器指令编写成一个微程序，这些微程序存到一个控制存储器中，可以通过寻址找到每个微程序中的微指令。目前，大多数计算机都采用微程序设计技术。</p>
<blockquote>
<p>每个微程序包含若干微指令，每条微指令对应一个或几个微操作命令。</p>
</blockquote>
<p>基本术语：</p>
<ul>
<li><p><strong>微命令、微操作：</strong></p>
<p>一条机器指令可以分解成一个微操作序列；微操作是计算机最基本的、不可再分的操作。</p>
<p>将控制部件向执行部件发出的各种控制命令称为微命令，它是构成控制序列的最小单位。例如：打开或关闭某个控制门的电位信号。</p>
<p><strong>微命令和微操作是一一对应的</strong>。微命令是微操作的控制信号，微操作是微命令的执行过程。</p>
</li>
<li><p><strong>微指令、微周期：</strong></p>
<p>微指令是若干微命令的集合。存放微指令的控制存储器的单元地址称为微地址。</p>
<p>一条微指令至少包含两部分：</p>
<ul>
<li>操作控制字段（微操作码字段），用于生产某一步操作所需的各种操作控制信号。</li>
<li>顺序控制字段（微地址码字段），用于控制产生下一条要执行的微指令地址。</li>
</ul>
<p>微周期是指 从控制存储器中读取一条微指令并执行相应的微操作所需的时间。</p>
</li>
<li><p><strong>主存储器、控制存储器：</strong></p>
<p>主存储器用于存放程序和数据，在CPU外部，用RAM实现；</p>
<p>控制存储器(CM)用于存放微程序，在CPU内部，用 只读存储器ROM 实现。</p>
</li>
<li><p><strong>程序与微程序：</strong></p>
<p>程序是指令的有序集合，用于完成特定的功能；</p>
<p>微程序是微指令的有序集合，用于描述机器指令，一条指令的功能由一段微程序来思想。</p>
<blockquote>
<p>微程序实际上是机器指令的实时解释器，一般是事先编制好并存放在控制存储器中，对外一般透明</p>
</blockquote>
</li>
</ul>
<p><strong>组成：</strong></p>
<ul>
<li>**控制存储器(CM)**：核心部件，用于存放各指令对应的微程序；</li>
<li><strong>微指令寄存器</strong>：存放从CM中取出的微指令，它的位数同微指令字长相等。</li>
<li><strong>微地址形成部件</strong>：用于产生初始微地址和后继微地址，保证微指令的连续执行；</li>
<li><strong>微地址寄存器</strong>：接收微地址形成部件送来的微地址</li>
</ul>
<p><img src="D:/Note/Typora_picture/image-20220220104112886.png" alt="image-20220220104112886"></p>
<p><strong>工作过程：</strong></p>
<p>实际上就是在微程序控制器的控制下计算机执行机器指令的过程，这个过程可以描述如下：</p>
<p>① 执行取微指令公共操作。具体的执行是：在机器开始运行时，自动将取指微程序的入口地址送入CMAR,并从CM中读出相应的微指令送入CMDR。取指微程序的入口地址般为CM的0号单元，当取指微程序执行完后，从主存中取出的机器指令就已存入指令寄存器中。</p>
<p>② 由机器指令的操作码字段通过微地址形成部件产生该机器指令所对应的微程序的入口地址，并送入CMAR.</p>
<p>③ 从CM中逐条取出对应的微指令并执行。</p>
<p>④ 执行完对应于一条机器指令的一个微程序后，又回到取指微程序的入口地址，继续第①步，以完成取下一条机器指令的公共操作</p>
<hr>
<p>注意区分一些寄存器的不同：</p>
<ul>
<li>地址寄存器(MAR)：用于存放主存的读&#x2F;写地址；</li>
<li>微地址寄存器(CMAR)：用于存放控制存储器的读&#x2F;写微指令的地址；</li>
<li>指令寄存器(IR)：用于存放从主存中读出的指令；</li>
<li>微指令寄存器(CMDR)：用于存放从控制存储器中读出的微指令。</li>
</ul>
<hr>
<p><strong>微指令的格式</strong></p>
<p>水平型微指令：一次能定义并执行多个并行操作</p>
<p><img src="D:/Note/Typora_picture/image-20220220104430559.png" alt="image-20220220104430559"></p>
<p>垂直型微指令：类似机器指令操作码的方式，由微操作码字段规定微指令的功能。</p>
<p><img src="D:/Note/Typora_picture/image-20220220104442016.png" alt="image-20220220104442016"></p>
<hr>
<p><strong>微指令的编码方式</strong></p>
<ul>
<li><p>直接编码方式</p>
<p>n个微命令需要微指令的操作字段有n位，虽然简单，速度快，但对控制存储器容量要求极大。</p>
</li>
<li><p>字段直接编码方式</p>
<p>将微指令的微命令字段分成若干字段；  把互斥性微命令组合在同一字段中，把相容性微命令组合在不同字段中；  每个字段独立编码，每种编码代表一个微命令且各字段编码含义单独定义，与其他字段无关，这就是字段直接编码方式。</p>
<p>优点：可以缩短微指令字长。</p>
<p>缺点：需经过译码再发出微命令，因此比直接编码方式慢。</p>
</li>
</ul>
<hr>
<p><strong>微指令的地址形成方式</strong></p>
<ol>
<li>由微指令的 <strong>下地址字段</strong> 指出（称为断定方式）；</li>
<li>根据机器指令的 <strong>操作码</strong> 形成：当机器指令取至指令寄存器后，微指令的地址由操作码经微地址形成部件形成。</li>
</ol>
<hr>
<p><img src="D:/Note/Typora_picture/image-20220220105619061.png" alt="image-20220220105619061"></p>
<h2 id="指令流水线"><a href="#指令流水线" class="headerlink" title="指令流水线"></a>指令流水线</h2><p>一条指令的执行过程：<strong>取指，分析，执行</strong></p>
<p><strong>取指</strong>：根据 PC内容访问主存储器，取出一条指令送到 IR 中。<br><strong>分析</strong>：对指令操作码进行译码，按照给定的寻址方式和地址字段中的内容形成操作数的有效地址EA,并从有效地址EA中取出操作数。<br><strong>执行</strong>：根据操作码字段，完成指令规定的功能，即把运算结果写到通用寄存器或主存中</p>
<p><strong>指令流水线</strong>：充分利用各功能部件。</p>
<p><img src="D:/Note/Typora_picture/image-20220220113352077.png" alt="image-20220220113352077"></p>
<p><img src="D:/Note/Typora_picture/image-20220220113548916.png" alt="image-20220220113548916"></p>
<hr>
<p>性能指标：吞吐率TP，加速比S，效率E</p>
<p>影响因素：结构相关（资源冲突），数据相关（数据冲突），控制相关（控制冲突）</p>
<p>分类：</p>
<p>多发技术：</p>
<h1 id="六、总线"><a href="#六、总线" class="headerlink" title="六、总线"></a>六、总线</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><u>总线是一组能为多个部件<strong>分时共享</strong>的<strong>公共</strong>信息传送线路。</u></p>
<p>共享：是指总线上可以挂接多个部件，各个部件之间互相交换的信息都可以通过这组线路共享。<br>分时：是指同一时刻只允许有一个部件向总线发送信息，如果系统中有多个部件，则它们只能分时地向总线发送信息。</p>
<blockquote>
<p>为什么使用总线？</p>
<p>早期计算机外部设备少时大多采用分散连接方式，不易实现随时增减外部设备。<br>为了更好地解决&#x2F;Oo设备和主机之间连接的灵活性问题，计算机的结构从分散连接发展为总线连接。</p>
</blockquote>
<p><strong>总线的特性：</strong></p>
<p>机械特性：尺寸、形状、管脚数、排列顺序；<br>电气特性：传输方向和有效的电平范围；<br>功能特性：每根传输线的功能(地址、数据、控制)；<br>时间特性：信号的时序关系；</p>
<p><strong>总线的分类：</strong></p>
<p>按数据传输格式：串行总线，并行总线；</p>
<p><img src="D:/Note/Typora_picture/image-20220220155959250.png" alt="image-20220220155959250"></p>
<p>按总线功能（连接的部件）：</p>
<ul>
<li><p><strong>片内总线</strong>：是芯片内部的总线。它是CPU芯片内部寄存器与寄存器之间、寄存器与AU之间的公共连接线。</p>
</li>
<li><p><strong>系统总线</strong>：是各功能部件（CPU，主存，I&#x2F;O接口）之间 相互连接的总线。可分为3类：数据总线，地址总线，控制总线；</p>
<p><img src="D:/Note/Typora_picture/image-20220220152454394.png" alt="image-20220220152454394"></p>
</li>
<li><p>通信总线：是计算机系统之间 或 计算机与其他系统之间信息传送的总线。也称外部总线。</p>
</li>
</ul>
<p>按时序控制方式：同步总线，异步总线；</p>
<hr>
<p>总线的结构：</p>
<ul>
<li><p>单总线结构： </p>
<p>CPU、主存、IO设备(通过IO接口) 都连接在一组总线上，允许IO设备之间、I&#x2F;O设备和CPU之间或IO设备与主存之间直接交换信。<br>优点：结构简单，成本低，易于接入新的设备。<br>缺点：带宽低、负载重，多个部件只能争用唯一的总线，且不支持并发传送操作</p>
<p><img src="D:/Note/Typora_picture/image-20220220152807606.png" alt="image-20220220152807606"></p>
</li>
<li><p>双总线结构：</p>
<p>有两条总线，一条是主存总线，用于CPU、主存和通道之间进行数据传送；另一条是 I&#x2F;O总线，用于多个外部设备与通道之间进行数据传送。<br>优点：将较低速的 I&#x2F;O设备从单总线上分离出来，实现存储器总线和 I&#x2F;O总线分离。<br>缺点：需要增加通道等硬件设备。</p>
<p><img src="D:/Note/Typora_picture/image-20220220153153326.png" alt="image-20220220153153326"></p>
</li>
<li><p>三总线结构：</p>
<p>在计算机系统各部件之间采用3条各自独立的总线来构成信息通路，这3条总线分别为<strong>主存总线</strong>、<strong>I&#x2F;O总线</strong>和直接内存访问<strong>DMA总线</strong>。<br>优点：提高了 I&#x2F;O设备的性能，使其更快地响应命令，提高系统吞吐量。<br>缺点：系统工作效率较低。</p>
<p> <img src="D:/Note/Typora_picture/image-20220220153412326.png" alt="image-20220220153412326"></p>
</li>
</ul>
<hr>
<p><strong>总线的性能指标：</strong></p>
<ul>
<li><p>总线的 传输周期（总线周期）：一次总线操作所需的时间（包括 申请，寻址，传输，结束），通常由若干个总线时钟周期构成。</p>
<p><img src="D:/Note/Typora_picture/image-20220220154622584.png" alt="image-20220220154622584"></p>
</li>
<li><p>总线的 时钟周期：即机器的时钟周期；</p>
</li>
<li><p>总线的 工作频率：为总线周期的倒数；</p>
</li>
<li><p>总线的 时钟频率：为时钟周期的倒数；</p>
</li>
<li><p>总线宽度：</p>
<p>又称为总线位宽，它是总线上同时能够传输的数据位数，通常是指数据总线的根数，如32根称为32位(bit)总线。</p>
</li>
<li><p>总线带宽：</p>
<p>可理解为总线的数据传输率，即单位时间内总线上可传输数据的位数，通常用每秒钟传送信息的字节数来衡量，单位可用字节&#x2F;秒(B&#x2F;s)表示。</p>
<p><img src="D:/Note/Typora_picture/image-20220220155133573.png" alt="image-20220220155133573"></p>
<blockquote>
<p>例题：</p>
<p><img src="D:/Note/Typora_picture/image-20220220155730564.png" alt="image-20220220155730564"></p>
</blockquote>
</li>
<li><p>总线复用：一种信号线在不同时间 可以传输不同的信息。</p>
</li>
<li><p>信号线数：地址总线，数据总线，控制总线这3种总线数的总和称为信号线数。</p>
</li>
</ul>
<h2 id="仲裁"><a href="#仲裁" class="headerlink" title="仲裁"></a>仲裁</h2><blockquote>
<p>解决多个设备争用总线的问题</p>
</blockquote>
<p>同一时刻<strong>只能有一个</strong>设备<strong>控制</strong>总线传输操作，另外可以<strong>有一个或多个</strong>设备从总线<strong>接收</strong>数据。</p>
<p>将总线上所连接的各类设备按其对总线有无控制功能分为：<br><strong>主设备</strong>：获得总线控制权的设备。<br><strong>从设备</strong>：被主设备访问的设备，只能响应从主设备发来的各种总线命令。</p>
<ul>
<li><p>为什么要仲裁？</p>
<p>总线作为一种共享设备，不可避免地会出现同一时刻有多个主设备竞争总线控制权的问题。</p>
</li>
<li><p>总线仲裁的定义：</p>
<p>多个主设备同时竞争主线控制权时，以某种方式选择一个主设各优先获得总线控制权称为总线仲裁。</p>
</li>
<li><p>总线仲裁分类</p>
<ul>
<li><p>集中仲裁方式：</p>
<p>链式査询方式、计数器定时查询方式、独立请求方式</p>
</li>
<li><p>分布仲裁方式：</p>
</li>
</ul>
</li>
</ul>
<p>请求总线的<strong>工作流程</strong>：</p>
<ol>
<li>主设备发出请求信号；</li>
<li>若多个主设备同时要使用总线，则由总线控制器的判优、仲裁逻辑按一定的优先等级顺序确定哪主设各能使用总线；</li>
<li>获得总线使用权的主设备开始传送数据。</li>
</ol>
<p><img src="D:/Note/Typora_picture/image-20220220161957124.png" alt="image-20220220161957124"></p>
<p>链式查询：<img src="D:/Note/Typora_picture/image-20220220162329585.png" alt="image-20220220162329585"></p>
<p>计数器定时查询：<img src="D:/Note/Typora_picture/image-20220220162516927.png" alt="image-20220220162516927"></p>
<p>独立请求：<img src="D:/Note/Typora_picture/image-20220220162603652.png" alt="image-20220220162603652"></p>
<h2 id="操作和定时"><a href="#操作和定时" class="headerlink" title="操作和定时"></a>操作和定时</h2><blockquote>
<p>占用总线的一对设备如何进行数据传输</p>
</blockquote>
<p><strong>总线传输的四个阶段</strong>：</p>
<ol>
<li><p><strong>申请分配</strong>：</p>
<p>由需要使用总线的主模块（或主设备）提出申请，经总线仲裁机构決定将下一传输周期的总线使用权授予某一申请者。也可将此阶段细分为 传输请求 和 总线仲裁 两个阶段。</p>
</li>
<li><p><strong>寻址</strong>：获得使用权的主模块通过总线发出本次要访问的从模块的地址及有关命令，启动参与本次传输的从模块。</p>
</li>
<li><p><strong>传输</strong>：主模块和从模块进行数据交换，可单向或双向进行数据传送。</p>
</li>
<li><p><strong>结束阶段</strong>：主模块的有关信息均从系统总线上撤除，让出总线使用权。</p>
</li>
</ol>
<p><strong>总线定时</strong>：实质是一种协议或规则，用于在总线上 交换数据的双方 在时间上的配合。</p>
<ul>
<li><p><strong>同步通信（同步定时方式）</strong>：由 统一时钟 控制数据传送；</p>
<blockquote>
<p>优点：传送速度快，具有较高的传输速率；总线控制逻辑简单。<br>缺点：主从设备属于强制性同步；不能及时进行数据通信的有效性检验，可靠性较差。</p>
<p>同步通信适用于总线长度较短及总线所接部件的存取时间比较接近的系统。</p>
</blockquote>
</li>
<li><p><strong>异通信（异步定时方式）</strong>：采用应答方式，没有公共时钟标准；</p>
<blockquote>
<p>优点：总线周期长度可变，能保证两个工作速度相差很大的部件或设备之间可靠地进行信息交换，自动适应时间的配合。</p>
<p>缺点：比同步控制方式稍复杂一些，速度比同步定时方式慢。</p>
<p><img src="D:/Note/Typora_picture/image-20220220164600629.png" alt="image-20220220164600629"></p>
</blockquote>
</li>
<li><p><strong>半同步通信</strong>：同步、异步结合；</p>
<blockquote>
<p>在统一时钟的基础上，增加一个“等待”响应信号。</p>
</blockquote>
</li>
<li><p><strong>分离式通信</strong>：充分利用总线的空闲阶段。</p>
<blockquote>
<p>上述三种通信，在主模块发地址、命令，从模块发数据时会使用总线，当在从模块准备数据时，没有使用总线，但主模块仍会占用总线。</p>
<p>所以分离式通信 将总线传输周期分为两个子周期：</p>
<ul>
<li>子周期1：主模块申请占用总线，使用完后放弃总线的使用权。</li>
<li>子周期2：从模块申请占用总线，将各种信息送至总线上。</li>
</ul>
<p>特点：</p>
<p>各模块均有权申请占用总线<br>采用同步方式通信，不等对方回答<br>各模块准备数据时，不占用总线<br>总线利用率提高</p>
</blockquote>
</li>
</ul>
<h2 id="标准"><a href="#标准" class="headerlink" title="标准"></a>标准</h2><blockquote>
<p>易于实现系统的模块化设计</p>
</blockquote>
<h1 id="七、输入输出系统"><a href="#七、输入输出系统" class="headerlink" title="七、输入输出系统"></a>七、输入输出系统</h1><h2 id="I-x2F-O接口"><a href="#I-x2F-O接口" class="headerlink" title="I&#x2F;O接口"></a>I&#x2F;O接口</h2><h2 id="I-x2F-O方式"><a href="#I-x2F-O方式" class="headerlink" title="I&#x2F;O方式"></a>I&#x2F;O方式</h2><blockquote>
<p>程序查询方式，程序中断方式，DMA方式</p>
</blockquote>
<ul>
<li><p>程序査询方式：</p>
<p>由CPU通过程序不断查询I&#x2F;O设备是否已做好准备，从而控制I&#x2F;O设备与主机交换信息。</p>
</li>
<li><p>程序中断方式：</p>
<p>只在 I&#x2F;O设备准备就绪并向CPU发出中断请求时才予以响应。</p>
</li>
<li><p>DMA方式：</p>
<p>主存和 I&#x2F;O设备之间有一条直接数据通路，当主存和 I&#x2F;O设备交换信息时无须调用中断服务程序。</p>
</li>
<li><p>通道方式：</p>
<p>在系统中设有通道控制部件，每个通道都挂接若干外设，主机在执行 I&#x2F;O命令时，只需启动有关通道，通道将执行通道程序，从而完成 I&#x2F;O操作。</p>
</li>
</ul>
<blockquote>
<p>程序查询方式和程序中断方式 用于 数据传输效率较低的外部设备，DMA方式和通道方式用于数据传输效率较高的设备。</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/04/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" data-id="cl1ynefmf000dswtu52xqaolz" data-title="计算机组成原理" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-计算机网络Others" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/Notes/2022/04/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9COthers/" class="article-date">
  <time class="dt-published" datetime="2022-04-14T06:55:35.274Z" itemprop="datePublished">2022-04-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/Notes/2022/04/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9COthers/">计算机网络</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>计算机网络已由一种<strong>通信基础设施</strong>发展为一种重要的<strong>信息服务基础设施</strong>。</p>
<h2 id="1-1-因特网概述"><a href="#1-1-因特网概述" class="headerlink" title="1.1 因特网概述"></a>1.1 因特网概述</h2><h3 id="1、-网络、互联网-和-因特网"><a href="#1、-网络、互联网-和-因特网" class="headerlink" title="1、 网络、互联网 和 因特网"></a>1、 网络、互联网 和 因特网</h3><p>网络：网络（Network）由若干<strong>结点（Node）</strong>和连接这些结点的<strong>链路（Link）</strong>组成。</p>
<p>互连网（互联网）：多个网络通过<strong>路由器</strong>互连起来，这样就构成了一个覆盖范围更大的网络，即互连网（互联网）。因此，互联网又称为“网络的网络（Network of Networks）”。</p>
<p>因特网：因特网（Internet）是世界上最大的互连网络（用户数以亿计，互连的网络数以百万计）。</p>
<blockquote>
<p><strong>internet与Internet的区别</strong></p>
<ul>
<li><strong>internet(互联网或互连网)是一个通用名词，它泛指多个计算机网络互连而成的网络</strong>。在这些网络之间的通信协议可以是任意的。</li>
<li><strong>Internet（因特网）则是一个专用名词</strong>，它指<strong>当前全球最大的、开放的、由众多网络互连而成的特定计算机网络</strong>，它采用TCP&#x2F;IP协议族作为通信的规则，其前身是美国的ARPANET。</li>
</ul>
<p><strong>任意把几个计算机网络互连起来（不管采用什么协议），并能够相互通信，这样构成的是一个互连网(internet) ，而不是因特网(Internet)。</strong></p>
</blockquote>
<h3 id="2、因特网发展的三个阶段"><a href="#2、因特网发展的三个阶段" class="headerlink" title="2、因特网发展的三个阶段"></a>2、因特网发展的三个阶段</h3><p>一，从单个网络AEPANET向互联网发展</p>
<blockquote>
<p>1969年，第一个分组交换网AEPANET；</p>
<p>70年代中期，研究多种网络之间的互联；</p>
<p>1983年，TCP&#x2F;IP协议成为ARPANET的标准协议(因特网诞生)</p>
</blockquote>
<p>二，逐步建成三级结构的因特网</p>
<blockquote>
<p>1985年，NSF围绕六个大型计算机中心建设NSFNET（主干网，地区网，校园网）；</p>
<p>1990年，ARPANET任务完成，正式关闭；</p>
<p>1991年，美国政府将因特网主干网交给私人公式经营，并开始对接入因特网的单位收费；</p>
</blockquote>
<p>三，逐步形成了多层次的ISP结构的因特网</p>
<blockquote>
<p>1993年，NSFNET逐渐被若干个商用因特网主干网替代，政府不再负责因特网运营，让各种<strong>因特网服务提供者ISP</strong>来运营；</p>
<p>1994年，万维网WWW技术促使因特网迅速发展；</p>
<p>1995年，NSFNET停止运作，因特网彻底商业化</p>
</blockquote>
<p><strong>因特网服务提供者ISP(Internet Service Provider)</strong></p>
<blockquote>
<p>普通用户是如何接入到因特网的呢？</p>
<p>答：<strong>通过ISP接入因特网</strong></p>
<p>ISP可以从因特网管理机构申请到成块的IP地址，同时拥有通信线路以及路由器等联网设备。任何机构和个人只需缴纳费用，就可从<strong>ISP的得到所需要的IP地址</strong>。</p>
<p><strong>因为因特网上的主机都必须有IP地址才能进行通信，所以要通过该ISP接入到因特网</strong></p>
<p>中国的三大<code>ISP</code>：中国电信，中国联通和中国移动</p>
<p>一旦某个用户能够接入到因特网，那么他也可以成为一个ISP，所需要做的就是购买一些如调制解调器或路由器这样的设备，让其他用户可以和他相连。</p>
</blockquote>
<h3 id="3、因特网的标准化工作"><a href="#3、因特网的标准化工作" class="headerlink" title="3、因特网的标准化工作"></a>3、因特网的标准化工作</h3><ul>
<li><p>因特网的标准化工作对因特网的发展起到了非常重要的作用。</p>
</li>
<li><p>因特网在指定其标准上的一个很大的特点是</p>
<p>面向公众。</p>
<ul>
<li>因特网所有的<strong>RFC</strong>(Request For Comments)技术文档都可从因特网上免费下载；</li>
<li>任何人都可以随时用电子邮件发表对某个文档的意见或建议。</li>
</ul>
</li>
<li><p>因特网协会ISOC</p>
<p>是一个国际性组织，它负责对因特网进行全面管理，以及在世界范围内促进其发展和使用。</p>
<ul>
<li>因特网体系结构委员会IAB，负责管理因特网有关协议的开发；</li>
<li>因特网工程部IETF，负责研究中短期工程问题，主要针对协议的开发和标准化；</li>
<li>因特网研究部IRTF，从事理论方面的研究和开发一些需要长期考虑的问题。</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016103816.png" alt="image-20201006170959060"></p>
<ul>
<li><p>制订因特网的正式标准要经过以下<strong>4个阶段</strong>：</p>
<p>1、因特网草案（在这个阶段还不是RFC文档）</p>
<p>2、建议标准（从这个阶段开始就成为RFC文档）</p>
<p>3、草案标准</p>
<p>4、因特网标准</p>
</li>
</ul>
<h3 id="4、因特网的组成"><a href="#4、因特网的组成" class="headerlink" title="4、因特网的组成"></a>4、因特网的组成</h3><ul>
<li><p>边缘部分</p>
<p>由所有连接在因特网上的<strong>主机</strong>组成（台式电脑，大型服务器，笔记本电脑，平板，智能手机等）。这部分是<strong>用户直接使用</strong>的，用来进行<strong>通信</strong>（传送数据、音频或视频）和<strong>资源共享</strong>。</p>
</li>
<li><p>核心部分</p>
<p>由<strong>大量网络</strong>和连接这些网络的<strong>路由器</strong>组成。这部分是<strong>为边缘部分提供服务</strong>的（提供连通性和交换）。</p>
</li>
</ul>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016103822.png" alt="image-20201006180725282"></p>
<blockquote>
<p>路由器是一种专用计算机，但我们不称它为主机，路由器是实现分组交换的关键构建，其任务是转发收到的分组，这是网络核心最重要的部分。</p>
<p>处在互联网边缘的部分就是连接在互联网上的所有的主机。这些主机又称为**端系统 (end system)**。</p>
<p><strong>端系统在功能上可能有很大的差别：</strong></p>
<ol>
<li>小的端系统可以是一台普通个人电脑，具有上网功能的智能手机，甚至是一个很小的网络摄像头。</li>
<li>大的端系统则可以是一台非常昂贵的大型计算机。</li>
<li>端系统的拥有者可以是个人，也可以是单位（如学校、企业、政府机关等），当然也可以是某个ISP。</li>
</ol>
</blockquote>
<p><strong>端系统之间通信的含义</strong></p>
<p>“主机 A 和主机 B 进行通信”实际上是指：“运行在主机 A 上的某个程序和运行在主机 B 上的另一个程序进行通信”。<strong>即“主机</strong> <strong>A</strong> <strong>的某个进程和主机</strong> <strong>B</strong> <strong>上的另一个进程进行通信”。简称为“计算机之间通信”。</strong></p>
<p>端系统之间的通信方式通常可划分为两大类：</p>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016103829.png" alt="image-20201010234145371"></p>
<p><strong>客户-服务器方式（C&#x2F;S方式）：</strong></p>
<ul>
<li>客户 (client) 和服务器 (server) 都是指通信中所涉及的两个应用进程。</li>
<li>客户 - 服务器方式所描述的是进程之间服务和被服务的关系。</li>
<li>客户是服务的请求方，服务器是服务的提供方。</li>
</ul>
<blockquote>
<p><strong>服务请求方和服务提供方都要使用网络核心部分所提供的服务。</strong></p>
</blockquote>
<p><strong>对等连接方式：</strong></p>
<ul>
<li><strong>对等连接</strong> (peer-to-peer，简写为 <strong>P2P</strong> ) 是指两个主机在通信时并不区分哪一个是服务请求方还是服务提供方。</li>
<li>只要两个主机都运行了对等连接软件 ( P2P 软件) ，它们就可以进行<strong>平等的、对等连接通信</strong>。</li>
<li>双方都可以下载对方已经存储在硬盘中的共享文档。</li>
</ul>
<hr>
<h2 id="1-2-三种交换方式"><a href="#1-2-三种交换方式" class="headerlink" title="1.2 三种交换方式"></a>1.2 三种交换方式</h2><p>网络核心部分是互联网中最复杂的部分。</p>
<p>网络中的核心部分要向网络边缘中的大量主机提供连通性，使边缘部分中的任何一个主机都能够向其他主机通信（即传送或接收各种形式的数据）。</p>
<p>在网络核心部分起特殊作用的是<strong>路由器</strong>(router)。</p>
<p><strong>路由器</strong>是实现<strong>分组交换</strong> (packet switching) 的关键构件，其任务是<strong>转发</strong>收到的分组，这是网络核心部分最重要的功能。</p>
<h4 id="1、电路交换（Circuit-Switching）"><a href="#1、电路交换（Circuit-Switching）" class="headerlink" title="1、电路交换（Circuit Switching）"></a>1、电路交换（Circuit Switching）</h4><p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016103836.png" alt="image-20201006182240000"></p>
<blockquote>
<p>传统两两相连的方式，当电话数量很多时，电话线也很多，就很不方便</p>
<p>所以要使得每一部电话能够很方便地和另一部电话进行通信，就应该使用一个<strong>中间设备</strong>将这些电话连接起来，这个中间设备就是<strong>电话交换机</strong></p>
</blockquote>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016103840.png" alt="image-20201006182634249"></p>
<ul>
<li><p>电话交换机接通电话线的方式称为电路交换；</p>
</li>
<li><p>从通信资源的分配角度来看，交换（Switching）就是按照某种方式动态地分配传输线路的资源；</p>
</li>
<li><p>电路交换的三个步骤：</p>
<p>1、建立连接（分配通信资源）</p>
<p>2、通话（一直占用通信资源）</p>
<p>3、释放连接（归还通信资源）</p>
</li>
</ul>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016103845.png" alt="image-20201006183020317"></p>
<blockquote>
<p>当使用电路交换来传送计算机数据时，其线路的传输效率往往很低。</p>
<p>这是因为计算机数据是突发式地出现在传输线路上的。</p>
<p>所以计算机通常采用的是<strong>分组交换</strong>，而不是线路交换</p>
</blockquote>
<h4 id="2、分组交换（Packet-Switching）"><a href="#2、分组交换（Packet-Switching）" class="headerlink" title="2、分组交换（Packet Switching）"></a>2、分组交换（Packet Switching）</h4><p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016103852.png" alt="image-20201006183312843"></p>
<blockquote>
<p>通常我们把表示<strong>该消息的整块数据</strong>成为一个<strong>报文</strong>。</p>
<p>在发送报文之前，先把较长的报文划分成一个个更小的<strong>等长数据段</strong>，在每一个数据段前面。加上一些由必<strong>要的控制信息组成的首部</strong>后，就构成一个分组，也可简称为“包”，相应地，首部也可称为“包头”。</p>
<p>首部包含了<strong>分组的目的地址</strong></p>
<p>分组从源主机到目的主机，可走不同的路径。</p>
</blockquote>
<p>发送方</p>
<ul>
<li>构造分组</li>
<li>发送分组</li>
</ul>
<p>路由器</p>
<ul>
<li>缓存分组</li>
<li>转发分组</li>
<li>简称为“分组转发”</li>
</ul>
<blockquote>
<p>在路由器中的输入和输出端口之间没有直接连线。</p>
<p>路由器处理分组的过程是：</p>
<ol>
<li>把收到的分组先<strong>放入缓存（暂时存储）；</strong></li>
<li><strong>查找转发表</strong>，找出到某个目的地址应从哪个端口转发；</li>
<li>把分组送到适当的端口<strong>转发</strong>出去。</li>
</ol>
</blockquote>
<p>接收方</p>
<ul>
<li>接收分组</li>
<li>还原报文</li>
</ul>
<h4 id="3、报文交换（Message-Switching）"><a href="#3、报文交换（Message-Switching）" class="headerlink" title="3、报文交换（Message Switching）"></a>3、报文交换（Message Switching）</h4><p>报文交换中的交换结点也采用存储转发方式，但报文交换对报文的大小没有限制，这就要求交换结点需要较大的缓存空间。报文交换主要用于早期的电报通信网，现在较少使用，<strong>通常被较先进的分组交换方式所取代</strong>。</p>
<h4 id="三种交换方式的对比"><a href="#三种交换方式的对比" class="headerlink" title="三种交换方式的对比"></a>三种交换方式的对比</h4><blockquote>
<p>假设A，B，C，D是分组传输路径所要经过的4个结点交换机，纵坐标为时间</p>
</blockquote>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016103900.png" alt="image-20201006184451671"></p>
<p>分析：</p>
<p>电路交换：</p>
<ul>
<li>通信之前首先要建立连接；连接建立好之后，就可以使用已建立好的连接进行数据传送；数据传送后，需释放连接，以归还之前建立连接所占用的通信线路资源。</li>
<li>一旦建立连接，中间的各结点交换机就是直通形式的，比特流可以直达终点；</li>
</ul>
<p>报文交换：</p>
<ul>
<li>可以随时发送报文，而不需要事先建立连接；整个报文先传送到相邻结点交换机，全部存储下来后进行查表转发，转发到下一个结点交换机。</li>
<li>整个报文需要在各结点交换机上进行存储转发，由于不限制报文大小，因此需要各结点交换机都具有较大的缓存空间。</li>
</ul>
<p>分组交换：</p>
<ul>
<li>可以随时发送分组，而不需要事先建立连接。构成原始报文的一个个分组，依次在各结点交换机上存储转发。各结点交换机在发送分组的同时，还缓存接收到的分组。</li>
<li>构成原始报文的一个个分组，在各结点交换机上进行存储转发，相比报文交换，减少了转发时延，还可以避免过长的报文长时间占用链路，同时也有利于进行差错控制。</li>
</ul>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016103949.png" alt="image-20201006185601460"></p>
<hr>
<h2 id="1-3-计算机网络的定义和分类"><a href="#1-3-计算机网络的定义和分类" class="headerlink" title="1.3 计算机网络的定义和分类"></a>1.3 计算机网络的定义和分类</h2><p><strong>定义</strong></p>
<ul>
<li><p>计算机网络的精确定义并未统一</p>
</li>
<li><p>计算机网络的最简单的定义是：一些互相连接的、自治的计算机的集合</p>
<ul>
<li>互连：是指计算机之间可以通过有线或无线的方式进行数据通信；</li>
<li>自治：是指独立的计算机，他有自己的硬件和软件，可以单独运行使用；</li>
<li>集合：是指至少需要两台计算机；</li>
</ul>
</li>
<li><p>计算机网络的较好的定义是：计算机网络主要是由一些</p>
<p>通用的，可编程的硬件（一定包含有中央处理机CPU）互连</p>
<p>而成的，而这些硬件并非专门用来实现某一特定目的（例如，传送数据或视频信号）。这些可编程的硬件能够用来</p>
<p>传送多种不同类型的数据</p>
<p>，并能</p>
<p>支持广泛的和日益增长的应用</p>
<p>。</p>
<ul>
<li>计算机网络所连接的硬件，并不限于一般的计算机，而是包括了智能手机等智能硬件。</li>
<li>计算机网络并非专门用来传送数据，而是能够支持很多种的应用（包括今后可能出现的各种应用）。</li>
</ul>
</li>
</ul>
<p><strong>分类：</strong></p>
<p><strong>按交换技术分类：</strong></p>
<ul>
<li>电路交换网络</li>
<li>报文交换网络</li>
<li>分组交换网络</li>
</ul>
<p><strong>按使用者分类：</strong></p>
<ul>
<li><p>公用网</p>
</li>
<li><p>专用网</p>
</li>
</ul>
<p><strong>按传输介质分类：</strong></p>
<ul>
<li>有线网络</li>
<li>无线网络</li>
</ul>
<p><strong>按覆盖范围分类：</strong></p>
<ul>
<li>广域网WAN（Wide Area Network）</li>
</ul>
<p>作用范围通常为几十到几千公里，因而有时也称为远程网（long haul network）。广域网是互联网的核心部分，其任务是通过长距离（例如，跨越不同的国家）运送主机所发送的数据。</p>
<ul>
<li>城域网MAN</li>
</ul>
<p>作用范围一般是一个城市，可跨越几个街区甚至整个城市</p>
<ul>
<li>局域网LAN</li>
</ul>
<p>一般用微型计算机或工作站通过高速通信线路相连（速率通常在 10 Mbit&#x2F;s 以上），但地理上范围较小（1 km 左右）</p>
<ul>
<li>个域网PAN</li>
</ul>
<p>就是在个人工作的地方把个人使用的电子设备用无线技术连接起来的网络。</p>
<p><strong>按拓扑结构分类：</strong></p>
<ul>
<li>总线型网络</li>
</ul>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016103958.png" alt="image-20201007005149993"></p>
<ul>
<li>星型网络</li>
</ul>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104005.png" alt="image-20201007005203129"></p>
<ul>
<li>环形网络</li>
</ul>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104009.png" alt="image-20201007005212345"></p>
<ul>
<li>网状型网络</li>
</ul>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104015.png" alt="image-20201007005249137"></p>
<hr>
<h2 id="1-4-计算机网络的性能指标"><a href="#1-4-计算机网络的性能指标" class="headerlink" title="1.4 计算机网络的性能指标"></a>1.4 计算机网络的性能指标</h2><h3 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h3><p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104021.png" alt="image-20201007012419698"></p>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104026.png" alt="image-20201007012439769"></p>
<h3 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h3><p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104031.png" alt="image-20201007012943970"></p>
<h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h3><p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104038.png" alt="image-20201007013119621"></p>
<blockquote>
<p>带宽1 Gb&#x2F;s的以太网，代表其额定速率是1 Gb&#x2F;s，这个数值也是该以太网的<strong>吞吐量的绝对上限值</strong>。因此，对于带宽1 Gb&#x2F;s的以太网，可能实际吞吐量只有 700 Mb&#x2F;s，甚至更低。</p>
<p>注意：吞吐量还可以用每秒传送的字节数或帧数表示</p>
</blockquote>
<h3 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h3><p>时延时指数据（一个报文或分组，甚至比特）从网络（或链路）的一端传送到另一端所需的时间。</p>
<p>网络时延由几部分组成：</p>
<ul>
<li>发送时延</li>
</ul>
<p>主机或路由器发送数据帧所需要的时间，也就是从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间。</p>
<ul>
<li>传播时延</li>
</ul>
<p>电磁波在信道中传播一定的距离需要花费的时间。</p>
<ul>
<li>处理时延</li>
</ul>
<p>主机或路由器在收到分组时要花费一定时间进行处理</p>
<ul>
<li>排队时延</li>
</ul>
<p>分组在进过网络传输时，要经过许多路由器。但分组在进入路由器后要先在输入队列中排队等待处理。</p>
<blockquote>
<p>有时会把排队时延看成<strong>处理时延 一部分</strong></p>
<p>总时延 &#x3D; 发送时延 + 传播时延 + 处理时延 （处理时延 + 排队时延）</p>
</blockquote>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104045.png" alt="image-20201007014139333"></p>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104050.png" alt="image-20201007015401505"></p>
<blockquote>
<p>当处理时延忽略不计时，发送时延 和 传播时延谁占主导，要具体情况具体分析</p>
</blockquote>
<h3 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h3><p>时延带宽积 &#x3D; 传播时延 * 带宽</p>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104057.png" alt="image-20201007115317347"></p>
<h3 id="往返时间"><a href="#往返时间" class="headerlink" title="往返时间"></a>往返时间</h3><p>互联网上的信息不仅仅单方向传输而是双向交互的。因此，我们有时很需要知道<strong>双向交互一次所需的时间</strong>。</p>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104104.png" alt="image-20201007115647631"></p>
<h3 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h3><p>利用率有<strong>信道利用率</strong>和<strong>网络利用率</strong>两种。</p>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104110.png" alt="image-20201012164544306"></p>
<h3 id="丢包率"><a href="#丢包率" class="headerlink" title="丢包率"></a>丢包率</h3><p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104116.png" alt="image-20201007132900210"></p>
<hr>
<h2 id="1-5-计算机网络体系结构"><a href="#1-5-计算机网络体系结构" class="headerlink" title="1.5 计算机网络体系结构"></a>1.5 计算机网络体系结构</h2><h3 id="1、常见的体系结构"><a href="#1、常见的体系结构" class="headerlink" title="1、常见的体系结构"></a>1、常见的体系结构</h3><p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104122.png" alt="image-20201007133848212"></p>
<blockquote>
<p>如今用的最多的是TCP&#x2F;IP体系结构，现今规模最大的、覆盖全球的、基于TCP&#x2F;IP的互联网并未使用OSI标准。</p>
<p>TCP&#x2F;IP体系结构相当于将OSI体系结构的<strong>物理层</strong>和<strong>数据链路层</strong>合并为了<strong>网络接口层</strong>，并去掉了<strong>会话层</strong>和<strong>表示层</strong>。</p>
<p>TCP&#x2F;IP在网络层使用的协议是IP协议，IP协议的意思是网际协议，因此<strong>TCP&#x2F;IP体系结构的网络层称为网际层</strong></p>
</blockquote>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104127.png" alt="image-20201007135220030"></p>
<blockquote>
<p>在用户主机的操作系统中，通常都带有符合TCP&#x2F;IP体系结构标准的TCP&#x2F;IP协议族。</p>
<p>而用于网络互连的路由器中，也带有符合TCP&#x2F;IP体系结构标准的TCP&#x2F;IP协议族。</p>
<p>只不过路由器一般只包含网络接口层和网际层。</p>
</blockquote>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104135.png" alt="image-20201007135518050"></p>
<blockquote>
<p><strong>网络接口层</strong>：并没有规定具体内容，这样做的目的是可以互连全世界各种不同的网络接口，例如：有线的以太网接口，无线局域网的WIFI接口等。</p>
<p><strong>网际层</strong>：它的核心协议是IP协议。</p>
<p><strong>运输层</strong>：TCP和UDP是这层的两个重要协议。</p>
<p><strong>应用层</strong>：这层包含了大量的应用层协议，如 HTTP , DNS 等。</p>
</blockquote>
<blockquote>
<p><strong>IP协议（网际层）</strong>可以将不同的<strong>网络接口（网络接口层）</strong>进行互连，并向其上的<strong>TCP协议和UDP协议（运输层）</strong>提供网络互连服务</p>
<p>而<strong>TCP协议</strong>在享受IP协议提供的网络互连服务的基础上，可向<strong>应用层的相应协议</strong>提供<strong>可靠</strong>的传输服务。</p>
<p><strong>UDP协议</strong>在享受IP协议提供的网络互连服务的基础上，可向<strong>应用层的相应协议</strong>提供<strong>不可靠</strong>的传输服务。</p>
</blockquote>
<blockquote>
<p>TCP&#x2F;IP体系结构中最重要的是<strong>IP协议</strong>和<strong>TCP协议</strong>，因此用TCP和IP来表示整个协议大家族。</p>
</blockquote>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104142.png" alt="image-20201007141110338"></p>
<blockquote>
<p>教学时把TCP&#x2F;IP体系结构的<strong>网络接口层</strong>分成了<strong>物理层</strong>和<strong>数据链路层</strong></p>
</blockquote>
<h3 id="2、结构分层的必要性"><a href="#2、结构分层的必要性" class="headerlink" title="2、结构分层的必要性"></a>2、结构分层的必要性</h3><p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104151.png" alt="image-20201007141318411"></p>
<p><strong>物理层问题</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104156.png" alt="image-20201007141806675"></p>
<blockquote>
<p>这图说明</p>
<ul>
<li>第一，严格来说，传输媒体并不属于物理层</li>
<li>计算机传输的信号，并不是图示的方波信号</li>
</ul>
<p>这样举例只是让初学者容易理解</p>
</blockquote>
<p><strong>数据链路层问题</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104204.png" alt="image-20201007142049812"></p>
<p><strong>网络层问题</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104211.png" alt="image-20201007142408792"></p>
<p><strong>运输层问题</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104216.png" alt="image-20201007142631029"></p>
<blockquote>
<p>如何标识与网络通信相关的应用进程：一个分组到来，我们应该交给哪个进程处理呢？浏览器进程还是QQ进程</p>
</blockquote>
<p><strong>应用层问题</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104224.png" alt="image-20201007142755720"></p>
<blockquote>
<p>应用层该用什么方法（应用层协议）去解析数据</p>
</blockquote>
<p><strong>总结</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104231.png" alt="image-20201007204006284"></p>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104235.png" alt="image-20201007143138937"></p>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104241.png" alt="image-20201007195641140"></p>
<h3 id="3、结构分层思想举例"><a href="#3、结构分层思想举例" class="headerlink" title="3、结构分层思想举例"></a>3、结构分层思想举例</h3><p>例子：主机的浏览器如何与Web服务器进行通信</p>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104246.png" alt="image-20201007144900565"></p>
<p><strong>解析：</strong></p>
<p>主机和Web服务器之间基于网络的通信，实际上是主机中的<strong>浏览器应用进程</strong>与Web服务器中的<strong>Web服务器应用进程</strong>之间基于<strong>网络的通信</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104254.png" alt="image-20201007145242020"></p>
<p><strong>体系结构的各层在整个过程中起到怎样的作用？</strong></p>
<p><strong>1、发送方发送</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104300.png" alt="image-20201007145441370"></p>
<blockquote>
<p>第一步：</p>
<ul>
<li><strong>应用层</strong>按照HTTP协议的规定构建一个<strong>HTTP请求报文</strong></li>
<li>应用层将<strong>HTTP请求报文</strong>交付给<strong>运输层</strong>处理</li>
</ul>
</blockquote>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104304.png" alt="image-20201007145720661"></p>
<blockquote>
<p>第二步：</p>
<ul>
<li><strong>运输层</strong>给<strong>HTTP请求报文</strong>添加一个<strong>TCP首部</strong>，使之成为<strong>TCP报文段</strong></li>
<li><strong>TCP报文段的首部格式</strong>作用是区分应用进程以及实现可靠传输</li>
<li><strong>运输层</strong>将T<strong>CP报文段</strong>交付给<strong>网络层</strong>处理</li>
</ul>
</blockquote>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104309.png" alt="image-20201007150234909"></p>
<blockquote>
<p>第三步：</p>
<ul>
<li><strong>网络层</strong>给<strong>TCP报文段</strong>添加一个<strong>IP首部</strong>，使之成为<strong>IP数据报</strong></li>
<li><strong>IP数据报的首部格式</strong>作用是使<strong>IP数据报</strong>可以在互联网传输，也就是被路由器转发</li>
<li><strong>网络层</strong>将<strong>IP数据报</strong>交付给<strong>数据链路层</strong>处理</li>
</ul>
</blockquote>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104314.png" alt="image-20201007150723365"></p>
<blockquote>
<p>第四步：</p>
<ul>
<li><strong>数据链路层</strong>给<strong>IP数据报</strong>添加一个<strong>首部</strong>和一个<strong>尾部</strong>，使之成为<strong>帧</strong> （图示右边为首部，左边为尾部）</li>
<li>该<strong>首部</strong>的作用主要是为了让<strong>帧</strong>能够在一段链路上或一个网络上传输，能够被相应的目的主机接收</li>
<li>该<strong>尾部</strong>的作用是让目的主机检查所接收到的<strong>帧</strong>是否有误码</li>
<li><strong>数据链路层</strong>将<strong>帧</strong>交付给<strong>物理层</strong></li>
</ul>
</blockquote>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104319.png" alt="image-20201007151342502"></p>
<blockquote>
<p>第五步：</p>
<ul>
<li><strong>物理层</strong>先将<strong>帧</strong>看做是<strong>比特流</strong>，这里的网络N1假设是以太网，所以<strong>物理层</strong>还会给该<strong>比特流</strong>前面添加<strong>前导码</strong></li>
<li><strong>前导码</strong>的作用是为了让目的主机做好接收帧的准备</li>
<li><strong>物理层</strong>将装有<strong>前导码</strong>的<strong>比特流</strong>变换成相应的<strong>信号</strong>发送给传输媒体</li>
</ul>
</blockquote>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104325.png" alt="image-20201007151900254"></p>
<blockquote>
<p>第六步：</p>
<ul>
<li><strong>信号</strong>通过<strong>传输媒体</strong>到达<strong>路由器</strong></li>
</ul>
</blockquote>
<p><strong>2、路由器转发</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104331.png" alt="image-20201007152029458"> <img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104337.png" alt="image-20201007152138961"> <img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104350.png" alt="image-20201007152627778"></p>
<blockquote>
<p>在路由器中</p>
<ul>
<li><strong>物理层</strong>将<strong>信号</strong>变为<strong>比特流</strong>，然后去掉<strong>前导码</strong>后，将其交付给<strong>数据链路层</strong></li>
<li><strong>数据链路层</strong>将<strong>帧</strong>的<strong>首部</strong>和<strong>尾部</strong>去掉后，将其交付给<strong>网络层</strong>，这实际交付的是<strong>IP数据报</strong></li>
<li><strong>网络层</strong>解析<strong>IP数据报</strong>的<strong>首部</strong>，从中提取<strong>目的网络地址</strong></li>
</ul>
</blockquote>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104356.png" alt="image-20201007152650863"> <img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104400.png" alt="image-20201007152812431"> <img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104404.png" alt="image-20201007153714840"></p>
<blockquote>
<p>在路由器中</p>
<ul>
<li>提取<strong>目的网络地址</strong>后查找<strong>自身路由表</strong>。确定<strong>转发端口</strong>， 以便进行转发</li>
<li><strong>网络层</strong>将<strong>IP数据报</strong>交付给<strong>数据链路层</strong></li>
<li><strong>数据链路层</strong>给<strong>IP数据报</strong>添加一个<strong>首部</strong>和一个<strong>尾部</strong>，使之成为<strong>帧</strong></li>
<li><strong>数据链路层</strong>将帧交付给<strong>物理层</strong></li>
<li><strong>物理层</strong>先将<strong>帧</strong>看成<strong>比特流</strong>，这里的网络N2假设是以太网，所以<strong>物理层</strong>还会给该<strong>比特流</strong>前面添加<strong>前导码</strong></li>
<li>物理层将装有<strong>前导码</strong>的<strong>比特流</strong>变换成相应的<strong>信号</strong>发送给传输媒体，信号通过传输媒体到达<strong>Web服务器</strong></li>
</ul>
</blockquote>
<p><strong>3、接收方接收</strong></p>
<blockquote>
<p>和发送方（主机）发送过程的封装正好是反着来</p>
<p>在Web 服务器上</p>
<ul>
<li><strong>物理层</strong>将<strong>信号</strong>变换为<strong>比特流</strong>，然后去掉<strong>前导码</strong>后成为<strong>帧</strong>，交付给<strong>数据链路层</strong></li>
<li><strong>数据链路层</strong>将<strong>帧</strong>的<strong>首部</strong>和<strong>尾部</strong>去掉后成为<strong>IP数据报</strong>，将其交付给<strong>网络层</strong></li>
<li><strong>网络层</strong>将<strong>IP数据报</strong>的<strong>首部</strong>去掉后成为<strong>TCP报文段</strong>，将其交付给<strong>运输层</strong></li>
<li><strong>运输层</strong>将<strong>TCP报文段</strong>的<strong>首部</strong>去掉后成为<strong>HTTP请求报文</strong>，将其交付给<strong>应用层</strong></li>
<li><strong>应用层</strong>对<strong>HTTP请求报文</strong>进行<strong>解析</strong>，然后给主机发回<strong>响应报文</strong></li>
</ul>
<p><strong>发回响应报文的步骤和之前过程类似</strong></p>
</blockquote>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104410.png" alt="image-20201007155051275"></p>
<h3 id="4、结构中的专用术语"><a href="#4、结构中的专用术语" class="headerlink" title="4、结构中的专用术语"></a>4、结构中的专用术语</h3><p>以下介绍的专用术语来源于OSI的七层协议体系结构，但也适用于TCP&#x2F;IP的四层体系结构和五层协议体系结构</p>
<p><strong>实体</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104417.png" alt="image-20201007155444920"></p>
<p><strong>协议</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104423.png" alt="image-20201007155545934"></p>
<blockquote>
<p>协议：控制两个对等实体进行逻辑通信的规则的集合</p>
<p>协议三要素：</p>
<ul>
<li>语法：定义所交换信息的格式</li>
<li>语义：定义收发双方所要完成的操作</li>
<li>同步：定义收发双发的时序关系</li>
</ul>
</blockquote>
<p><strong>服务</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104434.png" alt="image-20201007160246561"></p>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104757.png" alt="image-20201016104750288"></p>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104806.png" alt="image-20201007162620250"></p>
<h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><h3 id="体系结构题目"><a href="#体系结构题目" class="headerlink" title="体系结构题目"></a>体系结构题目</h3><p><img src="D:/Note/Typora_picture/image-20201007230219248.png" alt="image-20201007230219248"></p>
<hr>
<p><img src="D:/Note/Typora_picture/image-20201007230242426.png" alt="image-20201007230242426"></p>
<hr>
<p><img src="D:/Note/Typora_picture/image-20201007230300194.png" alt="image-20201007230300194"></p>
<hr>
<p><img src="D:/Note/Typora_picture/image-20201007230345580.png" alt="image-20201007230345580"></p>
<hr>
<p><img src="D:/Note/Typora_picture/image-20201007230404271.png" alt="image-20201007230404271"></p>
<hr>
<p><img src="D:/Note/Typora_picture/image-20201007230432453.png" alt="image-20201007230432453"></p>
<hr>
<p><img src="D:/Note/Typora_picture/image-20201007230450993.png" alt="image-20201007230450993"></p>
<hr>
<p><img src="D:/Note/Typora_picture/image-20201007230511370.png" alt="image-20201007230511370"></p>
<hr>
<p><img src="D:/Note/Typora_picture/image-20201007230548012.png" alt="image-20201007230548012"></p>
<hr>
<p><img src="D:/Note/Typora_picture/image-20201007230616796.png" alt="image-20201007230616796"></p>
<hr>
<p><img src="D:/Note/Typora_picture/image-20201007230635007.png" alt="image-20201007230635007"></p>
<h3 id="时延相关题目"><a href="#时延相关题目" class="headerlink" title="时延相关题目"></a>时延相关题目</h3><p><img src="D:/Note/Typora_picture/image-20201007230747143.png" alt="image-20201007230747143"></p>
<p><img src="D:/Note/Typora_picture/image-20201007231024960.png" alt="image-20201007231024960"></p>
<p><img src="D:/Note/Typora_picture/image-20201007230843470.png" alt="image-20201007230843470"></p>
<hr>
<p><img src="D:/Note/Typora_picture/image-20201007231125552.png" alt="image-20201007231125552"></p>
<hr>
<p><img src="D:/Note/Typora_picture/image-20201007231159268.png" alt="image-20201007231159268"></p>
<hr>
<p><img src="D:/Note/Typora_picture/image-20201007231234486.png" alt="image-20201007231234486"></p>
<hr>
<p><img src="D:/Note/Typora_picture/image-20201007231318549.png" alt="image-20201007231318549"></p>
<hr>
<p><img src="D:/Note/Typora_picture/image-20201007231338817.png" alt="image-20201007231338817"></p>
<hr>
<hr>
<h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><h2 id="2-1、物理层的基本概念"><a href="#2-1、物理层的基本概念" class="headerlink" title="2.1、物理层的基本概念"></a>2.1、物理层的基本概念</h2><p><img src="D:/Note/Typora_picture/image-20201008130211749.png" alt="image-20201008130211749"></p>
<hr>
<h2 id="2-2、物理层下面的传输媒体"><a href="#2-2、物理层下面的传输媒体" class="headerlink" title="2.2、物理层下面的传输媒体"></a>2.2、物理层下面的传输媒体</h2><p><strong>传输媒体</strong>也称为传输介质或传输媒介，他就是数据传输系统中在发送器和接收器之间的物理通路。<strong>传输媒体</strong>课分为两大类，即<strong>导引型传输媒体</strong>和<strong>非导引型传输媒体</strong></p>
<p>传输媒体不属于计算机网络体系结构的任何一层。如果非要将它添加到体系结构中，那只能将其放置到物理层之下。</p>
<h3 id="导引型传输媒体"><a href="#导引型传输媒体" class="headerlink" title="导引型传输媒体"></a>导引型传输媒体</h3><p>在导引型传输媒体中，电磁波被导引沿着固体媒体传播。</p>
<p><strong>同轴电缆</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201008132050917.png" alt="image-20201008132050917"></p>
<p><strong>双绞线</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201008132225715.png" alt="image-20201008132225715"></p>
<p><strong>光纤</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201008132403903.png" alt="image-20201008132403903"></p>
<p><img src="D:/Note/Typora_picture/image-20201011001240573.png" alt="image-20201011001240573"></p>
<blockquote>
<p><strong>多模光纤</strong></p>
<ul>
<li>可以存在多条不同角度入射的光线在一条光纤中传输。这种光纤就称为<strong>多模光纤</strong>。</li>
</ul>
<p><strong>单模光纤</strong></p>
<ul>
<li>若光纤的直径减小到只有一个光的波长，则光纤就像一根波导那样，它可使光线一直向前传播，而不会产生多次反射。这样的光纤称为<strong>单模光纤</strong>。</li>
</ul>
</blockquote>
<p><strong>电力线</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201008132709015.png" alt="image-20201008132709015"></p>
<h3 id="非导引型传输媒体"><a href="#非导引型传输媒体" class="headerlink" title="非导引型传输媒体"></a>非导引型传输媒体</h3><p>非导引型传输媒体是指自由空间。</p>
<p><img src="D:/Note/Typora_picture/image-20201008132857833.png" alt="image-20201008132857833"></p>
<p><img src="D:/Note/Typora_picture/image-20201008132943176.png" alt="image-20201008132943176"></p>
<p><strong>无线电波</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201008133135659.png" alt="image-20201008133135659"></p>
<p><strong>微波</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201008133317293.png" alt="image-20201008133317293"></p>
<p><strong>红外线</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201008133421986.png" alt="image-20201008133421986"></p>
<p><strong>可见光</strong></p>
<p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%8F%AF%E8%A7%81%E5%85%89%E6%97%A0%E7%BA%BF%E9%80%9A%E4%BF%A1/16268518?fromtitle=LiFi&fromid=5675729&fr=aladdin">LIFI</a></p>
<p><img src="D:/Note/Typora_picture/image-20201008133718810.png" alt="image-20201008133718810"></p>
<hr>
<h2 id="2-3、传输方式"><a href="#2-3、传输方式" class="headerlink" title="2.3、传输方式"></a>2.3、传输方式</h2><h3 id="串行传输和并行传输"><a href="#串行传输和并行传输" class="headerlink" title="串行传输和并行传输"></a>串行传输和并行传输</h3><p><img src="D:/Note/Typora_picture/image-20201008135603009.png" alt="image-20201008135603009"></p>
<blockquote>
<p><strong>串行传输</strong>：</p>
<ul>
<li>数据是一个比特一个比特依次发送的，因此在发送端与接收端之间，只需要一条数据传输线路即可</li>
</ul>
<p><strong>并行传输</strong>：</p>
<ul>
<li><p>一次发送n个比特，因此，在发送端和接收端之间需要有n条传输线路</p>
</li>
<li><p>并行传输的优点是比串行传输的速度n倍，但成本高</p>
</li>
</ul>
<p>数据在传输线路上的传输采用是<strong>串行传输</strong>，计算机内部的数据传输常用<strong>并行传输</strong></p>
</blockquote>
<h3 id="同步传输和异步传输"><a href="#同步传输和异步传输" class="headerlink" title="同步传输和异步传输"></a>同步传输和异步传输</h3><p><img src="D:/Note/Typora_picture/image-20201008140209430.png" alt="image-20201008140209430"></p>
<blockquote>
<p><strong>同步传输</strong>：</p>
<ul>
<li>数据块以稳定的比特流的形式传输。字节之间没有间隔</li>
<li>接收端在每个比特信号的中间时刻进行检测，以判别接收到的是比特0还是比特1</li>
<li>由于不同设备的时钟频率存在一定差异，不可能做到完全相同，在传输大量数据的过程中，所产生的判别时刻的累计误差，会导致接收端对比特信号的判别错位</li>
</ul>
<p>所以要使收发双发时钟保持同步</p>
</blockquote>
<p><img src="D:/Note/Typora_picture/image-20201008140850958.png" alt="image-20201008140850958"></p>
<blockquote>
<p><strong>异步传输</strong>：</p>
<ul>
<li>以字节为独立的传输单位，字节之间的时间间隔不是固定</li>
<li>接收端仅在每个字节的起始处对字节内的比特实现同步</li>
<li>通常在每个字节前后分别加上起始位和结束位</li>
</ul>
</blockquote>
<h3 id="单向通信（单工）、双向交替通信（半双工）和双向同时通信（全双工）"><a href="#单向通信（单工）、双向交替通信（半双工）和双向同时通信（全双工）" class="headerlink" title="单向通信（单工）、双向交替通信（半双工）和双向同时通信（全双工）"></a>单向通信（单工）、双向交替通信（半双工）和双向同时通信（全双工）</h3><p>在许多情况下，我们要使用“<strong>信道（channel）</strong>”这一名词。信道和电路并不等同。信道一般都是用来表示向某一个方向传送信息的媒体。因此，一条通信电路往往包含一条发送信道和一条接收信道。</p>
<p>从通信的双方信息交互的方式来看，可以有以下三种基本方式：</p>
<p><strong>单向通信</strong>：</p>
<p>又称为<strong>单工通信</strong>，即只能有一个方向的通信而没有反方向的交互。无线电广播或有线电以及电视广播就属于这种类型</p>
<p><img src="D:/Note/Typora_picture/image-20201008141345239.png" alt="image-20201008141345239"></p>
<p><strong>双向交替通信</strong>：</p>
<p>又称为<strong>半双工通信</strong>，即通信的双方可以发送信息，但不能双方同时发送（当然也就不能同时接收）。这种通信方式使一方发送另一方接收，过一段时间后可以再反过来</p>
<p><img src="D:/Note/Typora_picture/image-20201008141921924.png" alt="image-20201008141921924"></p>
<p><strong>双向同时通信</strong>：</p>
<p>又称为<strong>全双工通信</strong>，即通信的双发可以同时发送和接收信息。</p>
<p><img src="D:/Note/Typora_picture/image-20201008142037846.png" alt="image-20201008142037846"></p>
<blockquote>
<p><strong>单向通信</strong>只需要一条信道，而<strong>双向交替通信</strong>或<strong>双向同时通信</strong>则需要两条信道（每个方向各一条）</p>
<p><strong>双向同时通信</strong>的传输效率最高</p>
</blockquote>
<h2 id="2-4、编码与调制"><a href="#2-4、编码与调制" class="headerlink" title="2.4、编码与调制"></a>2.4、编码与调制</h2><p><img src="D:/Note/Typora_picture/image-20201008144616896.png" alt="image-20201008144616896"></p>
<blockquote>
<p><strong>常用术语</strong></p>
<ul>
<li><p><strong>数据 (data)</strong> —— 运送消息的实体。</p>
</li>
<li><p><strong>信号 (signal)</strong> —— 数据的电气的或电磁的表现。 </p>
</li>
<li><p><strong>模拟信号 (analogous signal)</strong> —— 代表消息的参数的取值是连续的。 </p>
</li>
<li><p><strong>数字信号 (digital signal)</strong> —— 代表消息的参数的取值是离散的。 </p>
</li>
<li><p><strong>码元 (code)</strong> —— 在使用时间域（或简称为时域）的波形表示数字信号时，代表不同离散数值的基本波形。</p>
</li>
<li><p><strong>基带信号</strong>（即基本频带信号）—— 来自信源的信号。像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。</p>
</li>
<li><p>基带信号往往包含有较多的低频成分，甚至有直流成分，而许多信道并不能传输这种低频分量或直流分量。因此必须对基带信号进行<strong>调制</strong>  (modulation)。</p>
</li>
</ul>
</blockquote>
<p>在计算机网络中，常见的是将数字基带信号通过编码或调制的方法在相应信道进行传输</p>
<p><img src="D:/Note/Typora_picture/image-20201008145747263.png" alt="image-20201008145747263"></p>
<h3 id="传输媒体与信道的关系"><a href="#传输媒体与信道的关系" class="headerlink" title="传输媒体与信道的关系"></a><strong>传输媒体与信道的关系</strong></h3><blockquote>
<p><strong>信道的几个基本概念</strong></p>
<ul>
<li><strong>信道</strong> —— 一般用来表示向某一个方向传送信息的媒体。</li>
<li><strong>单向通信（单工通信）</strong>——只能有一个方向的通信而没有反方向的交互。</li>
<li><strong>双向交替通信（半双工通信）</strong>——通信的双方都可以发送信息，但不能双方同时发送(当然也就不能同时接收)。</li>
<li><strong>双向同时通信（全双工通信）</strong>——通信的双方可以同时发送和接收信息。</li>
</ul>
</blockquote>
<p>严格来说，传输媒体不能和信道划等号</p>
<p>对于单工传输，传输媒体只包含一个信道，要么是发送信道，要么是接收信道</p>
<p><img src="D:/Note/Typora_picture/image-20201008145304974.png" alt="image-20201008145304974"></p>
<p>对于半双工和全双工，传输媒体中要包含两个信道，一个发送信道，另一个是接收信道</p>
<p><img src="D:/Note/Typora_picture/image-20201008145329540.png" alt="image-20201008145329540"></p>
<blockquote>
<p>如果使用信道复用技术，一条传输媒体还可以包含多个信道</p>
</blockquote>
<h3 id="常用编码"><a href="#常用编码" class="headerlink" title="常用编码"></a>常用编码</h3><p><strong>不归零编码</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201008150058039.png" alt="image-20201008150058039"></p>
<blockquote>
<ul>
<li><p>正电平表示比特1&#x2F;0</p>
</li>
<li><p>负电平表示比特0&#x2F;1</p>
</li>
</ul>
<p>中间的虚线是零电平，所谓不归零编码，就是指在整个码元时间内，电平不会出现零电平</p>
<p><strong>实际比特1和比特0的表示要看现实怎么规定</strong></p>
</blockquote>
<p><img src="D:/Note/Typora_picture/image-20201008150528228.png" alt="image-20201008150528228"></p>
<blockquote>
<p>这需要发送方的发送与接收方的接收做到严格的同步</p>
<ul>
<li>需要<strong>额外一根传输线来传输时钟信号</strong>，使发送方和接收方同步，接收方按时钟信号的节拍来逐个接收码元</li>
<li><strong>但是</strong>对于计算机网络，<strong>宁愿利用这根传输线传输数据信号</strong>，而不是传输时钟信号</li>
</ul>
<p>由于<strong>不归零编码</strong>存在<strong>同步问题</strong>，因此计算机网络中的数据传输不采用这类编码！</p>
</blockquote>
<p><strong>归零编码</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201008195033189.png" alt="image-20201008195033189"></p>
<img src="D:/Note/Typora_picture/image-20201008151347028.png" alt="image-20201008151347028" style="zoom:67%;" />

<blockquote>
<p><strong>归零编码</strong>虽然<strong>自同步</strong>，但<strong>编码效率低</strong></p>
</blockquote>
<p><strong>曼彻斯特编码</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201008195148727.png" alt="image-20201008195148727"></p>
<blockquote>
<p>在每个码元时间的中间时刻，信号都会发生跳变</p>
<ul>
<li>负跳变表示比特1&#x2F;0</li>
<li>正跳变表示比特0&#x2F;1</li>
<li>码元中间时刻的跳变即表示时钟，又表示数据</li>
</ul>
<p><strong>实际比特1和比特0的表示要看现实怎么规定</strong></p>
<p>传统以太网使用的就是曼切斯特编码</p>
</blockquote>
<p><strong>差分曼彻斯特编码</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201008195235561.png" alt="image-20201008195235561"></p>
<blockquote>
<p>在每个码元时间的中间时刻，信号都会发送跳变，但与<strong>曼彻斯特不同</strong></p>
<ul>
<li><strong>跳变仅表示时钟</strong></li>
<li><strong>码元开始处电平是否变换表示数据</strong><ul>
<li>变化表示比特1&#x2F;0</li>
<li>不变化表示比特0&#x2F;1</li>
</ul>
</li>
</ul>
<p><strong>实际比特1和比特0的表示要看现实怎么规定</strong></p>
<p>比曼彻斯特编码变化少，更适合较高的传输速率</p>
</blockquote>
<p><strong>总结</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201008153522501.png" alt="image-20201008153522501"></p>
<h3 id="调制"><a href="#调制" class="headerlink" title="调制"></a>调制</h3><p>数字信号转换为模拟信号，在模拟信道中传输，例如WiFi，采用补码键控CCK&#x2F;直接序列扩频DSSS&#x2F;正交频分复用OFDM等<strong>调制</strong>方式。</p>
<p>模拟信号转换为另一种模拟信号，在模拟信道中传输，例如，语音数据加载到模拟的载波信号中传输。频分复用FDM技术，充分利用带宽资源。</p>
<p><strong>基本调制方法</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201008155429044.png" alt="image-20201008155429044"></p>
<blockquote>
<ul>
<li><strong>调幅AM</strong>：所调制的信号由两种不同振幅的基本波形构成。每个基本波形只能表示1比特信息量。</li>
<li><strong>调频FM</strong>：所调制的信号由两种不同频率的基本波形构成。每个基本波形只能表示1比特信息量。</li>
<li><strong>调相PM</strong>：所调制的信号由两种不同初相位的基本波形构成。每个基本波形只能表示1比特信息量。</li>
</ul>
<p>但是使用基本调制方法，1个码元只能包含1个比特信息</p>
</blockquote>
<p><strong>混合调制</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201008155804617.png" alt="image-20201008155804617"></p>
<p><img src="D:/Note/Typora_picture/image-20201008155835940.png" alt="image-20201008155835940"></p>
<p><img src="D:/Note/Typora_picture/image-20201008155955169.png" alt="image-20201008155955169"></p>
<p><img src="D:/Note/Typora_picture/image-20201008160133748.png" alt="image-20201008160133748"></p>
<blockquote>
<p>上图码元所对应的4个比特是错误的，码元不能随便对应4个比特</p>
</blockquote>
<p><img src="D:/Note/Typora_picture/image-20201008160208060.png" alt="image-20201008160208060"></p>
<h3 id="码元"><a href="#码元" class="headerlink" title="码元"></a>码元</h3><p>在使用时间域的波形表示数字信号时，代表不同离散数值的基本波形。</p>
<h2 id="2-5、信道的极限容量"><a href="#2-5、信道的极限容量" class="headerlink" title="2.5、信道的极限容量"></a>2.5、信道的极限容量</h2><ul>
<li>任何实际的信道都不是理想的，在传输信号时会产生各种失真以及带来多种干扰。 </li>
<li>码元传输的速率越高，或信号传输的距离越远，或传输媒体质量越差，在信道的输出端的波形的失真就越严重。</li>
</ul>
<p><img src="D:/Note/Typora_picture/image-20201010204336400.png" alt="image-20201010204336400"></p>
<p>失真的原因：</p>
<ul>
<li>码元传输的速率越高</li>
<li>信号传输的距离越远</li>
<li>噪声干扰越大</li>
<li>传输媒体质量越差</li>
</ul>
<p><img src="D:/Note/Typora_picture/image-20201010204818976.png" alt="image-20201010204818976"></p>
<p><img src="D:/Note/Typora_picture/image-20201010204928756.png" alt="image-20201010204928756"></p>
<p>奈氏准则和香农公式对比：</p>
<p><img src="D:/Note/Typora_picture/image-20201010205029346.png" alt="image-20201010205029346"></p>
<h2 id="补充：信道复用技术"><a href="#补充：信道复用技术" class="headerlink" title="补充：信道复用技术"></a>补充：信道复用技术</h2><p>本节内容视频未讲到，是《计算机网络（第7版）谢希仁》物理层的内容</p>
<h3 id="频分复用、时分复用和统计时分复用"><a href="#频分复用、时分复用和统计时分复用" class="headerlink" title="频分复用、时分复用和统计时分复用"></a>频分复用、时分复用和统计时分复用</h3><p>复用 (multiplexing) 是通信技术中的基本概念。</p>
<p>它允许用户使用一个共享信道进行通信，降低成本，提高利用率。</p>
<p><img src="D:/Note/Typora_picture/image-20201011001949479.png" alt="image-20201011001949479"></p>
<p><strong>频分复用 FDM (Frequency Division Multiplexing)</strong></p>
<ul>
<li>将整个带宽分为多份，用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。</li>
<li><strong>频分复用</strong>的所有用户在同样的时间<strong>占用不同的带宽资源</strong>（请注意，这里的“带宽”是频率带宽而不是数据的发送速率）。</li>
</ul>
<p><img src="D:/Note/Typora_picture/image-20201011002236208.png" alt="image-20201011002236208"></p>
<p><strong>时分复用TDM (Time Division Multiplexing)</strong> </p>
<ul>
<li><strong>时分复用</strong>则是将时间划分为一段段等长的<strong>时分复用帧（TDM帧）</strong>。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。</li>
<li>每一个用户所占用的时隙是<strong>周期性地出现</strong>（其周期就是TDM帧的长度）的。</li>
<li>TDM 信号也称为<strong>等时</strong> (isochronous) 信号。</li>
<li><strong>时分复用的所有用户在不同的时间占用同样的频带宽度。</strong></li>
</ul>
<p><img src="D:/Note/Typora_picture/image-20201011002540041.png" alt="image-20201011002540041"></p>
<ul>
<li><strong>时分复用可能会造成线路资源的浪费</strong><ul>
<li>使用时分复用系统传送计算机数据时，由于计算机数据的突发性质，用户对分配到的子信道的利用率一般是不高的。</li>
</ul>
</li>
</ul>
<p><img src="D:/Note/Typora_picture/image-20201011002842704.png" alt="image-20201011002842704"></p>
<p><strong>统计时分复用 STDM  (Statistic TDM)</strong> </p>
<p><img src="D:/Note/Typora_picture/image-20201011002953703.png" alt="image-20201011002953703"></p>
<h3 id="波分复用"><a href="#波分复用" class="headerlink" title="波分复用"></a>波分复用</h3><p>波分复用 WDM(Wavelength Division Multiplexing)</p>
<p><img src="D:/Note/Typora_picture/image-20201011003214653.png" alt="image-20201011003214653"></p>
<h3 id="码分复用"><a href="#码分复用" class="headerlink" title="码分复用"></a>码分复用</h3><p>码分复用 CDM  (Code Division Multiplexing)</p>
<ul>
<li>常用的名词是<strong>码分多址</strong> CDMA (Code Division Multiple Access)。</li>
<li>各用户使用经过特殊挑选的不同码型，因此彼此不会造成干扰。</li>
<li>这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。</li>
</ul>
<h2 id="习题-1"><a href="#习题-1" class="headerlink" title="习题"></a>习题</h2><h3 id="物理层的基本概念"><a href="#物理层的基本概念" class="headerlink" title="物理层的基本概念"></a>物理层的基本概念</h3><p><img src="D:/Note/Typora_picture/image-20201010213213489.png" alt="image-20201010213213489"></p>
<hr>
<p><img src="D:/Note/Typora_picture/image-20201010213423319.png" alt="image-20201010213423319"></p>
<h3 id="编码与调制习题"><a href="#编码与调制习题" class="headerlink" title="编码与调制习题"></a>编码与调制习题</h3><p><img src="D:/Note/Typora_picture/image-20201008154232079.png" alt="image-20201008154232079"></p>
<hr>
<p><img src="D:/Note/Typora_picture/image-20201010213815232.png" alt="image-20201010213815232"></p>
<h3 id="信道的极限容量习题"><a href="#信道的极限容量习题" class="headerlink" title="信道的极限容量习题"></a>信道的极限容量习题</h3><p><img src="D:/Note/Typora_picture/image-20201010205425612.png" alt="image-20201010205425612"></p>
<hr>
<p><img src="D:/Note/Typora_picture/image-20201010205914234.png" alt="image-20201010205914234"></p>
<hr>
<p><img src="D:/Note/Typora_picture/image-20201010210031254.png" alt="image-20201010210031254"></p>
<hr>
<p><img src="D:/Note/Typora_picture/image-20201010210217898.png" alt="image-20201010210217898"></p>
<hr>
<p><img src="D:/Note/Typora_picture/image-20201010210350902.png" alt="image-20201010210350902"></p>
<h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><h2 id="3-1、数据链路层概述"><a href="#3-1、数据链路层概述" class="headerlink" title="3.1、数据链路层概述"></a>3.1、数据链路层概述</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p><strong>链路</strong>是从一个结点到相邻结点的一段物理线路，<strong>数据链路</strong>则是在链路的基础上增加了一些必要的硬件（如网络适配器）和软件（如协议的实现）</p>
<p><strong>网络中的主机、路由器等都必须实现数据链路层</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201011102531462.png" alt="image-20201011102531462"></p>
<p><strong>局域网中的主机、交换机等都必须实现数据链路层</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201014004326549.png" alt="image-20201014004326549"></p>
<p><strong>从层次上来看数据的流动</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201011102618878.png" alt="image-20201011102618878"></p>
<p><strong>仅从数据链路层观察帧的流动</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201011102653161.png" alt="image-20201011102653161"></p>
<p><img src="D:/Note/Typora_picture/image-20201011102733584.png" alt="image-20201011102733584"></p>
<blockquote>
<p>主机H1 到主机H2 所经过的网络可以是多种不同类型的</p>
<p><strong>注意：不同的链路层可能采用不同的数据链路层协议</strong></p>
</blockquote>
<p><strong>数据链路层使用的信道</strong></p>
<p>数据链路层属于计算机网路的低层。<strong>数据链路层使用的信道主要有以下两种类型：</strong></p>
<ul>
<li>点对点信道</li>
<li>广播信道</li>
</ul>
<p><img src="D:/Note/Typora_picture/image-20201014004459744.png" alt="image-20201014004459744"></p>
<blockquote>
<p><strong>局域网属于数据链路层</strong></p>
<p>局域网虽然是个网络。但我们并不把局域网放在网络层中讨论。这是因为在网络层要讨论的是多个网络互连的问题，是讨论分组怎么从一个网络，通过路由器，转发到另一个网络。</p>
<p>而在同一个局域网中，分组怎么从一台主机传送到另一台主机，但并不经过路由器转发。从整个互联网来看，<strong>局域网仍属于数据链路层</strong>的范围</p>
</blockquote>
<h3 id="三个重要问题"><a href="#三个重要问题" class="headerlink" title="三个重要问题"></a>三个重要问题</h3><p>数据链路层传送的协议数据单元是<strong>帧</strong></p>
<p><strong>封装成帧</strong></p>
<ul>
<li><strong>封装成帧</strong> (framing) 就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。</li>
<li>首部和尾部的一个重要作用就是进行<strong>帧定界</strong>。</li>
</ul>
<p><img src="D:/Note/Typora_picture/image-20201011103650253.png" alt="image-20201011103650253"></p>
<p><strong>差错控制</strong></p>
<p>在传输过程中可能会产生<strong>比特差错</strong>：1 可能会变成 0， 而 0 也可能变成 1。</p>
<p><img src="D:/Note/Typora_picture/image-20201011103917512.png" alt="image-20201011103917512"></p>
<p><strong>可靠传输</strong></p>
<p>接收方主机收到有误码的帧后，是不会接受该帧的，会将它丢弃</p>
<p>如果数据链路层向其上层提供的是不可靠服务，那么丢弃就丢弃了，不会再有更多措施</p>
<p><strong>如果数据链路层向其上层提供的是可靠服务，那就还需要其他措施，来确保接收方主机还可以重新收到被丢弃的这个帧的正确副本</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201011105314053.png" alt="image-20201011105314053"></p>
<blockquote>
<p>以上三个问题都是使用<strong>点对点信道的数据链路层</strong>来举例的</p>
</blockquote>
<p><strong>如果使用广播信道的数据链路层除了包含上面三个问题外，还有一些问题要解决</strong></p>
<p>如图所示，主机A，B，C，D，E通过一根总线进行互连，主机A要给主机C发送数据，代表帧的信号会通过总线传输到总线上的其他各主机，那么主机B，D，E如何知道所收到的帧不是发送给她们的，主机C如何知道发送的帧是发送给自己的</p>
<p><img src="D:/Note/Typora_picture/image-20201011105824466.png" alt="image-20201011105824466"></p>
<p>可以用编址（地址）的来解决</p>
<p>将帧的目的地址添加在帧中一起传输</p>
<p><img src="D:/Note/Typora_picture/image-20201011110017415.png" alt="image-20201011110017415"></p>
<p>还有数据碰撞问题</p>
<p><img src="D:/Note/Typora_picture/image-20201011110129994.png" alt="image-20201011110129994"></p>
<blockquote>
<p>随着技术的发展，交换技术的成熟，</p>
<p>在 有线（局域网）领域 使用<strong>点对点链路</strong>和<strong>链路层交换机</strong>的<strong>交换式局域网</strong>取代了<del>共享式局域网</del></p>
<p>在无线局域网中仍然使用的是共享信道技术</p>
</blockquote>
<hr>
<h2 id="3-2、封装成帧"><a href="#3-2、封装成帧" class="headerlink" title="3.2、封装成帧"></a>3.2、封装成帧</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>封装成帧是指数据链路层给上层交付的协议数据单元添加帧头和帧尾使之成为帧</p>
<ul>
<li><strong>帧头和帧尾中包含有重要的控制信息</strong></li>
</ul>
<p><img src="D:/Note/Typora_picture/image-20201011110851301.png" alt="image-20201011110851301"></p>
<p>发送方的数据链路层将上层交付下来的协议数据单元封装成帧后，还要通过物理层，将构成帧的各比特，转换成电信号交给传输媒体，那么接收方的数据链路层如何从物理层交付的比特流中提取出一个个的帧？</p>
<p>答：需要帧头和帧尾来做<strong>帧定界</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201011111334052.png" alt="image-20201011111334052"></p>
<p>但比不是每一种数据链路层协议的帧都包含有帧定界标志，例如下面例子</p>
<p><img src="D:/Note/Typora_picture/image-20201011111729324.png" alt="image-20201011111729324"></p>
<blockquote>
<p>前导码</p>
<ul>
<li>前同步码：作用是使接收方的时钟同步</li>
<li>帧开始定界符：表明其后面紧跟着的就是MAC帧</li>
</ul>
</blockquote>
<p>另外以太网还规定了帧间间隔为96比特时间，因此，MAC帧不需要帧结束定界符</p>
<p><img src="D:/Note/Typora_picture/image-20201011112450187.png" alt="image-20201011112450187"></p>
<h3 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h3><blockquote>
<p><strong>透明</strong></p>
<p>指某一个实际存在的事物看起来却好像不存在一样。</p>
</blockquote>
<p>透明传输是指<strong>数据链路层对上层交付的传输数据没有任何限制</strong>，好像数据链路层不存在一样</p>
<p>帧界定标志也就是个特定数据值，如果在上层交付的协议数据单元中，  恰好也包含这个特定数值，接收方就不能正确接收</p>
<p><img src="D:/Note/Typora_picture/image-20201011113207944.png" alt="image-20201011113207944"></p>
<blockquote>
<p>所以数据链路层应该对上层交付的数据有限制，其内容不能包含帧定界符的值</p>
</blockquote>
<p><strong>解决透明传输问题</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201011113804721.png" alt="image-20201011113804721"></p>
<ul>
<li><strong>解决方法</strong>：面向字节的物理链路使用<strong>字节填充</strong> (byte stuffing) 或<strong>字符填充</strong> (character stuffing)，面向比特的物理链路使用比特填充的方法实现透明传输</li>
<li>发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面<strong>插入一个转义字符“ESC”</strong>(其十六进制编码是1B)。</li>
<li>接收端的数据链路层在将数据送往网络层之前删除插入的转义字符。</li>
<li>如果转义字符也出现在数据当中，那么应在转义字符前面插入一个转义字符 ESC。当接收端收到连续的两个转义字符时，就删除其中前面的一个。</li>
</ul>
<p><strong>帧的数据部分长度</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201011115008209.png" alt="image-20201011115008209"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="D:/Note/Typora_picture/image-20201011115049672.png" alt="image-20201011115049672"></p>
<hr>
<h2 id="3-3、差错检测"><a href="#3-3、差错检测" class="headerlink" title="3.3、差错检测"></a>3.3、差错检测</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p><img src="D:/Note/Typora_picture/image-20201011133757804.png" alt="image-20201011133757804"></p>
<h3 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h3><p><img src="D:/Note/Typora_picture/image-20201011234428217.png" alt="image-20201011234428217"></p>
<h3 id="循环冗余校验CRC-Cyclic-Redundancy-Check"><a href="#循环冗余校验CRC-Cyclic-Redundancy-Check" class="headerlink" title="循环冗余校验CRC(Cyclic Redundancy Check)"></a>循环冗余校验CRC(Cyclic Redundancy Check)</h3><p><img src="D:/Note/Typora_picture/image-20201011234605045.png" alt="image-20201011234605045"></p>
<p><img src="D:/Note/Typora_picture/image-20201011234701845.png" alt="image-20201011234701845"></p>
<p><strong>例题</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201011235128869.png" alt="image-20201011235128869"></p>
<p><img src="D:/Note/Typora_picture/image-20201011235325022.png" alt="image-20201011235325022"></p>
<p><strong>总结</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201011235726437.png" alt="image-20201011235726437"></p>
<blockquote>
<p>循环冗余校验 CRC 是一种检错方法，而帧校验序列 FCS 是添加在数据后面的冗余码</p>
</blockquote>
<hr>
<h2 id="3-4、可靠传输"><a href="#3-4、可靠传输" class="headerlink" title="3.4、可靠传输"></a>3.4、可靠传输</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>下面是比特差错</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201012153605893.png" alt="image-20201012153605893"></p>
<p><strong>其他传输差错</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201012153811724.png" alt="image-20201012153811724"></p>
<ul>
<li>分组丢失</li>
</ul>
<p>路由器输入队列快满了，主动丢弃收到的分组</p>
<p><img src="D:/Note/Typora_picture/image-20201012154910921.png" alt="image-20201012154910921"></p>
<ul>
<li>分组失序</li>
</ul>
<p>数据并未按照发送顺序依次到达接收端</p>
<p><img src="D:/Note/Typora_picture/image-20201012155300937.png" alt="image-20201012155300937"></p>
<ul>
<li>分组重复</li>
</ul>
<p>由于某些原因，有些分组在网络中滞留了，没有及时到达接收端，这可能会造成发送端对该分组的重发，重发的分组到达接收端，但一段时间后，滞留在网络的分组也到达了接收端，这就造成<strong>分组重复</strong>的传输差错</p>
<p><img src="D:/Note/Typora_picture/image-20201012160026362.png" alt="image-20201012160026362"></p>
<h3 id="三种可靠协议"><a href="#三种可靠协议" class="headerlink" title="三种可靠协议"></a>三种可靠协议</h3><ul>
<li>停止-等待协议SW</li>
<li>回退N帧协议GBN</li>
<li>选择重传协议SR</li>
</ul>
<blockquote>
<p>这三种可靠传输实现机制的基本原理并不仅限于数据链路层，可以应用到计算机网络体系结构的各层协议中</p>
</blockquote>
<h4 id="停止-等待协议"><a href="#停止-等待协议" class="headerlink" title="停止-等待协议"></a>停止-等待协议</h4><h5 id="停止-等待协议可能遇到的四个问题"><a href="#停止-等待协议可能遇到的四个问题" class="headerlink" title="停止-等待协议可能遇到的四个问题"></a>停止-等待协议可能遇到的四个问题</h5><p><strong>确认与否认</strong></p>
<img src="D:/Note/Typora_picture/image-20201012162009780.png" alt="image-20201012162009780" style="zoom:67%;" />

<p><strong>超时重传</strong></p>
<img src="D:/Note/Typora_picture/image-20201012162112151.png" alt="image-20201012162112151" style="zoom:67%;" />

<p><strong>确认丢失</strong></p>
<img src="D:/Note/Typora_picture/image-20201012162318298.png" alt="image-20201012162318298" style="zoom:67%;" />

<img src="D:/Note/Typora_picture/image-20201012162348428.png" alt="image-20201012162348428" style="zoom:67%;" />

<blockquote>
<p>既然数据分组需要编号，确认分组是否需要编号？</p>
<p>要。如下图所示</p>
</blockquote>
<p><strong>确认迟到</strong></p>
<img src="D:/Note/Typora_picture/image-20201012162815885.png" alt="image-20201012162815885" style="zoom:67%;" />

<blockquote>
<p>注意，图中最下面那个数据分组与之前序号为0的那个数据分组不是同一个数据分组</p>
</blockquote>
<p><strong>注意事项</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201012164008780.png" alt="image-20201012164008780"></p>
<h5 id="停止-等待协议的信道利用率"><a href="#停止-等待协议的信道利用率" class="headerlink" title="停止-等待协议的信道利用率"></a>停止-等待协议的信道利用率</h5><p>假设收发双方之间是一条直通的信道</p>
<ul>
<li><strong>TD</strong>：是发送方发送数据分组所耗费的发送时延</li>
<li><strong>RTT</strong>：是收发双方之间的往返时间</li>
<li><strong>TA</strong>：是接收方发送确认分组所耗费的发送时延</li>
</ul>
<p>TA一般都远小于TD，可以忽略，当RTT远大于TD时，信道利用率会非常低</p>
<p><img src="D:/Note/Typora_picture/image-20201012164924635.png" alt="image-20201012164924635"></p>
<p><img src="D:/Note/Typora_picture/image-20201012181005719.png" alt="image-20201012181005719"></p>
<p><img src="D:/Note/Typora_picture/image-20201012181047665.png" alt="image-20201012181047665"></p>
<blockquote>
<p>像停止-等待协议这样通过确认和重传机制实现的可靠传输协议，常称为自动请求重传协议ARQ(<strong>A</strong>utomatic <strong>R</strong>epeat re<strong>Q</strong>uest)，意思是重传的请求是自动进行，因为不需要接收方显式地请求，发送方重传某个发送的分组</p>
</blockquote>
<h4 id="回退N帧协议GBN"><a href="#回退N帧协议GBN" class="headerlink" title="回退N帧协议GBN"></a>回退N帧协议GBN</h4><h5 id="为什么用回退N帧协议"><a href="#为什么用回退N帧协议" class="headerlink" title="为什么用回退N帧协议"></a>为什么用回退N帧协议</h5><p>在相同的时间内，使用停止-等待协议的发送方只能发送一个数据分组，而采用流水线传输的发送方，可以发送多个数据分组</p>
<p><img src="D:/Note/Typora_picture/image-20201012190027828.png" alt="image-20201012190027828"></p>
<p>回退N帧协议在流水线传输的基础上，利用发送窗口来限制发送方可连续发送数据分组的个数</p>
<p><img src="D:/Note/Typora_picture/image-20201012190632086.png" alt="image-20201012190632086"></p>
<h5 id="无差错情况流程"><a href="#无差错情况流程" class="headerlink" title="无差错情况流程"></a>无差错情况流程</h5><p>发送方将序号落在发送窗口内的0~4号数据分组，依次连续发送出去</p>
<p><img src="D:/Note/Typora_picture/image-20201012191936466.png" alt="image-20201012191936466"></p>
<p>他们经过互联网传输正确到达接收方，就是没有乱序和误码，接收方按序接收它们，每接收一个，接收窗口就向前滑动一个位置，并给发送方发送针对所接收分组的确认分组，在通过互联网的传输正确到达了发送方</p>
<p><img src="D:/Note/Typora_picture/image-20201012192932035.png" alt="image-20201012192932035"></p>
<p>发送方每接收一个、发送窗口就向前滑动一个位置，这样就有新的序号落入发送窗口，发送方可以将收到确认的数据分组从缓存中删除了，而接收方可以择机将已接收的数据分组交付上层处理</p>
<p><img src="D:/Note/Typora_picture/image-20201012193212419.png" alt="image-20201012193212419"></p>
<h5 id="累计确认"><a href="#累计确认" class="headerlink" title="累计确认"></a><strong>累计确认</strong></h5><p><img src="D:/Note/Typora_picture/image-20201012194304696.png" alt="image-20201012194304696"></p>
<blockquote>
<p>累计确认</p>
<p>优点:</p>
<ul>
<li>即使确认分组丢失，发送方也可能不必重传</li>
<li>减小接收方的开销</li>
<li>减小对网络资源的占用</li>
</ul>
<p>缺点：</p>
<ul>
<li>不能向发送方及时反映出接收方已经正确接收的数据分组信息</li>
</ul>
</blockquote>
<h5 id="有差错情况"><a href="#有差错情况" class="headerlink" title="有差错情况"></a><strong>有差错情况</strong></h5><p>例如</p>
<p>在传输数据分组时，5号数据分组出现误码，接收方通过数据分组中的检错码发现了错误</p>
<p><img src="D:/Note/Typora_picture/image-20201012195440780.png" alt="image-20201012195440780"></p>
<p>于是丢弃该分组，而后续到达的这剩下四个分组与接收窗口的序号不匹配</p>
<p><img src="D:/Note/Typora_picture/image-20201012195629368.png" alt="image-20201012195629368"></p>
<p>接收同样也不能接收它们，讲它们丢弃，并对之前按序接收的最后一个数据分组进行确认，发送ACK4，<strong>每丢弃一个数据分组，就发送一个ACK4</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201012195836902.png" alt="image-20201012195836902"></p>
<p>当收到重复的ACK4时，就知道之前所发送的数据分组出现了差错，于是可以不等超时计时器超时就立刻开始重传，具体收到几个重复确认就立刻重传，根据具体实现决定</p>
<p><img src="D:/Note/Typora_picture/image-20201012200120166.png" alt="image-20201012200120166"></p>
<p> 如果收到这4个重复的确认并不会触发发送立刻重传，一段时间后。超时计时器超时，也会将发送窗口内以发送过的这些数据分组全部重传</p>
<p><img src="D:/Note/Typora_picture/image-20201012200454557.png" alt="image-20201012200454557"></p>
<p>若WT超过取值范围，例如WT&#x3D;8，会出现什么情况？</p>
<p><img src="D:/Note/Typora_picture/image-20201012201109774.png" alt="image-20201012201109774"></p>
<p>习题</p>
<p><img src="D:/Note/Typora_picture/image-20201012202419107.png" alt="image-20201012202419107"></p>
<p><strong>总结</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201012202222138.png" alt="image-20201012202222138"></p>
<ul>
<li>回退N帧协议在流水线传输的基础上利用发送窗口来限制发送方连续发送数据分组的数量，是一种连续ARQ协议</li>
<li>在协议的工作过程中发送窗口和接收窗口不断向前滑动，因此这类协议又称为滑动窗口协议</li>
<li>由于回退N帧协议的特性，当通信线路质量不好时，其信道利用率并不比停止-等待协议高</li>
</ul>
<h4 id="选择重传协议SR"><a href="#选择重传协议SR" class="headerlink" title="选择重传协议SR"></a>选择重传协议SR</h4><p><img src="D:/Note/Typora_picture/image-20201012203638722.png" alt="image-20201012203638722"></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1c4411d7jb?p=27">具体流程请看视频</a></p>
<p><strong>习题</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201012205250996.png" alt="image-20201012205250996"></p>
<p><strong>总结</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201012204742870.png" alt="image-20201012204742870"></p>
<p><img src="D:/Note/Typora_picture/image-20201012205133924.png" alt="image-20201012205133924"></p>
<hr>
<h2 id="3-5、点对点协议PPP"><a href="#3-5、点对点协议PPP" class="headerlink" title="3.5、点对点协议PPP"></a>3.5、点对点协议PPP</h2><ul>
<li>点对点协议PPP（Point-to-Point Protocol）是目前使用最广泛的点对点数据链路层协议</li>
<li>PPP协议是因特网工程任务组IEIF在1992年制定的。经过1993年和1994年的修订，现在的PPP协议已成为因特网的正式标准[RFC1661，RFC1662]</li>
<li>数据链路层使用的一种协议，它的特点是：简单；只检测差错，而不是纠正差错；不使用序号，也不进行流量控制；可同时支持多种网络层协议</li>
</ul>
<p><img src="D:/Note/Typora_picture/image-20201012210844629.png" alt="image-20201012210844629"></p>
<ul>
<li>PPPoE 是为宽带上网的主机使用的链路层协议</li>
</ul>
<p><img src="D:/Note/Typora_picture/image-20201012211423528.png" alt="image-20201012211423528"></p>
<h3 id="帧格式"><a href="#帧格式" class="headerlink" title="帧格式"></a>帧格式</h3><p>必须规定特殊的字符作为帧定界符</p>
<p><img src="D:/Note/Typora_picture/image-20201012211826281.png" alt="image-20201012211826281"></p>
<h3 id="透明传输-1"><a href="#透明传输-1" class="headerlink" title="透明传输"></a>透明传输</h3><p> 必须保证数据传输的透明性</p>
<p>实现透明传输的方法</p>
<ul>
<li>面向字节的异步链路：字节填充法（插入“转义字符”）</li>
</ul>
<p><img src="D:/Note/Typora_picture/image-20201012212148803.png" alt="image-20201012212148803"></p>
<ul>
<li>面向比特的同步链路：比特填充法（插入“比特0”）</li>
</ul>
<p><img src="D:/Note/Typora_picture/image-20201012212255550.png" alt="image-20201012212255550"></p>
<h3 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h3><p>能够对接收端收到的帧进行检测，并立即丢弃有差错的帧。</p>
<p><img src="D:/Note/Typora_picture/image-20201012212558654.png" alt="image-20201012212558654"></p>
<h3 id="工作状态"><a href="#工作状态" class="headerlink" title="工作状态"></a>工作状态</h3><ul>
<li>当用户拨号接入 ISP 时，路由器的调制解调器对拨号做出确认，并建立一条物理连接。</li>
<li>PC 机向路由器发送一系列的 LCP 分组（封装成多个 PPP 帧）。</li>
<li>这些分组及其响应选择一些 PPP 参数，并进行网络层配置，NCP 给新接入的 PC 机</li>
<li>分配一个临时的 IP 地址，使 PC 机成为因特网上的一个主机。</li>
<li>通信完毕时，NCP 释放网络层连接，收回原来分配出去的 IP 地址。接着，LCP 释放数据链路层连接。最后释放的是物理层的连接。</li>
</ul>
<p><img src="D:/Note/Typora_picture/image-20201012213021860.png" alt="image-20201012213021860"></p>
<blockquote>
<p>可见，PPP 协议已不是纯粹的数据链路层的协议，它还包含了物理层和网络层的内容。</p>
</blockquote>
<hr>
<h2 id="3-6、媒体接入控制（介质访问控制）——广播信道"><a href="#3-6、媒体接入控制（介质访问控制）——广播信道" class="headerlink" title="3.6、媒体接入控制（介质访问控制）——广播信道"></a>3.6、媒体接入控制（介质访问控制）——广播信道</h2><p><strong>媒体接入控制（介质访问控制）使用一对多的广播通信方式</strong></p>
<blockquote>
<p><strong>Medium Access Control</strong>翻译成媒体接入控制，有些翻译成介质访问控制</p>
</blockquote>
<p><strong>局域网的数据链路层</strong></p>
<ul>
<li>局域网最主要的<strong>特点</strong>是：<ul>
<li>网络为一个单位所拥有；</li>
<li>地理范围和站点数目均有限。</li>
</ul>
</li>
<li>局域网具有如下<strong>主要优点</strong>：<ul>
<li>具有广播功能，从一个站点可很方便地访问全网。局域网上的主机可共享连接在局域网上的各种硬件和软件资源。 </li>
<li>便于系统的扩展和逐渐地演变，各设备的位置可灵活调整和改变。</li>
<li>提高了系统的可靠性、可用性和残存性。</li>
</ul>
</li>
</ul>
<p><img src="D:/Note/Typora_picture/image-20201013201521915.png" alt="image-20201013201521915"></p>
<p><img src="D:/Note/Typora_picture/image-20201013201533445.png" alt="image-20201013201533445"></p>
<p><strong>数据链路层的两个子层</strong></p>
<p>为了使数据链路层能更好地适应多种局域网标准，IEEE 802 委员会就将局域网的数据链路层拆成<strong>两个子层</strong>：</p>
<ol>
<li><strong>逻辑链路控制</strong> LLC (Logical Link Control)子层；</li>
<li><strong>媒体接入控制</strong> MAC (Medium Access Control)子层。</li>
</ol>
<p>与接入到传输媒体有关的内容都放在 MAC子层，而 LLC 子层则与传输媒体无关。<br><strong>不管采用何种协议的局域网，对 LLC 子层来说都是透明的。</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201013201133903.png" alt="image-20201013201133903"></p>
<h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><p>为什么要媒体接入控制（介质访问控制）？</p>
<p><strong>共享信道带来的问题</strong></p>
<p>若多个设备在共享信道上同时发送数据，则会造成彼此干扰，导致发送失败。</p>
<p><img src="D:/Note/Typora_picture/image-20201013152007335.png" alt="image-20201013152007335"></p>
<p><img src="D:/Note/Typora_picture/image-20201013152453425.png" alt="image-20201013152453425"></p>
<blockquote>
<p>随着技术的发展，交换技术的成熟和成本的降低，具有更高性能的使用点对点链路和链路层交换机的交换式局域网在有线领域已完全取代了共享式局域网，但由于无线信道的广播天性，无线局域网仍然使用的是共享媒体技术</p>
</blockquote>
<h3 id="静态划分信道"><a href="#静态划分信道" class="headerlink" title="静态划分信道"></a>静态划分信道</h3><p><strong>信道复用</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201013153642544.png" alt="image-20201013153642544"></p>
<p><strong>频分复用FDM (Frequency Division Multiplexing)</strong></p>
<ul>
<li><p>将整个带宽分为多份，用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。</p>
</li>
<li><p><strong>频分复用</strong>的所有用户在同样的时间<strong>占用不同的带宽资源</strong>（请注意，这里的“带宽”是频率带宽而不是数据的发送速率）。</p>
</li>
</ul>
<p><img src="D:/Note/Typora_picture/image-20201013153947668.png" alt="image-20201013153947668"></p>
<p><strong>时分复用TDM (Time Division Multiplexing)</strong></p>
<ul>
<li><strong>时分复用</strong>则是将时间划分为一段段等长的<strong>时分复用帧（TDM帧）</strong>。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。</li>
<li>每一个用户所占用的时隙是<strong>周期性地出现</strong>（其周期就是TDM帧的长度）的。</li>
<li>TDM 信号也称为<strong>等时</strong> (isochronous) 信号。</li>
<li><strong>时分复用的所有用户在不同的时间占用同样的频带宽度。</strong></li>
</ul>
<p><img src="D:/Note/Typora_picture/image-20201013154142540.png" alt="image-20201013154142540"></p>
<p><strong>波分复用 WDM(Wavelength Division Multiplexing)</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201013202218132.png" alt="image-20201013202218132"></p>
<blockquote>
<p>波分复用就是光的频分复用，使用一根光纤来同时传输多个光载波信号</p>
<p>光信号传输一段距离后悔衰减，所以要用 掺铒光纤放大器 放大光信号</p>
</blockquote>
<p><strong>码分复用 CDM  (Code Division Multiplexing)</strong> </p>
<p><img src="D:/Note/Typora_picture/image-20201013203126625.png" alt="image-20201013203126625"></p>
<p><img src="D:/Note/Typora_picture/image-20201013203324709.png" alt="image-20201013203324709"></p>
<p><img src="D:/Note/Typora_picture/image-20201013203459640.png" alt="image-20201013203459640"></p>
<p><img src="D:/Note/Typora_picture/image-20201013203819578.png" alt="image-20201013203819578"></p>
<h3 id="动态接入控制"><a href="#动态接入控制" class="headerlink" title="动态接入控制"></a>动态接入控制</h3><p>受控接入</p>
<p><strong>受控接入在局域网中使用得较少，本书不再讨论</strong></p>
<p><strong>随机接入</strong></p>
<p><strong>重点</strong></p>
<h3 id="随机接入（CSMA-x2F-CD协议）"><a href="#随机接入（CSMA-x2F-CD协议）" class="headerlink" title="随机接入（CSMA&#x2F;CD协议）"></a>随机接入（CSMA&#x2F;CD协议）</h3><p><strong>总线局域网使用协议：CSMA&#x2F;CD</strong></p>
<h4 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h4><p><strong>最初</strong>的<strong>以太网</strong>是将许多计算机都连接到一根总线上。易于实现广播通信。当初认为这样的连接方法既简单又可靠，因为总线上没有有源器件。</p>
<blockquote>
<p><strong>以太网（Ethernet）</strong>是一种计算机<strong>局域网技术</strong>。IEEE组织的IEEE 802.3标准制定了<strong>以太网（Ethernet）</strong>的技术标准</p>
<p>以太网采用无连接的工作方式，对发送的数据帧不进行编号，也不要求对方发回确认。目的站收到有差错帧就把它丢弃，其他什么也不做</p>
</blockquote>
<p><img src="D:/Note/Typora_picture/image-20201013211620687.png" alt="image-20201013211620687"></p>
<p><img src="D:/Note/Typora_picture/image-20201013213102777.png" alt="image-20201013213102777"></p>
<h4 id="多址接入MA"><a href="#多址接入MA" class="headerlink" title="多址接入MA"></a>多址接入MA</h4><p>表示许多主机以多点接入的方式连接在一根总线上。</p>
<p><img src="D:/Note/Typora_picture/image-20201013215400688.png" alt="image-20201013215400688"></p>
<h4 id="载波监听CS"><a href="#载波监听CS" class="headerlink" title="载波监听CS"></a>载波监听CS</h4><p>是指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据，如果有，则暂时不要发送数据，以免发生碰撞。</p>
<p><img src="D:/Note/Typora_picture/image-20201013215530979.png" alt="image-20201013215530979"></p>
<p>总线上并没有什么“载波”。因此， <strong>“载波监听”就是用电子技术检测总线上有没有其他计算机发送的数据信号。</strong></p>
<h4 id="碰撞检测CD"><a href="#碰撞检测CD" class="headerlink" title="碰撞检测CD"></a>碰撞检测CD</h4><ul>
<li><strong>“碰撞检测”</strong>就是计算机<strong>边发送数据边检测</strong>信道上的信号电压大小。</li>
<li>当几个站同时在总线上发送数据时，总线上的信号电压摆动值将会增大（互相叠加）。</li>
<li>当一个站检测到的信号电压摆动值超过一定的门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞。</li>
<li><strong>所谓“碰撞”就是发生了冲突。因此“碰撞检测”也称为“冲突检测”。</strong></li>
<li>在发生碰撞时，总线上传输的信号产生了严重的失真，无法从中恢复出有用的信息来。</li>
<li><strong>每一个正在发送数据的站，一旦发现总线上出现了碰撞，就要立即停止发送，免得继续浪费网络资源，然后等待一段随机时间后再次发送。</strong></li>
</ul>
<p><img src="D:/Note/Typora_picture/image-20201013221240514.png" alt="image-20201013221240514"></p>
<blockquote>
<p>为什么要进行碰撞检测？ 因为信号传播时延对载波监听产生了影响</p>
<p><img src="D:/Note/Typora_picture/image-20201013221834942.png" alt="image-20201013221834942"></p>
<p>A 需要单程传播时延的 2 倍的时间，才能检测到与 B 的发送产生了冲突</p>
</blockquote>
<h4 id="CSMA-x2F-CD-协议工作流程"><a href="#CSMA-x2F-CD-协议工作流程" class="headerlink" title="CSMA&#x2F;CD 协议工作流程"></a>CSMA&#x2F;CD 协议工作流程</h4><p><img src="D:/Note/Typora_picture/image-20201013221705893.png" alt="image-20201013221705893"></p>
<h4 id="CSMA-x2F-CD-协议工作——争用期（碰撞窗口）"><a href="#CSMA-x2F-CD-协议工作——争用期（碰撞窗口）" class="headerlink" title="CSMA&#x2F;CD 协议工作——争用期（碰撞窗口）"></a>CSMA&#x2F;CD 协议工作——争用期（碰撞窗口）</h4><p><img src="D:/Note/Typora_picture/image-20201013223235305.png" alt="image-20201013223235305"></p>
<h4 id="CSMA-x2F-CD-协议工作——最小帧长"><a href="#CSMA-x2F-CD-协议工作——最小帧长" class="headerlink" title="CSMA&#x2F;CD 协议工作——最小帧长"></a>CSMA&#x2F;CD 协议工作——最小帧长</h4><p><img src="D:/Note/Typora_picture/image-20201013224051932.png" alt="image-20201013224051932"></p>
<h4 id="CSMA-x2F-CD-协议工作——最大帧长"><a href="#CSMA-x2F-CD-协议工作——最大帧长" class="headerlink" title="CSMA&#x2F;CD 协议工作——最大帧长"></a>CSMA&#x2F;CD 协议工作——最大帧长</h4><p><img src="D:/Note/Typora_picture/image-20201013225400777.png" alt="image-20201013225400777"></p>
<h4 id="CSMA-x2F-CD-协议工作——截断二进制指数退避算法"><a href="#CSMA-x2F-CD-协议工作——截断二进制指数退避算法" class="headerlink" title="CSMA&#x2F;CD 协议工作——截断二进制指数退避算法"></a>CSMA&#x2F;CD 协议工作——截断二进制指数退避算法</h4><p><img src="D:/Note/Typora_picture/image-20201013230717856.png" alt="image-20201013230717856"></p>
<h4 id="CSMA-x2F-CD-协议工作——信道利用率"><a href="#CSMA-x2F-CD-协议工作——信道利用率" class="headerlink" title="CSMA&#x2F;CD 协议工作——信道利用率"></a>CSMA&#x2F;CD 协议工作——信道利用率</h4><p><img src="D:/Note/Typora_picture/image-20201013231430295.png" alt="image-20201013231430295"></p>
<h4 id="CSMA-x2F-CD-协议工作——帧接收流程"><a href="#CSMA-x2F-CD-协议工作——帧接收流程" class="headerlink" title="CSMA&#x2F;CD 协议工作——帧接收流程"></a>CSMA&#x2F;CD 协议工作——帧接收流程</h4><p><img src="D:/Note/Typora_picture/image-20201013231703302.png" alt="image-20201013231703302"></p>
<h4 id="CSMA-x2F-CD-协议的重要特性"><a href="#CSMA-x2F-CD-协议的重要特性" class="headerlink" title="CSMA&#x2F;CD 协议的重要特性"></a>CSMA&#x2F;CD 协议的重要特性</h4><ul>
<li>使用 CSMA&#x2F;CD 协议的以太网不能进行全双工通信而<strong>只能进行双向交替通信（半双工通信）。</strong></li>
<li>每个站在发送数据之后的一小段时间内，存在着遭遇碰撞的可能性。 </li>
<li>这种<strong>发送的不确定性</strong>使整个以太网的平均通信量远小于以太网的最高数据率。</li>
</ul>
<blockquote>
<p>CSMA&#x2F;CD协议曾经用于各种总线结构以太网和双绞线以太网的早起版本中。</p>
<p><strong>现在的以太网基于交换机和全双工连接，不会有碰撞，因此没有必要使用CSMA&#x2F;CS协议</strong></p>
</blockquote>
<h3 id="随机接入（CSMA-x2F-CA协议）"><a href="#随机接入（CSMA-x2F-CA协议）" class="headerlink" title="随机接入（CSMA&#x2F;CA协议）"></a>随机接入（CSMA&#x2F;CA协议）</h3><p><strong>无线局域网使用的协议：CSMA&#x2F;CA</strong></p>
<h4 id="为什么无线局域网要使用CSMA-x2F-CA协议"><a href="#为什么无线局域网要使用CSMA-x2F-CA协议" class="headerlink" title="为什么无线局域网要使用CSMA&#x2F;CA协议"></a>为什么无线局域网要使用CSMA&#x2F;CA协议</h4><p><img src="D:/Note/Typora_picture/image-20201014192811760.png" alt="image-20201014192811760"></p>
<h4 id="帧间间隔IFS（InterFrame-Space）"><a href="#帧间间隔IFS（InterFrame-Space）" class="headerlink" title="帧间间隔IFS（InterFrame Space）"></a>帧间间隔IFS（InterFrame Space）</h4><p><img src="D:/Note/Typora_picture/image-20201014200149717.png" alt="image-20201014200149717"></p>
<h4 id="CSMA-x2F-CA协议的工作原理"><a href="#CSMA-x2F-CA协议的工作原理" class="headerlink" title="CSMA&#x2F;CA协议的工作原理"></a>CSMA&#x2F;CA协议的工作原理</h4><p><img src="D:/Note/Typora_picture/image-20201014200833233.png" alt="image-20201014200833233"></p>
<blockquote>
<p><strong>源站为什么在检测到信道空闲后还要再等待一段时间DIFS？</strong></p>
<ul>
<li>考虑到可能有其他的站有高优先级的帧要发送。若有，就要让高优先级帧先发送</li>
</ul>
<p><strong>目的站为什么正确接收数据帧后还要等待一段时间SIFS才能发送ACK帧？</strong></p>
<ul>
<li>SIFS是最短的帧间间隔，用来分隔开属于一次对话的各帧，在这段时间内，一个站点应当能够从发送方式切换到接收方式</li>
</ul>
</blockquote>
<p><img src="D:/Note/Typora_picture/image-20201014201511741.png" alt="image-20201014201511741"></p>
<blockquote>
<p><strong>信道由忙转为空闲且经过DIFS时间后，还要退避一段随机时间才能使用信道？</strong></p>
<p>防止多个站点同时发送数据而产生碰撞</p>
</blockquote>
<p><strong>使用退避算法的时机</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201014201927680.png" alt="image-20201014201927680"></p>
<h4 id="CSMA-x2F-CA协议的退避算法"><a href="#CSMA-x2F-CA协议的退避算法" class="headerlink" title="CSMA&#x2F;CA协议的退避算法"></a>CSMA&#x2F;CA协议的退避算法</h4><p><img src="D:/Note/Typora_picture/image-20201014202213766.png" alt="image-20201014202213766"></p>
<p><strong>退避算法的示例</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201014202819851.png" alt="image-20201014202819851"></p>
<h4 id="CSMA-x2F-CA协议的信道预约和虚拟载波监听"><a href="#CSMA-x2F-CA协议的信道预约和虚拟载波监听" class="headerlink" title="CSMA&#x2F;CA协议的信道预约和虚拟载波监听"></a>CSMA&#x2F;CA协议的信道预约和虚拟载波监听</h4><p><img src="D:/Note/Typora_picture/image-20201014203119710.png" alt="image-20201014203119710"></p>
<p><img src="D:/Note/Typora_picture/image-20201014203506878.png" alt="image-20201014203506878"></p>
<p><strong>虚拟载波监听机制能减少隐蔽站带来的碰撞问题的示例</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201014203859033.png" alt="image-20201014203859033"></p>
<hr>
<h2 id="3-7、MAC地址、IP地址以及ARP协议"><a href="#3-7、MAC地址、IP地址以及ARP协议" class="headerlink" title="3.7、MAC地址、IP地址以及ARP协议"></a>3.7、MAC地址、IP地址以及ARP协议</h2><p><img src="D:/Note/Typora_picture/image-20201014222831663.png" alt="image-20201014222831663"></p>
<h3 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h3><blockquote>
<ul>
<li>使用点对点信道的数据链路层不需要使用地址</li>
<li>使用广播信道的数据链路层必须使用地址来区分各主机</li>
</ul>
</blockquote>
<p><img src="D:/Note/Typora_picture/image-20201014223659993.png" alt="image-20201014223659993"></p>
<h4 id="广播信道的数据链路层必须使用地址（MAC）"><a href="#广播信道的数据链路层必须使用地址（MAC）" class="headerlink" title="广播信道的数据链路层必须使用地址（MAC）"></a>广播信道的数据链路层必须使用地址（MAC）</h4><p><img src="D:/Note/Typora_picture/image-20201014224732019.png" alt="image-20201014224732019"></p>
<blockquote>
<p><strong>MAC地址又称为硬件地址或物理地址</strong>。请注意：不要被 “物理” 二字误导认为物理地址属于物理层范畴，物理地址属于数据链路层范畴</p>
</blockquote>
<h4 id="IEEE-802局域网的MAC地址格式"><a href="#IEEE-802局域网的MAC地址格式" class="headerlink" title="IEEE 802局域网的MAC地址格式"></a>IEEE 802局域网的MAC地址格式</h4><p><img src="D:/Note/Typora_picture/image-20201014225358570.png" alt="image-20201014225358570"></p>
<blockquote>
<p><strong>组织唯一标识符OUI</strong></p>
<ul>
<li>生产网络设备的厂商，需要向IEEE的注册管理机构申请一个或多个OUI</li>
</ul>
<p><strong>网络接口标识符</strong></p>
<ul>
<li>由获得OUI的厂商自行随意分配</li>
</ul>
<p><strong>EUI-48</strong></p>
<ul>
<li>48是这个MAC地址的位数</li>
</ul>
</blockquote>
<p><img src="D:/Note/Typora_picture/image-20201014230248959.png" alt="image-20201014230248959"></p>
<blockquote>
<p>对于使用EUI-48空间的应用程序，IEEE的目标寿命为100年（直到2080年），但是鼓励采用EUI-64作为替代</p>
</blockquote>
<p><strong>关于无效的 MAC 帧</strong></p>
<ul>
<li>数据字段的长度与长度字段的值不一致；</li>
<li>帧的长度不是整数个字节；</li>
<li>用收到的帧检验序列 FCS 查出有差错；</li>
<li>数据字段的长度不在 46 ~ 1500 字节之间。</li>
<li>有效的 MAC 帧长度为 64 ~ 1518 字节之间。</li>
</ul>
<blockquote>
<p><strong>对于检查出的无效</strong> <strong>MAC</strong> <strong>帧就简单地丢弃。以太网不负责重传丢弃的帧。</strong> </p>
</blockquote>
<h4 id="IEEE-802局域网的MAC地址发送顺序"><a href="#IEEE-802局域网的MAC地址发送顺序" class="headerlink" title="IEEE 802局域网的MAC地址发送顺序"></a>IEEE 802局域网的MAC地址发送顺序</h4><p><img src="D:/Note/Typora_picture/image-20201014230625182.png" alt="image-20201014230625182"></p>
<h4 id="单播MAC地址举例"><a href="#单播MAC地址举例" class="headerlink" title="单播MAC地址举例"></a>单播MAC地址举例</h4><p><img src="D:/Note/Typora_picture/image-20201014230822305.png" alt="image-20201014230822305"></p>
<blockquote>
<p>主机B给主机C发送<strong>单播帧</strong>，主机B首先要构建该<strong>单播帧</strong>，<strong>在帧首部中的目的地址字段填入主机C的MAC地址</strong>，源地址字段填入自己的MAC地址，再加上帧首部的其他字段、数据载荷以及帧尾部，就构成了该<strong>单播帧</strong></p>
</blockquote>
<p><img src="D:/Note/Typora_picture/image-20201014231244655.png" alt="image-20201014231244655"></p>
<blockquote>
<p>主机B将该<strong>单播帧</strong>发送出去，主机A和C都会收到该<strong>单播帧</strong></p>
<p>主机A的网卡发现该<strong>单播帧</strong>的目的MAC地址与自己的MAC地址不匹配，丢弃该帧</p>
<p>主机C的网卡发现该<strong>单播帧</strong>的目的MAC地址与自己的MAC地址匹配，接受该帧</p>
<p>并将该帧交给其上层处理</p>
</blockquote>
<h4 id="广播MAC地址举例"><a href="#广播MAC地址举例" class="headerlink" title="广播MAC地址举例"></a>广播MAC地址举例</h4><p><img src="D:/Note/Typora_picture/image-20201014231754669.png" alt="image-20201014231754669"></p>
<blockquote>
<p>假设主机B要发送一个<strong>广播帧</strong>，主机B首先要构建该<strong>广播帧</strong>，<strong>在帧首部中的目的地址字段填入广播地址</strong>，也就是十六进制的全F，源地址字段填入自己的MAC地址，再加上帧首部中的其他字段、数据载荷以及帧尾部，就构成了该<strong>广播帧</strong></p>
</blockquote>
<p><img src="D:/Note/Typora_picture/image-20201014232132424.png" alt="image-20201014232132424"></p>
<blockquote>
<p>主机B讲该<strong>广播帧</strong>发送出去，主机A和C都会收到该<strong>广播帧</strong>，<strong>发现该帧首部中的目的地址字段的内容是广播地址</strong>，就知道该帧是<strong>广播帧</strong>，主机A和主机C都接受该帧，并将该帧交给上层处理</p>
</blockquote>
<h4 id="多播MAC地址举例"><a href="#多播MAC地址举例" class="headerlink" title="多播MAC地址举例"></a>多播MAC地址举例</h4><p><img src="D:/Note/Typora_picture/image-20201014232714791.png" alt="image-20201014232714791"></p>
<blockquote>
<p>假设主机A要发送<strong>多播帧</strong>给该<strong>多播地址</strong>。将该<strong>多播地址</strong>的左起第一个字节写成8个比特，第一个字节的最低比特位是1，这就表明该地址是<strong>多播地址</strong>。</p>
<p>快速判断地址是不是<strong>多播地址</strong>，就是上图所示箭头所指的第十六进制数不能整除2（1,3,5,7,9,B,D,F），则该地址是<strong>多播地址</strong></p>
<p>假设主机B，C和D支持多播，各用户给自己的主机配置多播组列表<strong>如下所示</strong></p>
</blockquote>
<p><img src="D:/Note/Typora_picture/image-20201015001243584.png" alt="image-20201015001243584"></p>
<blockquote>
<p>主机B属于两个多播组，主机C也属于两个多播组，而主机D不属于任何多播组</p>
</blockquote>
<p><img src="D:/Note/Typora_picture/image-20201015001535528.png" alt="image-20201015001535528"></p>
<blockquote>
<p>主机A首先要构建该<strong>多播帧</strong>，<strong>在帧首部中的目的地址字段填入该多播地址</strong>，源地址点填入自己的MAC地址，再加上帧首部中的其他字段、数据载荷以及帧尾部，就构成了该<strong>多播帧</strong></p>
</blockquote>
<p><img src="D:/Note/Typora_picture/image-20201015002054876.png" alt="image-20201015002054876"></p>
<blockquote>
<p>主机A将该<strong>多播帧</strong>发送出去，主机B、C、D都会收到该<strong>多播帧</strong></p>
<p><strong>主机B和C发现该多播帧的目的MAC地址在自己的多播组列表中</strong>，主机B和C都会接受该帧</p>
<p>主机D发现该<strong>多播帧</strong>的目的MAC地址不在自己得多播组列表中，则丢弃该<strong>多播帧</strong></p>
</blockquote>
<blockquote>
<p>给主机配置多播组列表进行私有应用时，不得使用公有的标准多播地址</p>
</blockquote>
<h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p>IP地址属于网络层的范畴，不属于数据链路层的范畴</p>
<p>下面内容讲的是IP地址的使用，详细的IP地址内容在网络层中介绍</p>
<h4 id="基本概念-3"><a href="#基本概念-3" class="headerlink" title="基本概念"></a>基本概念</h4><p><img src="D:/Note/Typora_picture/image-20201015104441580.png" alt="image-20201015104441580"></p>
<h4 id="从网络体系结构看IP地址与MAC地址"><a href="#从网络体系结构看IP地址与MAC地址" class="headerlink" title="从网络体系结构看IP地址与MAC地址"></a>从网络体系结构看IP地址与MAC地址</h4><p><img src="D:/Note/Typora_picture/image-20201015104913755.png" alt="image-20201015104913755"></p>
<h4 id="数据包转发过程中IP地址与MAC地址的变化情况"><a href="#数据包转发过程中IP地址与MAC地址的变化情况" class="headerlink" title="数据包转发过程中IP地址与MAC地址的变化情况"></a>数据包转发过程中IP地址与MAC地址的变化情况</h4><p>图上各主机和路由器各接口的IP地址和MAC地址用简单的标识符来表示</p>
<p><img src="D:/Note/Typora_picture/image-20201015105455043.png" alt="image-20201015105455043"></p>
<p><img src="D:/Note/Typora_picture/image-20210103212224961.png" alt="image-20210103212224961"></p>
<blockquote>
<p>如何从IP地址找出其对应的MAC地址？</p>
<p>ARP协议</p>
</blockquote>
<h3 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h3><p>如何从IP地址找出其对应的MAC地址？</p>
<p>ARP（地址解析协议）</p>
<h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p><img src="D:/Note/Typora_picture/image-20201015113826197.png" alt="image-20201015113826197"></p>
<p>ARP高速缓存表</p>
<p><img src="D:/Note/Typora_picture/image-20201015114052206.png" alt="image-20201015114052206"></p>
<blockquote>
<p>当主机B要给主机C发送数据包时，会首先在自己的ARP高速缓存表中查找主机C的IP地址所对应的MAC地址，但未找到，因此，主机B需要发送ARP请求报文，来获取主机C的MAC地址</p>
</blockquote>
<p><img src="D:/Note/Typora_picture/image-20201015114444263.png" alt="image-20201015114444263"></p>
<blockquote>
<p>ARP请求报文有具体的格式，上图的只是简单描述</p>
<p>ARP请求报文被封装在MAC帧中发送，目的地址为广播地址</p>
<p>主机B发送封装有ARP请求报文的广播帧，总线上的其他主机都能收到该广播帧</p>
</blockquote>
<p><img src="D:/Note/Typora_picture/image-20201015114811501.png" alt="image-20201015114811501"></p>
<blockquote>
<p>收到ARP请求报文的主机A和主机C会把ARP请求报文交给上层的ARP进程</p>
<p>主机A发现所询问的IP地址不是自己的IP地址，因此不用理会</p>
<p>主机C的发现所询问的IP地址是自己的IP地址，需要进行相应</p>
</blockquote>
<p><img src="D:/Note/Typora_picture/image-20201015115212170.png" alt="image-20201015115212170"></p>
<p><img src="D:/Note/Typora_picture/image-20201015115236673.png" alt="image-20201015115236673"></p>
<p><img src="D:/Note/Typora_picture/image-20201015115252972.png" alt="image-20201015115252972"></p>
<p>动态与静态的区别</p>
<p><img src="D:/Note/Typora_picture/image-20201015115831543.png" alt="image-20201015115831543"></p>
<p><strong>ARP协议只能在一段链路或一个网络上使用，而不能跨网络使用</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201015120108028.png" alt="image-20201015120108028"></p>
<blockquote>
<p>ARP协议的使用是逐段链路进行的</p>
</blockquote>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p><img src="D:/Note/Typora_picture/image-20201015120707150.png" alt="image-20201015120707150"></p>
<blockquote>
<p>ARP表中的IP地址与MAC地址的对应关系记录，是<strong>会定期自动删除的</strong>，<strong>因为IP地址与MAC地址的对应关系不是永久性的</strong></p>
</blockquote>
<hr>
<h2 id="3-8、集线器与交换机的区别"><a href="#3-8、集线器与交换机的区别" class="headerlink" title="3.8、集线器与交换机的区别"></a>3.8、集线器与交换机的区别</h2><h3 id="集线器-在物理层扩展以太网"><a href="#集线器-在物理层扩展以太网" class="headerlink" title="集线器-在物理层扩展以太网"></a>集线器-在物理层扩展以太网</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p><img src="D:/Note/Typora_picture/image-20201015144628691.png" alt="image-20201015144628691"></p>
<blockquote>
<ul>
<li>传统以太网最初是使用粗同轴电缆，后来演进到使用比较便宜的细同轴电缆，最后发展为使用更便宜和更灵活的双绞线。</li>
<li>采用双绞线的以太网采用星形拓扑，在星形的中心则增加了一种可靠性非常高的设备，叫做<strong>集线器</strong> (hub)。</li>
<li><strong>集线器</strong>是也可以看做多口中继器，每个端口都可以成为一个中继器，中继器是对减弱的信号进行放大和发送的设备</li>
<li><strong>集线器</strong>的以太网在逻辑上仍是个总线网，需要使用CSMA&#x2F;CD协议来协调各主机争用总线，只能工作在半双工模式，收发帧不能同时进行</li>
</ul>
</blockquote>
<h4 id="集线器HUB在物理层扩展以太网"><a href="#集线器HUB在物理层扩展以太网" class="headerlink" title="集线器HUB在物理层扩展以太网"></a>集线器HUB在物理层扩展以太网</h4><p><strong>使用集线器扩展</strong>：将多个以太网段连成更大的、多级星形结构的以太网</p>
<p><img src="D:/Note/Typora_picture/image-20201015145732275.png" alt="image-20201015145732275"></p>
<blockquote>
<ul>
<li><strong>优点</strong><ol>
<li>使原来属于不同碰撞域的以太网上的计算机能够进行跨碰撞域的通信。</li>
<li>扩大了以太网覆盖的地理范围。</li>
</ol>
</li>
<li><strong>缺点</strong><ol>
<li>碰撞域增大了，但总的吞吐量并未提高。</li>
<li>如果不同的碰撞域使用不同的数据率，那么就不能用集线器将它们互连起来。</li>
</ol>
</li>
</ul>
</blockquote>
<p><strong>碰撞域</strong></p>
<ul>
<li><strong>碰撞域（collision domain）</strong>又称为<strong>冲突域</strong>，是指网络中一个站点发出的帧会与其他站点发出的帧产生碰撞或冲突的那部分网络。</li>
<li>碰撞域越大，发生碰撞的概率越高。</li>
</ul>
<h3 id="以太网交换机-在数据链路层扩展以太网"><a href="#以太网交换机-在数据链路层扩展以太网" class="headerlink" title="以太网交换机-在数据链路层扩展以太网"></a>以太网交换机-在数据链路层扩展以太网</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><ul>
<li>扩展以太网更常用的方法是在数据链路层进行。</li>
<li>早期使用<strong>网桥</strong>，现在使用<strong>以太网交换机</strong>。</li>
</ul>
<p><img src="D:/Note/Typora_picture/image-20201015150620067.png" alt="image-20201015150620067"></p>
<blockquote>
<p><strong>网桥</strong></p>
<ul>
<li>网桥工作在数据链路层。</li>
<li>它根据 MAC 帧的目的地址对收到的帧进行转发和过滤。</li>
<li>当网桥收到一个帧时，并不是向所有的接口转发此帧，而是先检查此帧的目的MAC 地址，然后再确定将该帧转发到哪一个接口，或把它丢弃。</li>
</ul>
<p><strong>交换机</strong></p>
<ul>
<li>1990 年问世的交换式集线器 (switching hub) 可明显地提高以太网的性能。</li>
<li>交换式集线器常称为<strong>以太网交换机</strong> (switch) 或<strong>第二层交换机</strong> (L2 switch)，强调这种交换机工作在数据链路层。</li>
<li>以太网交换机实质上就是一个<strong>多接口的网桥</strong></li>
</ul>
</blockquote>
<h4 id="集线器HUB与交换机SWITCH区别"><a href="#集线器HUB与交换机SWITCH区别" class="headerlink" title="集线器HUB与交换机SWITCH区别"></a><strong>集线器HUB与交换机SWITCH区别</strong></h4><p><img src="D:/Note/Typora_picture/image-20201015152232158.png" alt="image-20201015152232158"></p>
<blockquote>
<p>使用<strong>集线器</strong>互连而成的共享总线式以太网上的某个主机，要给另一个主机发送单播帧，该单播帧会通过共享总线传输到<strong>总线上的其他各个主机</strong></p>
<p>使用交换机互连而成的交换式以太网上的某个主机，要给另一个主机发送单播帧，该单播帧进入交换机后，交换机会将该单播帧转发给目的主机，<strong>而不是网络中的其他各个主机</strong></p>
<p><strong>这个例子的前提条件是忽略ARP过程，并假设交换机的帧交换表已经学习或配置好了</strong></p>
</blockquote>
<p><img src="D:/Note/Typora_picture/image-20201015152858146.png" alt="image-20201015152858146"></p>
<blockquote>
<p><strong>以太网交换机的交换方式</strong></p>
<ul>
<li>存储转发方式<ul>
<li>把整个数据帧<strong>先缓存</strong>后再进行处理。</li>
</ul>
</li>
<li>直通 (cut-through) 方式<ul>
<li>接收数据帧的同时就<strong>立即按数据帧的目的 MAC 地址决定该帧的转发接口</strong>，因而提高了帧的转发速度。</li>
<li><strong>缺点</strong>是它不检查差错就直接将帧转发出去，因此有可能也将一些无效帧转发给其他的站。</li>
</ul>
</li>
</ul>
<p><strong>这个例子的前提条件是忽略ARP过程，并假设交换机的帧交换表已经学习或配置好了</strong></p>
</blockquote>
<p><strong>对比集线器和交换机</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201015153907268.png" alt="image-20201015153907268"></p>
<p><img src="D:/Note/Typora_picture/image-20201015154523036.png" alt="image-20201015154523036"></p>
<blockquote>
<p>多台主机同时给另一台主机发送单播帧</p>
<p>集线器以太网：会产生碰撞，遭遇碰撞的帧会传播到总线上的各主机</p>
<p>交换机以太网：会将它们缓存起来，然后逐个转发给目的主机，不会产生碰撞</p>
<p><strong>这个例子的前提条件是忽略ARP过程，并假设交换机的帧交换表已经学习或配置好了</strong></p>
</blockquote>
<p><strong>集线器扩展以太网和交换机扩展以太网区别</strong></p>
<p><strong>单播</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201015155408692.png" alt="image-20201015155408692"></p>
<p><strong>广播</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201015155440402.png" alt="image-20201015155440402"></p>
<p><strong>多个单播</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201015155526386.png" alt="image-20201015155526386"></p>
<p><img src="D:/Note/Typora_picture/image-20201015155706698.png" alt="image-20201015155706698"></p>
<p>广播域（broadcast domain）：指这样一部分网络，其中任何一台设备发出的广播通信都能被该部分网络中的所有其他设备所接收。</p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p><img src="D:/Note/Typora_picture/image-20201015160146482.png" alt="image-20201015160146482"></p>
<p><img src="D:/Note/Typora_picture/image-20201015160526999.png" alt="image-20201015160526999"></p>
<blockquote>
<p>工作在数据链路层的以太网交换机，其性能远远超过工作在物理层的集线器，而且价格并不贵，这就使得集线器逐渐被市场淘汰</p>
</blockquote>
<hr>
<h2 id="3-9、以太网交换机自学习和转发帧的流程"><a href="#3-9、以太网交换机自学习和转发帧的流程" class="headerlink" title="3.9、以太网交换机自学习和转发帧的流程"></a>3.9、以太网交换机自学习和转发帧的流程</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p><img src="D:/Note/Typora_picture/image-20201015161015165.png" alt="image-20201015161015165"></p>
<h3 id="自学习和转发帧的例子"><a href="#自学习和转发帧的例子" class="headerlink" title="自学习和转发帧的例子"></a>自学习和转发帧的例子</h3><p>以下例子假设各主机知道网络中其他各主机的MAC地址（无需进行ARP）</p>
<p><strong>A -&gt; B</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201015161458528.png" alt="image-20201015161458528"></p>
<blockquote>
<ol>
<li>A 先向 B 发送一帧。该帧从接口 1 进入到交换机</li>
<li>交换机收到帧后，先查找（图中左边）交换表。没有查到应从哪个接口转发这个帧给 B</li>
<li>交换机把这个帧的源地址 A 和接口 1 写入（图中左边）交换表中</li>
<li>交换机向除接口 1 以外的所有的接口广播这个帧</li>
<li>接口 4到接口 2，先查找（图中右边）交换表。没有查到应从哪个接口转发这个帧给 B</li>
<li>交换机把这个帧的源地址 A 和接口 1 写入（图中右边）交换表中</li>
<li>除B主机之外与该帧的目的地址不相符，将丢弃该帧</li>
<li>主机B发现是给自己的帧，接受该帧</li>
</ol>
</blockquote>
<p><strong>B -&gt; A</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201015162310922.png" alt="image-20201015162310922"></p>
<blockquote>
<ol>
<li>B 向 A 发送一帧。该帧从接口 3 进入到交换机</li>
<li>交换机收到帧后，先查找（图中左边）交换表。发现（图中左边）交换表中的 MAC 地址有 A，表明要发送给A的帧应从接口1转发出去。于是就把这个帧传送到接口 1 转发给 A。</li>
<li>主机 A 发现目的地址是它，就接受该帧</li>
<li>交换机把这个帧的源地址 B 和接口 3 写入（图中左边）交换表中</li>
</ol>
</blockquote>
<p><strong>E -&gt; A</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201015162622462.png" alt="image-20201015162622462"></p>
<blockquote>
<ol>
<li>E 向 A发送一帧</li>
<li>交换机收到帧后，先查找（图中右边）交换表。发现（图中右边）交换表中的 MAC 地址有 A，表明要发送给A的帧应从接口2转发出去。于是就把这个帧传送到接口 2 转发给 接口 4。</li>
<li>交换机把这个帧的源地址 E 和接口 3 写入（图中右边）交换表中</li>
<li>接口 4 到 左边的交换机，先查找（图中左边）交换表。发现（图中左边）交换表中的 MAC 地址有 A，表明要发送给A的帧应从接口1转发出去。于是就把这个帧传送到接口 1 转发给 A。</li>
<li>交换机把这个帧的源地址 E 和接口 4 写入（图中左边）交换表中</li>
<li>主机 A 发现目的地址是它，就接受该帧</li>
</ol>
</blockquote>
<p><strong>G -&gt; A</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201015163157140.png" alt="image-20201015163157140"></p>
<blockquote>
<p>主机 A、主机 G、交换机 1的接口 1就共享同一条总线（相当于总线式网络，可以想象成用集线器连接了）</p>
<ol>
<li>主机 G 发送给 主机 A 一个帧</li>
<li>主机 A 和 交换机接口 1都能接收到</li>
<li>主机 A 的网卡收到后，根据帧的目的MAC地址A，就知道是发送给自己的帧，就接受该帧</li>
<li>交换机 1收到该帧后，首先进行登记工作</li>
<li>然后交换机 1对该帧进行转发，该帧的MAC地址是A，在（图中左边）交换表查找MAC 地址有 A</li>
<li>MAC 地址为 A的接口号是1，但是该帧正是从接口 1 进入交换机的，交换机不会再从该接口 1 将帧转发出去，因为这是没有必要，于是丢弃该帧</li>
</ol>
</blockquote>
<p>随着网络中各主机都发送了帧后，网络中的各交换机就可以学习到各主机的MAC地址，以及它们与自己各接口的对应关系</p>
<p><img src="D:/Note/Typora_picture/image-20201015164210543.png" alt="image-20201015164210543"></p>
<blockquote>
<p>考虑到可能有时要在交换机的接口更换主机，或者主机要更换其网络适配器，这就需要更改交换表中的项目。为此，在交换表中每个项目都设有一定的<strong>有效时间</strong>。<strong>过期的项目就自动被删除</strong>。</p>
<p><strong>以太网交换机的这种自学习方法使得以太网交换机能够即插即用，不必人工进行配置，因此非常方便。</strong></p>
</blockquote>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p><strong>交换机自学习和转发帧的步骤归纳</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201015170656500.png" alt="image-20201015170656500"></p>
<p><img src="D:/Note/Typora_picture/image-20201015170739679.png" alt="image-20201015170739679"></p>
<hr>
<h2 id="3-10、以太网交换机的生成树协议STP"><a href="#3-10、以太网交换机的生成树协议STP" class="headerlink" title="3.10、以太网交换机的生成树协议STP"></a>3.10、以太网交换机的生成树协议STP</h2><h3 id="如何提高以太网的可靠性"><a href="#如何提高以太网的可靠性" class="headerlink" title="如何提高以太网的可靠性"></a>如何提高以太网的可靠性</h3><p><img src="D:/Note/Typora_picture/image-20201015171453001.png" alt="image-20201015171453001"></p>
<p><img src="D:/Note/Typora_picture/image-20201015171515481.png" alt="image-20201015171515481"></p>
<p><img src="D:/Note/Typora_picture/image-20201015171900775.png" alt="image-20201015171900775"></p>
<h3 id="生成树协议STP"><a href="#生成树协议STP" class="headerlink" title="生成树协议STP"></a>生成树协议STP</h3><p><img src="D:/Note/Typora_picture/image-20201015172204419.png" alt="image-20201015172204419"></p>
<blockquote>
<ul>
<li>IEEE 802.1D 标准制定了一个<strong>生成树协议 STP</strong>  (Spanning Tree Protocol)。</li>
<li>其<strong>要点</strong>是：<strong>不改变</strong>网络的实际拓扑，但在逻辑上则切断某些链路，使得从一台主机到所有其他主机的路径是<strong>无环路的树状结构</strong>，从而消除了兜圈子现象。</li>
</ul>
</blockquote>
<p><img src="D:/Note/Typora_picture/image-20201015202257756.png" alt="image-20201015202257756"></p>
<hr>
<h2 id="3-11、虚拟局域网VLAN"><a href="#3-11、虚拟局域网VLAN" class="headerlink" title="3.11、虚拟局域网VLAN"></a>3.11、虚拟局域网VLAN</h2><h3 id="为什么要虚拟局域网VLAN"><a href="#为什么要虚拟局域网VLAN" class="headerlink" title="为什么要虚拟局域网VLAN"></a>为什么要虚拟局域网VLAN</h3><p><strong>广播风暴</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201015202859124.png" alt="image-20201015202859124"></p>
<p><strong>分割广播域的方法</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201015203113654.png" alt="image-20201015203113654"></p>
<blockquote>
<p>为了分割广播域，所以虚拟局域网VLAN技术应运而生</p>
</blockquote>
<h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><p><img src="D:/Note/Typora_picture/image-20201015203559548.png" alt="image-20201015203559548"></p>
<blockquote>
<ul>
<li>利用以太网交换机可以很方便地实现虚拟局域网 VLAN (Virtual LAN)。</li>
<li>IEEE 802.1Q 对虚拟局域网 VLAN 的<strong>定义</strong>：<br><strong>虚拟局域网 VLAN</strong> 是由一些局域网网段构成的<strong>与物理位置无关的逻辑组</strong>，而这些网段具有某些共同的需求。每一个 VLAN 的帧都有一个明确的标识符，指明发送这个帧的计算机是属于哪一个 VLAN。</li>
<li>同一个VLAN内部可以广播通信，不同VLAN不可以广播通信</li>
<li><strong>虚拟局域网其实只是局域网给用户提供的一种服务，而并不是一种新型局域网。</strong></li>
<li>由于虚拟局域网是用户和网络资源的逻辑组合，因此可按照需要将有关设备和资源非常方便地重新组合，使用户从不同的服务器或数据库中存取所需的资源。</li>
</ul>
</blockquote>
<h3 id="虚拟局域网VLAN的实现机制"><a href="#虚拟局域网VLAN的实现机制" class="headerlink" title="虚拟局域网VLAN的实现机制"></a>虚拟局域网VLAN的实现机制</h3><p>虚拟局域网VLAN技术是在交换机上实现的，需要交换机能够实现以下功能</p>
<ul>
<li>能够处理带有VLAN标记的帧——IEEE 802.1 Q帧</li>
<li>交换机的各端口可以支持不同的端口类型，不同端口类型的端口对帧的处理方式有所不同</li>
</ul>
<p><img src="D:/Note/Typora_picture/image-20201015204639599.png" alt="image-20201015204639599"></p>
<p><img src="D:/Note/Typora_picture/image-20201015204749141.png" alt="image-20201015204749141"></p>
<p><strong>Access端口</strong></p>
<p>交换机与用户计算机之间的互连</p>
<p><img src="D:/Note/Typora_picture/image-20201015205311757.png" alt="image-20201015205311757"></p>
<blockquote>
<p>同一个VLAN内部可以广播通信，不同VLAN不可以广播通信</p>
</blockquote>
<p><strong>Truck端口</strong></p>
<p>交换机之间或交换机与路由器之间的互连</p>
<p><img src="D:/Note/Typora_picture/image-20201015205947636.png" alt="image-20201015205947636"></p>
<p><strong>小例题</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201015210417695.png" alt="image-20201015210417695"></p>
<p><strong>华为交换机私有的Hybrid端口类型</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201015211031361.png" alt="image-20201015211031361"></p>
<p><img src="D:/Note/Typora_picture/image-20201015211349531.png" alt="image-20201015211349531"></p>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p><img src="D:/Note/Typora_picture/image-20201015211512622.png" alt="image-20201015211512622"></p>
<blockquote>
<p><strong>虚拟局域网优点</strong></p>
<p>虚拟局域网（VLAN）技术具有以下主要优点：</p>
<ol>
<li>改善了性能</li>
<li>简化了管理</li>
<li>降低了成本</li>
<li>改善了安全性</li>
</ol>
</blockquote>
<h2 id="习题-2"><a href="#习题-2" class="headerlink" title="习题"></a>习题</h2><h3 id="封装成帧习题"><a href="#封装成帧习题" class="headerlink" title="封装成帧习题"></a>封装成帧习题</h3><p><img src="D:/Note/Typora_picture/image-20201011114856991.png" alt="image-20201011114856991"></p>
<h3 id="差错检测习题"><a href="#差错检测习题" class="headerlink" title="差错检测习题"></a>差错检测习题</h3><p><img src="D:/Note/Typora_picture/image-20201011235128869-16361023284031.png" alt="image-20201011235128869"></p>
<p><img src="D:/Note/Typora_picture/image-20201011235325022-16361023284043.png" alt="image-20201011235325022"></p>
<h3 id="可靠传输习题"><a href="#可靠传输习题" class="headerlink" title="可靠传输习题"></a>可靠传输习题</h3><p><img src="D:/Note/Typora_picture/image-20201012181005719-16361023284042.png" alt="image-20201012181005719"></p>
<hr>
<p><img src="D:/Note/Typora_picture/image-20201012182002090.png" alt="image-20201012182002090"></p>
<hr>
<p><img src="D:/Note/Typora_picture/image-20201012202419107-16361023284044.png" alt="image-20201012202419107"></p>
<hr>
<p><img src="D:/Note/Typora_picture/image-20201012205250996-16361023284045.png" alt="image-20201012205250996"></p>
<h3 id="媒体接入控制习题"><a href="#媒体接入控制习题" class="headerlink" title="媒体接入控制习题"></a>媒体接入控制习题</h3><p><img src="D:/Note/Typora_picture/image-20201013203459640-16361023284046.png" alt="image-20201013203459640"></p>
<hr>
<p><img src="D:/Note/Typora_picture/image-20201013204352725.png" alt="image-20201013204352725"></p>
<hr>
<p><img src="D:/Note/Typora_picture/image-20201013205054730.png" alt="image-20201013205054730"></p>
<hr>
<p><img src="D:/Note/Typora_picture/image-20201013232656202.png" alt="image-20201013232656202"></p>
<hr>
<p><img src="D:/Note/Typora_picture/image-20201013232840109.png" alt="image-20201013232840109"></p>
<hr>
<p><img src="D:/Note/Typora_picture/image-20201013233632636.png" alt="image-20201013233632636"></p>
<hr>
<p><img src="D:/Note/Typora_picture/image-20201014204557440.png" alt="image-20201014204557440"></p>
<hr>
<p><img src="D:/Note/Typora_picture/image-20201014204839055.png" alt="image-20201014204839055"></p>
<hr>
<p><img src="D:/Note/Typora_picture/image-20201014204939865.png" alt="image-20201014204939865"></p>
<hr>
<p><img src="D:/Note/Typora_picture/image-20201014224410943.png" alt="image-20201014224410943"></p>
<h3 id="MAC地址、IP地址以及ARP协议习题"><a href="#MAC地址、IP地址以及ARP协议习题" class="headerlink" title="MAC地址、IP地址以及ARP协议习题"></a>MAC地址、IP地址以及ARP协议习题</h3><p><img src="D:/Note/Typora_picture/image-20201015110420372.png" alt="image-20201015110420372"></p>
<h3 id="以太网交换机自学习和转发帧的流程"><a href="#以太网交换机自学习和转发帧的流程" class="headerlink" title="以太网交换机自学习和转发帧的流程"></a>以太网交换机自学习和转发帧的流程</h3><p><img src="D:/Note/Typora_picture/image-20201015164846227.png" alt="image-20201015164846227"></p>
<hr>
<p><img src="D:/Note/Typora_picture/image-20201015165218663.png" alt="image-20201015165218663"></p>
<hr>
<p><img src="D:/Note/Typora_picture/image-20201015170131492.png" alt="image-20201015170131492"></p>
<h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><h2 id="4-1、网络层概述"><a href="#4-1、网络层概述" class="headerlink" title="4.1、网络层概述"></a>4.1、网络层概述</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul>
<li>网络层的主要任务是<strong>实现网络互连</strong>，进而<strong>实现数据包在各网络之间的传输</strong></li>
</ul>
<p><img src="D:/Note/Typora_picture/image-20201017134630948.png" alt="image-20201017134630948"></p>
<blockquote>
<p>这些异构型网络N1~N7如果只是需要各自内部通信，他们只要实现各自的物理层和数据链路层即可</p>
<p>但是如果要将这些异构型网络互连起来，形成一个更大的互联网，就需要实现网络层设备路由器</p>
<p>有时为了简单起见，可以不用画出这些网络，图中N1~N7，而将他们看做是一条链路即可</p>
</blockquote>
<ul>
<li><p>要实现网络层任务，需要解决一下主要问题：</p>
<ul>
<li>网络层向运输层提供怎样的服务（“可靠传输”还是“不可靠传输”）</li>
</ul>
<p>在数据链路层那课讲过的可靠传输，详情可以看那边的笔记：网络层对以下的<strong>分组丢失</strong>、<strong>分组失序</strong>、<strong>分组重复</strong>的传输错误采取措施，使得接收方能正确接受发送方发送的数据，就是<strong>可靠传输</strong>，反之，如果什么措施也不采取，则是<strong>不可靠传输</strong></p>
<ul>
<li>网络层寻址问题</li>
</ul>
<p><img src="D:/Note/Typora_picture/image-20201017135644630.png" alt="image-20201017135644630"></p>
<ul>
<li>路由选择问题</li>
</ul>
<p><img src="D:/Note/Typora_picture/image-20201017135710478.png" alt="image-20201017135710478"></p>
<blockquote>
<p>路由器收到数据后，是依据什么来决定将数据包从自己的哪个接口转发出去？</p>
<p><strong>依据数据包的目的地址和路由器中的路由表</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201017135914985.png" alt="image-20201017135914985"></p>
<p>但在实际当中，路由器是怎样知道这些路由记录？</p>
<ul>
<li>由用户或网络管理员进行人工配置，这种方法只适用于规模较小且网络拓扑不改变的小型互联网</li>
<li><strong>另一种是实现各种路由选择协议，由路由器执行路由选择协议中所规定的路由选择算法，而自动得出路由表中的路有记录，这种方法更适合规模较大且网络拓扑经常改变的大型互联网</strong></li>
</ul>
</blockquote>
</li>
</ul>
<p><img src="D:/Note/Typora_picture/image-20201017142545630.png" alt="image-20201017142545630"></p>
<blockquote>
<p>补充 <strong>网络层（网际层）</strong>除了 <strong>IP协议</strong>外，还有之前介绍过的<strong>地址解析协议ARP</strong>，还有<strong>网际控制报文协议ICMP</strong>，<strong>网际组管理协议IGMP</strong></p>
</blockquote>
<h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><p><img src="D:/Note/Typora_picture/image-20201017140623851.png" alt="image-20201017140623851"></p>
<hr>
<h2 id="4-2、网络层提供的两种服务"><a href="#4-2、网络层提供的两种服务" class="headerlink" title="4.2、网络层提供的两种服务"></a>4.2、网络层提供的两种服务</h2><ul>
<li>在计算机网络领域，网络层应该向运输层提供怎样的服务（“<strong>面向连接</strong>”还是“<strong>无连接</strong>”）曾引起了长期的争论。</li>
<li>争论焦点的实质就是：<strong>在计算机通信中，可靠交付应当由谁来负责</strong>？是<strong>网络</strong>还是<strong>端系统</strong>？</li>
</ul>
<h3 id="面向连接的虚电路服务"><a href="#面向连接的虚电路服务" class="headerlink" title="面向连接的虚电路服务"></a>面向连接的虚电路服务</h3><p><strong>一种观点：让网络负责可靠交付</strong></p>
<ul>
<li>这种观点认为，应借助于电信网的成功经验，让网络负责可靠交付，计算机网络应模仿电信网络，使用<strong>面向连接</strong>的通信方式。</li>
<li>通信之前先建立<strong>虚电路</strong> (Virtual Circuit)，以保证双方通信所需的一切网络资源。 </li>
<li>如果再使用可靠传输的网络协议，就可使所发送的分组无差错按序到达终点，不丢失、不重复。</li>
</ul>
<p><img src="D:/Note/Typora_picture/image-20201017141425892.png" alt="image-20201017141425892"></p>
<p><strong>发送方</strong> 发送给 <strong>接收方</strong> 的所有分组都沿着同一条虚电路传送</p>
<blockquote>
<ul>
<li>虚电路表示这只是一条逻辑上的连接，分组都沿着这条逻辑连接按照存储转发方式传送，而并不是真正建立了一条物理连接。</li>
<li>请注意，电路交换的电话通信是先建立了一条真正的连接。</li>
<li>因此分组交换的虚连接和电路交换的连接只是类似，但并不完全一样</li>
</ul>
</blockquote>
<h3 id="无连接的数据报服务"><a href="#无连接的数据报服务" class="headerlink" title="无连接的数据报服务"></a>无连接的数据报服务</h3><p><strong>另一种观点：网络提供数据报服务</strong></p>
<ul>
<li>互联网的先驱者提出了一种崭新的网络设计思路。</li>
<li>网络层向上只提供简单灵活的、<strong>无连接的</strong>、<strong>尽最大努力交付</strong>的<strong>数据报服务</strong>。</li>
<li>网络在发送分组时不需要先建立连接。每一个分组（即 IP 数据报）独立发送，与其前后的分组无关（不进行编号）。</li>
<li><strong>网络层不提供服务质量的承诺</strong>。即所传送的分组可能出错、丢失、重复和失序（不按序到达终点），当然也不保证分组传送的时限。</li>
</ul>
<p><img src="D:/Note/Typora_picture/image-20201017141851030.png" alt="image-20201017141851030"></p>
<p><strong>发送方</strong> 发送给 <strong>接收方</strong> 的分组可能沿着不同路径传送</p>
<blockquote>
<p><strong>尽最大努力交付</strong></p>
<ul>
<li>如果主机（即端系统）中的进程之间的通信需要是可靠的，那么就由网络的<strong>主机中的运输层负责可靠交付（包括差错处理、流量控制等）</strong> 。</li>
<li><strong>采用这种设计思路的好处是</strong>：网络的造价大大降低，运行方式灵活，能够适应多种应用。</li>
<li>互连网能够发展到今日的规模，充分证明了当初采用这种设计思路的正确性。</li>
</ul>
</blockquote>
<h3 id="虚电路服务与数据报服务的对比"><a href="#虚电路服务与数据报服务的对比" class="headerlink" title="虚电路服务与数据报服务的对比"></a>虚电路服务与数据报服务的对比</h3><table>
<thead>
<tr>
<th><strong>对比的方面</strong></th>
<th><strong>虚电路服务</strong></th>
<th><strong>数据报服务</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>思路</strong></td>
<td><strong>可靠通信应当由网络来保证</strong></td>
<td><strong>可靠通信应当由用户主机来保证</strong></td>
</tr>
<tr>
<td><strong>连接的建立</strong></td>
<td><strong>必须有</strong></td>
<td><strong>不需要</strong></td>
</tr>
<tr>
<td><strong>终点地址</strong></td>
<td><strong>仅在连接建立阶段使用，每个分组使用短的虚电路号</strong></td>
<td><strong>每个分组都有终点的完整地址</strong></td>
</tr>
<tr>
<td><strong>分组的转发</strong></td>
<td><strong>属于同一条虚电路的分组均按照同一路由进行转发</strong></td>
<td><strong>每个分组独立选择路由进行转发</strong></td>
</tr>
<tr>
<td><strong>当结点出故障时</strong></td>
<td><strong>所有通过出故障的结点的虚电路均不能工作</strong></td>
<td><strong>出故障的结点可能会丢失分组，一些路由可能会发生变化</strong></td>
</tr>
<tr>
<td><strong>分组的顺序</strong></td>
<td><strong>总是按发送顺序到达终点</strong></td>
<td><strong>到达终点时不一定按发送顺序</strong></td>
</tr>
<tr>
<td><strong>端到端的差错处理和流量控制</strong></td>
<td><strong>可以由网络负责，也可以由用户主机负责</strong></td>
<td><strong>由用户主机负责</strong></td>
</tr>
</tbody></table>
<hr>
<h2 id="4-3、IPv4"><a href="#4-3、IPv4" class="headerlink" title="4.3、IPv4"></a>4.3、IPv4</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p><img src="D:/Note/Typora_picture/image-20201017143206060.png" alt="image-20201017143206060"></p>
<h3 id="分类编制的IPv4地址"><a href="#分类编制的IPv4地址" class="headerlink" title="分类编制的IPv4地址"></a>分类编制的IPv4地址</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p><img src="D:/Note/Typora_picture/image-20201017144317166.png" alt="image-20201017144317166"></p>
<ul>
<li>每一类地址都由两个固定长度的字段组成，其中一个字段是<strong>网络号 net-id</strong>，它标志主机（或路由器）所连接到的网络，而另一个字段则是<strong>主机号 host-id</strong>，它标志该主机（或路由器）。</li>
<li>主机号在它前面的网络号所指明的网络范围内必须是唯一的。</li>
<li>由此可见，<strong>一个 IP 地址在整个互联网范围内是唯一的</strong>。</li>
</ul>
<p><strong>A类地址</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201017145210533.png" alt="image-20201017145210533"></p>
<p><strong>B类地址</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201017145508001.png" alt="image-20201017145508001"></p>
<p><strong>C类地址</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201017150204774.png" alt="image-20201017150204774"></p>
<p><strong>练习</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201017150543386.png" alt="image-20201017150543386"></p>
<h4 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h4><p><strong>IP 地址的指派范围</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201017152911541.png" alt="image-20201017152911541"></p>
<p><strong>一般不使用的特殊的 IP 地址</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201017152959586.png" alt="image-20201017152959586"></p>
<p><strong>IP 地址的一些重要特点</strong></p>
<p>(1) <strong>IP 地址是一种分等级的地址结构</strong>。分两个等级的好处是：</p>
<ul>
<li><strong>第一</strong>，IP 地址管理机构在分配 IP 地址时只分配网络号，而剩下的主机号则由得到该网络号的单位自行分配。这样就方便了 IP 地址的管理。</li>
<li><strong>第二</strong>，路由器仅根据目的主机所连接的网络号来转发分组（而不考虑目的主机号），这样就可以使路由表中的项目数大幅度减少，从而减小了路由表所占的存储空间。</li>
</ul>
<p>(2) <strong>实际上 IP 地址是标志一个主机（或路由器）和一条链路的接口</strong>。</p>
<ul>
<li>当一个主机同时连接到两个网络上时，该主机就必须同时具有两个相应的 IP 地址，其网络号 net-id 必须是不同的。这种主机称为<strong>多归属主机</strong> (multihomed host)。</li>
<li>由于一个路由器至少应当连接到两个网络（这样它才能将 IP 数据报从一个网络转发到另一个网络），因此<strong>一个路由器至少应当有两个不同的 IP 地址</strong>。</li>
</ul>
<p>(3) <strong>用转发器或网桥连接起来的若干个局域网仍为一个网络</strong>，因此这些局域网都具有同样的网络号 net-id。</p>
<p>(4) <strong>所有分配到网络号 net-id 的网络，无论是范围很小的局域网，还是可能覆盖很大地理范围的广域网，都是平等的。</strong></p>
<h3 id="划分子网的IPv4地址"><a href="#划分子网的IPv4地址" class="headerlink" title="划分子网的IPv4地址"></a>划分子网的IPv4地址</h3><h4 id="为什么要划分子网"><a href="#为什么要划分子网" class="headerlink" title="为什么要划分子网"></a>为什么要划分子网</h4><p>在 ARPANET 的早期，IP 地址的设计确实不够合理：</p>
<ul>
<li>IP 地址空间的利用率有时很低。 </li>
<li>给每一个物理网络分配一个网络号会使路由表变得太大因而使网络性能变坏。 </li>
<li>两级的 IP 地址不够灵活。</li>
</ul>
<p><img src="D:/Note/Typora_picture/image-20201017154645198.png" alt="image-20201017154645198"></p>
<p>如果想要将原来的网络划分成三个独立的网路</p>
<p><img src="D:/Note/Typora_picture/image-20201017154852896.png" alt="image-20201017154852896"></p>
<p>所以是否可以从主机号部分借用一部分作为子网号</p>
<p><img src="D:/Note/Typora_picture/image-20201017155026814.png" alt="image-20201017155026814"></p>
<blockquote>
<p>但是如果未在图中标记子网号部分，那么我们和计算机又如何知道分类地址中主机号有多少比特被用作子网号了呢？</p>
<p>所以就有了划分子网的工具：<strong>子网掩码</strong></p>
<ul>
<li>从 1985 年起在 IP 地址中又增加了一个“<strong>子网号字段</strong>”，使两级的 IP 地址变成为<strong>三级的 IP 地址</strong>。</li>
<li>这种做法叫做<strong>划分子网</strong> (subnetting) 。</li>
<li>划分子网已成为互联网的正式标准协议。</li>
</ul>
</blockquote>
<h4 id="如何划分子网"><a href="#如何划分子网" class="headerlink" title="如何划分子网"></a>如何划分子网</h4><p>基本思路</p>
<ul>
<li>划分子网纯属一个<strong>单位内部的事情</strong>。单位对外仍然表现为没有划分子网的网络。</li>
<li>从主机号<strong>借用</strong>若干个位作为<strong>子网号</strong> subnet-id，而主机号 host-id 也就相应减少了若干个位。</li>
</ul>
<p><img src="D:/Note/Typora_picture/image-20201017155930011.png" alt="image-20201017155930011"></p>
<ul>
<li>凡是从其他网络发送给本单位某个主机的 IP 数据报，仍然是根据 IP 数据报的<strong>目的网络号</strong> net-id，先找到连接在本单位网络上的路由器。</li>
<li>然后<strong>此路由器</strong>在收到 IP 数据报后，再按<strong>目的网络号</strong> net-id 和<strong>子网号</strong> subnet-id 找到目的子网。</li>
<li>最后就将 IP 数据报直接交付目的主机。</li>
</ul>
<p>划分为三个子网后对外仍是一个网络</p>
<p><img src="D:/Note/Typora_picture/image-20201017160116239.png" alt="image-20201017160116239"></p>
<blockquote>
<ul>
<li><strong>优点</strong><ol>
<li>减少了 IP 地址的浪费</li>
<li>使网络的组织更加灵活</li>
<li>更便于维护和管理</li>
</ol>
</li>
<li><strong>划分子网纯属一个单位内部的事情，对外部网络透明</strong>，对外仍然表现为没有划分子网的一个网络。</li>
</ul>
</blockquote>
<h4 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h4><p><img src="D:/Note/Typora_picture/image-20201017160252066.png" alt="image-20201017160252066"></p>
<blockquote>
<p><strong>(IP 地址) AND (子网掩码) &#x3D; 网络地址</strong> 重要，下面很多相关知识都会用到</p>
</blockquote>
<p>举例</p>
<p>例子1</p>
<p><img src="D:/Note/Typora_picture/image-20201017161651058.png" alt="image-20201017161651058"></p>
<p>例子2</p>
<p><img src="D:/Note/Typora_picture/image-20201017161719339.png" alt="image-20201017161719339"></p>
<p><strong>默认子网掩码</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201017162807076.png" alt="image-20201017162807076"></p>
<h4 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h4><p><img src="D:/Note/Typora_picture/image-20201017162938612.png" alt="image-20201017162938612"></p>
<blockquote>
<ul>
<li>子网掩码是一个网络或一个子网的重要属性。</li>
<li>路由器在和相邻路由器交换路由信息时，必须把自己所在网络（或子网）的子网掩码告诉相邻路由器。</li>
<li>路由器的路由表中的每一个项目，除了要给出目的网络地址外，还必须同时给出该网络的子网掩码。</li>
<li>若一个路由器连接在两个子网上，就拥有两个网络地址和两个子网掩码。</li>
</ul>
</blockquote>
<h3 id="无分类编址的IPv4地址"><a href="#无分类编址的IPv4地址" class="headerlink" title="无分类编址的IPv4地址"></a>无分类编址的IPv4地址</h3><h4 id="为什么使用无分类编址"><a href="#为什么使用无分类编址" class="headerlink" title="为什么使用无分类编址"></a>为什么使用无分类编址</h4><p><strong>无分类域间路由选择 CIDR</strong> (Classless Inter-Domain Routing)。 </p>
<p><img src="D:/Note/Typora_picture/image-20201017164031532.png" alt="image-20201017164031532"></p>
<blockquote>
<p><strong>CIDR 最主要的特点</strong></p>
<ul>
<li>CIDR使用各种长度的“<strong>网络前缀</strong>”(network-prefix)来代替分类地址中的网络号和子网号。</li>
<li><strong>IP 地址从三级编址（使用子网掩码）又回到了两级编址</strong>。</li>
</ul>
</blockquote>
<h4 id="如何使用无分类编址"><a href="#如何使用无分类编址" class="headerlink" title="如何使用无分类编址"></a>如何使用无分类编址</h4><p><img src="D:/Note/Typora_picture/image-20201017165037268.png" alt="image-20201017165037268"></p>
<p>举例</p>
<p><img src="D:/Note/Typora_picture/image-20201017165113442.png" alt="image-20201017165113442"></p>
<h4 id="路由聚合（构造超网）"><a href="#路由聚合（构造超网）" class="headerlink" title="路由聚合（构造超网）"></a>路由聚合（构造超网）</h4><p><img src="D:/Note/Typora_picture/image-20201017165615915.png" alt="image-20201017165615915"></p>
<h4 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h4><p><img src="D:/Note/Typora_picture/image-20201017170552495.png" alt="image-20201017170552495"></p>
<h3 id="IPv4地址的应用规划"><a href="#IPv4地址的应用规划" class="headerlink" title="IPv4地址的应用规划"></a>IPv4地址的应用规划</h3><p>给定一个IPv4地址快，如何将其划分成几个更小的地址块，并将这些地址块分配给互联网中不同网络，进而可以给各网络中的主机和路由器接口分配IPv4地址</p>
<h4 id="定长的子网掩码FLSM（Fixed-Length-Subnet-Mask）"><a href="#定长的子网掩码FLSM（Fixed-Length-Subnet-Mask）" class="headerlink" title="定长的子网掩码FLSM（Fixed Length Subnet Mask）"></a>定长的子网掩码FLSM（Fixed Length Subnet Mask）</h4><p><img src="D:/Note/Typora_picture/image-20201018143550103.png" alt="image-20201018143550103"></p>
<p><strong>划分子网的IPv4就是定长的子网掩码</strong></p>
<p>举例</p>
<p><img src="D:/Note/Typora_picture/image-20201018140809079.png" alt="image-20201018140809079"></p>
<p><img src="D:/Note/Typora_picture/image-20201018140916631.png" alt="image-20201018140916631"></p>
<p><img src="D:/Note/Typora_picture/image-20201018141132446.png" alt="image-20201018141132446"></p>
<blockquote>
<p>通过上面步骤分析，就可以从子网1<del>8中任选5个分配给左图中的N1</del>N5</p>
<p><strong>采用定长的子网掩码划分，只能划分出2^n个子网，其中n是从主机号部分借用的用来作为子网号的比特数量，每个子网所分配的IP地址数量相同</strong></p>
<p><strong>但是也因为每个子网所分配的IP地址数量相同，不够灵活，容易造成IP地址的浪费</strong></p>
</blockquote>
<h4 id="变长的子网掩码VLSM（Variable-Length-Subnet-Mask）"><a href="#变长的子网掩码VLSM（Variable-Length-Subnet-Mask）" class="headerlink" title="变长的子网掩码VLSM（Variable Length Subnet Mask）"></a>变长的子网掩码VLSM（Variable Length Subnet Mask）</h4><p><img src="D:/Note/Typora_picture/image-20201018143632352.png" alt="image-20201018143632352"></p>
<p><strong>无分类编址的IPv4就是变长的子网掩码</strong></p>
<p>举例</p>
<p><img src="D:/Note/Typora_picture/image-20201018142333145.png" alt="image-20201018142333145"></p>
<p><img src="D:/Note/Typora_picture/image-20201018143344440.png" alt="image-20201018143344440"></p>
<hr>
<h2 id="4-4、IP数据报的发送和转发过程"><a href="#4-4、IP数据报的发送和转发过程" class="headerlink" title="4.4、IP数据报的发送和转发过程"></a>4.4、IP数据报的发送和转发过程</h2><p><img src="D:/Note/Typora_picture/image-20201018144335297.png" alt="image-20201018144335297"></p>
<p>举例</p>
<p><img src="D:/Note/Typora_picture/image-20201018151314019.png" alt="image-20201018151314019"></p>
<p><img src="D:/Note/Typora_picture/image-20201018150151171.png" alt="image-20201018150151171"></p>
<p>源主机如何知道目的主机是否与自己在同一个网络中，是直接交付，还是间接交付？</p>
<p><img src="D:/Note/Typora_picture/image-20201018150223497.png" alt="image-20201018150223497"></p>
<blockquote>
<p>可以通过<strong>目的地址IP</strong>和<strong>源地址的子网掩码</strong>进行<strong>逻辑与运算</strong>得到<strong>目的网络地址</strong></p>
<ul>
<li>如果<strong>目的网络地址</strong>和<strong>源网络地址</strong> <strong>相同</strong>，就是<strong>在同一个网络</strong>中，属于<strong>直接交付</strong></li>
<li>如果<strong>目的网络地址</strong>和<strong>源网络地址</strong> <strong>不相同</strong>，就<strong>不在同一个网络</strong>中，属于<strong>间接交付</strong>，传输给主机所在网络的<strong>默认网关</strong>（路由器——下图会讲解）,由默认网关帮忙转发</li>
</ul>
</blockquote>
<p>主机C如何知道路由器R的存在？</p>
<p><img src="D:/Note/Typora_picture/image-20201018145501063.png" alt="image-20201018145501063"></p>
<blockquote>
<p>用户为了让本网络中的主机能和其他网络中的主机进行通信，就必须给其指定本网络的一个路由器的接口，由该路由器帮忙进行转发，<strong>所指定的路由器</strong>，也被称为<strong>默认网关</strong></p>
<p>例如。路由器的接口0的IP地址192.168.0.128做为左边网络的默认网关</p>
</blockquote>
<p><img src="D:/Note/Typora_picture/image-20201018150029179.png" alt="image-20201018150029179"></p>
<blockquote>
<p>主机A会将该IP数据报传输给自己的默认网关，也就是图中所示的路由器接口0</p>
</blockquote>
<p>路由器收到IP数据报后如何转发？</p>
<ul>
<li>检查IP数据报首部是否出错：<ul>
<li>若出错，则直接丢弃该IP数据报并通告源主机</li>
<li>若没有出错，则进行转发</li>
</ul>
</li>
<li>根据IP数据报的目的地址在路由表中查找匹配的条目：<ul>
<li>若找到匹配的条目，则转发给条目中指示的吓一跳</li>
<li>若找不到，则丢弃该数据报并通告源主机</li>
</ul>
</li>
</ul>
<p>假设IP数据报首部没有出错，路由器取出IP数据报首部各地址字段的值</p>
<p><img src="D:/Note/Typora_picture/image-20201018151108989.png" alt="image-20201018151108989"></p>
<p>接下来路由器对该IP数据报进行查表转发</p>
<p><img src="D:/Note/Typora_picture/image-20201018151528027.png" alt="image-20201018151528027"></p>
<blockquote>
<p>逐条检查路由条目，将目的地址与路由条目中的地址掩码进行逻辑与运算得到目的网络地址，然后与路由条目中的目的网络进行比较，如果相同，则这条路由条目就是匹配的路由条目，按照它的下一条指示，图中所示的也就是接口1转发该IP数据报</p>
</blockquote>
<p><img src="D:/Note/Typora_picture/image-20201018151956275.png" alt="image-20201018151956275"></p>
<p>路由器是隔离广播域的</p>
<p><img src="D:/Note/Typora_picture/image-20201018152040610.png" alt="image-20201018152040610"></p>
<hr>
<h2 id="4-5、静态路由配置及其可能产生的路由环路问题"><a href="#4-5、静态路由配置及其可能产生的路由环路问题" class="headerlink" title="4.5、静态路由配置及其可能产生的路由环路问题"></a>4.5、静态路由配置及其可能产生的路由环路问题</h2><h3 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h3><p><img src="D:/Note/Typora_picture/image-20201018155702081.png" alt="image-20201018155702081"></p>
<h3 id="多种情况举例"><a href="#多种情况举例" class="headerlink" title="多种情况举例"></a>多种情况举例</h3><p> <strong>静态路由配置</strong></p>
<p>举例</p>
<p><img src="D:/Note/Typora_picture/image-20201018160349375.png" alt="image-20201018160349375"></p>
<p><strong>默认路由</strong></p>
<p>举例</p>
<p>默认路由可以被所有网络匹配，但路由匹配有优先级，默认路由是优先级最低的</p>
<p><img src="D:/Note/Typora_picture/image-20201018160906284.png" alt="image-20201018160906284"></p>
<p><strong>特定主机路由</strong></p>
<p>举例</p>
<p>有时候，我们可以给路由器添加针对某个主机的特定主机路由条目</p>
<p>一般用于网络管理人员对网络的管理和测试</p>
<p><img src="D:/Note/Typora_picture/image-20201018161440257.png" alt="image-20201018161440257"></p>
<blockquote>
<p>多条路由可选，匹配路由最具体的</p>
</blockquote>
<p><strong>静态路由配置错误导致路由环路</strong></p>
<p>举例</p>
<p><img src="D:/Note/Typora_picture/image-20201018161542579.png" alt="image-20201018161542579"></p>
<p>假设将R2的路由表中第三条目录配置错了下一跳</p>
<p>这导致R2和R3之间产生了路由环路</p>
<p><img src="D:/Note/Typora_picture/image-20201018162041966.png" alt="image-20201018162041966"></p>
<p><strong>聚合了不存在的网络而导致路由环路</strong></p>
<p>举例</p>
<p>正常情况</p>
<p><img src="D:/Note/Typora_picture/image-20201018162333671.png" alt="image-20201018162333671"></p>
<p><img src="D:/Note/Typora_picture/image-20201018162759562.png" alt="image-20201018162759562"></p>
<p>错误情况</p>
<p><img src="D:/Note/Typora_picture/image-20201018163323343.png" alt="image-20201018163323343"></p>
<p>解决方法</p>
<p><img src="D:/Note/Typora_picture/image-20201018163933715.png" alt="image-20201018163933715"></p>
<p><img src="D:/Note/Typora_picture/image-20201018164453398.png" alt="image-20201018164453398"></p>
<blockquote>
<p>黑洞路由的下一跳为null0，这是路由器内部的虚拟接口，IP数据报进入它后就被丢弃</p>
</blockquote>
<p><strong>网络故障而导致路由环路</strong></p>
<p>举例</p>
<p><img src="D:/Note/Typora_picture/image-20201018164811811.png" alt="image-20201018164811811"></p>
<p><img src="D:/Note/Typora_picture/image-20201018164913684.png" alt="image-20201018164913684"></p>
<p>解决方法</p>
<p>添加故障的网络为黑洞路由</p>
<p><img src="D:/Note/Typora_picture/image-20201018165122023.png" alt="image-20201018165122023"></p>
<p><img src="D:/Note/Typora_picture/image-20201018165153517.png" alt="image-20201018165153517"></p>
<p>假设。一段时间后故障网络恢复了</p>
<p>R1又自动地得出了其接口0的直连网络的路由条目</p>
<p>针对该网络的黑洞网络会自动失效</p>
<p><img src="D:/Note/Typora_picture/image-20201018165328319.png" alt="image-20201018165328319"></p>
<p>如果又故障</p>
<p>则生效该网络的黑洞网络</p>
<p><img src="D:/Note/Typora_picture/image-20201018165521938.png" alt="image-20201018165521938"></p>
<h3 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h3><p><img src="D:/Note/Typora_picture/image-20201018165709294.png" alt="image-20201018165709294"></p>
<hr>
<h2 id="4-6、路由选择协议"><a href="#4-6、路由选择协议" class="headerlink" title="4.6、路由选择协议"></a>4.6、路由选择协议</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p><img src="D:/Note/Typora_picture/image-20201019134827343.png" alt="image-20201019134827343"></p>
<p><strong>因特网所采用的路由选择协议的主要特点</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201019134946971.png" alt="image-20201019134946971"></p>
<p><strong>因特网采用分层次的路由选择协议</strong></p>
<ul>
<li><strong>自治系统 AS</strong>：在单一的技术管理下的一组路由器，而这些路由器使用一种 AS 内部的路由选择协议和共同的度量以确定分组在该 AS 内的路由，同时还使用一种 AS 之间的路由选择协议用以确定分组在 AS之间的路由。</li>
</ul>
<p><img src="D:/Note/Typora_picture/image-20201019135122326.png" alt="image-20201019135122326"></p>
<blockquote>
<p>自治系统之间的路由选择简称为域间路由选择，自治系统内部的路由选择简称为域内路由选择</p>
</blockquote>
<p><img src="D:/Note/Typora_picture/image-20201019135328925.png" alt="image-20201019135328925"></p>
<blockquote>
<p>域间路由选择使用外部网关协议EGP这个类别的路由选择协议</p>
<p>域内路由选择使用内部网关协议IGP这个类别的路由选择协议</p>
<p><strong>网关协议</strong>的名称可称为<strong>路由协议</strong></p>
</blockquote>
<p><strong>常见的路由选择协议</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201019140009740.png" alt="image-20201019140009740"></p>
<p><strong>路由器的基本结构</strong></p>
<p>路由器是一种具有多个输入端口，和输出端口的专用计算机，其任务是转发分组</p>
<p><img src="D:/Note/Typora_picture/image-20201019140234652.png" alt="image-20201019140234652"></p>
<p>路由器结构可划分为两大部分：</p>
<p>1、<strong>分组转发部分</strong></p>
<p> 由三部分构成</p>
<ul>
<li><p>交换结构</p>
</li>
<li><p>一组输入端口：</p>
<p>信号从某个输入端口进入路由器</p>
<img src="D:/Note/Typora_picture/image-20201019141149194.png" alt="image-20201019141149194" style="zoom:50%;" />

<p>物理层将信号转换成比特流，送交数据链路层处理</p>
<img src="D:/Note/Typora_picture/image-20201019141210774.png" alt="image-20201019141210774" style="zoom: 50%;" />

<p>数据链路层识别从比特流中识别出帧，去掉帧头和帧尾后，送交网络层处理</p>
<img src="D:/Note/Typora_picture/image-20201019141242246.png" alt="image-20201019141242246" style="zoom:50%;" />

<p>  如果送交网络层的分组是普通待转发的数据分组</p>
<img src="D:/Note/Typora_picture/image-20201019141305650.png" alt="image-20201019141305650" style="zoom:50%;" />

<p>   则根据分组首部中的目的地址进行查表转发</p>
<img src="D:/Note/Typora_picture/image-20201019141327380.png" alt="image-20201019141327380" style="zoom:50%;" />

<p>若找不到匹配的转发条目，则丢弃该分组，否则，按照匹配条目中所指示的端口进行转发</p>
</li>
<li><p>一组输出端口</p>
<p>网络层更新数据分组首部中某些字段的值，例如将数据分组的生存时间减1，然后送交数据链路层进行封装</p>
<img src="D:/Note/Typora_picture/image-20201019141745375.png" alt="image-20201019141745375" style="zoom:50%;" />

<p>数据链路层将数据分组封装成帧，交给物理层处理</p>
<img src="D:/Note/Typora_picture/image-20201019141838032.png" alt="image-20201019141838032" style="zoom:50%;" />

<p>物理层将帧看成比特流将其变换成相应的电信号进行发送</p>
</li>
</ul>
<blockquote>
<p>路由器的各端口还会有输入缓冲区和输出缓冲区</p>
<ul>
<li><p>输入缓冲区用来暂存新进入路由器但还来不及处理的分组</p>
</li>
<li><p>输出缓冲区用来暂存已经处理完毕但还来不及发送的分组</p>
</li>
</ul>
<p><img src="D:/Note/Typora_picture/image-20201019143040253.png" alt="image-20201019143040253"></p>
<p><strong>路由器的端口一般都具有输入和输出功能</strong>，这些实例分出了输入端口和输出端口是更好演示路由基本工作过程</p>
</blockquote>
<p> 2、<strong>路由选择部分</strong></p>
<ul>
<li><p>路由选择部分的核心构件是路由选择处理机，它的任务是根据所使用的路由选择协议。周期性地与其他路由器 进行路由信息的交互，来更新路由表</p>
<p>如果送交给输入端口的网络层的分组是路由器之间交换路由信息的路由报文，则把这种分组送交给路由选择处理机</p>
<img src="D:/Note/Typora_picture/image-20201019142228360.png" alt="image-20201019142228360" style="zoom:50%;" />

<p>路由选择处理机根据分组的内容来更新自己的<strong>路由表</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201019142415055.png" alt="image-20201019142415055"></p>
<p>路由选择处理机还会周期性地给其他路由器发送自己所知道的路由信息</p>
<p><img src="D:/Note/Typora_picture/image-20201019142924889.png" alt="image-20201019142924889"></p>
</li>
</ul>
<h3 id="路由信息协议RIP"><a href="#路由信息协议RIP" class="headerlink" title="路由信息协议RIP"></a>路由信息协议RIP</h3><p><img src="D:/Note/Typora_picture/image-20201019144915687.png" alt="image-20201019144915687"></p>
<p><img src="D:/Note/Typora_picture/image-20201019145247606.png" alt="image-20201019145247606"></p>
<p><strong>RIP的基本工作过程</strong></p>
<p>举例</p>
<p><img src="D:/Note/Typora_picture/image-20201019145510947.png" alt="image-20201019145510947"></p>
<p><strong>RIP的路由条目的更新规则</strong></p>
<p>举例1</p>
<p><img src="D:/Note/Typora_picture/image-20201019145627339.png" alt="image-20201019145627339"></p>
<blockquote>
<p>路由器C的表到达各目的网络的下一条都记为问号，可以理解为路由器D并不需要关心路由器C的这些内容</p>
<p>假设路由器C的RIP更新报文发送周期到了，则路由器C将自己路由表中的相关路由信息封装到RIP更新报文中发送给路由器D</p>
</blockquote>
<p><img src="D:/Note/Typora_picture/image-20201019150120900.png" alt="image-20201019150120900"></p>
<blockquote>
<p>路由器C能到达这些网络，说明路由器C的相邻路由器也能到达，只是比路由器C的距离大1，于是根据距离的对比，路由器D更新自己的路由表</p>
</blockquote>
<p><img src="D:/Note/Typora_picture/image-20201019150412666.png" alt="image-20201019150412666"></p>
<p>举例2</p>
<p><img src="D:/Note/Typora_picture/image-20201019150525711.png" alt="image-20201019150525711"></p>
<p><strong>RIP存在“坏消息传播得慢”的问题</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201019151041492.png" alt="image-20201019151041492"></p>
<p><img src="D:/Note/Typora_picture/image-20201019151135255.png" alt="image-20201019151135255"></p>
<p><img src="D:/Note/Typora_picture/image-20201019151332767.png" alt="image-20201019151332767"></p>
<p>解决方法</p>
<p><img src="D:/Note/Typora_picture/image-20201019151639181.png" alt="image-20201019151639181"></p>
<blockquote>
<p>但是，这些方法也不能完全解决“坏消息传播得慢”的问题，这是距离向量的本质决定</p>
</blockquote>
<p><strong>总结</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201019152526098.png" alt="image-20201019152526098"></p>
<blockquote>
<p>RIP 协议的优缺点</p>
<p>优点：</p>
<ol>
<li>实现简单，开销较小。</li>
</ol>
<p>缺点：</p>
<ol>
<li><p>RIP 限制了网络的规模，它能使用的最大距离为 15（16 表示不可达）。</p>
</li>
<li><p>路由器之间交换的路由信息是路由器中的完整路由表，因而随着网络规模的扩大，开销也就增加。</p>
</li>
<li><p>“坏消息传播得慢”，使更新过程的收敛时间过长。</p>
</li>
</ol>
</blockquote>
<h3 id="开放最短路径优先OSPF"><a href="#开放最短路径优先OSPF" class="headerlink" title="开放最短路径优先OSPF"></a>开放最短路径优先OSPF</h3><p><strong>开放最短路径优先 OSPF (Open Shortest Path First)</strong></p>
<p><strong>注意</strong>：OSPF 只是一个协议的名字，它并不表示其他的路由选择协议不是“最短路径优先”。</p>
<p><strong>概念</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201019161841695.png" alt="image-20201019161841695"></p>
<p><strong>问候（Hello）分组</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201019161653875.png" alt="image-20201019161653875"></p>
<blockquote>
<p>IP数据报首部中协议号字段的取值应为89，来表明IP数据报的数据载荷为OSPF分组</p>
</blockquote>
<p><strong>发送链路状态通告LSA</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201019162341151.png" alt="image-20201019162341151"></p>
<blockquote>
<p>洪泛法有点类似于广播，就是从一个接口进来，从其他剩余所有接口出去</p>
</blockquote>
<p><strong>链路状态数据库同步</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201019162933483.png" alt="image-20201019162933483"></p>
<p><strong>使用SPF算法计算出各自路由器到达其他路由器的最短路径</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201019163148068.png" alt="image-20201019163148068"></p>
<p><strong>OSPF五种分组类型</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201019163250129.png" alt="image-20201019163250129"></p>
<p><strong>OSPF的基本工作过程</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201019163746254.png" alt="image-20201019163746254"></p>
<p><strong>OSPF在多点接入网络中路由器邻居关系建立</strong></p>
<p>如果不采用其他机制，将会产生大量的多播分组</p>
<p><img src="D:/Note/Typora_picture/image-20201019164657606.png" alt="image-20201019164657606"></p>
<blockquote>
<p>若DR出现问题，则由BDR顶替DR</p>
</blockquote>
<p><strong>为了使OSPF能够用于规模很大的网络，OSPF把一个自治系统再划分为若干个更小的范围，叫做区域（Area）</strong></p>
<ul>
<li><p>在该自治系统内，所有路由器都使用OSPF协议，OSPF将该自治系统再划分成4个更小的区域</p>
</li>
<li><p>每个区域都有一个32比特的区域标识符</p>
</li>
<li><p>主干区域的区域标识符必须为0，主干区域用于连通其他区域</p>
</li>
<li><p>其他区域的区域标识符不能为0且不相同</p>
</li>
<li><p>每个区域一般不应包含路由器超过200个</p>
</li>
<li><p>划分区域的好处就是，利用洪泛法交换链路状态信息局限于每一个区域而不是自治系统，这样减少整个网络上的通信量</p>
</li>
</ul>
<p><img src="D:/Note/Typora_picture/image-20201019170100568.png" alt="image-20201019170100568"></p>
<p><strong>总结</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201019170217622.png" alt="image-20201019170217622"></p>
<h3 id="边界网关协议BGP"><a href="#边界网关协议BGP" class="headerlink" title="边界网关协议BGP"></a>边界网关协议BGP</h3><p>BGP（Border Gateway Protocol） 是<strong>不同自治系统的路由器之间</strong>交换路由信息的协议</p>
<p><img src="D:/Note/Typora_picture/image-20201019191438399.png" alt="image-20201019191438399"></p>
<p><img src="D:/Note/Typora_picture/image-20201019191718506.png" alt="image-20201019191718506"></p>
<p><img src="D:/Note/Typora_picture/image-20201019191836397.png" alt="image-20201019191836397"></p>
<p><img src="D:/Note/Typora_picture/image-20201019192031087.png" alt="image-20201019192031087"></p>
<p><img src="D:/Note/Typora_picture/image-20201019192059962.png" alt="image-20201019192059962"></p>
<p><strong>总结</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201019192840368.png" alt="image-20201019192840368"></p>
<h3 id="直接封装RIP、OSPF和BGP报文的协议"><a href="#直接封装RIP、OSPF和BGP报文的协议" class="headerlink" title="直接封装RIP、OSPF和BGP报文的协议"></a>直接封装RIP、OSPF和BGP报文的协议</h3><p><img src="D:/Note/Typora_picture/image-20201019192800829.png" alt="image-20201019192800829"></p>
<hr>
<h2 id="4-7、IPv4数据报的首部格式"><a href="#4-7、IPv4数据报的首部格式" class="headerlink" title="4.7、IPv4数据报的首部格式"></a>4.7、IPv4数据报的首部格式</h2><h3 id="各字段的作用"><a href="#各字段的作用" class="headerlink" title="各字段的作用"></a>各字段的作用</h3><ul>
<li>一个 IP 数据报由<strong>首部</strong>和<strong>数据</strong>两部分组成。</li>
<li><strong>首部的前一部分是固定长度，共 20 字节，是所有 IP 数据报必须具有的。</strong></li>
<li>在首部的固定部分的后面是一些可选字段，其长度是可变的。</li>
</ul>
<p><img src="D:/Note/Typora_picture/image-20201019205931748.png" alt="image-20201019205931748"></p>
<p>图中的每一行都由32个比特（也就是4个字节）构成，每个小格子称为字段或者域，每个字段或某些字段的组合用来表达IP协议的相关功能</p>
<p><img src="D:/Note/Typora_picture/image-20201019211719880.png" alt="image-20201019211719880"></p>
<blockquote>
<p><strong>IP数据报的首部长度一定是4字节的整数倍</strong></p>
<p>因为首部中的可选字段的长度从1个字节到40个字节不等，那么，当20字节的固定部分加上1到40个字节长度不等的可变部分，<strong>会造成首部长度不是4字节整数倍时，就用取值为全0的填充字段填充相应个字节</strong>，以确保IP数据报的首部长度是4字节的整数倍</p>
</blockquote>
<p><img src="D:/Note/Typora_picture/image-20201019212617006.png" alt="image-20201019212617006"></p>
<p><img src="D:/Note/Typora_picture/image-20201019220435415.png" alt="image-20201019220435415"></p>
<p><strong>对IPv4数据报进行分片</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201019221021157.png" alt="image-20201019221021157"></p>
<p>​        现在假定分片2的IP数据报经过某个网络时还需要进行分片</p>
<p><img src="D:/Note/Typora_picture/image-20201019221246870.png" alt="image-20201019221246870"></p>
<p><img src="D:/Note/Typora_picture/image-20201019222512112.png" alt="image-20201019222512112"></p>
<p><img src="D:/Note/Typora_picture/image-20201019222552444.png" alt="image-20201019222552444"></p>
<p><img src="D:/Note/Typora_picture/image-20201019222729797.png" alt="image-20201019222729797"></p>
<p><img src="D:/Note/Typora_picture/image-20201019223101434.png" alt="image-20201019223101434"></p>
<h3 id="总结-10"><a href="#总结-10" class="headerlink" title="总结"></a>总结</h3><p><img src="D:/Note/Typora_picture/image-20201019225141559.png" alt="image-20201019225141559"></p>
<hr>
<h2 id="4-8、网际控制报文协议ICMP"><a href="#4-8、网际控制报文协议ICMP" class="headerlink" title="4.8、网际控制报文协议ICMP"></a>4.8、网际控制报文协议ICMP</h2><h3 id="概念-5"><a href="#概念-5" class="headerlink" title="概念"></a>概念</h3><p>架构IP网络时需要特别注意两点：</p>
<ul>
<li>确认网络是否正常工作</li>
<li>遇到异常时进行问题诊断</li>
</ul>
<p><strong>而ICMP就是实现这些问题的协议</strong></p>
<p>ICMP的主要功能包括：</p>
<ul>
<li>确认IP包是否成功送达目标地址</li>
<li>通知在发送过程当中IP包被废弃的具体原因</li>
<li>改善网络设置等</li>
</ul>
<p><strong>有了这些功能以后，就可以获得网络是否正常，设置是否有误以及设备有何异常等信息，从而便于进行网络上的问题诊断</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201019232539898.png" alt="image-20201019232539898"></p>
<p><strong>ICMP 不是高层协议（看起来好像是高层协议，因为 ICMP 报文是装在 IP 数据报中，作为其中的数据部分），而是 IP 层的协议</strong></p>
<p>ICMP 报文的格式</p>
<p><img src="D:/Note/Typora_picture/image-20201020001035813.png" alt="image-20201020001035813"></p>
<h3 id="ICMP差错报告报文"><a href="#ICMP差错报告报文" class="headerlink" title="ICMP差错报告报文"></a>ICMP差错报告报文</h3><h4 id="终点不可达"><a href="#终点不可达" class="headerlink" title="终点不可达"></a>终点不可达</h4><p><img src="D:/Note/Typora_picture/image-20201019230838587.png" alt="image-20201019230838587"></p>
<h4 id="源点抑制"><a href="#源点抑制" class="headerlink" title="源点抑制"></a>源点抑制</h4><p><img src="D:/Note/Typora_picture/image-20201019231022291.png" alt="image-20201019231022291"></p>
<h4 id="时间超过"><a href="#时间超过" class="headerlink" title="时间超过"></a>时间超过</h4><p><img src="D:/Note/Typora_picture/image-20201019231230798.png" alt="image-20201019231230798"></p>
<h4 id="参数问题"><a href="#参数问题" class="headerlink" title="参数问题"></a>参数问题</h4><p><img src="D:/Note/Typora_picture/image-20201019231355471.png" alt="image-20201019231355471"></p>
<h4 id="改变路由（重定向）"><a href="#改变路由（重定向）" class="headerlink" title="改变路由（重定向）"></a>改变路由（重定向）</h4><p><img src="D:/Note/Typora_picture/image-20201019231553990.png" alt="image-20201019231553990"></p>
<h4 id="不应发送ICMP差错报告报文情况"><a href="#不应发送ICMP差错报告报文情况" class="headerlink" title="不应发送ICMP差错报告报文情况"></a>不应发送ICMP差错报告报文情况</h4><p><img src="D:/Note/Typora_picture/image-20201019231733673.png" alt="image-20201019231733673"></p>
<h3 id="ICMP应用举例"><a href="#ICMP应用举例" class="headerlink" title="ICMP应用举例"></a>ICMP应用举例</h3><h4 id="分组网间探测PING（Packet-InterNet-Groper）"><a href="#分组网间探测PING（Packet-InterNet-Groper）" class="headerlink" title="分组网间探测PING（Packet InterNet Groper）"></a>分组网间探测PING（Packet InterNet Groper）</h4><p><img src="D:/Note/Typora_picture/image-20201019233817921.png" alt="image-20201019233817921"></p>
<h4 id="跟踪路由（traceroute）"><a href="#跟踪路由（traceroute）" class="headerlink" title="跟踪路由（traceroute）"></a>跟踪路由（traceroute）</h4><p><img src="D:/Note/Typora_picture/image-20201019234123026.png" alt="image-20201019234123026"></p>
<p><strong>tracert命令的实现原理</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201019234718107.png" alt="image-20201019234718107"></p>
<p><img src="D:/Note/Typora_picture/image-20201019234741268.png" alt="image-20201019234741268"></p>
<p><img src="D:/Note/Typora_picture/image-20201019234758693.png" alt="image-20201019234758693"></p>
<h3 id="总结-11"><a href="#总结-11" class="headerlink" title="总结"></a>总结</h3><p><img src="D:/Note/Typora_picture/image-20201019234909146.png" alt="image-20201019234909146"></p>
<hr>
<h2 id="4-9、虚拟专用网VPN与网络地址转换NAT"><a href="#4-9、虚拟专用网VPN与网络地址转换NAT" class="headerlink" title="4.9、虚拟专用网VPN与网络地址转换NAT"></a>4.9、虚拟专用网VPN与网络地址转换NAT</h2><h3 id="虚拟专用网VPN（Virtual-Private-Network）"><a href="#虚拟专用网VPN（Virtual-Private-Network）" class="headerlink" title="虚拟专用网VPN（Virtual Private Network）"></a>虚拟专用网VPN（Virtual Private Network）</h3><ul>
<li>由于 <strong>IP 地址的紧缺</strong>，一个机构能够申请到的IP地址数往往远小于本机构所拥有的主机数。</li>
<li>考虑到<strong>互联网并不很安全</strong>，一个机构内也并不需要把所有的主机接入到外部的互联网。</li>
<li>假定在一个机构内部的计算机通信也是采用 TCP&#x2F;IP 协议，那么从原则上讲，对于这些仅在<strong>机构内部使用</strong>的计算机就可以由本机构<strong>自行分配其 IP 地址</strong>。</li>
</ul>
<p><img src="D:/Note/Typora_picture/image-20201019235534728.png" alt="image-20201019235534728"></p>
<p><img src="D:/Note/Typora_picture/image-20201019235631474.png" alt="image-20201019235631474"></p>
<p><img src="D:/Note/Typora_picture/image-20201019235718010.png" alt="image-20201019235718010"></p>
<blockquote>
<p>上图是因特网数字分配机构IANA官网查看IPv4地址空间中特殊地址的分配方案</p>
<p>用粉红色标出来的地址就是无需申请的、可自由分配的专用地址，或称私有地址</p>
</blockquote>
<p><img src="D:/Note/Typora_picture/image-20201020000136443.png" alt="image-20201020000136443"></p>
<blockquote>
<p>私有地址只能用于一个机构的内部通信，而不能用于和因特网上的主机通信</p>
<p>私有地址只能用作本地地址而不能用作全球地址</p>
<p>因特网中所有路由器对目的地址是私有地址的IP数据报一律不进行转发</p>
<p><strong>本地地址与全球地址</strong></p>
<ul>
<li><strong>本地地址</strong>——仅在机构内部使用的 IP 地址，可以由本机构自行分配，而不需要向互联网的管理机构申请。</li>
<li><strong>全球地址</strong>——全球唯一的 IP 地址，必须向互联网的管理机构申请。 </li>
<li><strong>问题</strong>：在内部使用的本地地址就有可能和互联网中某个 IP 地址重合，这样就会出现地址的二义性问题。</li>
</ul>
</blockquote>
<p>所以部门A和部门B至少需要一个 路由器具有合法的全球IP地址，这样各自的专用网才能利用公用的因特网进行通信</p>
<p><img src="D:/Note/Typora_picture/image-20201020000618797.png" alt="image-20201020000618797"></p>
<p>部门A向部门B发送数据流程</p>
<p><img src="D:/Note/Typora_picture/image-20201020001107425.png" alt="image-20201020001107425"></p>
<blockquote>
<p>两个专用网内的主机间发送的数据报是通过了公用的因特网，但在效果上就好像是在本机构的专用网上传送一样</p>
<p>数据报在因特网中可能要经过多个网络和路由器，但从逻辑上看，R1和R2之间好像是一条直通的点对点链路</p>
<p><img src="D:/Note/Typora_picture/image-20201020001528569.png" alt="image-20201020001528569"></p>
<p>因此也被称为IP隧道技术</p>
</blockquote>
<p><img src="D:/Note/Typora_picture/image-20201020001935801.png" alt="image-20201020001935801"></p>
<h3 id="网络地址转换NAT（Network-Address-Translation）"><a href="#网络地址转换NAT（Network-Address-Translation）" class="headerlink" title="网络地址转换NAT（Network Address Translation）"></a>网络地址转换NAT（Network Address Translation）</h3><p><img src="D:/Note/Typora_picture/image-20201020002020607.png" alt="image-20201020002020607"></p>
<p>举例</p>
<p><img src="D:/Note/Typora_picture/image-20201020002439942.png" alt="image-20201020002439942"></p>
<blockquote>
<p>使用私有地址的主机，如何才能与因特网上使用全球IP地址的主机进行通信？</p>
<p>这需要在专用网络连接到因特网的路由器上安装NAT软件</p>
</blockquote>
<p><img src="D:/Note/Typora_picture/image-20201020002734192.png" alt="image-20201020002734192"></p>
<blockquote>
<p>专有NAT软件的路由器叫做NAT路由器</p>
<p>它至少有一个有效的外部全球IP地址</p>
<p>这样，所有使用私有地址的主机在和外界通信时，都要在NAT路由器上将其私有地址转换为全球IP地址</p>
</blockquote>
<p>假设，使用私有地址的主机要给因特网上使用全球IP地址的另一台主机发送IP数据报</p>
<p><img src="D:/Note/Typora_picture/image-20201020003238729.png" alt="image-20201020003238729"></p>
<p>因特网上的这台主机给源主机发回数据报</p>
<p><img src="D:/Note/Typora_picture/image-20201020003411024.png" alt="image-20201020003411024"></p>
<p>当专用网中的这两台使用私有地址的主机都要给因特网使用全球地址的另一台主机发送数据报时，在NAT路由器的NAT转换表中就会产生两条记录，分别记录两个私有地址与全球地址的对应关系</p>
<p><img src="D:/Note/Typora_picture/image-20201020003658349.png" alt="image-20201020003658349"></p>
<p>这种基本转换存在一个问题</p>
<p><img src="D:/Note/Typora_picture/image-20201020003733863.png" alt="image-20201020003733863"></p>
<p>解决方法</p>
<p><img src="D:/Note/Typora_picture/image-20201020003840584.png" alt="image-20201020003840584"></p>
<blockquote>
<p>我们现在用的很多家用路由器都是这种NART路由器</p>
</blockquote>
<p>内网主机与外网主机的通信，是否能由外网主机首先发起？</p>
<p>否定</p>
<p><img src="D:/Note/Typora_picture/image-20201020004159360.png" alt="image-20201020004159360"></p>
<p><img src="D:/Note/Typora_picture/image-20201020004312942.png" alt="image-20201020004312942"></p>
<h3 id="总结-12"><a href="#总结-12" class="headerlink" title="总结"></a>总结</h3><p><img src="D:/Note/Typora_picture/image-20201020004447021.png" alt="image-20201020004447021"></p>
<h2 id="习题-3"><a href="#习题-3" class="headerlink" title="习题"></a>习题</h2><h3 id="IPv4习题"><a href="#IPv4习题" class="headerlink" title="IPv4习题"></a>IPv4习题</h3><p><img src="D:/Note/Typora_picture/image-20201017151024579.png" alt="image-20201017151024579"></p>
<hr>
<p><img src="D:/Note/Typora_picture/image-20201017151500372.png" alt="image-20201017151500372"></p>
<blockquote>
<p>题目的注意点</p>
<p><strong>本题按照节约原则</strong></p>
<p>路由器的接口也要分配一个IP地址</p>
<p>所以橙色网络的IP地址数量是 65534 + 1 &#x3D; 65535，同理 蓝色网络的是 255 个，绿色网络（交换式以太网）的是 16 + 24 + 1 &#x3D; 41 个，红色网络（两台路由器通过一段链路直连，它们的直连接口也属于一个网络）是 2 个</p>
<p>分配IP地址不能相同</p>
<p>不能出现两个一样的网络号</p>
</blockquote>
<hr>
<p><img src="D:/Note/Typora_picture/image-20201017161733295.png" alt="image-20201017161733295"></p>
<hr>
<p><img src="D:/Note/Typora_picture/image-20201017162644758.png" alt="image-20201017162644758"></p>
<hr>
<p><img src="D:/Note/Typora_picture/image-20201017165224804.png" alt="image-20201017165224804"></p>
<hr>
<p><img src="D:/Note/Typora_picture/image-20201017170339534.png" alt="image-20201017170339534"></p>
<hr>
<p><img src="D:/Note/Typora_picture/image-20201017170516701.png" alt="image-20201017170516701"></p>
<h3 id="IP数据报的发送和转发过程"><a href="#IP数据报的发送和转发过程" class="headerlink" title="IP数据报的发送和转发过程"></a>IP数据报的发送和转发过程</h3><p><img src="D:/Note/Typora_picture/image-20201018152326777.png" alt="image-20201018152326777"></p>
<hr>
<p><img src="D:/Note/Typora_picture/image-20201018152504951.png" alt="image-20201018152504951"></p>
<hr>
<p><img src="D:/Note/Typora_picture/image-20201018152811812.png" alt="image-20201018152811812"></p>
<h3 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h3><p><img src="D:/Note/Typora_picture/image-20201019150738458.png" alt="image-20201019150738458"></p>
<hr>
<p><img src="D:/Note/Typora_picture/image-20201019152221295.png" alt="image-20201019152221295"></p>
<hr>
<p><img src="D:/Note/Typora_picture/image-20201019192349770.png" alt="image-20201019192349770"></p>
<hr>
<p><img src="D:/Note/Typora_picture/image-20201019192546327.png" alt="image-20201019192546327"></p>
<h3 id="IPv4数据报的首部格式"><a href="#IPv4数据报的首部格式" class="headerlink" title="IPv4数据报的首部格式"></a>IPv4数据报的首部格式</h3><p><img src="D:/Note/Typora_picture/image-20201019223719168.png" alt="image-20201019223719168"></p>
<blockquote>
<p>780&#x2F;8向下取整等于97</p>
<p>97*8 &#x3D; 776</p>
</blockquote>
<hr>
<p><img src="D:/Note/Typora_picture/image-20201019224949922.png" alt="image-20201019224949922"></p>
<h3 id="网际控制报文协议ICMP"><a href="#网际控制报文协议ICMP" class="headerlink" title="网际控制报文协议ICMP"></a>网际控制报文协议ICMP</h3><p><img src="D:/Note/Typora_picture/image-20201019232300815.png" alt="image-20201019232300815"></p>
<h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><h2 id="5-1、运输层概述"><a href="#5-1、运输层概述" class="headerlink" title="5.1、运输层概述"></a>5.1、运输层概述</h2><h3 id="概念-6"><a href="#概念-6" class="headerlink" title="概念"></a>概念</h3><p><strong>进程之间的通信</strong></p>
<img src="D:/Note/Typora_picture/image-20201020211725185.png" alt="image-20201020211725185" style="zoom:67%;" />

<ul>
<li>从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务，<strong>它属于面向通信部分的最高层，同时也是用户功能中的最低层</strong>。</li>
<li>当网络的边缘部分中的两个主机使用网络的核心部分的功能进行端到端的通信时，<strong>只有位于网络边缘部分的主机的协议栈才有运输层</strong>，而网络核心部分中的路由器在转发分组时都只用到三层（到网络层）的功能。</li>
</ul>
<p><img src="D:/Note/Typora_picture/image-20201020211339131.png" alt="image-20201020211339131"></p>
<p><strong>进程之间通信流程</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201020213721054.png" alt="image-20201020213721054"></p>
<p>“逻辑通信”是指运输层之间的通信好像是沿水平方向传送数据，但事实上，这两条数据并没有一条水平方向的物理连接，要传送的数据是沿着图中上下多次的虚线方向传送的</p>
<blockquote>
<p>进程Ap1与Ap4之间进行基于网络的通信，进程Ap2与Ap3之间进行基于网络的通信</p>
<p>在运输层使用不同的端口，来对应不同的应用进程</p>
<p>然后通过网络层及其下层来传输应用层报文</p>
<p>接收方的运输层通过不同的端口，将收到的应用层报文，交付给应用层中相应的应用进程</p>
<p>这里端口并不是指看得见、摸得着的物理端口，而是指用来区分不同应用进程的标识符</p>
</blockquote>
<p><img src="D:/Note/Typora_picture/image-20201020220439303.png" alt="image-20201020220439303"></p>
<h3 id="总结-13"><a href="#总结-13" class="headerlink" title="总结"></a>总结</h3><p><img src="D:/Note/Typora_picture/image-20201020220545411.png" alt="image-20201020220545411"></p>
<p><img src="D:/Note/Typora_picture/image-20201020222828878.png" alt="image-20201020222828878"></p>
<hr>
<h2 id="5-2、运输层端口号、复用与分用的概念"><a href="#5-2、运输层端口号、复用与分用的概念" class="headerlink" title="5.2、运输层端口号、复用与分用的概念"></a>5.2、运输层端口号、复用与分用的概念</h2><h3 id="为什么用端口号"><a href="#为什么用端口号" class="headerlink" title="为什么用端口号"></a>为什么用端口号</h3><p><img src="D:/Note/Typora_picture/image-20201020223242364.png" alt="image-20201020223242364"></p>
<h3 id="发送方的复用和接收方的分用"><a href="#发送方的复用和接收方的分用" class="headerlink" title="发送方的复用和接收方的分用"></a>发送方的复用和接收方的分用</h3><p><img src="D:/Note/Typora_picture/image-20201020223920225.png" alt="image-20201020223920225"></p>
<blockquote>
<p><strong>多个进程（这里一个端口表示一个进程）</strong> 利用一个运输层协议（或者称为运输层接口）<strong>发送</strong>数据称为 <strong>复用</strong></p>
<p><strong>多个进程（这里一个端口表示一个进程）</strong> 利用一个运输层协议（或者称为运输层接口）<strong>接收</strong>时叫做  <strong>分用</strong>。</p>
</blockquote>
<h3 id="TCP-x2F-IP体系的应用层常用协议所使用的运输层熟知端口号"><a href="#TCP-x2F-IP体系的应用层常用协议所使用的运输层熟知端口号" class="headerlink" title="TCP&#x2F;IP体系的应用层常用协议所使用的运输层熟知端口号"></a>TCP&#x2F;IP体系的应用层常用协议所使用的运输层熟知端口号</h3><p><img src="D:/Note/Typora_picture/image-20201020224521744.png" alt="image-20201020224521744"></p>
<h3 id="运输层传输流程"><a href="#运输层传输流程" class="headerlink" title="运输层传输流程"></a>运输层传输流程</h3><p>举例</p>
<p><img src="D:/Note/Typora_picture/image-20201020224658524.png" alt="image-20201020224658524"></p>
<blockquote>
<p>在浏览器输入域名，回车浏览</p>
<p>然后用户PC中的DNS客户端进程会发送一个DNS查询请求报文</p>
<p>DNS查询请求报文需要使用运输层的UDP协议</p>
<p>首部中的源端口字段的值，在短暂端口号49151~65535中挑选一个未被占用的，用来表示DNS客户端进程</p>
<p>首部中的目的端口字段的值：53，是DNS服务器端进程所使用的熟知端口号</p>
</blockquote>
<p><img src="D:/Note/Typora_picture/image-20201020225830336.png" alt="image-20201020225830336"></p>
<blockquote>
<p>之后，将UDP用户数据报封装在IP数据报中，通过以太网发送给DNS服务器</p>
</blockquote>
<p><img src="D:/Note/Typora_picture/image-20201020230059196.png" alt="image-20201020230059196"></p>
<blockquote>
<p>DNS服务器收到该IP数据报后，从中解封出UDP用户数据报</p>
<p>UDP首部中的目的端口号为53，这表明应将该UDP用户数据报的数据载荷部分，也就是DNS查询请求报文，交付给本服务器中的DNS服务器端进程</p>
<p>DNS服务器端进程解析DNS查询请求报文的内容，然后按其要求查找对应的IP地址</p>
<p>之后，会给用户PC发送DNS响应报文，DNS响应报文需要使用运输层的UDP协议封装成UDP用户数据报</p>
<p>其首部中的源端口字段的值设置为熟知端口号53，表明这是DNS服务器端进程所发送的UDP用户数据报，目的端口的值设置为49152，这是之前用户PC中发送DNS查询请求报文的DNS客户端进程所使用的短暂端口号</p>
</blockquote>
<p><img src="D:/Note/Typora_picture/image-20201020231032812.png" alt="image-20201020231032812"></p>
<blockquote>
<p>将UDP用户数据报封装在IP数据报中，通过以太网发送给用户PC</p>
</blockquote>
<p><img src="D:/Note/Typora_picture/image-20201020231308120.png" alt="image-20201020231308120"></p>
<blockquote>
<p>用户PC收到该数据报后，从中解封出UDP用户数据报</p>
<p>UDP首部中的目的端口号为49152，这表明应将该UDP用户数据报的数据载荷部分，也就是DNS响应报文，交付给用户PC中的DNS客户端进程</p>
<p>DNS客户端进程解析DNS响应报文的内容，就可知道自己之前所请求的Web服务器的域名对应的IP地址</p>
</blockquote>
<p>现在用户PC中的HTTP客户端进程可以向Web服务器发送HTTP请求报文（和DNS发送和接收流程差不多）</p>
<p><img src="D:/Note/Typora_picture/image-20201020231935656.png" alt="image-20201020231935656"></p>
<p><img src="D:/Note/Typora_picture/image-20201020232517383.png" alt="image-20201020232517383"></p>
<p><img src="D:/Note/Typora_picture/image-20201020232132890.png" alt="image-20201020232132890"></p>
<p><img src="D:/Note/Typora_picture/image-20201020232548833.png" alt="image-20201020232548833"></p>
<p><img src="D:/Note/Typora_picture/image-20201020232337332.png" alt="image-20201020232337332"></p>
<hr>
<h2 id="5-3、UDP和TCP的对比"><a href="#5-3、UDP和TCP的对比" class="headerlink" title="5.3、UDP和TCP的对比"></a>5.3、UDP和TCP的对比</h2><h3 id="概念-7"><a href="#概念-7" class="headerlink" title="概念"></a>概念</h3><ul>
<li><strong>UDP</strong> 和 <strong>TCP</strong> 是TCP&#x2F;IP体系结构<strong>运输层</strong>中的两个重要协议</li>
<li>当运输层采用面向连接的 <strong>TCP</strong> 协议时，尽管下面的网络是不可靠的（只提供尽最大努力服务），但这种逻辑通信信道就相当于一条<strong>全双工的可靠信道</strong>。</li>
<li>当运输层采用无连接的 <strong>UDP</strong> 协议时，这种逻辑通信信道是一条<strong>不可靠信道</strong>。</li>
</ul>
<p>可靠信道与不可靠信道</p>
<p><img src="D:/Note/Typora_picture/image-20201021192221061.png" alt="image-20201021192221061"></p>
<ul>
<li><p>两个对等运输实体在通信时传送的数据单位叫作<strong>运输协议数据单元</strong> TPDU (Transport Protocol Data Unit)。</p>
</li>
<li><p>TCP 传送的数据单位协议是 <strong>TCP 报文段</strong>(segment)。</p>
</li>
<li><p>UDP 传送的数据单位协议是 <strong>UDP 报文</strong>或<strong>用户数据报</strong>。</p>
</li>
</ul>
<p><img src="D:/Note/Typora_picture/image-20201021193640130.png" alt="image-20201021193640130"></p>
<p>UDP的通信是无连接的，不需要套接字（Socket）</p>
<p>TCP是面向连接的，TCP之间的通信必须要在两个套接字（Socket）之间建立连接</p>
<h3 id="用户数据报协议UDP（User-Datagram-Protocol）"><a href="#用户数据报协议UDP（User-Datagram-Protocol）" class="headerlink" title="用户数据报协议UDP（User Datagram Protocol）"></a>用户数据报协议UDP（User Datagram Protocol）</h3><p>可以发送广播</p>
<img src="D:/Note/Typora_picture/image-20201021194104694.png" alt="image-20201021194104694" style="zoom: 50%;" />

<p>可以向某个多播组发送多播</p>
<img src="D:/Note/Typora_picture/image-20201021194225567.png" alt="image-20201021194225567" style="zoom:50%;" />

<p>还可以发送单播</p>
<img src="D:/Note/Typora_picture/image-20201021194341256.png" alt="image-20201021194341256" style="zoom:50%;" />

<blockquote>
<p>UDP 支持单播、多播以及广播</p>
<p>换句话说，UDP支持一对一，一对多，以及一对全的通信</p>
</blockquote>
<p>运输过程</p>
<p><img src="D:/Note/Typora_picture/image-20201021195034383.png" alt="image-20201021195034383"></p>
<blockquote>
<p>UDP对应用进程交下来的报文既不合并也不拆分，而是保留这些报文的边界</p>
<p>换句话说，UDP是面向应用报文的</p>
</blockquote>
<p>UDP向上层提供无连接不可靠传输服务</p>
<p><img src="D:/Note/Typora_picture/image-20201021204152175.png" alt="image-20201021204152175"></p>
<p>UDP结构</p>
<p><img src="D:/Note/Typora_picture/image-20201021205214512.png" alt="image-20201021205214512"></p>
<h3 id="传输控制协议TCP（Transmission-Control-Protocol）"><a href="#传输控制协议TCP（Transmission-Control-Protocol）" class="headerlink" title="传输控制协议TCP（Transmission Control Protocol）"></a>传输控制协议TCP（Transmission Control Protocol）</h3><p>使用TCP协议的通信双方，在进行数据传输之前，必须使用“三报文握手”建立TCP连接</p>
<img src="D:/Note/Typora_picture/image-20201021194557102.png" alt="image-20201021194557102" style="zoom:50%;" />

<p>TCP连接建立成功后，通信双方之间就好像有一条可靠的通信信道，通信双方使用这条基于TCP连接的可靠信道进行通信</p>
<img src="D:/Note/Typora_picture/image-20201021194749562.png" alt="image-20201021194749562" style="zoom:50%;" />

<blockquote>
<p>很显然，TCP仅支持单播，也就是一对一的通信</p>
</blockquote>
<p>运输过程</p>
<p><img src="D:/Note/Typora_picture/image-20201021195435677.png" alt="image-20201021195435677"></p>
<blockquote>
<p>发送方</p>
<ul>
<li><p>TCP会把应用进程交付下来的数据块看作是一连串无结构的字节流，TCP并不知道这些待传送的字节流的含义</p>
</li>
<li><p>并将他们编号，并存储在自己发送缓存中</p>
</li>
<li><p>TCP会根据发送策略，提取一定量的字节构建TCP报文并发送</p>
</li>
</ul>
<p>接收方</p>
<ul>
<li>一方面从所接受到的TCP报文段中，取出数据载荷部分并存储在接收缓存中；一方面将接收缓存中的一些字节交付给应用进程</li>
<li>TCP不保证接收方应用进程所收到的数据块与发送方发送的数据块，具有对应大小的关系（例如，发送方应用进程交给发送方的TCP共10个数据块，但接收方的TCP可能只用了4个数据块，就把收到的字节流交付给了上层的应用进程，但接收方收到的字节流必须和发送方应用进程发出的字节流完全一样）</li>
<li>接收方的应用进程必须有能力识别收到的字节流，把它还原成有意义的应用层数据</li>
</ul>
<p>TCP是面向字节流的，这正是TCP实现可靠传输、流量控制、以及拥塞控制的基础</p>
<p>本图只画了一个方向的数据流，在实际网络中，基于TCP连接的两端，可以同时进行TCP报文段的发送和接收</p>
</blockquote>
<p>TCP向上层提供面向连接的可靠传输服务</p>
<p><img src="D:/Note/Typora_picture/image-20201021204508839.png" alt="image-20201021204508839"></p>
<p>TCP结构</p>
<p><img src="D:/Note/Typora_picture/image-20201021205307406.png" alt="image-20201021205307406"></p>
<h3 id="总结-14"><a href="#总结-14" class="headerlink" title="总结"></a>总结</h3><p><img src="D:/Note/Typora_picture/image-20201023004653315.png" alt="image-20201023004653315"></p>
<hr>
<h2 id="5-4、TCP的流量控制"><a href="#5-4、TCP的流量控制" class="headerlink" title="5.4、TCP的流量控制"></a>5.4、TCP的流量控制</h2><h3 id="概念-8"><a href="#概念-8" class="headerlink" title="概念"></a>概念</h3><p><img src="D:/Note/Typora_picture/image-20201021223432091.png" alt="image-20201021223432091"></p>
<p>举例</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1c4411d7jb?p=60">具体流程的视频</a></p>
<p><img src="D:/Note/Typora_picture/image-20201021231801076.png" alt="image-20201021231801076"></p>
<p>上图主机A现在可将发送缓存中序号1~200的字节数据全部删除，因为已经收到了主机B对它们的累计确认</p>
<p><img src="D:/Note/Typora_picture/image-20201021231904707.png" alt="image-20201021231904707"></p>
<p>上图主机A现在可将发送缓存中序号201~500的字节数据全部删除，因为已经收到了主机B对它们的累计确认</p>
<p><img src="D:/Note/Typora_picture/image-20201021231945653.png" alt="image-20201021231945653"></p>
<p><img src="D:/Note/Typora_picture/image-20201021232027721.png" alt="image-20201021232027721"></p>
<p>上图主机A现在可将发送缓存中序号501~600的字节数据全部删除，因为已经收到了主机B对它们的累计确认</p>
<p><img src="D:/Note/Typora_picture/image-20201021232600497.png" alt="image-20201021232600497"></p>
<p><img src="D:/Note/Typora_picture/image-20201021232645300.png" alt="image-20201021232645300"></p>
<blockquote>
<p>上图如果零窗口探测报文在发送过程中如果丢失，还是能打破死锁局面</p>
<p>因为零窗口探测报文段也有重传计时器，重传计时器超时后，零窗口探测报文段会被重传</p>
</blockquote>
<h3 id="总结-15"><a href="#总结-15" class="headerlink" title="总结"></a>总结</h3><p><img src="D:/Note/Typora_picture/image-20201021234004254.png" alt="image-20201021234004254"></p>
<hr>
<h2 id="5-5、TCP的拥塞控制"><a href="#5-5、TCP的拥塞控制" class="headerlink" title="5.5、TCP的拥塞控制"></a>5.5、TCP的拥塞控制</h2><h3 id="概念-9"><a href="#概念-9" class="headerlink" title="概念"></a>概念</h3><p><img src="D:/Note/Typora_picture/image-20201022141057083.png" alt="image-20201022141057083"></p>
<p><strong>网络拥塞往往是由许多因素引起的。例如：</strong></p>
<ol>
<li>点缓存的容量太小；</li>
<li>链路的容量不足；</li>
<li>处理机处理的速率太慢；</li>
<li>拥塞本身会进一步加剧拥塞；</li>
</ol>
<p><strong>拥塞控制的一般原理</strong></p>
<ul>
<li>拥塞控制的前提：网络能够承受现有的网络负荷。</li>
<li>实践证明，拥塞控制是很难设计的，因为它是一个<strong>动态问题</strong>。</li>
<li>分组的丢失是网络发生拥塞的<strong>征兆</strong>而不是原因。</li>
<li>在许多情况下，甚至正是<strong>拥塞控制本身</strong>成为引起网络性能恶化、甚至发生死锁的原因。</li>
</ul>
<p><strong>开环控制和闭环控制</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201022142108309.png" alt="image-20201022142108309"></p>
<p><strong>监测网络的拥塞</strong></p>
<p>主要指标有：</p>
<ol>
<li>由于缺少缓存空间而被丢弃的分组的百分数；</li>
<li>平均队列长度；</li>
<li>超时重传的分组数；</li>
<li>平均分组时延；</li>
<li>分组时延的标准差，等等。</li>
</ol>
<p>上述这些指标的上升都标志着拥塞的增长。</p>
<h3 id="拥塞控制的算法"><a href="#拥塞控制的算法" class="headerlink" title="拥塞控制的算法"></a>拥塞控制的算法</h3><p><img src="D:/Note/Typora_picture/image-20201022141423443.png" alt="image-20201022141423443"></p>
<p><img src="D:/Note/Typora_picture/image-20201022141556134.png" alt="image-20201022141556134"></p>
<blockquote>
<p>真正的发送窗口值 &#x3D; Min (接收方窗口值，拥塞窗口值)</p>
</blockquote>
<p>下图的实例横纵坐标的意思</p>
<p>传输轮次：</p>
<ul>
<li>发送方给接收方发送数据报文段后，接收方给发送方发发回相应的确认报文段</li>
<li>一个传输轮次所经历的时间其实就是往返时间，往返时间并非是恒定的数值</li>
<li>使用传输轮次是为了强调把拥塞窗口所允许发送的报文段都连续发送出去，并受到了对已发送的最后一个报文段的确认</li>
</ul>
<p>拥塞窗口：</p>
<ul>
<li>它会随网络拥塞程度，以及所使用的拥塞控制算法动态变化</li>
</ul>
<h4 id="慢开始和拥塞避免"><a href="#慢开始和拥塞避免" class="headerlink" title="慢开始和拥塞避免"></a>慢开始和拥塞避免</h4><h5 id="慢开始（slow-start）"><a href="#慢开始（slow-start）" class="headerlink" title="慢开始（slow-start）"></a>慢开始（slow-start）</h5><ul>
<li>目的：用来确定网络的负载能力或拥塞程度。</li>
<li>算法的思路：由小到大逐渐增大拥塞窗口数值。</li>
<li>两个变量：<ul>
<li><strong>拥塞窗口（cwnd）</strong>：初始拥塞窗口值：2 种设置方法。窗口值逐渐增大。<ul>
<li>1 至 2 个最大报文段 （旧标准）</li>
<li>2 至 4 个最大报文段 （RFC 5681）</li>
</ul>
</li>
<li><strong>慢开始门限（ssthresh）</strong>：防止拥塞窗口增长过大引起网络拥塞。</li>
</ul>
</li>
</ul>
<p><img src="D:/Note/Typora_picture/image-20201022145631052.png" alt="image-20201022145631052"></p>
<p><img src="D:/Note/Typora_picture/image-20201022144725100.png" alt="image-20201022144725100"></p>
<blockquote>
<p>图中swnd是发送窗口</p>
<p>每经过一个传输轮次，拥塞窗口就加倍</p>
<p>窗口大小按<strong>指数增加</strong>，2的n-1次方</p>
</blockquote>
<h5 id="拥塞避免（congestion-avoidance）"><a href="#拥塞避免（congestion-avoidance）" class="headerlink" title="拥塞避免（congestion avoidance）"></a>拥塞避免（congestion avoidance）</h5><ul>
<li>思路：让拥塞窗口 cwnd <strong>缓慢地增大</strong>，避免出现拥塞。</li>
<li>每经过一个传输轮次，拥塞窗口 <strong>cwnd &#x3D; cwnd + 1</strong>。</li>
<li>使拥塞窗口 cwnd 按线性规律缓慢增长。</li>
<li>在拥塞避免阶段，具有 “<strong>加法增大</strong>” (Additive Increase) 的特点。</li>
</ul>
<p><img src="D:/Note/Typora_picture/image-20201022150143886.png" alt="image-20201022150143886"></p>
<p>如果在发送过程中出现部分报文段丢失，这必然会造成发送方对这些丢失报文段的超时重传</p>
<p><img src="D:/Note/Typora_picture/image-20201022145749592.png" alt="image-20201022145749592"></p>
<p>这个时候又回到了慢开始</p>
<p><img src="D:/Note/Typora_picture/image-20201022145544163.png" alt="image-20201022145544163"></p>
<p><img src="D:/Note/Typora_picture/image-20201022145824004.png" alt="image-20201022145824004"></p>
<h5 id="两个算法完整示意图"><a href="#两个算法完整示意图" class="headerlink" title="两个算法完整示意图"></a>两个算法完整示意图</h5><p><img src="D:/Note/Typora_picture/image-20201022150236926.png" alt="image-20201022150236926"></p>
<h4 id="快重传和快恢复"><a href="#快重传和快恢复" class="headerlink" title="快重传和快恢复"></a>快重传和快恢复</h4><p><img src="D:/Note/Typora_picture/image-20201022150902709.png" alt="image-20201022150902709"></p>
<h5 id="快重传（fast-retrasmit）"><a href="#快重传（fast-retrasmit）" class="headerlink" title="快重传（fast retrasmit）"></a>快重传（fast retrasmit）</h5><p><img src="D:/Note/Typora_picture/image-20201022151250183.png" alt="image-20201022151250183"></p>
<h5 id="快恢复（fast-recovery）"><a href="#快恢复（fast-recovery）" class="headerlink" title="快恢复（fast recovery）"></a>快恢复（fast recovery）</h5><p><img src="D:/Note/Typora_picture/image-20201022151819265.png" alt="image-20201022151819265"></p>
<h5 id="改进后的整体算法的示意图"><a href="#改进后的整体算法的示意图" class="headerlink" title="改进后的整体算法的示意图"></a>改进后的整体算法的示意图</h5><p><img src="D:/Note/Typora_picture/image-20201022152041751.png" alt="image-20201022152041751"></p>
<hr>
<h2 id="5-6、TCP超时重传时间的选择"><a href="#5-6、TCP超时重传时间的选择" class="headerlink" title="5.6、TCP超时重传时间的选择"></a>5.6、TCP超时重传时间的选择</h2><p><img src="D:/Note/Typora_picture/image-20201022152651184.png" alt="image-20201022152651184"></p>
<blockquote>
<p>如果超时重传时间RTO的值设置得比RTT0的值小很多，这会引起报文段不必要的重传，使网络负荷增大</p>
</blockquote>
<p><img src="D:/Note/Typora_picture/image-20201022152708875.png" alt="image-20201022152708875"></p>
<blockquote>
<p>如果超时重传时间RTO的值设置得远大于RTT0的值，这会使重传时间推迟的太长，使网络的空闲时间增大，降低传输效率</p>
</blockquote>
<p><img src="D:/Note/Typora_picture/image-20201022153244047.png" alt="image-20201022153244047"></p>
<p><img src="D:/Note/Typora_picture/image-20201022153518218.png" alt="image-20201022153518218"></p>
<p><strong>RFC6298建议使用下式计算超时重传时间RTO</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201022153758413.png" alt="image-20201022153758413"></p>
<p><strong>往返时间RTT的测量比较复杂</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201022154045440.png" alt="image-20201022154045440"></p>
<p><img src="D:/Note/Typora_picture/image-20201022154137911.png" alt="image-20201022154137911"></p>
<p><strong>TCP超时重传的计算</strong></p>
<p>举例</p>
<p><img src="D:/Note/Typora_picture/image-20201022154350745.png" alt="image-20201022154350745"></p>
<p><strong>总结</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201022154418863.png" alt="image-20201022154418863"></p>
<hr>
<h2 id="5-7、TCP可靠传输的实现"><a href="#5-7、TCP可靠传输的实现" class="headerlink" title="5.7、TCP可靠传输的实现"></a>5.7、TCP可靠传输的实现</h2><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1c4411d7jb?p=63">本集具体讲解</a></p>
<p><img src="D:/Note/Typora_picture/image-20201022161436801.png" alt="image-20201022161436801"></p>
<p><img src="D:/Note/Typora_picture/image-20201022161734997.png" alt="image-20201022161734997"></p>
<p><img src="D:/Note/Typora_picture/image-20201022164339902.png" alt="image-20201022164339902"></p>
<hr>
<h2 id="5-8、TCP的运输连接管理"><a href="#5-8、TCP的运输连接管理" class="headerlink" title="5.8、TCP的运输连接管理"></a>5.8、TCP的运输连接管理</h2><h3 id="概念-10"><a href="#概念-10" class="headerlink" title="概念"></a>概念</h3><p><img src="D:/Note/Typora_picture/image-20201022193215183.png" alt="image-20201022193215183"></p>
<h3 id="TCP的连接建立"><a href="#TCP的连接建立" class="headerlink" title="TCP的连接建立"></a>TCP的连接建立</h3><ul>
<li>TCP 建立连接的过程叫做<strong>握手</strong>。</li>
<li>握手需要在客户和服务器之间交换三个 TCP 报文段。称之为<strong>三报文握手</strong>。</li>
<li>采用<strong>三报文握手</strong>主要是为了防止已失效的连接请求报文段突然又传送到了，因而产生错误。</li>
</ul>
<h4 id="TCP的连接建立要解决以下三个问题"><a href="#TCP的连接建立要解决以下三个问题" class="headerlink" title="TCP的连接建立要解决以下三个问题"></a>TCP的连接建立要解决以下三个问题</h4><p><img src="D:/Note/Typora_picture/image-20201022193418673.png" alt="image-20201022193418673"></p>
<h4 id="TCP使用“三报文握手”建立连接"><a href="#TCP使用“三报文握手”建立连接" class="headerlink" title="TCP使用“三报文握手”建立连接"></a>TCP使用“三报文握手”建立连接</h4><ul>
<li>TCP 连接的建立<strong>采用客户服务器方式</strong>。</li>
<li>主动发起连接建立的应用进程叫做<strong>TCP客户</strong> (client)。</li>
<li>被动等待连接建立的应用进程叫做<strong>TCP服务器</strong> (server)。</li>
</ul>
<p>“握手”需要在TCP客户端和服务器之间交换三个TCP报文段</p>
<p>过程</p>
<p><img src="D:/Note/Typora_picture/image-20201022194219693.png" alt="image-20201022194219693"></p>
<blockquote>
<p>最初两端的TCP进程都处于关闭状态</p>
</blockquote>
<p><img src="D:/Note/Typora_picture/image-20201022194350899.png" alt="image-20201022194350899"></p>
<blockquote>
<p>一开始，TCP服务器进程首先创建传输控制块，用来存储TCP连接中的一些重要信息。例如TCP连接表、指向发送和接收缓存的指针、指向重传队列的指针，当前的发送和接收序号等</p>
<p>之后，就准备接受TCP客户端进程的连接请求</p>
<p>此时，TCP服务器进程就进入监听状态，等待TCP客户端进程的连接请求</p>
</blockquote>
<p>TCP服务器进程是被动等待来自TCP客户端进程的连接请求，因此成为<strong>被动打开</strong>连接</p>
<p><img src="D:/Note/Typora_picture/image-20201022194926877.png" alt="image-20201022194926877"></p>
<blockquote>
<p>TCP客户进程也是首先创建传输控制块</p>
</blockquote>
<p>由于TCP连接建立是由TCP客户端主动发起的，因此称为<strong>主动打开</strong>连接</p>
<p><img src="D:/Note/Typora_picture/image-20201022195108616.png" alt="image-20201022195108616"></p>
<blockquote>
<p>然后，在打算建立TCP连接时，向TCP服务器进程发送TCP连接请求报文段，并进入同步已发送状态</p>
<p>TCP连接请求报文段首部中</p>
<ul>
<li>同步位SYN被设置为1，表明这是一个TCP连接请求报文段</li>
<li>序号字段seq被设置了一个初始值x，作为TCP客户端进程所选择的初始序号</li>
</ul>
<p>请注意：TCP规定SYN被设置为1的报文段不能携带数据，但要消耗掉一个序号</p>
</blockquote>
<p><img src="D:/Note/Typora_picture/image-20201022195847144.png" alt="image-20201022195847144"></p>
<blockquote>
<p>TCP服务器进程收到TCP连接请求报文段后，如果同意建立连接，则向TCP客户进程发送TCP连接请求确认报文段，并进入同步已接收状态</p>
<p>TCP连接请求确认报文段首部中</p>
<ul>
<li>同步位SYN和确认为ACK都设置为1，表明这是一个TCP连接请求确认报文段</li>
<li>序号字段seq被设置了一个初始值y，作为TCP服务器进程所选择的初始序号，</li>
<li>确认号字段ack的值被设置成了x+1，这是对TCP客户进程所选择的初始序号（seq）的确认</li>
</ul>
<p>请注意：这个报文段也不能携带数据，因为它是SYN被设置为1的报文段，但同样要消耗掉一个序号</p>
</blockquote>
<p><img src="D:/Note/Typora_picture/image-20201022202010182.png" alt="image-20201022202010182"></p>
<blockquote>
<p>TCP客户进程收到TCP连接请求确认报文段后，还要向TCP服务器进程发送一个普通的TCP确认报文段，并进入连接已连接状态</p>
<p>普通的TCP确认报文段首部中</p>
<ul>
<li>确认位ACK被设置为1，表明这是一个普通的TCP确认报文段</li>
<li>序号字段seq被设置为x+1，这是因为TCP客户进程发送的第一个TCP报文段的序号为x，所以TCP客户进程发送的第二个报文段的序号为x+1</li>
<li>确认号字段ack被设置为y+1，这是对TCP服务器进程所选择的初始序号的确认</li>
</ul>
<p>请注意：TCP规定普通的TCP确认报文段可以携带数据，但如果不携带数据，则不消耗序号</p>
</blockquote>
<p><img src="D:/Note/Typora_picture/image-20201022202932905.png" alt="image-20201022202932905"></p>
<blockquote>
<p>TCP服务器进程收到该确认报文段后也进入连接已建立状态</p>
<p>现在，TCP双方都进入了连接已建立状态，它们可以基于已建立好的TCP连接，进行可靠的数据传输</p>
</blockquote>
<p>为什么TCP客户进程最后还要发送一个普通的TCP确认报文段？能否使用“两报文握手”建立连接？</p>
<p>下图实例是“两报文握手”</p>
<p><img src="D:/Note/Typora_picture/image-20201022203744174.png" alt="image-20201022203744174"></p>
<blockquote>
<p>为了防止已经失效的连接请求报文段突然又传到服务端，因而产生错误”，这种情况是：一端(client)A发出去的第一个连接请求报文并没有&gt; 丢失，而是因为某些未知的原因在某个网络节点上发生滞留，导致延迟到连接释放以后的某个时间才到达另一端(server)B。本来这是一个&gt; 早已失效的报文段，但是B收到此失效的报文之后，会误认为是A再次发出的一个新的连接请求，于是B端就向A又发出确认报文，表示同&gt; 意建立连接。如果不采用“三次握手”，那么只要B端发出确认报文就会认为新的连接已经建立了，但是A端并没有发出建立连接的请求，因&gt; 此不会去向B端发送数据，B端没有收到数据就会一直等待，这样B端就会白白浪费掉很多资源。</p>
<p>所以并不<strong>多余</strong>，这是为了防止已失效的连接请求报文段突然又传送到了TCP服务器，因而导致错误</p>
</blockquote>
<h4 id="总结-16"><a href="#总结-16" class="headerlink" title="总结"></a>总结</h4><p><img src="D:/Note/Typora_picture/image-20201022204422775.png" alt="image-20201022204422775"></p>
<h3 id="TCP的连接释放"><a href="#TCP的连接释放" class="headerlink" title="TCP的连接释放"></a>TCP的连接释放</h3><ul>
<li>TCP 连接释放过程比较复杂。</li>
<li>数据传输结束后，通信的双方都可释放连接。</li>
<li>TCP 连接释放过程是<strong>四报文握手</strong>。</li>
</ul>
<h4 id="TCP通过“四报文挥手”来释放连接"><a href="#TCP通过“四报文挥手”来释放连接" class="headerlink" title="TCP通过“四报文挥手”来释放连接"></a>TCP通过“四报文挥手”来释放连接</h4><ul>
<li>TCP 连接的建立<strong>采用客户服务器方式</strong>。</li>
<li>主动发起连接建立的应用进程叫做<strong>TCP客户</strong> (client)。</li>
<li>被动等待连接建立的应用进程叫做<strong>TCP服务器</strong> (server)。</li>
<li><strong>任何一方都可以在数据传送结束后发出连接释放的通知</strong></li>
</ul>
<p>过程</p>
<p><img src="D:/Note/Typora_picture/image-20201022205124204.png" alt="image-20201022205124204"></p>
<blockquote>
<p>现在TCP客户进程和TCP服务器进程都处于连接已建立状态</p>
<p>TCP客户进程的应用进程通知其主动关闭TCP连接</p>
<p>TCP客户进程会发送TCP连接释放报文段，并进入终止等待1状态</p>
<p>TCP连接释放报文段首部中</p>
<ul>
<li>终止位FIN和确认为ACK的值都被设置为1，表明这是一个TCP连接释放报文段，同时也对之前收到的报文段进行确认</li>
<li>序号seq字段的值设置为u，它等于TCP客户进程之前已传送过的数据的最后一个字节的序号加1</li>
<li>确认号ack字段的值设置为v，它等于TCP客户进程之前已收到的、数据的最后一个字节的序号加1</li>
</ul>
<p>请注意：TCP规定终止位FIN等于1的报文段即使不携带数据，也要消耗掉一个序号</p>
</blockquote>
<p><img src="D:/Note/Typora_picture/image-20201022210030419.png" alt="image-20201022210030419"></p>
<blockquote>
<p>TCP服务器进程收到TCP连接释放报文段后，会发送一个普通的TCP确认报文段并进入关闭等待状态</p>
<p>普通的TCP确认报文段首部中</p>
<ul>
<li>确认位ACK的值被设置为1，表明这是一个普通的TCP确认报文段</li>
<li>序号seq字段的值设置为v，它等于TCP服务器进程之前已传送过的数据的最后一个字节的序号加1，这也与之前收到的TCP连接释放报文段中的确认号匹配</li>
<li>确认号ack字段的值设置为u+1，这是对TCP连接释放报文段的确认</li>
</ul>
</blockquote>
<p><img src="D:/Note/Typora_picture/image-20201022232158631.png" alt="image-20201022232158631"></p>
<blockquote>
<p>TCP服务器进程应该通知高层应用进程，TCP客户进程要断开与自己的TCP连接</p>
<p>此时，从TCP客户进程到TCP服务器进程这个方向的连接就释放了</p>
<p>这时的TCP连接属于半关闭状态，也就是TCP客户进程已经没有数据要发送了</p>
<p>但如果TCP服务器进程还有数据要发送，TCP客户进程仍要接收，也就是说从TCP服务器进程到TCP客户进程这个方向的连接并未关闭</p>
</blockquote>
<p><img src="D:/Note/Typora_picture/image-20201022233050922.png" alt="image-20201022233050922"></p>
<blockquote>
<p>TCP客户进程收到TCP确认报文段后就进入终止等待2状态，等待TCP服务器进程发出的TCP连接释放报文段</p>
<p>若使用TCP服务器进程的应用进程已经没有数据要发送了，应用进程就通知其TCP服务器进程释放连接</p>
<p>由于TCP连接释放是由TCP客户进程主动发起的，因此TCP服务器进程对TCP连接的释放称为被动关闭连接</p>
</blockquote>
<p><img src="D:/Note/Typora_picture/image-20201022233941557.png" alt="image-20201022233941557"></p>
<blockquote>
<p>TCP服务器进程发送TCP连接释放报文段并进入最后确认状态</p>
<p>该报文段首部中</p>
<ul>
<li>终止位FIN和确认位ACK的值都被设置为1，表明这是一个TCP连接释放报文段，同时也对之前收到的报文段进行确认</li>
<li>序号seq字段的值为w，这是因为在半关闭状态下，TCP服务器进程可能又发送</li>
<li>确认号ack字段的值为u+1，这是对之前收到的TCP连接释放报文段的重复确认</li>
</ul>
</blockquote>
<p><img src="D:/Note/Typora_picture/image-20201022234741310.png" alt="image-20201022234741310"></p>
<blockquote>
<p>TCP客户进程收到TCP连接释放报文段后，必须针对该报文段发送普通的TCP确认报文段，之后进入时间等待状态</p>
<p>该报文段首部中</p>
<ul>
<li>确认为ACK的值被设置为1，表明这是一个普通的TCP确认报文段</li>
<li>序号seq字段的值设置为u+1，这是因为TCP客户进程之前发送的TCP连接释放报文段虽然不携带数据，但要消耗掉一个序号</li>
<li>确认号ack字段的值设置为w+1，这是对所收到的TCP连接释放报文段的确认</li>
</ul>
<p>TCP服务器进程收到该报文段后就进入关闭状态，而TCP客户进程还要进过2MSL后才能进入关闭状态</p>
</blockquote>
<p>TCP客户进程在发送完最后一个确认报文后，为什么不直接进入关闭状态？而是要进入时间等待状态？</p>
<p><img src="D:/Note/Typora_picture/image-20201022234942562.png" alt="image-20201022234942562"></p>
<blockquote>
<p>因为时间等待状态以及处于该状态2MSL时长，可以确保TCP服务器进程可以收到最后一个TCP确认报文段而进入关闭状态</p>
<p>另外，TCP客户进程在发送完最后一个TCP确认报文段后，在经过2MSL时长，就可以使本次连接持续时间内所产生的所有报文段都从网络中消失，这样就可以使下一个新的TCP连接中，不会出现旧连接中的报文段</p>
</blockquote>
<h4 id="TCP保活计时器的作用"><a href="#TCP保活计时器的作用" class="headerlink" title="TCP保活计时器的作用"></a>TCP保活计时器的作用</h4><p>TCP双方已经建立了连接，后来，TCP客户进程所在的主机突然出现了故障</p>
<p>TCP服务器进程以后就不能再收到TCP客户进程发来的数据</p>
<p>因此，应当有措施使TCP服务器进程不要再白白等待下去</p>
<p><img src="D:/Note/Typora_picture/image-20201022235800155.png" alt="image-20201022235800155"></p>
<hr>
<h2 id="5-9、TCP报文段的首部格式"><a href="#5-9、TCP报文段的首部格式" class="headerlink" title="5.9、TCP报文段的首部格式"></a>5.9、TCP报文段的首部格式</h2><p><img src="D:/Note/Typora_picture/image-20201023000859363.png" alt="image-20201023000859363"></p>
<h3 id="各字段的作用-1"><a href="#各字段的作用-1" class="headerlink" title="各字段的作用"></a>各字段的作用</h3><p>源端口和目的端口</p>
<p><img src="D:/Note/Typora_picture/image-20201023005210010.png" alt="image-20201023005210010"></p>
<p>序号、确认号和确认标志位</p>
<p><img src="D:/Note/Typora_picture/image-20201023003826059.png" alt="image-20201023003826059"></p>
<p>数据偏移、保留、窗口和校验和</p>
<p><img src="D:/Note/Typora_picture/image-20201023004227265.png" alt="image-20201023004227265"></p>
<p>同步标志位、终止标志位、复位标志位、推送标志位、紧急标志位和紧急指针</p>
<p><img src="D:/Note/Typora_picture/image-20201023005001450.png" alt="image-20201023005001450"></p>
<p>选项和填充</p>
<p><img src="D:/Note/Typora_picture/image-20201023005132426.png" alt="image-20201023005132426"></p>
<h2 id="TCP的流量控制"><a href="#TCP的流量控制" class="headerlink" title="TCP的流量控制"></a>TCP的流量控制</h2><p><img src="D:/Note/Typora_picture/image-20201021233918057.png" alt="image-20201021233918057"></p>
<h2 id="TCP的拥塞控制"><a href="#TCP的拥塞控制" class="headerlink" title="TCP的拥塞控制"></a>TCP的拥塞控制</h2><p><img src="D:/Note/Typora_picture/image-20201022152255103.png" alt="image-20201022152255103"></p>
<h2 id="TCP可靠传输的实现"><a href="#TCP可靠传输的实现" class="headerlink" title="TCP可靠传输的实现"></a>TCP可靠传输的实现</h2><p><img src="D:/Note/Typora_picture/image-20201022163045361.png" alt="image-20201022163045361"></p>
<hr>
<p><img src="D:/Note/Typora_picture/image-20201022164057627.png" alt="image-20201022164057627"></p>
<h2 id="TCP的运输连接管理"><a href="#TCP的运输连接管理" class="headerlink" title="TCP的运输连接管理"></a>TCP的运输连接管理</h2><p><img src="D:/Note/Typora_picture/image-20201022204336098.png" alt="image-20201022204336098"></p>
<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="6-1、应用层概述"><a href="#6-1、应用层概述" class="headerlink" title="6.1、应用层概述"></a>6.1、应用层概述</h2><p><img src="D:/Note/Typora_picture/image-20201023195112701.png" alt="image-20201023195112701"></p>
<p><img src="D:/Note/Typora_picture/image-20201023200511781.png" alt="image-20201023200511781"></p>
<p>我们在浏览器的地址中输入某个网站的域名后，就可以访问该网站的内容，这个就是<strong>万维网WWW应用</strong>，其相关的应用层协议为<strong>超文本传送协议HTTP</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201023200819770.png" alt="image-20201023200819770"></p>
<p>用户在浏览器地址栏中输入的是“见名知意”的<strong>域名</strong>，而TCP&#x2F;IP的网际层使用<strong>IP地址</strong>来表示目的主机，从域名到IP地址的装转换，由属于<strong>应用层范畴的域名系统DNS</strong>，在后台帮用户完成</p>
<p><img src="D:/Note/Typora_picture/image-20201023201028141.png" alt="image-20201023201028141"></p>
<p>常见的应用</p>
<p><img src="D:/Note/Typora_picture/image-20201023201101024.png" alt="image-20201023201101024"></p>
<p>总结</p>
<p><img src="D:/Note/Typora_picture/image-20201023201137047.png" alt="image-20201023201137047"></p>
<hr>
<h2 id="6-2、客户-x2F-服务器方式（C-x2F-S方式）和对等方式（P2P方式）"><a href="#6-2、客户-x2F-服务器方式（C-x2F-S方式）和对等方式（P2P方式）" class="headerlink" title="6.2、客户&#x2F;服务器方式（C&#x2F;S方式）和对等方式（P2P方式）"></a>6.2、客户&#x2F;服务器方式（C&#x2F;S方式）和对等方式（P2P方式）</h2><h3 id="概念-11"><a href="#概念-11" class="headerlink" title="概念"></a>概念</h3><p><img src="D:/Note/Typora_picture/image-20201023201308269.png" alt="image-20201023201308269"></p>
<h3 id="客户-x2F-服务器方式（C-x2F-S方式）"><a href="#客户-x2F-服务器方式（C-x2F-S方式）" class="headerlink" title="客户&#x2F;服务器方式（C&#x2F;S方式）"></a>客户&#x2F;服务器方式（C&#x2F;S方式）</h3><p><img src="D:/Note/Typora_picture/image-20201023201610088.png" alt="image-20201023201610088"></p>
<h3 id="对等方式（P2P方式）"><a href="#对等方式（P2P方式）" class="headerlink" title="对等方式（P2P方式）"></a>对等方式（P2P方式）</h3><p><img src="D:/Note/Typora_picture/image-20201023202017683.png" alt="image-20201023202017683"></p>
<h3 id="总结-17"><a href="#总结-17" class="headerlink" title="总结"></a>总结</h3><p><img src="D:/Note/Typora_picture/image-20201023202049202.png" alt="image-20201023202049202"></p>
<hr>
<h2 id="6-3、动态主机配置协议DHCP"><a href="#6-3、动态主机配置协议DHCP" class="headerlink" title="6.3、动态主机配置协议DHCP"></a>6.3、动态主机配置协议DHCP</h2><h3 id="概念-12"><a href="#概念-12" class="headerlink" title="概念"></a>概念</h3><ul>
<li>互联网广泛使用的<strong>动态主机配置协议 DHCP</strong> (Dynamic Host Configuration Protocol) 提供了<strong>即插即用连网</strong> (plug-and-play networking) 的机制。</li>
<li>这种机制允许一台计算机加入新的网络和获取 IP 地址，而不用手工配置。</li>
</ul>
<h3 id="DHCP的作用"><a href="#DHCP的作用" class="headerlink" title="DHCP的作用"></a>DHCP的作用</h3><p>在之前，如果要正常访问Web服务器，需要该主机手动配置网络的相关配置信息</p>
<p><img src="D:/Note/Typora_picture/image-20201023205719672.png" alt="image-20201023205719672"></p>
<blockquote>
<p>如果主机数很多，就工作量大，容易出错</p>
</blockquote>
<p>如果我们给网络中添加一台DHCP服务器</p>
<p><img src="D:/Note/Typora_picture/image-20201023210345650.png" alt="image-20201023210345650"></p>
<h3 id="DHCP的工作过程"><a href="#DHCP的工作过程" class="headerlink" title="DHCP的工作过程"></a>DHCP的工作过程</h3><p><strong>DHCP 使用客户 - 服务器方式</strong></p>
<ul>
<li>需要 IP 地址的主机在启动时就向 DHCP 服务器广播发送发现报文<br>（DHCP DISCOVER），这时该主机就成为 DHCP 客户。</li>
<li>本地网络上所有主机都能收到此广播报文，但只有 DHCP 服务器才回答此广播报文。</li>
<li>DHCP 服务器先在其数据库中查找该计算机的配置信息。若找到，则返回找到的信息。若找不到，则从服务器的 IP 地址池 (address pool) 中取一个地址分配给该计算机。DHCP服务器的回答报文叫做提供报文（DHCP OFFER）。</li>
</ul>
<p><strong>DHCP 工作方式</strong></p>
<ul>
<li>DHCP 使用客户-服务器方式，采用请求&#x2F;应答方式工作。</li>
<li>DHCP 基于 UDP 工作（DHCP报文在运输层会被封装成为UDP用户数据报），DHCP 服务器运行在 67 号端口， DHCP客户运行在 68 号端口。</li>
</ul>
<p><strong>DHCP交互过程</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201023211525686.png" alt="image-20201023211525686"></p>
<blockquote>
<p><strong>DHCP客户端将广播发送DHCP发现报文（DHCP DISCOVER）</strong></p>
<ul>
<li>事务ID</li>
<li>DHCP客户端的MAC地址</li>
</ul>
<p><strong>封装该报文的IP数据报的源IP地址为0.0.0.0，这是因为主机目前还未分配到IP地址</strong>，因此使用该地址代替</p>
<p><strong>目的IP地址为广播地址255.255.255.255，之所以广播发送，是因为主机现在并不知道网络中有哪几个DHCP服务器</strong>。它们的IP地址各是什么</p>
<p><strong>DHCP服务器收到DHCP发现报文后，根据其中封装的DHCP客户端的MAC地址来查找自己的数据库</strong>，如果查到匹配信息，则使用这些配置信息来构建并发送DHCP提供报文，如果没有则采用默认配置信息来构建报文并发送</p>
</blockquote>
<p><img src="D:/Note/Typora_picture/image-20201023213058543.png" alt="image-20201023213058543"></p>
<blockquote>
<p><strong>DHCP服务端将广播发送DHCP提供报文（DHCP OFFER）</strong></p>
<ul>
<li>事务ID：DHCP客户端会与之前DHCP发现报文的事务ID做对比，来判断该DHCP提供报文是否是自己的</li>
<li>配置信息：<ul>
<li>IP地址：DHCP服务器从自己的IP地址池中挑选待租用给主机的IP地址（使用ARP来确保所选IP地址未被网络中其他主机占用）</li>
<li>子网掩码</li>
<li>地址租期</li>
<li>默认网关</li>
<li>DNS服务器</li>
</ul>
</li>
</ul>
<p>源IP地址：发送DHCP提供报文的DHCP服务器的IP</p>
<p>目的地址：因为目的主机还没分配到IP，所以使用广播地址</p>
</blockquote>
<p>在本例中，DHCP客户会收到两个DHCP服务器发来的DHCP提供报文，DHCP客户从中选择一个，一般选择先到的，并向所选择的DHCP服务器发送DHCP请求报文</p>
<p><img src="D:/Note/Typora_picture/image-20201023214542329.png" alt="image-20201023214542329"></p>
<blockquote>
<p><strong>DHCP客户端将广播发送DHCP请求报文（DHCP REQUEST）</strong></p>
<ul>
<li>事务ID</li>
<li>DHCP客户端的MAC地址</li>
<li>接收的租约中的IP地址</li>
<li>提供此租约的DHCP服务器端的IP地址</li>
</ul>
<p>源地址：0.0.0.0，因为此时DHCP客户才从多个DHCP服务器中挑选一个作为自己的DHCP服务器。它首先要征得该服务器的同意，之后才能正式使用向该DHCP服务器租用的IP地址</p>
<p>目的地址：广播地址，这样可以一次性向所有DHCP服务器发送DHCP请求报文，来告知它们是否请求它们作为自己的DHCP服务器</p>
</blockquote>
<p>在本例中，假设DHCP客户端选择DHCP服务器1作为自己的DHCP服务器，DHCP服务器1接受该请求，于是DHCP服务器1给DHCP客户端发送DHCP确认报文</p>
<p><img src="D:/Note/Typora_picture/image-20201023215341522.png" alt="image-20201023215341522"></p>
<blockquote>
<p>源地址：DHCP服务器1的IP地址</p>
<p>目的地址：广播地址</p>
<p><strong>DHCP客户收到该报文后就可以使用租用的IP地址</strong></p>
<p><strong>在使用前还会进行ARP检测</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201023215652859.png" alt="image-20201023215652859"></p>
</blockquote>
<p>剩下流程图示</p>
<p><img src="D:/Note/Typora_picture/image-20201023220114952.png" alt="image-20201023220114952"></p>
<h3 id="DHCP中继代理"><a href="#DHCP中继代理" class="headerlink" title="DHCP中继代理"></a>DHCP中继代理</h3><p>下图的网络拓扑中的各主机是否可以通过DHCP来自动获取到网络配置？</p>
<p><img src="D:/Note/Typora_picture/image-20201023221111923.png" alt="image-20201023221111923"></p>
<blockquote>
<p>使用DHCP中继代理是因为我们不用给每一个网络上都设置一个DHCP服务器，这样会使DHCP服务器的数量太多</p>
</blockquote>
<h3 id="总结-18"><a href="#总结-18" class="headerlink" title="总结"></a>总结</h3><p><img src="D:/Note/Typora_picture/image-20201023221251022.png" alt="image-20201023221251022"></p>
<hr>
<h2 id="6-4、域名系统DNS"><a href="#6-4、域名系统DNS" class="headerlink" title="6.4、域名系统DNS"></a>6.4、域名系统DNS</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><p>域名相比IP地址更容易记忆</p>
<p><img src="D:/Note/Typora_picture/image-20201023234832678.png" alt="image-20201023234832678"></p>
<p>因特网是否可以只使用一台DNS服务器？</p>
<p>不行</p>
<p><img src="D:/Note/Typora_picture/image-20201023235123151.png" alt="image-20201023235123151"></p>
<p><img src="D:/Note/Typora_picture/image-20201023235231869.png" alt="image-20201023235231869"></p>
<p><img src="D:/Note/Typora_picture/image-20201023235457857.png" alt="image-20201023235457857"></p>
<blockquote>
<p>名称相同的域名其等级未必相同</p>
</blockquote>
<p><img src="D:/Note/Typora_picture/image-20201023235617575.png" alt="image-20201023235617575"></p>
<p><img src="D:/Note/Typora_picture/image-20201023235910545.png" alt="image-20201023235910545"></p>
<h3 id="域名解析过程"><a href="#域名解析过程" class="headerlink" title="域名解析过程"></a>域名解析过程</h3><p><img src="D:/Note/Typora_picture/image-20201024000255580.png" alt="image-20201024000255580"></p>
<p><img src="D:/Note/Typora_picture/image-20201024000335147.png" alt="image-20201024000335147"></p>
<p><img src="D:/Note/Typora_picture/image-20201024000408396.png" alt="image-20201024000408396"></p>
<p><img src="D:/Note/Typora_picture/image-20201024002135210.png" alt="image-20201024002135210"></p>
<h3 id="总结-19"><a href="#总结-19" class="headerlink" title="总结"></a>总结</h3><p><img src="D:/Note/Typora_picture/image-20201024002224354.png" alt="image-20201024002224354"></p>
<hr>
<h2 id="6-5、文件传送协议FTP"><a href="#6-5、文件传送协议FTP" class="headerlink" title="6.5、文件传送协议FTP"></a>6.5、文件传送协议FTP</h2><h3 id="概念-13"><a href="#概念-13" class="headerlink" title="概念"></a>概念</h3><p><img src="D:/Note/Typora_picture/image-20201024132745558.png" alt="image-20201024132745558"></p>
<h3 id="文件传送协议FTP的应用"><a href="#文件传送协议FTP的应用" class="headerlink" title="文件传送协议FTP的应用"></a>文件传送协议FTP的应用</h3><p>FTP采用C&#x2F;S方式（客户&#x2F;服务器方式）</p>
<p>FTP客户计算机可将各种类型的文件上传到FTP服务器计算机</p>
<img src="D:/Note/Typora_picture/image-20201024133155327.png" alt="image-20201024133155327" style="zoom:50%;" />

<p>FTP客户计算机也可以从FTP服务器计算机下载文件</p>
<img src="D:/Note/Typora_picture/image-20201024133247537.png" alt="image-20201024133247537" style="zoom:50%;" />

<p><img src="D:/Note/Typora_picture/image-20201024133400777.png" alt="image-20201024133400777"></p>
<p><img src="D:/Note/Typora_picture/image-20201024133601943.png" alt="image-20201024133601943"></p>
<h3 id="FTP基本工作原理"><a href="#FTP基本工作原理" class="headerlink" title="FTP基本工作原理"></a>FTP基本工作原理</h3><p>FTP服务器监听熟知端口（端口号为 21），使客户进程能够连接上。</p>
<p>FTP客户随机选择一个临时端口号与其建立TCP连接，这条TCP连接用于FTP客户与服务器之间传送FTP的相关控制命令（这条连接是FTP客户与服务器之间的命令通道）</p>
<p><img src="D:/Note/Typora_picture/image-20201024134319922.png" alt="image-20201024134319922"></p>
<p>下图为建立数据通道的TCP连接</p>
<p>FTP服务器使用自己的熟知端口号20与其建立TCP连接，这条TCP连接用于FTP客户与服务器之间传送文件</p>
<p><img src="D:/Note/Typora_picture/image-20201024134624114.png" alt="image-20201024134624114"></p>
<blockquote>
<p>上面例子是主动模式：建立数据通道时，FTP服务器主动连接FTP客户</p>
</blockquote>
<p>下图实例为被动模式</p>
<img src="D:/Note/Typora_picture/image-20201024135018620.png" alt="image-20201024135018620" style="zoom:67%;" />

<p>两种模式对比</p>
<p><img src="D:/Note/Typora_picture/image-20201024135050743.png" alt="image-20201024135050743"></p>
<blockquote>
<p>注意两种模式都是</p>
<p>控制连接在整个会话期间保持打开状态</p>
<p>数据连接传输完毕后就关闭</p>
</blockquote>
<h3 id="总结-20"><a href="#总结-20" class="headerlink" title="总结"></a>总结</h3><p><img src="D:/Note/Typora_picture/image-20201024135848563.png" alt="image-20201024135848563"></p>
<hr>
<h2 id="6-6、电子邮件"><a href="#6-6、电子邮件" class="headerlink" title="6.6、电子邮件"></a>6.6、电子邮件</h2><h3 id="概念-14"><a href="#概念-14" class="headerlink" title="概念"></a>概念</h3><p><img src="D:/Note/Typora_picture/image-20201024151757221.png" alt="image-20201024151757221"></p>
<h3 id="邮件发送和接收过程"><a href="#邮件发送和接收过程" class="headerlink" title="邮件发送和接收过程"></a>邮件发送和接收过程</h3><p><img src="D:/Note/Typora_picture/image-20201024152052056.png" alt="image-20201024152052056"></p>
<h3 id="简单邮件传送协议SMTP（Simple-Mail-Transfer-Protocol）的基本工作原理"><a href="#简单邮件传送协议SMTP（Simple-Mail-Transfer-Protocol）的基本工作原理" class="headerlink" title="简单邮件传送协议SMTP（Simple Mail Transfer Protocol）的基本工作原理"></a>简单邮件传送协议SMTP（Simple Mail Transfer Protocol）的基本工作原理</h3><p><img src="D:/Note/Typora_picture/image-20201024152628966.png" alt="image-20201024152628966"></p>
<h3 id="电子邮件的信息格式"><a href="#电子邮件的信息格式" class="headerlink" title="电子邮件的信息格式"></a>电子邮件的信息格式</h3><p><img src="D:/Note/Typora_picture/image-20201024153425016.png" alt="image-20201024153425016"></p>
<h3 id="邮件读取"><a href="#邮件读取" class="headerlink" title="邮件读取"></a>邮件读取</h3><p><img src="D:/Note/Typora_picture/image-20201024153736033.png" alt="image-20201024153736033"></p>
<h3 id="基于万维网的电子邮件"><a href="#基于万维网的电子邮件" class="headerlink" title="基于万维网的电子邮件"></a>基于万维网的电子邮件</h3><p><img src="D:/Note/Typora_picture/image-20201024154039565.png" alt="image-20201024154039565"></p>
<h3 id="总结-21"><a href="#总结-21" class="headerlink" title="总结"></a>总结</h3><p><img src="D:/Note/Typora_picture/image-20201024154744175.png" alt="image-20201024154744175"></p>
<hr>
<h2 id="6-7、万维网WWW"><a href="#6-7、万维网WWW" class="headerlink" title="6.7、万维网WWW"></a>6.7、万维网WWW</h2><h3 id="概念-15"><a href="#概念-15" class="headerlink" title="概念"></a>概念</h3><p><strong>概述</strong></p>
<ul>
<li><strong>万维网</strong> WWW (World Wide Web) 并非某种特殊的计算机网络。</li>
<li>万维网是一个大规模的、联机式的<strong>信息储藏所</strong>。</li>
<li>万维网用链接的方法能非常方便地从互联网上的一个站点访问另一个站点，从而主动地按需获取丰富的信息。</li>
<li>这种访问方式称为“<strong>链接</strong>”。</li>
</ul>
<p><strong>万维网的工作方式</strong></p>
<ul>
<li>万维网以<strong>客户 - 服务器</strong>方式工作。</li>
<li><strong>浏览器</strong>就是在用户计算机上的万维网<strong>客户程序</strong>。万维网文档所驻留的计算机则运行<strong>服务器程序</strong>，因此这个计算机也称为<strong>万维网服务器</strong>。</li>
<li>客户程序向服务器程序发出请求，服务器程序向客户程序送回客户所要的<strong>万维网文档</strong>。</li>
<li>在一个客户程序主窗口上显示出的万维网文档称为<strong>页面</strong> (page)。</li>
</ul>
<p><img src="D:/Note/Typora_picture/image-20201024170819303.png" alt="image-20201024170819303"></p>
<p><img src="D:/Note/Typora_picture/image-20201024171432743.png" alt="image-20201024171432743"></p>
<p><strong>万维网应用举例</strong></p>
<p>访问网页</p>
<p><img src="D:/Note/Typora_picture/image-20201024170923530.png" alt="image-20201024170923530"></p>
<p><strong>怎样标志分布在整个互联网上的万维网文档？</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201024171058583.png" alt="image-20201024171058583"></p>
<p><strong>万维网的文档</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201024171724030.png" alt="image-20201024171724030"></p>
<h3 id="超文本传输协议HTTP（Hyper-Transfer-Protocol）"><a href="#超文本传输协议HTTP（Hyper-Transfer-Protocol）" class="headerlink" title="超文本传输协议HTTP（Hyper Transfer Protocol）"></a>超文本传输协议HTTP（Hyper Transfer Protocol）</h3><h4 id="概念和传输过程"><a href="#概念和传输过程" class="headerlink" title="概念和传输过程"></a>概念和传输过程</h4><ul>
<li>在万维网客户程序与万维网服务器程序之间进行交互所使用的协议，是<strong>超文本传送协议</strong> HTTP (HyperText Transfer Protocol)。</li>
<li>HTTP 是一个应用层协议，它使用 TCP 连接进行可靠的传送。</li>
</ul>
<p><img src="D:/Note/Typora_picture/image-20201024222457800.png" alt="image-20201024222457800"></p>
<ul>
<li>每个万维网网点都有一个服务器进程，它不断地<strong>监听 TCP 的端口 80</strong>，以便发现是否有浏览器向它发出连接建立请求。</li>
<li>一旦监听到连接建立请求并建立了 TCP 连接之后，浏览器就向万维网服务器发出浏览某个页面的请求，服务器接着就返回所请求的页面作为响应。</li>
<li>最后，TCP 连接就被释放了。</li>
</ul>
<p><img src="D:/Note/Typora_picture/image-20201024222825888.png" alt="image-20201024222825888"></p>
<h4 id="HTTP报文格式"><a href="#HTTP报文格式" class="headerlink" title="HTTP报文格式"></a>HTTP报文格式</h4><p><strong>HTTP请求报文格式</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201024224828528.png" alt="image-20201024224828528"></p>
<p><strong>HTTP响应报文格式</strong></p>
<p><img src="D:/Note/Typora_picture/image-20201024224920638.png" alt="image-20201024224920638"></p>
<h4 id="使用Cookie在服务器上记录用户信息"><a href="#使用Cookie在服务器上记录用户信息" class="headerlink" title="使用Cookie在服务器上记录用户信息"></a>使用Cookie在服务器上记录用户信息</h4><p><img src="D:/Note/Typora_picture/image-20201024224945200.png" alt="image-20201024224945200"></p>
<h4 id="万维网缓存与代理服务器"><a href="#万维网缓存与代理服务器" class="headerlink" title="万维网缓存与代理服务器"></a>万维网缓存与代理服务器</h4><p><img src="D:/Note/Typora_picture/image-20201024224632514.png" alt="image-20201024224632514"></p>
<p>如果该请求有缓存</p>
<p><img src="D:/Note/Typora_picture/image-20201024224720124.png" alt="image-20201024224720124"></p>
<p>如果该请求没有缓存</p>
<p><img src="D:/Note/Typora_picture/image-20201024225013288.png" alt="image-20201024225013288"></p>
<blockquote>
<p>若WEb缓存的命中率比较高</p>
<p>则会大大减小了该链路上的通信量，因而减少了访问因特网的时延</p>
</blockquote>
<p>假设原始服务器的文档被更改，这样代理服务器的文档就不是最新的</p>
<p>所以原始服务器通常会为每个响应的对象设定一个<strong>修改时间字段</strong>和一个<strong>有效日期字段</strong></p>
<p>若未过期</p>
<p><img src="D:/Note/Typora_picture/image-20201024225504869.png" alt="image-20201024225504869"></p>
<p>若过期并且代理服务器的文档和原始服务器的<strong>文档一致</strong>，原始服务器则给代理服务器发送不包含实体主体的响应</p>
<p><img src="D:/Note/Typora_picture/image-20201024225846863.png" alt="image-20201024225846863"></p>
<p>若过期并且代理服务器的文档和原始服务器的<strong>文档不一致</strong>，原始服务器则给代理服务器发送封装有该文档的响应报文</p>
<p><img src="D:/Note/Typora_picture/image-20201024230242550.png" alt="image-20201024230242550"></p>
<h3 id="总结-22"><a href="#总结-22" class="headerlink" title="总结"></a>总结</h3><p><img src="D:/Note/Typora_picture/image-20201024231143505.png" alt="image-20201024231143505"></p>
<h2 id="习题-4"><a href="#习题-4" class="headerlink" title="习题"></a>习题</h2><h3 id="域名系统DNS"><a href="#域名系统DNS" class="headerlink" title="域名系统DNS"></a>域名系统DNS</h3><p><img src="D:/Note/Typora_picture/image-20201024000627823.png" alt="image-20201024000627823"></p>
<hr>
<p><img src="D:/Note/Typora_picture/image-20201024002135210-16361031864137.png" alt="image-20201024002135210"></p>
<h3 id="文件传送协议FTP"><a href="#文件传送协议FTP" class="headerlink" title="文件传送协议FTP"></a>文件传送协议FTP</h3><p><img src="D:/Note/Typora_picture/image-20201024135242632.png" alt="image-20201024135242632"></p>
<hr>
<p><img src="D:/Note/Typora_picture/image-20201024135740064.png" alt="image-20201024135740064"></p>
<h3 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h3><p><img src="D:/Note/Typora_picture/image-20201024154357384.png" alt="image-20201024154357384"></p>
<hr>
<p><img src="D:/Note/Typora_picture/image-20201024154637025.png" alt="image-20201024154637025"></p>
<hr>
<p><img src="D:/Note/Typora_picture/image-20201024154704101.png" alt="image-20201024154704101"></p>
<h3 id="超文本传输协议HTTP"><a href="#超文本传输协议HTTP" class="headerlink" title="超文本传输协议HTTP"></a>超文本传输协议HTTP</h3><p><img src="D:/Note/Typora_picture/image-20201024230522020.png" alt="image-20201024230522020"></p>
<hr>
<p><img src="D:/Note/Typora_picture/image-20201024230846111.png" alt="image-20201024230846111"></p>
<h1 id="网络是怎么连接的"><a href="#网络是怎么连接的" class="headerlink" title="网络是怎么连接的"></a>网络是怎么连接的</h1><h2 id="0、大致流程"><a href="#0、大致流程" class="headerlink" title="0、大致流程"></a>0、大致流程</h2><ul>
<li>首先，用户输入网址</li>
<li><strong>浏览器</strong>解析网址，生成HTTP消息并转交给Socket库</li>
<li><strong>Socket库</strong>将收到 的HTTP消息作为数据转交给协议栈</li>
<li><strong>TCP</strong>按照网络包的长度对数据进行拆分，在每个包前面加上TCP头部并转交给IP——【TCP-HTTP数据块】</li>
<li><strong>IP</strong>在TCP包前加上IP头部，然后查询MAC地址并加上MAC头部，然后将包转交给网卡驱动——【MAC-IP-TCP-HTTP数据块】</li>
<li><strong>网卡驱动</strong>收到IP发来的包，将其转交给网卡并发出发送指令</li>
<li><strong>网卡</strong>检查以太网的可发送状态，将包转换成电信号，通过双绞线发送出去</li>
<li>信号通过<strong>双绞线</strong>到达集线器</li>
<li><strong>集线器</strong>将信号广播到所有端口，信号会到达交换机</li>
<li><strong>交换机</strong>根据收到的包的接收方MAC地址查询自身的地址表，找到输出端口，并将包转发到输出端口——【IP-TCP-HTTP数据块】</li>
<li><strong>互联网接入路由器</strong>根据收到的包的接收方IP地址查询自身的路由表，找到输出端口，并将包转发到输出端口（互联网接入路由器输出到互联网的包带有PPPoE头部和PPP头部）——【MAC-PPPoE-PPP-IP-TCP-HTTP数据块】</li>
<li><strong>ADSL Modem</strong>将收到的包拆分成ATM信元，然后转换成电信号通过电话线发送到电话局的DSLAM</li>
<li><strong>DSLAM</strong>（局端多路Modem）将收到的电信号还原成ATM信号并发送给BAS</li>
<li><strong>BAS</strong>将ATM信元还原成网络包，根据接收方IP地址进行转发——【MAC-PPPoE-PPP-IP-TCP-HTTP数据块】</li>
<li>BAS转发的包加上L2TP头部并通过<strong>隧道</strong>——【L2TP-PPP-IP-TCP-HTTP数据块】</li>
<li>网络包到达位于隧道出口的隧道路由器，L2TP头部和PPP头部被丢弃，通过互联网流向Web服务器【MAC-IP-TCP-HTTP数据块】</li>
<li>服务器端的局域网中有防火墙，对进入的包进行检查，判断是否允许通过。Web服务器前面如果有缓存服务器，会拦截通过防火墙的包。如果用户请求的页面已经缓存在服务器上，则代替服务器向用户返回页面数据。如果请求的页面没有被缓存，缓存服务器会将请求转发给Web服务器</li>
<li>Web服务器收到包后，网卡和网卡驱动会接收这个包并转交给协议栈</li>
<li>协议栈依次检查IP头部和TCP头部，如果没有问题则取出HTTP消息的数据进行组装</li>
<li>HTTP消息被恢复成原始状态，然后通过Socket库转交给Web服务器，Web服务器分析HTTP信息的内容，并根据请求内容将读取的数据返回给客户端</li>
</ul>
<h2 id="一、浏览器生成消息"><a href="#一、浏览器生成消息" class="headerlink" title="一、浏览器生成消息"></a><strong>一、浏览器生成消息</strong></h2><h3 id="1-生成HTTP-1-请求消息"><a href="#1-生成HTTP-1-请求消息" class="headerlink" title="1.生成HTTP[^1]请求消息"></a>1.生成HTTP[^1]请求消息</h3><p>当使用浏览器输入网址时，浏览器首先会对URL[^2]进行解析，（URL有多种格式<a href="%E4%B8%BB%E8%A6%81%E6%98%AF%E7%94%B1%E4%BA%8E%E5%BC%80%E5%A4%B4%E9%83%A8%E5%88%86%E4%BD%BF%E7%94%A8%E7%9A%84%E5%8D%8F%E8%AE%AE%E7%B1%BB%E5%9E%8B%E4%B8%8D%E5%90%8C%EF%BC%8C%E5%A6%82%EF%BC%9AHTTP%E5%8D%8F%E8%AE%AE%EF%BC%8CFTP%E5%8D%8F%E8%AE%AE%EF%BC%8Cfile%EF%BC%88%E8%AF%BB%E5%8F%96%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%EF%BC%89%EF%BC%8Cmallto%EF%BC%88%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%EF%BC%89%E7%AD%89%EF%BC%8C%E5%85%B7%E4%BD%93%E7%A4%BA%E4%BE%8B%E5%A6%82%E4%B8%8B%E5%9B%BE%E3%80%82%E5%85%B6%E4%B8%AD%E5%AF%B9%E4%BA%8E%E5%90%8E%E9%9D%A2%E7%9A%84%E6%96%87%E4%BB%B6%E5%90%8D%E7%9C%81%E7%95%A5%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BC%9A%E8%AE%BF%E9%97%AE%E4%BA%8B%E5%85%88%E8%AE%BE%E7%BD%AE%E5%A5%BD%E7%9A%84%E9%BB%98%E8%AE%A4%E6%96%87%E4%BB%B6%EF%BC%8C%E5%8D%B3%E4%B8%BB%E9%A1%B5%E3%80%82">^3</a>）浏览器由此可确定服务器的域名和文件名，接下来便根据这些信息生成HTTP请求消息，</p>
<p>[^2]: URL:Uniforn Resource Locator,统一资源定位符，即网址。<br>[^1]: HTTP:Hypertext Transfer Protocol,超文本传送协议</p>
<p><img src="D:/Note/Typora_picture/%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E5%A4%A7%E8%87%B4%E6%B5%81%E7%A8%8B1.jpg" alt="网络连接大致流程1"></p>
<p><img src="D:/Note/Typora_picture/%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E5%A4%A7%E8%87%B4%E6%B5%81%E7%A8%8B2.jpg" alt="网络连接大致流程2"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/04/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9COthers/" data-id="cl1ynefmi000gswtuhmba70c2" data-title="计算机网络" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-计算机操作系统" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/Notes/2022/04/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="article-date">
  <time class="dt-published" datetime="2022-04-14T06:55:35.266Z" itemprop="datePublished">2022-04-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/Notes/2022/04/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">计算机操作系统</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="一、初识操作系统"><a href="#一、初识操作系统" class="headerlink" title="一、初识操作系统"></a>一、初识操作系统</h1><h3 id="操作系统是什么？"><a href="#操作系统是什么？" class="headerlink" title="操作系统是什么？"></a>操作系统是什么？</h3><p><strong>操作系统（Operating System，OS）</strong>：是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源分配，以提供给用户和其他软件方便的接口和环境，它是计算机系统中最基本的<strong>系统软件</strong>。</p>
<p>用户角度：操作系统是一个<strong>控制软件</strong></p>
<ul>
<li>管理应用程序</li>
<li>为应用程序提供服务</li>
<li>杀死应用程序</li>
</ul>
<p>程序角度：操作系统是<strong>资源管理器</strong></p>
<ul>
<li>管理外设、分配资源</li>
<li>抽象<ul>
<li>将CPU抽象成进程</li>
<li>将磁盘抽象成文件</li>
<li>将内存抽象成地址空间</li>
</ul>
</li>
</ul>
<p><strong>操作系统层次</strong>：位于硬件之上，应用程序之下</p>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p><strong>接口：操作系统为用户和计算机之间的交互提供接口</strong></p>
<ul>
<li><strong>命令接口</strong>：允许用户直接使用<ul>
<li><strong>联机命令接口</strong>：交互式命令接口，“说一句，做一句”</li>
<li><strong>脱机命令接口</strong>：批处理命令接口，“说一堆，做一堆”</li>
</ul>
</li>
<li>程序接口：允许用户通过程序间接使用，也叫<strong>系统调用</strong>，广义指令；</li>
<li>CUI：图形化用户接口</li>
</ul>
<p><strong>内部组件</strong>：</p>
<ul>
<li>CPU调度器</li>
<li>物理内存管理</li>
<li>虚拟内存管理</li>
<li>文件系统管理</li>
<li>中断处理与设备驱动</li>
</ul>
<h3 id="四大特征"><a href="#四大特征" class="headerlink" title="四大特征"></a>四大特征</h3><ul>
<li><p><strong>并发</strong></p>
<ul>
<li><p>一段时间内运行多个进程，宏观上是同时发生的，但微观上仍是交替发生的</p>
<blockquote>
<p>并行 : 一个时间点运行多个进程，一般要求有多个CPU</p>
</blockquote>
</li>
<li><p>需要OS管理和调度</p>
</li>
</ul>
</li>
<li><p><strong>共享</strong></p>
<p>指资源共享，是指系统中的资源能让内存中的多个并发执行的进程共同使用；</p>
<ul>
<li>“同时”共享：一个时间段内只允许多个进程访问该资源，“同时”一般是宏观的；</li>
<li>互斥共享：一个时间段内只允许一个进程访问该资源；</li>
</ul>
</li>
<li><p><strong>虚拟</strong></p>
<p>虚拟 是指把物理上的实体转变为若干个逻辑上的对应物，让每一个用户觉得的有一个计算机专门为他服务；</p>
<blockquote>
<p>并发是虚拟的前提，如果没有并发性，则一段时间内只运行一道程序，就没有实现虚拟性的必要了。</p>
</blockquote>
<ul>
<li>空分复用技术：虚拟存储器技术</li>
<li>时分复用技术：如虚拟处理器</li>
</ul>
</li>
<li><p><strong>异步</strong></p>
<p>多个程序并发执行，由于资源有限，进程是走走停停，而不是一直运行的；</p>
<blockquote>
<p>并发是异步性的前提。</p>
</blockquote>
</li>
</ul>
<h3 id="OS的发展"><a href="#OS的发展" class="headerlink" title="OS的发展"></a>OS的发展</h3><ul>
<li><p>手工操作阶段：</p>
<ul>
<li>缺点：人机速度矛盾；</li>
</ul>
</li>
<li><p>批处理阶段：<strong>单道批处理系统</strong></p>
<p>引入脱机输入输出技术，并监督程序的输入输出（操作系统雏形）</p>
<ul>
<li>优点：缓解人机速度矛盾；</li>
<li>缺点：内存中只有一道程序运行，CPU有大量空闲时间等待IO完成，资源利用率依然很低；</li>
</ul>
</li>
<li><p>批处理阶段：<strong>多道批处理系统</strong></p>
<ul>
<li><p>优点：<strong>多道程序并发执行，共享计算机资源</strong>。资源利用率大幅提升，系统吞吐量增大；</p>
</li>
<li><p>缺点：等待用户响应时间长，且<strong>没有人机交互功能</strong>；</p>
</li>
</ul>
</li>
<li><p><strong>分时操作系统</strong></p>
<p>计算机以<strong>时间片</strong>为单位<strong>轮流</strong>为各个用户&#x2F;作业服务，用户可以通过终端与计算机交互。</p>
<ul>
<li>优点：用户请求可以被<strong>及时响应，解决了人机交互问题</strong>。允许多个用户同时使用同一台计算机，且用户间的操作互相独立，不会相互影响；</li>
<li>不能优先处理一些紧急任务，OS对所有的用户完全公平，<strong>不能区分任务的优先度</strong>；</li>
</ul>
</li>
<li><p><strong>实时操作系统</strong></p>
<p>实时操作系统 能在严格的时限内处理事件，特点是及时性、可靠性；</p>
<ul>
<li>优点：能优先响应一些紧急任务；</li>
</ul>
</li>
</ul>
<h3 id="OS内容"><a href="#OS内容" class="headerlink" title="OS内容"></a>OS内容</h3><h4 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h4><p>两种指令</p>
<blockquote>
<p>指令是指 CPU处理器能识别、执行的最基本命令，一条高级语言的代码可能会对应对条指令</p>
</blockquote>
<ul>
<li><strong>特权指令</strong>：不允许用户使用的指令，如内存清零指令；</li>
<li><strong>非特权指令</strong>：如普通的运算指令；</li>
</ul>
<p>两种处理器状态</p>
<blockquote>
<p>程序状态寄存器PSW中断有一个标志位 用于标识当前CPU处于什么状态，如：0为用户态，1为核心态。</p>
</blockquote>
<ul>
<li><strong>核心态（管态）</strong>：可以执行特权指令、非特权指令；</li>
<li><strong>用户态（目态）</strong>：只能执行非特权指令；</li>
</ul>
<p>两种程序</p>
<ul>
<li><strong>内核程序</strong>：是系统的管理者，运行在核心态，特权、非特权指令都能指令；</li>
<li><strong>应用程序</strong>：运行在用户态，为了系统安全，只能执行非特权指令；</li>
</ul>
<h4 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h4><p>内核是计算机上的底层软件，是操作系统最基本，最核心的部分；</p>
<p>内核程序：实现内核功能的程序；</p>
<ul>
<li><p><strong>时钟管理</strong>：实现计时功能；</p>
</li>
<li><p><strong>中断处理</strong>：负责实现中断机制；</p>
</li>
<li><p><strong>原语</strong>：是一种特殊的程序，处于操作系统最底层，是最接近硬件的部分；这种程序速度运行具有<strong>原子性</strong>——其运行不可中断；特点：运行时间短，调用频繁；</p>
<blockquote>
<p>原语的原子性，即运行不可中断，由关中断指令，开中断指令来完成</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">关中断指令;</span><br><span class="line">原语代码1	#暂时屏蔽中断</span><br><span class="line">原语代码2</span><br><span class="line">开中断指令;</span><br><span class="line">代码...</span><br></pre></td></tr></table></figure>


</blockquote>
</li>
<li><p><strong>对系统资源的管理</strong>（有些时候不被划分在内核中）</p>
<ul>
<li>进程管理</li>
<li>存储器管理</li>
<li>设备管理</li>
</ul>
</li>
</ul>
<h4 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h4><p>操作系统有两种体系结构：大内核，微内核</p>
<ul>
<li><p><strong>大内核</strong></p>
<p>将操作系统的主要功能模块作为系统内核，运行在核心态；</p>
<p>优点：高性能</p>
<p>缺点：内核代码庞大，结构混乱，难以维护</p>
</li>
<li><p><strong>微内核</strong></p>
<p>只把最基本的功能保留在内核；</p>
<p>优点：内核功能少，结构清晰，方便维护</p>
<p>缺点：性能低，需频繁在核心态和用户态之间切换</p>
</li>
</ul>
<h1 id="二、中断、系统调用"><a href="#二、中断、系统调用" class="headerlink" title="二、中断、系统调用"></a>二、中断、系统调用</h1><h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p>中断是为了实现多道程序并发执行而引入的一种技术，发生中断，就意味着需要系统介入开展管理工作；</p>
<p>当<strong>发生中断时，CPU会立即进入核心态</strong>；在<strong>中断发生后，当前运行的进程暂停</strong>，并交由操作系统内核对中断进行处理；</p>
<p><strong>中断是用户态到核心态的唯一途径</strong>；而核心态到用户态，通过执行一个特权指令，将PSW的标志位设置为“用户态”；</p>
<p><strong>中断分类</strong></p>
<ul>
<li><p>内中断（异常、例外、陷入）</p>
<ul>
<li>自愿中断：指令中断，如：系统调用时的访管指令（陷入指令&#x2F;trap指令）；</li>
<li>强迫中断：硬件中断（如缺页），软件中断（如整数除0）；</li>
</ul>
<blockquote>
<p>内中断 也可分为：陷入trap，故障fault，终止abort；</p>
<p>陷入：有意为之的异常，如系统调用；</p>
<p>故障：由错误条件引起的，可以被故障处理程序修复，如缺页；</p>
<p>终止：不可修复的致命错误造成的结果，如整数除0；</p>
</blockquote>
</li>
<li><p>外中断</p>
<ul>
<li>外设请求：如IO操作完成发出的中断信号；</li>
<li>人工干预：用户强行终止一个进程；</li>
</ul>
</li>
</ul>
<p><strong>外中断处理过程</strong></p>
<ol>
<li>执行完每个指令后，CPU都要检查当前是否有外部中断信号；</li>
<li>如果检测到外部中断信号，则需要保护被中断进程的CPU环境（如程序状态字PSW，程序计数器PC，各种通用寄存器）；</li>
<li>根据中断信号类型转入相应的中断处理程序；</li>
<li>恢复原进程的CPU环境并退出中断，返回原进程继续往下执行；</li>
</ol>
<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>概念：应用程序通过<strong>系统调用</strong>请求操作系统的服务。</p>
<p>用户通过程序 间接 使用系统调用功能，系统调用在核心态中执行。</p>
<p><strong>作用：</strong></p>
<blockquote>
<p>系统中的各种共享资源都由操作系统统一掌管，因此在用户程序中，凡是与资源有关的操作(如存储分配， I&#x2F;O操作、文件管理等)，都必须通过系统调用的方式向操作系统提出服务请求，由操作系统代为完成。</p>
<p>这样可以保证系统的稳定性和安全性，防止用户进行非法操作。</p>
</blockquote>
<p><strong>功能分类</strong></p>
<ul>
<li>设备管理：完成设备的请求&#x2F;释放&#x2F;启动 等功能</li>
<li>文件管理：完成文件的读&#x2F;写&#x2F;创建&#x2F;删除 等功能</li>
<li>进程控制：完成进程的创建&#x2F;撒销&#x2F;阻塞&#x2F;唤醒 等功能</li>
<li>进程通信：完成进程之间的消息传递&#x2F;信号传递 等功能</li>
<li>内存管理：完成内存的 分配&#x2F;回收 等功能</li>
</ul>
<p><strong>系统调用与库函数的区别</strong></p>
<table>
<thead>
<tr>
<th>普通应用程序</th>
<th>可直接进行系统调用，也可使用库函数。有的库函数包含系统调用，有的不涉及</th>
</tr>
</thead>
<tbody><tr>
<td>编程语言</td>
<td>向上提供库函数。有时会将系统调用封装成库函数，以隐藏系统调用的一些细节，使上层进行系统调用更加方便。</td>
</tr>
<tr>
<td>操作系统</td>
<td>向上提供系统调用</td>
</tr>
<tr>
<td>裸机</td>
<td></td>
</tr>
</tbody></table>
<p><strong>过程：</strong></p>
<ol>
<li>传递系统调用参数；</li>
<li>执行陷入指令（陷入指令在<strong>用户态</strong>下执行，执行完后立即<strong>引发一个内中断，使CPU进入核心态</strong>）；</li>
<li>执行系统调用相应服务程序（<strong>核心态</strong>）；</li>
<li>返回用户程序；</li>
</ol>
<blockquote>
<p><strong>陷入指令（访管指令）</strong>：用于<strong>让用户态进入核心态</strong>，是唯一一个只能在用户态使用，<strong>不能在核心态使用</strong>的指令。</p>
</blockquote>
<p><strong>特点</strong></p>
<ul>
<li>通常情况下，每个系统调用有对应的序号<ul>
<li>系统调用接口根据这些序号来维护表的索引</li>
</ul>
</li>
<li>系统调用接口调用内核态中预期的系统调用<ul>
<li>并返回系统调用的状态和其他任何返回值</li>
</ul>
</li>
<li>用户不需要知道系统调用是如何实现的<ul>
<li>只需要获取API和了解操作系统将什么作为返回结果</li>
<li>操作系统接口的细节大部分都隐藏在API中</li>
</ul>
</li>
</ul>
<p><strong>对于这些操作需要 跨越操作系统边界的开销，是值得的且必须的（保证了操作系统的安全性）</strong></p>
<ul>
<li>前提：程序在执行时间上的开销远超过程序调用的开销。</li>
<li>开销：<ul>
<li>建立中断、异常、系统调用与对应服务例程映射关系的初始化开销</li>
<li>建立内核堆栈</li>
<li>验证参数</li>
<li>内核态映射到用户态的地址空间（更新页面映射权限）</li>
<li>内核态独立地址空间（TLB）</li>
</ul>
</li>
</ul>
<p><strong>中断，异常，系统调用的区别：</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>源头</th>
<th>处理时间</th>
<th>响应</th>
</tr>
</thead>
<tbody><tr>
<td>中断</td>
<td>外设</td>
<td>异步</td>
<td>持续，对应用程序透明</td>
</tr>
<tr>
<td>异常</td>
<td>应用程序意向不到的行为</td>
<td>同步</td>
<td>杀死或重新执行指令</td>
</tr>
<tr>
<td>系统调用</td>
<td>应用程序请求系统提供服务</td>
<td>同步或异步</td>
<td>等待和持续</td>
</tr>
</tbody></table>
<blockquote>
<p>  异步：应用程序不知道什么时候会发生中断</p>
<p>  同步：执行到某一条指令一定会发生该事件</p>
</blockquote>
<p>为什么应用程序不能直接访问硬件？</p>
<ul>
<li>在计算机运行时，内核是被信任的第三方</li>
<li>只有内核可以执行特权指令</li>
<li>为了方便应用程序</li>
</ul>
<h1 id="三、内存管理"><a href="#三、内存管理" class="headerlink" title="三、内存管理"></a>三、内存管理</h1><p><strong>计算机体系结构</strong></p>
<ol>
<li>CPU</li>
<li>内存</li>
<li>I&#x2F;O</li>
</ol>
<h2 id="内存分层体系"><a href="#内存分层体系" class="headerlink" title="内存分层体系"></a>内存分层体系</h2><p>存储器：运行内存(主存) 和 磁盘(虚拟内存)。 主存是在运行程序时所需要保存的数据空间，而磁盘是用于持久化数据保存的数据空间.</p>
<p>CPU可以访问的内存包括两大类 : 寄存器 &#x2F; cache(L1缓存 &#x2F; L2缓存)</p>
<p><strong>层次</strong></p>
<p>微处理器(CPU访问)</p>
<p>CPU寄存器 &#x2F; L1缓存</p>
<p>L2缓存</p>
<p>主存(程序访问)</p>
<p>磁盘(程序访问)</p>
<blockquote>
<p>  从CPU寄存器到磁盘，读写速度不断降低，单位成本不断降低，大小不断增大。</p>
</blockquote>
<p><strong>内存管理目标</strong></p>
<ul>
<li>抽象：逻辑地址空间</li>
<li>保护：独立地址空间</li>
<li>共享：访问相同内存</li>
<li>虚拟：更多的地址空间</li>
</ul>
<p>内存保护：即保证程序在内存中不会超出规定的范围，有两种方式：</p>
<ul>
<li>设置上下限寄存器；</li>
<li>利用重定位寄存器，界地址寄存器进行判断；</li>
</ul>
<p><strong>内存管理方法</strong></p>
<ul>
<li>程序重定位</li>
<li>分段</li>
<li>分页</li>
<li>虚拟内存</li>
<li>按需分页虚拟内存</li>
</ul>
<blockquote>
<p>  实现高度依赖于硬件, 其中内存管理单元(MMU)负责处理CPU的内存访问请求</p>
</blockquote>
<p><strong>地址空间</strong></p>
<p>地址空间的定义</p>
<ul>
<li>物理地址空间 —— 硬件支持的地址空间</li>
<li>逻辑地址空间 —— 一个运行在程序所拥有的的内存范围</li>
</ul>
<h2 id="程序运行原理"><a href="#程序运行原理" class="headerlink" title="程序运行原理"></a>程序运行原理</h2><p>从写程序到程序运行：</p>
<ol>
<li>编辑源代码</li>
<li><strong>编译</strong>：由源代码文件生成目标文件；</li>
<li><strong>链接</strong>：由目标模块生成装入模块，链接后形成完整的逻辑地址；</li>
<li><strong>装入</strong>：将装入模块装入内存，装入后形成物理地址；</li>
</ol>
<p>三种链接方式：</p>
<ul>
<li>静态链接：装入前形成一个完整的装入模块；</li>
<li>装入时动态链接：运行时边装入边链接；</li>
<li>运行时动态链接：运行时需要目标模块才能装入并链接；</li>
</ul>
<p>三种装入方式：</p>
<ul>
<li>绝对装入：编译时产生绝对地址；（单道批处理阶段使用）</li>
<li>可重定位装入：装入时将逻辑地址转换为物理地址；（早期的多道批处理操作系统使用）</li>
<li>动态运行装入：运行时将逻辑地址转换为物理地址，需设置重定位寄存器；（现代操作系统）</li>
</ul>
<h2 id="连续内存分配"><a href="#连续内存分配" class="headerlink" title="连续内存分配"></a>连续内存分配</h2><p><strong>连续分配</strong></p>
<p>存在 内存碎片问题：内存碎片问题指的是空闲的内存无法被利用</p>
<ul>
<li>外部碎片 : 分配单元间的未使用内存</li>
<li>内部碎片 : 分配单元内的未使用内存</li>
</ul>
<p><strong>分区的动态分配</strong></p>
<p>分区的动态分配方式有以下三种 :</p>
<ol>
<li><p><strong>首次适应算法</strong> : 空闲区按地址递增顺序排序，在内存中找到第一个满足需求的空闲块, 分配给应用程序</p>
<p>（<strong>临近适应算法</strong>：和首次适应算法相似，但避免每次都要经过低地址的很多小碎片区，每次查找都从上次查找结束的位置开始）</p>
</li>
<li><p><strong>最佳适应算法</strong> : 空闲区按尺寸从小到大排序，在内存中找到最小的空闲块, 分配给应用程序</p>
</li>
<li><p><strong>最坏适应算法</strong> : 空闲区按尺寸从大到小排序，在内存中找到最大的空闲块, 分配给应用程序</p>
</li>
</ol>
<p>分配方式的区别</p>
<table>
<thead>
<tr>
<th>分配方式</th>
<th>首次适应算法</th>
<th>最佳适应算法</th>
<th>最坏适应算法</th>
</tr>
</thead>
<tbody><tr>
<td>分配方式实现需求</td>
<td>1. 按地址排序的空闲块列表<br />2. 分配需要寻找一个合适的分区<br />3. 重分配需要检查是否可以合并相邻空闲分区</td>
<td>1. 按尺寸排序的空闲块列表<br />2. 分配需要寻找一个合适的分区<br />3. 重分配需要检查是否可以合并相邻空闲分区</td>
<td>1. 按尺寸排序的空闲块列表<br />2. 分配最大的分区<br />3. 重分配需要检查是否可以合并相邻空闲分区</td>
</tr>
<tr>
<td>优势</td>
<td>简单 &#x2F; 易于产生更大空闲块</td>
<td>比较简单 &#x2F; 大部分分配是小尺寸时高效</td>
<td>分配很快 &#x2F; 大部分分配是中尺寸时高效</td>
</tr>
<tr>
<td>劣势</td>
<td>产生外部碎片 &#x2F; 不确定性</td>
<td>产生外部碎片 &#x2F; 重分配慢 &#x2F; 产生很多没用的微小碎片</td>
<td>产生外部碎片 &#x2F; 重分配慢 &#x2F; 易于破碎大的空闲块以致大分区无法被分配</td>
</tr>
</tbody></table>
<blockquote>
<p>  三种分配方式并无优劣之分，因为我们无法判断内存请求的大小</p>
</blockquote>
<h2 id="碎片整理方法"><a href="#碎片整理方法" class="headerlink" title="碎片整理方法"></a>碎片整理方法</h2><p>可以看到的是，三种分区动态分配的方式都会产生外部碎片，因此我们可以对碎片进行一定的整理来解决碎片问题。</p>
<ol>
<li><p>压缩式碎片整理</p>
<ul>
<li>重置程序以合并碎片</li>
<li>要求所有程序是动态可重置的</li>
<li>问题 : <ul>
<li>何时重置 ：在程序处于等待状态时才可以重置</li>
<li>需要考虑内存拷贝的开销</li>
</ul>
</li>
</ul>
</li>
<li><p>交换式碎片整理</p>
<ul>
<li><p>运行程序需要更多的内存时，抢占等待的程序并且回收它们的内存</p>
</li>
<li><p>问题 ：</p>
<ul>
<li>哪些程序应该被回收 ?</li>
</ul>
</li>
<li><p>情况 :</p>
<p>运行中 : P3</p>
<p>等待中 : P1 P2 P4</p>
<p>内存分布 -&gt; 主存 : OS &#x2F; P1 &#x2F; P3 &#x2F; P2 &#x2F; P4 磁盘 : 空</p>
<p>当P3程序需要更大的内存时 -&gt;</p>
<p>内存分布 -&gt; 主存 : OS &#x2F; P1 &#x2F; P3 &#x2F; P2         磁盘 : P4</p>
</li>
</ul>
</li>
</ol>
<h1 id="四、非连续内存分配"><a href="#四、非连续内存分配" class="headerlink" title="四、非连续内存分配"></a>四、非连续内存分配</h1><h2 id="非连续内存分配的必要性"><a href="#非连续内存分配的必要性" class="headerlink" title="非连续内存分配的必要性"></a>非连续内存分配的必要性</h2><p><strong>连续内存分配的缺点：</strong></p>
<ol>
<li>分配给一个程序的物理内存是连续的</li>
<li>内存利用率低</li>
<li>有外碎片 &#x2F; 内碎片的问题</li>
</ol>
<p><strong>非连续内存分配的优点：</strong></p>
<ol>
<li><p>一个程序的物理地址空间是非连续的</p>
</li>
<li><p>更好的内存利用和管理</p>
</li>
<li><p>允许共享代码与数据(共享库等…)</p>
</li>
<li><p>支持动态加载和动态链接</p>
</li>
</ol>
<p><strong>非连续内存分配的缺点：</strong></p>
<ol>
<li><p>建立虚拟地址和物理地址的转换难度大</p>
<ul>
<li><p>软件方案</p>
</li>
<li><p>硬件方案(采用硬件方案) : 分段 &#x2F; 分页</p>
</li>
</ul>
</li>
</ol>
<h2 id="非连续内存分配"><a href="#非连续内存分配" class="headerlink" title="非连续内存分配"></a>非连续内存分配</h2><h3 id="分段-Segmentation"><a href="#分段-Segmentation" class="headerlink" title="分段(Segmentation)"></a>分段(Segmentation)</h3><p><strong>段 :</strong> 在程序中会有来自不同文件的函数 ; 在程序执行时, 不同的数据也有不同的字段, 比如 : 堆 &#x2F; 栈 &#x2F; .bss &#x2F; .data 等</p>
<p>**分段 : ** 更好的分离和共享</p>
<p>程序的分段地址空间如下图所示 : </p>
<img src="https://camo.githubusercontent.com/9db208b68e844759210535e7ec1929186e60dae2153ac930d2e662a782ca7bd1/68747470733a2f2f692e6c6f6c692e6e65742f323032302f31312f31312f4e416e7a484b6a3574454d343136682e6a7067"/>

<p><strong>分段寻址方案</strong></p>
<p>逻辑地址空间连续，但是物理地址空间不连续，使用映射机制进行关联.</p>
<p>一个段 : 一个内存”块”</p>
<p>程序访问内存地址需要 : 一个二维的二元组(s, addr) → (段号, 地址)</p>
<p>操作系统维护一张段表, 存储(段号, 物理地址中的起始地址, 长度限制)</p>
<p>物理地址 : 段表中的起始地址 + 二元组中的偏移地址</p>
<h3 id="分页-Paging"><a href="#分页-Paging" class="headerlink" title="分页(Paging)"></a>分页(Paging)</h3><p><strong>分页地址空间：</strong></p>
<p>划分<strong>物理内存</strong>至固定大小的<strong>帧</strong>(Frame)</p>
<ul>
<li>大小是2的幂, 512 &#x2F; 4096 &#x2F; 8192</li>
</ul>
<p>划分<strong>逻辑地址</strong>空间至相同大小的<strong>页</strong>(Page)</p>
<ul>
<li>大小是2的幂, 512 &#x2F; 4096 &#x2F; 8192</li>
</ul>
<p>建立方案 → 转换逻辑地址为物理地址(pages to frames)</p>
<ul>
<li>页表</li>
<li>MMU &#x2F; TLB（快表）</li>
</ul>
<p><strong>帧(Frame)</strong></p>
<p>物理内存被分割为大小相等的帧. 一个内存物理地址是一个二元组(f, o) → (帧号, 帧内偏移)</p>
<p>帧号 : F位, 共有2^F^个帧</p>
<p>帧内偏移 : S位, 每帧有2^S^个字节</p>
<p>物理地址 &#x3D; 2^S^ * f + o</p>
<p>(例子 : 16-bit地址空间, 9-bit(512 byte) 大小的页帧， 物理地址 &#x3D; (3,6) ，物理地址 &#x3D; 2^9^ * 3 + 6 &#x3D; 1542)</p>
<blockquote>
<p>  <strong>分页和分段的最大区别 : 这里的 S 是一个固定的数, 而分段中的长度限制不定</strong></p>
</blockquote>
<p><strong>页(Page)</strong></p>
<p>一个程序的逻辑地址空间被划分为大小相等的页. 页内偏移的大小 &#x3D; 帧内偏移的大小， 页号大小 &#x3D; 帧号大小</p>
<p>一个逻辑地址是一个二元组(p, o) → (页号, 页内偏移)</p>
<p>页号 : P位, 共有2^P^个页</p>
<p>页内偏移 : S位, 每页有2^S^个字节</p>
<p>虚拟地址  &#x3D; 2^S^ * p + o</p>
<h4 id="页表-Page-Table"><a href="#页表-Page-Table" class="headerlink" title="页表(Page Table)"></a>页表(Page Table)</h4><p><strong>页寻址方案：</strong></p>
<p>操作系统维护一张<strong>页表</strong>, 页表保存了逻辑地址——物理地址之间的映射关系</p>
<p>存储 : (页号, 帧号)</p>
<ul>
<li>逻辑地址空间应当大于物理内存空间</li>
<li>页映射到帧</li>
<li>页是连续的虚拟内存</li>
<li>帧是非连续的物理内存(有助于减少碎片的产生)</li>
<li>不是所有的页都有对应的帧</li>
</ul>
<p><strong>页表概述：</strong></p>
<p>每一个运行的程序都有一个页表</p>
<ul>
<li>属于程序运行状态, 会动态变化</li>
<li>PTBR : 页表基址寄存器</li>
</ul>
<p><strong>转换流程</strong></p>
<p>CPU根据程序的page的页号的若干位, 计算出索引值index, 在页表中搜索这个index, 得到的是帧号, 帧号和原本的offset组成物理地址.</p>
<p><strong>分页机制的性能问题：</strong></p>
<p>访问一个内存单元需要2次内存访问</p>
<ul>
<li>一次用于获取页表项</li>
<li>一次用于访问数据</li>
</ul>
<p>页表可能非常大</p>
<ul>
<li>64位机器如果每页1024字节, 那么一个页表的大小会是多少？(2^64 &#x2F; 2^10 &#x3D; 2^54 存放不下)</li>
<li>每一个运行的程序都需要有一个页表</li>
</ul>
<p>如何处理？</p>
<ul>
<li>缓存(Caching)</li>
<li>间接(Indirection)访问</li>
</ul>
<h4 id="转换后备缓冲区-快表TLB"><a href="#转换后备缓冲区-快表TLB" class="headerlink" title="转换后备缓冲区(快表TLB)"></a>转换后备缓冲区(快表TLB)</h4><p>能缓解时间问题</p>
<p>Translation Look-aside Buffer(TLB) 是一个缓冲区. CPU中有<strong>快表TLB</strong>（可以将经常访问的页表存放在这边)</p>
<p>缓存近期访问的页帧转换表项</p>
<ul>
<li>TLB使用关联内存实现, 具备快速访问性能</li>
<li>如果TLB命中, 物理页号可以很快被获取</li>
<li>如果TLB未命中, 对应的表项被更新到TLB中(x86的CPU由硬件实现, 其他的可能是由操作系统实现)</li>
</ul>
<h4 id="二级-x2F-多级页表"><a href="#二级-x2F-多级页表" class="headerlink" title="二级&#x2F;多级页表"></a>二级&#x2F;多级页表</h4><p>时间换空间</p>
<p>二级页表</p>
<ul>
<li>将页号分为两个部分, 页表分为两个, 一级页号对应一级页表, 二级页号对应二级页表.</li>
<li>一级页号查表获得在二级页表的起始地址, 地址加上二级页号的值, 在二级页表中获得帧号</li>
<li>节约了一定的空间, 在一级页表中如果resident bit &#x3D; 0, 可以使得在二级页表中不存储相关index,而只有一张页表的话, 这一些index都需要保留</li>
</ul>
<p>多级页表</p>
<ul>
<li>通过把页号分为k个部分, 来实现多级间接页表, 建立一棵页表”树”</li>
</ul>
<blockquote>
<p>注：采用多级页表机制，各级页表的大小不能超过一个页面。</p>
<p>例：</p>
<p>若某系统按字节编址，采用40位逻辑地址，页面大小为4KB，页表项大小为4B，问应采用多少级页表，页内偏移量为几位？</p>
<p>答：</p>
<p>页面大小 &#x3D; 4KB &#x3D; 2^12^B，因为是按字节编址，所以页内偏移量为12位。</p>
<p>页号 &#x3D; 40 - 12 &#x3D; 18位</p>
<p>因为页面大小 &#x3D; 2^12^B，页表项大小 &#x3D; 4B，则每个页面可存放 2^12^ &#x2F; 4 &#x3D; 2^10^个页表项，即各级页表需要10位来映射2^10^个页表项。</p>
<p>所以28位的页号至少需要分成3级。</p>
</blockquote>
<h4 id="反向页表"><a href="#反向页表" class="headerlink" title="反向页表"></a>反向页表</h4><p>解决大地址空间问题</p>
<p>目的 : 根据帧号获得页号</p>
<p>反向页表只需要存在一张即可</p>
<ul>
<li>有大地址空间(64-bits), 前向映射页表变得繁琐. 比如 : 使用了5级页表</li>
<li>不是让页表与逻辑地址空间的大小相对应, 而是当页表与物理地址空间的大小相对应. 逻辑地址空间增长速度快于物理地址空间</li>
</ul>
<h5 id="基于页寄存器-Page-Registers-的方案"><a href="#基于页寄存器-Page-Registers-的方案" class="headerlink" title="基于页寄存器(Page Registers)的方案"></a>基于页寄存器(Page Registers)的方案</h5><p>存储 (帧号, 页号) 使得表大小与物理内存大小相关, 而与逻辑内存关联减小.</p>
<p>每一个帧和一个寄存器关联, 寄存器内容包括 :</p>
<ul>
<li>resident bit : 此帧是否被占用</li>
<li>occupier : 对应的页号 p</li>
<li>protection bits : 保护位</li>
</ul>
<p>实例 :</p>
<ul>
<li>物理内存大小是 : 4096 * 4096 &#x3D; 4K * 4KB &#x3D; 16 MB</li>
<li>页面大小是 : 4096 bytes &#x3D; 4 KB</li>
<li>页帧数 : 4096 &#x3D; 4 K</li>
<li>页寄存器使用的空间(假设8 bytes &#x2F; register) : 8 * 4096 &#x3D; 32 Kbytes</li>
<li>页寄存器带来的额外开销 : 32K &#x2F; 16M &#x3D; 0.2%</li>
<li>虚拟内存大小 : 任意</li>
</ul>
<p>优势 :</p>
<ul>
<li>转换表的大小相对于物理内存来说很小</li>
<li>转换表的大小跟逻辑地址空间的大小无关</li>
</ul>
<p>劣势 :</p>
<ul>
<li>需要的信息对调了, 即根据帧号可以找到页号</li>
<li>如何转换回来? (如何根据页号找到帧号)</li>
<li>在需要在反向页表中搜索想要的页号</li>
</ul>
<h5 id="基于关联内存-associative-memory-的方案"><a href="#基于关联内存-associative-memory-的方案" class="headerlink" title="基于关联内存(associative memory)的方案"></a>基于关联内存(associative memory)的方案</h5><p>硬件设计复杂, 容量不大, 需要放置在CPU中</p>
<ul>
<li>如果帧数较少, 页寄存器可以被放置在关联内存中</li>
<li>在关联内存中查找逻辑页号<ul>
<li>成功 : 帧号被提取</li>
<li>失败 : 页错误异常 (page fault)</li>
</ul>
</li>
<li>限制因素:<ul>
<li>大量的关联内存非常昂贵(难以在单个时钟周期内完成 ; 耗电)</li>
</ul>
</li>
</ul>
<h5 id="基于哈希-hash-的方案"><a href="#基于哈希-hash-的方案" class="headerlink" title="基于哈希(hash)的方案"></a>基于哈希(hash)的方案</h5><p>哈希函数 : h(PID, p) 从 PID 标号获得页号</p>
<p>在反向页表中通过哈希算法来搜索一个页对应的帧号</p>
<ul>
<li>对页号做哈希计算, 为了在帧表中获取对应的帧号</li>
<li>页 i 被放置在表 f(i) 位置, 其中 f 是设定的哈希函数</li>
<li>为了查找页 i , 执行下列操作 :<ul>
<li>计算哈希函数 f(i) 并且使用它作为页寄存器表的索引, 获取对应的页寄存器</li>
<li>检查寄存器标签是否包含 i, 如果包含, 则代表成功, 否则失败</li>
</ul>
</li>
</ul>
<h3 id="段页式"><a href="#段页式" class="headerlink" title="段页式"></a>段页式</h3><p>段页式系统的逻辑地址结构为：</p>
<p>段号，页号，页内地址(业内偏移量)</p>
<p>如：</p>
<table>
<thead>
<tr>
<th>31……16</th>
<th>15……12</th>
<th>11……0</th>
</tr>
</thead>
<tbody><tr>
<td>段号</td>
<td>页号</td>
<td>页内偏移量</td>
</tr>
</tbody></table>
<ul>
<li>段号的位数决定了每个进程最多可以分几个段</li>
<li>页号位数决定了每个段最大有多少页</li>
<li>页内位移决定了页面大小、内存块大小是多少</li>
</ul>
<blockquote>
<p>一个进程对应一个段表，但每个段会对应一个页表，所以一个进程可以对应多个页表</p>
<p>访存次数：第一次访问段表，第二次访问页表，第三次访问实际物理地址（同样可以添加以快表来减少访存次数）</p>
</blockquote>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191729109.png" alt="image-20211222192103363"></p>
<h1 id="五、虚拟内存"><a href="#五、虚拟内存" class="headerlink" title="五、虚拟内存"></a>五、虚拟内存</h1><h2 id="虚拟内存的起因"><a href="#虚拟内存的起因" class="headerlink" title="虚拟内存的起因"></a>虚拟内存的起因</h2><p>使用硬盘&#x2F;磁盘使更多的程序在有限的内存中运行</p>
<p>理想的存储器 : 更大更快更便宜和非易失性的存储区</p>
<blockquote>
<p>传统的存储管理要求作业必须一次性装入内存后才能开始运行，且很多暂时用不到的数据也会长期占用内存，导致内存利用率不高。</p>
</blockquote>
<h2 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h2><p>如果是程序太大, 超出了内存的容量, 可以采用手动的概率(overlay)技术, 只把需要的指令和数据保存在内存当中</p>
<p>目的 : 是在较小的可用内存中运行较大的程序, 常用于多道程序系统, 与分区存储管理配合使用.</p>
<p>原理 ：</p>
<p>把程序按照其自身逻辑结构, 划分为若干个功能上相互独立的程序模块, 那些不会同时执行的模块共享同一块内存区域, 按时间先后来运行.</p>
<ul>
<li>必要部分(常用功能)的代码和数据常驻内存;</li>
<li>可选部分(不常用功能)在其他程序模块中实现, 平时存放在外存中, 在需要用到时才装入内存;</li>
<li>不存在调用关系的模块不必同时装入到内存, 从而可以相互覆盖, 即这些模块共用一个分区.</li>
</ul>
<blockquote>
<p>  也就是说,程序松耦合的部分可以按需装入内存,不需要的时候放在外存中,多个不常用部分共用一个分区.</p>
</blockquote>
<p>实例 :</p>
<p>A(20k) <strong><strong>B(50k) ____ D(30k)<br>        | ____ C(30k) ____ E(20k)<br>                             |</strong></strong> F(40k)</p>
<p>因此不需要将整个程序190k的数据全部放入内存中, 而是划分为 常驻区(20k) 、覆盖区0(50k) 、覆盖区1(40k) 压缩至了110k的内存空间使用</p>
<p>缺点 :</p>
<ul>
<li>由程序员来把一个大的程序划分为若干个小的功能模块, 并确定各个模块之间的覆盖关系, 费时费力, 增加了编程的复杂度;</li>
<li>覆盖模块并从外存装入内存, 实际上是以时间延长来换取空间节省.</li>
</ul>
<h2 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h2><p>如果是程序太多, 超过了内存的容量, 可以采用自动的交换(swapping)技术, 把暂时不能执行的程序送到外存中</p>
<p>目的 : 多道程序在内存时, 让正在运行的程序或需要运行的程序获得更多的内存资源</p>
<p>原理 :</p>
<p>可将暂时不能运行的程序送到外存, 从而获得空闲内存空间. 操作系统把一个进程的整个地址空间的内容保存到外存中(换出 swap out), 而将外存中的某个进程的地址空间读入到内存中(换入 swap in). 换入换出内容的大小为整个程序的地址空间.</p>
<p>存在问题 :</p>
<ul>
<li>交换时机的确定 : 何时需要发生交换? 只当内存空间不够或有不够的危险时换出;</li>
<li>交换区的大小 : 必须足够大以存放所有用户进程的所有内存映像的拷贝, 必须能够对这些内存映像进行直接存取</li>
<li>程序换入时的重定位 : 换出后再换入的内存位置一定要在原来的位置上嘛?(可能出现寻址问题) 最好采用动态地址映射的方法</li>
</ul>
<h2 id="覆盖技术和交换技术的对比"><a href="#覆盖技术和交换技术的对比" class="headerlink" title="覆盖技术和交换技术的对比"></a>覆盖技术和交换技术的对比</h2><p>特点 :</p>
<ul>
<li>覆盖只能发生在那些相互之间没有调用关系的程序模块之间, 因此程序员必须给出程序内的各个模块之间的逻辑覆盖结构.</li>
<li>交换技术是以在内存中的程序大小为单位进行的, 它不需要程序员给出各个模块之间的逻辑覆盖结构.</li>
<li>换言之, 交换发生在内存中程序与管理程序或操作系统之间, 而覆盖则发生在运行程序的内部.</li>
</ul>
<p>在内存不够用的情形下, 可以采用覆盖技术和交换技术, 但是 :</p>
<ul>
<li>覆盖技术 : 需要程序要自己把整个程序划分为若干个小的功能模块, 并确定各个模块之间的覆盖关系, 增加了程序员的负担.</li>
<li>交换技术 : 以进程作为交换的单位, 需要把进程的整个地址空间都换入换出, 增加了处理器的开销.</li>
</ul>
<h2 id="虚拟内存管理技术"><a href="#虚拟内存管理技术" class="headerlink" title="虚拟内存管理技术"></a>虚拟内存管理技术</h2><p>如果想要在有限容量的内存中, 以更小的页粒度为单位装入更多更大的程序, 可以采用自动的虚拟存储技术</p>
<ul>
<li><p>目标</p>
<p>像覆盖技术那样, 不是把程序的所有内容都放在内存中, 因而能够运行比当前的空闲内存空间还要大的程序. 但做的更好, 由操作系统自动来完成, 无需程序员的干涉.</p>
<p>像交换技术那样, 能够实现进程在内存与外存之间的交换, 因而获得更多的空闲内存空间. 但做的更好, 只对进程的部分内容在内存和外存之间进行交换.</p>
</li>
<li><p>程序局部性原理</p>
<p>程序的局部性原理(principle of locality) : 指程序在执行过程中的一个较短时期, 所执行的指令地址和指令的操作数地址, 分别局限于一定的区域.</p>
<ul>
<li>时间局部性 : 一条指令的一次执行和下次执行, 一个数据的一次访问和下次访问都集中在一个较短时期内 ;</li>
<li>空间局部性 : 当前指令和邻近的几条指令, 当前访问的数据和邻近的几个数据都集中在一个较小区域内.</li>
</ul>
<p>程序的局部性原理表明, 从理论上来说, 虚拟存储技术是能够实现的. 而且在实现了以后应该是能够取得一个满意的效果.</p>
<p>实例 :</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">题目描述 :</span><br><span class="line">页面大小为<span class="number">4</span>k, 分配给每个进程的物理页面是<span class="number">1.</span> </span><br><span class="line">在一个进程中, 定义了如下的二维数组 <span class="type">int</span> A[<span class="number">1024</span>][<span class="number">1024</span>]. 该数组按行存放在内存, 每一行放在一个页面中.</span><br><span class="line">考虑一下程序的编写方法对缺页率的影响?</span><br><span class="line"></span><br><span class="line">程序编写方法<span class="number">1</span> : (发生了<span class="number">1024</span>*<span class="number">1024</span>次缺页中断)</span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">1024</span>; j++)</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; i++)</span><br><span class="line">				A[i][j] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">程序编写方法<span class="number">2</span> : (发生了<span class="number">1024</span>次缺页中断)</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; i++)</span><br><span class="line">		<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">1024</span>; j++)</span><br><span class="line">				A[i][j] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>基本概念</p>
<p>可以在页式或段式内存管理的基础上实现</p>
<ul>
<li>在装入程序时, 不必将其全部装入内存, 而只需将当前需要执行的部分页面或段装入到内存中, 就可以让程序开始执行;</li>
<li>在程序执行过程中, 如果需执行的指令或访问的数据尚未在内存中(称为缺页或缺段), 则由处理器通知操作系统将相应的页面或段调入到内存, 然后继续执行程序;</li>
<li>另一方面, 操作系统将内存中暂时不使用的页面或段调出保存在外存上, 从而腾出更多空闲内存空间存放将要装入的程序以及将要调入的页面或段.</li>
</ul>
</li>
<li><p>基本特征</p>
<ul>
<li>大的用户空间 : 通过把物理内存和外存相结合, 提供给用户的虚拟内存空间通常大于实际的物理内存, 即实现了这两者的分离. 如32位的虚拟地址理论上可以访问4GB, 而可能计算机上仅有256M的物理内存, 但硬盘容量大于4GB.</li>
<li>部分交换 : 与交换技术相比较, 虚拟存储的调入和调出是对部分虚拟地址空间进行的;</li>
<li>不连续性 : 物理内存分配的不连续性, 虚拟地址空间使用的不连续性.</li>
</ul>
</li>
<li><p>虚拟页式内存管理</p>
<p>页式内存管理</p>
<p>页表 : 完成逻辑页到物理页帧的映射</p>
<p>根据页号去页表中寻找索引, 先查看 resident bit 是否为0, 0表示不存在, 1表示映射关系存在, 获得帧号加上原本的偏移, 获得了物理地址.</p>
<p>虚拟页式内存管理</p>
<ul>
<li><p>大部分虚拟存储系统都采用虚拟页式存储管理技术, 即在页式存储管理的基础上, 增加请求调页和页面置换功能.</p>
</li>
<li><p>基本思路</p>
<ul>
<li>当一个用户程序要调入内存运行时, 不是将该程序的所有页面都装入内存, 而是只装入部分的页面, 就可启动程序运行.</li>
<li>在运行的过程中, 如果发现要运行的程序或要访问的数据不在内存, 则向系统发出缺页的中断请求, 系统在处理这个中断时, 将外存中相应的页面调入内存, 使得该程序能够继续运行.</li>
</ul>
</li>
<li><p><strong>请求页表表项</strong></p>
<p>逻辑页号 | 访问位 | 修改位 | 保护位 | 驻留位 | 物理页帧号</p>
<p>驻留位 : 表示该页是在内存中还是在外存.</p>
<p>保护位 : 表示允许对该页做何种类型的访问, 如只读, 可读写, 可执行等</p>
<p>修改位 : 表示此页在内存中是否被修改过. 当系统回收该物理页面时, 根据此位来决定是否把它的内容写回外存</p>
<p>访问位 : 如果该页被访问过(包括读写操作), 则设置此位. 用于页面置换算法.</p>
</li>
<li><p>缺页中断处理过程 :</p>
<ol>
<li>如果在内存中有空闲的物理页面, 则分配一物理页帧f, 然后转第4步; 否则转到第2步;</li>
<li>采用某种页面置换算法, 选择一个将被替换的物理页帧f, 它所对应的逻辑页为q, 如果该页在内存期间被修改过, 则需要把它写回外存;</li>
<li>对q所对应的页表项修改, 把驻留位置为0;</li>
<li>将需要访问的页p装入到物理页面f当中;</li>
<li>修改p所对应的页表项的内容, 把驻留位置为1, 把物理页帧号置为f;</li>
<li>重新运行被中断的指令.</li>
</ol>
</li>
<li><p>虚拟内存性能</p>
<p>为了便于理解分页的开销, 使用有效存储器访问时间 effective memory access time (EAT)</p>
<p>EAT &#x3D; 访存时间 * 页表命中几率 + page fault处理时间 * page fault几率</p>
<p>实例 :</p>
<p>访存时间 : 10 ns</p>
<p>磁盘访问时间 : 5 ms</p>
<p>参数 p  &#x3D; page fault 几率</p>
<p>参数 q &#x3D; dirty page 几率(对页面写操作) </p>
<p>EAT &#x3D; 10*(1-p) + 5000000*p*(1+q)</p>
</li>
</ul>
</li>
</ul>
<h1 id="六、页面置换算法"><a href="#六、页面置换算法" class="headerlink" title="六、页面置换算法"></a>六、页面置换算法</h1><h2 id="功能与目标"><a href="#功能与目标" class="headerlink" title="功能与目标"></a>功能与目标</h2><p>功能 : 当缺页中断发生， 需要调入新的页面而内存已满时， 选择内存当中哪个物理页面被置换.</p>
<p>目标 : 尽可能地减少页面的换进换出次数(即缺页中断的次数)。 具体来说， 把未来不再使用的或短期内较少使用的页面换出， 通常只能在局部性原理指导下依据过去的统计数据来进行预测.</p>
<p>页面锁定 : 用于描述必须常驻内存的操作系统的关键部分或时间关键的应用进程。 实现的方式是 : 在页表中添加锁定标记位(lock bit).</p>
<h2 id="局部页面置换算法"><a href="#局部页面置换算法" class="headerlink" title="局部页面置换算法"></a>局部页面置换算法</h2><h3 id="最优页面置换算法-OPT"><a href="#最优页面置换算法-OPT" class="headerlink" title="最优页面置换算法(OPT)"></a>最优页面置换算法(OPT)</h3><p>基本思路 : 当一个缺页中断发生时, 对于保存在内存当中的每一个逻辑页面, 计算在它的下一次访问之前, 还需等待多长时间, 从中选择等待时间最长的那个, 作为被置换的页面.</p>
<p>这是一种理想情况, 在实际系统中是无法实现的, 因为操作系统无法知道每一个页面要等待多长时间以后才会再次被访问.</p>
<p>可用作其他算法的性能评价的依据.(在一个模拟器上运行某个程序, 并记录每一次的页面访问情况, 在第二遍运行时即可使用最优算法)</p>
<h3 id="先进先出算法-FIFO"><a href="#先进先出算法-FIFO" class="headerlink" title="先进先出算法(FIFO)"></a>先进先出算法(FIFO)</h3><p>基本思路 : 选择在内存中驻留时间最长的页面淘汰. 具体来说, 系统维护着一个链表, 记录了所有位于内存当中的逻辑页面. 从链表的排列顺序来看, 链首页面的驻留时间最长, 链尾页面的驻留时间最短. 当发生一个缺页中断时, 把链首页面淘汰出去, 并把新的页面添加到链表的末尾.</p>
<p>性能较差, 调出的页面有可能是经常要访问的页面. 并且有 belady现象. FIFO算法很少单独使用.</p>
<h3 id="最近最久未使用算法-LRU"><a href="#最近最久未使用算法-LRU" class="headerlink" title="最近最久未使用算法(LRU)"></a>最近最久未使用算法(LRU)</h3><p>LRU(Least Recently Used)</p>
<p>基本思路 : 当一个缺页中断发生时, 选择最久未使用的那个页面, 并淘汰.</p>
<p>它是对最优页面置换算法的一个近似, 其依据是程序的局部性原理, 即在最近一小段时间(最近几条指令)内, 如果某些页面被频繁地访问, 那么再将来的一小段时间内, 他们还可能会再一次被频繁地访问. 反过来说, 如果过去某些页面长时间未被访问, 那么在将来它们还可能会长时间地得不到访问.</p>
<p>LRU算法需要记录各个页面使用时间的先后顺序, 开销比较大.</p>
<p>两种可能的实现方法是 :</p>
<ul>
<li>系统维护一个页面链表, 最近刚刚使用过的页面作为首节点, 最久未使用的作为尾结点. 再一次访问内存时, 找出相应的页面, 把它从链表中摘下来, 再移动到链表首. 每次缺页中断发生时, 淘汰链表末尾的页面.</li>
<li>设置一个活动页面栈, 当访问某页时, 将此页号压入栈顶, 然后, 考察栈内是否有与此页面相同的页号, 若有则抽出. 当需要淘汰一个页面时, 总是选择栈底的页面, 它就是最久未使用的.</li>
</ul>
<h3 id="时钟页面置换算法"><a href="#时钟页面置换算法" class="headerlink" title="时钟页面置换算法"></a>时钟页面置换算法</h3><p>基本思路 :</p>
<p>需要用到页表项的访问位, 当一个页面被装入内存时, 把该位初始化为0. 然后如果这个页面被访问, 则把该位置设为1;</p>
<p>把各个页面组织成环形链表(类似钟表面), 把指针指向最老的页面(最先进来);</p>
<p>当发生一个缺页中断时, 考察指针所指向的最老页面, 若它的访问位为0, 立即淘汰; 若访问位为0, 然后指针往下移动一格. 如此下去, 直到找到被淘汰的页面, 然后把指针移动到下一格.</p>
<p>流程 :</p>
<p>如果访问页在物理内存中, 访问位置1.</p>
<p>如果不在物理页, 从指针当前指向的物理页开始, 如果访问位0, 替换当前页, 指针指向下一个物理页; 如果访问位为1, 置零以后访问下一个物理页再进行判断. 如果所有物理页的访问位都被清零了, 又回到了第一次指针所指向的物理页进行替换.</p>
<h3 id="二次机会算法"><a href="#二次机会算法" class="headerlink" title="二次机会算法"></a>二次机会算法</h3><p>因为考虑到时钟页面置换算法, 有时候会把一些 dirty bit 为1(有过写操作)的页面进行置换, 这样的话, 代价会比较大. 因此, 可以结合访问位和脏位一起来决定应该置换哪一页.</p>
<p>used   dirty     →  used   dirty</p>
<p> 0         0                  replace</p>
<p> 0         1                  0         0</p>
<p> 1          0                 0         0 </p>
<p> 1          1                 0         1 </p>
<p>相当于说, 替换的优先级, 没有读写也没写过, 那么直接走, 如果写过或者访问过, 那么给你一次机会, 如果又写过, 又访问过, 那么久给你两次机会.</p>
<h3 id="最不常用算法-LFU"><a href="#最不常用算法-LFU" class="headerlink" title="最不常用算法(LFU)"></a>最不常用算法(LFU)</h3><p>Least Frequently used, LFU</p>
<p>基本思路 : 当一个缺页中断发生时, 选择访问次数最少的那个页面, 并淘汰.</p>
<p>实现方法 : 对每一个页面设置一个访问计数器, 每当一个页面被访问时, 该页面的访问计数器加1. 当发生缺页中断时, 淘汰计数值最小的那个页面.</p>
<p>LRU和LFU的对比 : LRU考察的是多久未访问, 时间越短越好. 而LFU考察的是访问的次数和频度, 访问次数越多越好.</p>
<h3 id="Belady现象-科学家名字"><a href="#Belady现象-科学家名字" class="headerlink" title="Belady现象(科学家名字)"></a>Belady现象(科学家名字)</h3><p>在采用FIFO算法时, 有时会出现分配的物理页面数增加, 缺页率反而提高的异常现象;</p>
<p>出现原因 : FIFO算法的置换特征与进程访问内存的动态特征是矛盾的, 与置换算法的目标是不一致的(即替换较少使用的页面), 因此, 被他置换出去的页面不一定是进程不会访问的.</p>
<h3 id="LRU-x2F-FIFO-和-Clock-的比较"><a href="#LRU-x2F-FIFO-和-Clock-的比较" class="headerlink" title="LRU &#x2F; FIFO 和 Clock 的比较"></a>LRU &#x2F; FIFO 和 Clock 的比较</h3><p>LRU和FIFO都是先进先出的思路, 只不过LRU是针对页面最近访问时间来进行排序, 所以需要在每一次页面访问的时候动态地调整各个页面之间的先后顺序(有一个页面的最近访问时间变了). 而FIFO是针对页面进入内存的时间来进行排序, 这个时间是固定不变的, 所以各个页面之间的先后顺序是固定的. 如果一个页面在进入内存后没有被访问, 那么它的最近访问时间就是它进入内存的时间. 换句话说, 如果内存当中的所有页面都未曾访问过, 那么LRU算法就退化为了FIFO算法.</p>
<p>例如 : 给进程分配3个物理页面, 逻辑页面的访问顺序是 : 1,2,3,4,5,6,1,2,3 …</p>
<h2 id="全局页面置换算法"><a href="#全局页面置换算法" class="headerlink" title="全局页面置换算法"></a>全局页面置换算法</h2><h3 id="工作集模型"><a href="#工作集模型" class="headerlink" title="工作集模型"></a>工作集模型</h3><p>前面介绍的各种页面置换算法, 都是基于一个前提, 即程序的局部性原理. 但是此原理是否成立?</p>
<ul>
<li>如果局部性原理不成立, 那么各种页面置换算法就没有说明分别, 也没有什么意义. 例如 : 假设进程对逻辑页面的访问顺序是1,2,3,4,5,6,6,7,8,9…, 即单调递增, 那么在物理页面数有限的前提下, 不管采用何种置换算法, 每次的页面访问都必然导致缺页中断.</li>
<li>如果局部性原理是成立的, 那么如何来证明它的存在, 如何来对它进行定量地分析? 这就是工作集模型.</li>
</ul>
<h3 id="工作集"><a href="#工作集" class="headerlink" title="工作集"></a>工作集</h3><p>工作集 : 一个进程当前正在使用的逻辑页面集合.</p>
<p>可以使用一个二元函数 W(t, delta) 来表示：</p>
<p>t 是当前的执行时刻;</p>
<p>delta 称为工作集窗口, 即一个定长的页面访问的时间窗口;</p>
<p>W(t, delta) &#x3D; 在当前时刻 t 之前的 delta 时间窗口当中的所有页面所组成的集合(随着 t 的变化, 该集合也在不断的变化)</p>
<p>|W(t, delta)| 是工作集的大小, 即逻辑页的数量.</p>
<p>工作集大小的变化 : 进程开始执行后, 随着访问新页面逐步建立较稳定的工作集. 当内存访问的局部性区域的位置大致稳定时, 工作集大小也大致稳定; 局部性区域的位置改变时, 工作集快速扩张和收缩过渡到下一个稳定值.</p>
<h3 id="常驻集"><a href="#常驻集" class="headerlink" title="常驻集"></a>常驻集</h3><p>常驻集是指在当前时刻, 进程实际驻留在内存当中的页面集合.</p>
<ul>
<li>工作集是进程在运行过程中固有的性质, 而常驻集取决于系统分配给进程的物理页面数目, 以及所采用的页面置换算法;</li>
<li>如果一个进程的整个工作集都在内存当中, 即常驻集 包含 工作集, 那么进程将很顺利地运行, 而不会造成太多的缺页中断(直到工作集发生剧烈变动, 从而过渡到另一个状态);</li>
<li>当进程常驻集的大小达到某个数目之后, 再给它分配更多的物理页面, 缺页率也不会明显下降.</li>
</ul>
<h3 id="工作集页置换算法"><a href="#工作集页置换算法" class="headerlink" title="工作集页置换算法"></a>工作集页置换算法</h3><p>当工作集窗口在滑动过程中, 如果页面不在集合中, 那么就会直接丢失这个不在窗口中页面, 而不会等待缺页中断再丢弃.</p>
<h3 id="缺页率置换算法"><a href="#缺页率置换算法" class="headerlink" title="缺页率置换算法"></a>缺页率置换算法</h3><p>可变分配策略 : 常驻集大小可变. 例如 : 每个进程在刚开始运行的时候, 先根据程序大小给它分配一定数目的物理页面, 然后在进程运行过程中, 再动态地调整常驻集的大小.</p>
<ul>
<li>可采用全局页面置换的方式, 当发生一个缺页中断时, 被置换的页面可以是在其他进程当中, 各个并发进程竞争地使用物理页面.</li>
<li>优缺点 : 性能较好, 但增加了系统开销.</li>
<li>具体实现 : 可以使用缺页率算法来动态调整常驻集的大小.</li>
</ul>
<p>缺页率 : 表示 “缺页次数 &#x2F; 内存访问次数”</p>
<p>影响因素 : 页面置换算法, 分配给进程的物理页面数目, 页面本身的大小, 程序的编写方法.</p>
<h3 id="抖动问题"><a href="#抖动问题" class="headerlink" title="抖动问题"></a>抖动问题</h3><ul>
<li>如果分配给一个进程的物理页面太少, 不能包含整个的工作集, 即常驻集 属于 工作集, 那么进程将会造成很多的缺页中断, 需要频繁的在内存与外存之间替换页面, 从而使进程的运行速度变得很慢, 我们把这种状态称为 “抖动”.</li>
<li>产生抖动的原因 : 随着驻留内存的进程数目增加, 分配给每个进程的物理页面数不断就减小, 缺页率不断上升. 所以OS要选择一个适当的进程数目和进程需要的帧数, 以便在并发水平和缺页率之间达到一个平衡.</li>
</ul>
<h1 id="七、进程"><a href="#七、进程" class="headerlink" title="七、进程"></a>七、进程</h1><h2 id="进程-process-描述"><a href="#进程-process-描述" class="headerlink" title="进程(process)描述"></a>进程(process)描述</h2><p><strong>进程定义</strong></p>
<p>进程 : 一个具有一定独立功能的程序在一个数据集合上的<strong>一次动态执行过程</strong>，是系统进行资源分配和调度的一个独立单位。</p>
<p><strong>进程的组成</strong></p>
<p>进程包括 ：程序段、数据段、PCB</p>
<ul>
<li>程序段：程序的代码</li>
<li>数据段：程序处理的数据</li>
<li>程序计数器中的值, 指示下一条将运行的指令</li>
<li>一组通用的寄存器的当前值, 堆, 栈</li>
<li>一组系统资源(如打开的文件)</li>
</ul>
<p><strong>进程和程序的联系 :</strong></p>
<ul>
<li>程序是产生进程的基础</li>
<li>程序的每次运行构成不同的进程</li>
<li>进程是程序功能的体现</li>
<li>通过多次执行, 一个程序可以对应多个进程, 通过调用关系, 一个进程可包括多个程序.</li>
</ul>
<p><strong>进程和程序的区别 :</strong></p>
<ul>
<li>进程是动态的,  程序是静态的 : 程序是有序代码的集合. 进程是程序的执行, 进程有核心态 &#x2F; 用户态.</li>
<li>进程是暂时的, 程序是永久的. 进程是一个状态变化的过程, 程序可以长久保存.</li>
<li>进程和程序的组成不同 : 进程的组成包括程序代码, 数据和进程控制块(进程状态信息)</li>
</ul>
<p><strong>进程的特点</strong></p>
<ul>
<li><p><strong>动态性</strong> : 可动态地创建, 结束进程;</p>
</li>
<li><p><strong>并发性</strong> : 进程可以被独立调度并占用处理机运行 (并发: 一段； 并行:一时刻)</p>
</li>
<li><p><strong>独立性</strong> : 不同进程的工作不相互影响;（页表是保障措施之一)</p>
</li>
<li><p><strong>制约性</strong> : 因访问共享数据, 资源或进程间同步而产生制约.</p>
</li>
</ul>
<h2 id="进程控制块"><a href="#进程控制块" class="headerlink" title="进程控制块"></a>进程控制块</h2><p>描述进程的数据结构 : 进程控制块 (Process Control Block)</p>
<p>操作系统为每个进程都维护了一个PCB, 用来保存与该进程有关的各种状态信息.</p>
<p><strong>进程控制块 :</strong> 操作系统管理控制进程运行所用的信息集合.</p>
<ul>
<li><p>进程的创建 : 为该进程生成一个PCB</p>
</li>
<li><p>进程的终止 : 回收它的PCB</p>
</li>
<li><p>进程的组织管理 : 通过对PCB的组织管理来实现</p>
</li>
</ul>
<p>(PCB具体包含什么信息? 如何组织的? 进程的状态转换?)</p>
<p><strong>PCB有以下三大类信息 :</strong></p>
<ul>
<li><strong>进程标志信息</strong>：<ul>
<li>进程标识符UID：当进程被创建时，操作系统会为该进程分配一个唯一的、不重复的ID，用于区分不同的进程；</li>
<li>用户标识符UID</li>
</ul>
</li>
<li><strong>处理机信息保存区</strong> : 保存进程的运行现场信息 :<ul>
<li>用户可见寄存器. 用户程序可以使用的数据, 地址等寄存器</li>
<li>控制和状态寄存器. 如程序计数器(PC), 程序状态字(PSW)</li>
<li>栈指针. 过程调用, 系统调用, 中断处理和返回时需要用到它</li>
</ul>
</li>
<li><strong>进程控制信息</strong><ul>
<li>调度和状态信息：用于操作系统调度进程并占用处理机使用.</li>
<li>进程间通信信息： 为支持进程间与通信相关的各种标志, 信号, 信件等, 这些信息都存在接收方的进程控制块中.</li>
<li>存储管理信息：包含有指向本进程映像存储空间的数据结构.</li>
<li>进程所用资源：说明由进程打开, 使用的系统资源. 如打开的文件等.</li>
<li>有关数据结构的链接信息：进程可以连接到一个进程队列中, 或连接到相关的其他进程的PCB.</li>
</ul>
</li>
</ul>
<p><strong>进程的组织方式</strong></p>
<p>链表 : 同一状态的进程其PCB成一链表, 多个状态对应多个不同的链表.(各状态的进程形成不同的链表 : 就绪链表, 阻塞链表)</p>
<p>索引表 : 同一状态的进程归入一个index表(由index指向PCB), 多个状态对应多个不同的index表(各状态的进行形成不同的索引表 : 就绪索引表, 阻塞索引表)</p>
<h2 id="进程状态-state"><a href="#进程状态-state" class="headerlink" title="进程状态(state)"></a>进程状态(state)</h2><h3 id="进程的生命期管理"><a href="#进程的生命期管理" class="headerlink" title="进程的生命期管理"></a>进程的生命期管理</h3><h4 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h4><p>引起进程创建的3个主要事件 :</p>
<ul>
<li>系统初始化;</li>
<li>用户请求创建一个新进程;</li>
<li>正在运行的进程执行了创建进程的系统调用.</li>
</ul>
<h4 id="进程运行"><a href="#进程运行" class="headerlink" title="进程运行"></a>进程运行</h4><p>内核选择一个就绪的进程, 让它占用处理机并执行；</p>
<p>(为何选择?如何选择?)</p>
<h4 id="进程等待-阻塞"><a href="#进程等待-阻塞" class="headerlink" title="进程等待(阻塞)"></a>进程等待(阻塞)</h4><p>在以下情况下, 进程等待(阻塞):</p>
<ol>
<li>请求并等待系统服务, 无法马上完成</li>
<li>启动某种操作, 无法马上完成</li>
<li>需要的数据没有到达</li>
</ol>
<p>进程只能自己阻塞自己, 因为只有进程自身才能知道何时需要等待某种事件的发生.</p>
<h4 id="进程唤醒"><a href="#进程唤醒" class="headerlink" title="进程唤醒"></a>进程唤醒</h4><p>唤醒进程的原因 :</p>
<ol>
<li>被阻塞进程需要的资源可被满足</li>
<li>被阻塞进程等待的事件到达</li>
<li>将该进程的PCB插入到就绪队列</li>
</ol>
<p>进程只能被别的进程或操作系统唤醒</p>
<h4 id="进程结束"><a href="#进程结束" class="headerlink" title="进程结束"></a>进程结束</h4><p>在以下四种情况下, 进程结束 :</p>
<ul>
<li>正常退出(自愿)</li>
<li>错误退出(自愿)</li>
<li>致命错误(强制性)</li>
<li>被其他进程杀死(强制性)</li>
</ul>
<h3 id="进程状态变化模型"><a href="#进程状态变化模型" class="headerlink" title="进程状态变化模型"></a>进程状态变化模型</h3><p><strong>进程的三种基本状态 :</strong> 进程在生命结束前处于三种基本状态之一.</p>
<p>不同系统设置的进程状态数目不同.</p>
<p><strong>三种基本状态</strong></p>
<ol>
<li>运行状态(Running) : 当一个进程正在处理机上运行时</li>
<li>就绪状态(Ready) : 一个进程获得了除处理机之外的一切所需资源, 一旦得到处理机即可运行</li>
<li>等待状态(阻塞状态 Blocked) : 一个进程正在等待某一时间而暂停运行时. 如等待某资源, 等待输入&#x2F;输出完成.</li>
</ol>
<p><strong>进程其它的基本状态</strong></p>
<p>创建状态(New) : 一个进程正在被创建, 还没被转到就绪状态之前的状态</p>
<p>结束状态(Exit): 一个进程正在从系统中消失时的状态, 这是因为进程结束或由于其它原因所导致.</p>
<p><strong>可能的状态变化如下 :</strong></p>
<p>NULL → New : 一个新进程被产生出来执行一个程序</p>
<p>New → Ready: 当进程创建完成并初始化后, 一切就绪准备运行时, 变为就绪状态</p>
<p>Ready → Running  : 处于就绪态的进程被进程调度程序选中后, 就分配到处理机上来运行</p>
<p>Running → Exit   : 当进程表示它已经完成或者因出错, 当前运行进程会由操作系统作结束处理</p>
<p>Running → Ready  : 处于运行状态的进程在其运行过程中, 由于分配它的处理机时间片用完而让出处理机</p>
<p>Running → Blocked: 当进程请求某样东西且必须等待时</p>
<p>Blocked → Ready  : 当进程要等待某事件到来时, 它从阻塞状态变到就绪状态</p>
<h3 id="进程挂起"><a href="#进程挂起" class="headerlink" title="进程挂起"></a>进程挂起</h3><p>进程挂起, 为了合理且充分地利用系统资源.</p>
<p>进程在挂起状态时, 意味着进程没有占用内存空间, 处在挂起状态的进程映像在磁盘上。（把进程放到磁盘上)</p>
<p><strong>两种挂起状态</strong></p>
<ol>
<li>阻塞挂起状态 : 进程在外存并等待某事件的出现;</li>
<li>就绪挂起状态 : 进程在外存, 但只要进入内存, 即可运行.</li>
</ol>
<p><strong>与挂起相关的状态转换</strong></p>
<p><strong>挂起 :</strong> 把一个进程从内存转到外存, 可能有以下几种情况 :</p>
<ul>
<li>阻塞到阻塞挂起 : 没有进程处于就绪状态或就绪进程要求更多内存资源时, 会进行这种转换, 以提交新进程或运行时就绪进程.</li>
<li>就绪到就绪挂起 : 当有高优先级阻塞(系统认为会很快就绪的)进程和低优先级就绪进程时, 系统会选择挂起低优先级就绪进程.</li>
<li>运行到就绪挂起 : 对抢先式分时系统, 当有高优先级阻塞挂起进程因事件出现而进入就绪挂起时, 系统可能会把运行进程转导就绪挂起状态.</li>
</ul>
<p><strong>在外存时的状态转换 :</strong></p>
<ul>
<li>阻塞挂起到就绪挂起 : 当有阻塞挂起因相关事件出现时, 系统会把阻塞挂起进程转换为就绪挂起进程.</li>
</ul>
<p><strong>解挂, 激活 :</strong> 把一个进程从外存转到内存; 可能有以下几种情况 :</p>
<ul>
<li>就绪挂起到就绪 : 没有就绪进程或挂起就绪进程优先级高于就绪进程时, 会进行这种转换.</li>
<li>阻塞挂起到阻塞 : 当一个进程释放足够内存时, 系统会把一个高优先级阻塞挂起(系统认为会很快出现所等待的事件)进程转换为阻塞进程.</li>
</ul>
<blockquote>
<p>  抛出一个问题 : OS怎么通过PCB和定义的进程状态来管理PCB, 帮助完成进程的调度过程?</p>
</blockquote>
<h3 id="状态队列"><a href="#状态队列" class="headerlink" title="状态队列"></a>状态队列</h3><ul>
<li>由操作系统来维护一组队列, 用来表示系统当中所有进程的当前状态;</li>
<li>不同的状态分别用不同的队列来表示(就绪队列, 各种类型的阻塞队列)；</li>
<li>每个进程的PCB都根据它的状态加入到相应的队列当中, 当一个进程的状态发生变化时, 它的PCB从一个状态中脱离出来, 加入到另外一个队列.</li>
</ul>
<h2 id="线程-thread"><a href="#线程-thread" class="headerlink" title="线程(thread)"></a>线程(thread)</h2><h3 id="为什么使用线程"><a href="#为什么使用线程" class="headerlink" title="为什么使用线程?"></a>为什么使用线程?</h3><p>实例 : 编写一个MP3播放软件.</p>
<p>核心功能 : (1)从MP3音频文件中读取数据; (2)对数据进行解压缩; (3)把解压缩后的音频数据播放出来.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单进程方式</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">	<span class="built_in">Read</span>();</span><br><span class="line">	<span class="built_in">Decompress</span>();</span><br><span class="line">	<span class="built_in">Play</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//问题: 播放出来的声音能否连贯? 各个函数之间不是并发执行, 影响资源的使用效率.</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//多进程</span></span><br><span class="line"><span class="comment">//进程1</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">	<span class="built_in">Read</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//进程2</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">	<span class="built_in">Decompress</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//进程3</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">	<span class="built_in">Play</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//问题: 进程之间如何通信,共享数据?另外,维护进程的系统开销较大:</span></span><br><span class="line"><span class="comment">//创建进程时,分配资源,建立PCB;撤销进程时,回收资源,撤销PCB;进程切换时,保存当前进程的状态信息</span></span><br></pre></td></tr></table></figure>

<p>由于有的进程需要“同时”做很多事，而一个进程只能串行地执行一系列程序；</p>
<p>因此需要提出一种新的实体, 满足以下特征:</p>
<ol>
<li>实体之间可以并发执行;</li>
<li>实体之间共享相同的地址空间.</li>
</ol>
<p>这实体就是线程。</p>
<h3 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h3><p>线程是进程当中的一条执行流程。是一个基本的CPU执行单元，也是程序执行 流的最小单元。</p>
<p>从两个方面重新理解进程:</p>
<ol>
<li>从资源组合的角度: 进程把一组相关的资源组合起来，构成了一个资源平台(环境)，包括地址空间(代码段,数据段)，打开的文件等各种资源;</li>
<li>从运行的角度：代码在这个资源平台上的一条执行流程(线程).</li>
</ol>
<blockquote>
<p>即引入线程后，进程转变为 除CPU外的系统资源的分配单元。</p>
</blockquote>
<p>线程 &#x3D; 进程 - 共享资源</p>
<h3 id="线程的优缺点"><a href="#线程的优缺点" class="headerlink" title="线程的优缺点"></a>线程的优缺点</h3><p>线程的优点:</p>
<ul>
<li>一个进程中可以同时<strong>存在多个线程</strong>;</li>
<li>各个线程之间可以<strong>并发</strong>地执行;</li>
<li>各个线程之间可以<strong>共享</strong>地址空间和文件等资源.</li>
</ul>
<p>线程的缺点:</p>
<ul>
<li><p>一个线程崩溃，会导致其所属进程的所有线程崩溃。(给它了”权限”就得有更高的”责任”)</p>
</li>
<li><p>线程所需的资源</p>
<p>不同的线程需要独立的寄存器和堆栈, 共享代码,数据和文件等.</p>
</li>
</ul>
<h3 id="线程和进程的比较"><a href="#线程和进程的比较" class="headerlink" title="线程和进程的比较"></a>线程和进程的比较</h3><ul>
<li><strong>进程是资源分配单位</strong>，<strong>线程是CPU调度单位</strong>;</li>
<li>进程拥有一个完整的资源平台， 而<strong>线程只独享必不可少的资源</strong>，如寄存器和栈;</li>
<li>线程<strong>同样具有就绪、阻塞和执行三种基本状态，同样具有状态之间的转换关系</strong>;</li>
<li>线程能<strong>减少并发执行的时间和空间开销</strong>:<ul>
<li>线程的创建时间比进程短；(直接利用所属进程的一些状态信息)</li>
<li>线程的终止时间比进程短；(不需要考虑把这些状态信息给释放)</li>
<li>同一进程内的线程切换时间比进程短；(同一进程不同线程的切换不需要切换页表)</li>
<li>由于同一进程的各线程之间共享内存和文件资源，可直接进行不通过内核的通信。(直接通过内存地址读写资源)</li>
</ul>
</li>
</ul>
<h3 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h3><p>主要有三种线程的实现方式:</p>
<ul>
<li>用户线程  : 在用户空间实现； POSIX Pthreads, Mach C-threads, Solaris threads</li>
<li>内核线程  : 在内核中实现； Windows, Solaris, Linux</li>
<li>轻量级进程: 在内核中实现,支持用户线程； Solaris</li>
</ul>
<h4 id="用户线程"><a href="#用户线程" class="headerlink" title="用户线程"></a><strong>用户线程</strong></h4><p>操作系统只能看到进程, 看不到线程, 线程的TCB在线程库中实现;</p>
<p><strong>在用户空间实现的线程机制， 它不依赖于操作系统的内核</strong>， 由一组用户级的线程库来完成线程的管理， 包括进程的创建、终止、同步和调度等.</p>
<ul>
<li>由于用户线程的维护由相应的进程来完成(通过线程库函数)，不需要操作系统内核了解用户进程的存在，可用于不支持线程技术的多进程操作系统；</li>
<li>每个进程都需要它自己私有的线程控制块(TCB)列表，用来跟踪记录它的各个线程的状态信息(PC,栈指针,寄存器)，TCB由线程库函数来维护;</li>
<li>用户线程的切换也是由线程库函数来完成，无需用户态&#x2F;核心态切换，所以速度特别快;</li>
<li>允许每个进程拥有自定义的线程调度算法.</li>
</ul>
<p>用户线程的缺点:</p>
<ul>
<li>阻塞性的系统调用如何实现？如果一个线程发起系统调用而阻塞，则整个进程在等待;</li>
<li>当一个线程开始运行时，除非它主动地交出CPU的使用权，否则它所在的进程当中的其他线程将无法运行;</li>
<li>由于时间片分配给进程，所以与其他进程比，在多线程执行时，每个线程得到的时间片较少，执行会较慢.</li>
</ul>
<h4 id="内核线程"><a href="#内核线程" class="headerlink" title="内核线程"></a><strong>内核线程</strong></h4><p>操作系统能够看到进程也可能看到线程,线程在内核中实现;</p>
<p>内核线程是在操作系统的内核当中实现的一种线程机制，由操作系统的内核来完成线程的创建、终止和管理.</p>
<ul>
<li>在支持内核线程的操作系统中，由内核来维护进程和线程的上下文信息(PCB和TCB);</li>
<li>线程的创建、终止和切换都是通过系统调用、内核函数的方式来进行，由内核来完成，因此系统开销较大;</li>
<li>在一个进程当中，如果某个内核线程发起系统调用而被阻塞，并不会影响其他内核线程的运行;</li>
<li>时间片分配给线程，多线程的进程获得更多CPU时间;</li>
</ul>
<p><strong>轻量级进程</strong></p>
<p>它是内核支持的用户线程.一个进程可以有一个或多个轻量化进程,每个量级进程由一个单独的内核线程来支持.(Solaris,Linux)</p>
<h3 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h3><p>由于内核级线程才是处理机分配的单位，所以可以采用组合的方法：将n个用户线程映射到m个内核线程上。</p>
<p><strong>多对一模型</strong>：多个用户线程映射到一个内核进程，每个进程只对应一个内核进程；</p>
<ul>
<li>优点：用户线程切换在用户空间即可完成，不需切到核心态，系统开销小，效率高；</li>
<li>缺点：当一个用户线程被阻塞，整个进程都会被阻塞，并发度不高；且多个线程不可在多核处理机上并行运行。</li>
</ul>
<p><strong>一对一模型：</strong>一个用户线程映射到一个内核线程，每个进程有多个内核进程；</p>
<ul>
<li>优点：一个线程被阻塞后，别的线程可以继续执行，并发度高；且多个线程可在多核处理机上并发执行；</li>
<li>缺点：一个用户进程占用多个内核线程，因为内核线程的操作 需要在操作系统核心态下进行，因此，线程管理开销大；</li>
</ul>
<p><strong>多对多模型：</strong>多个用户线程通过线程库映射到多个内核线程；</p>
<ul>
<li>客服了多对一的并发度不高的缺点，和一对一开销大的缺点。</li>
</ul>
<h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><p>停止当前运行进程(从运行状态变成其他状态),并且调度其他进程(转变为运行状态)</p>
<ul>
<li>必须在切换之前存储进程上下文</li>
<li>必须能够在之后恢复他们,所以进程不能显示它曾经被暂停过</li>
<li>必须快速(上下文切换时非常频繁)</li>
</ul>
<p>切换上下文需要存储：寄存器(PC,SP…)，CPU状态等信息。</p>
<p>操作系统为 进程 维护进程控制块。</p>
<p>操作系统将进程控制块放置在一个合适的队列中</p>
<ul>
<li>就绪队列</li>
<li>等待IO队列(每个设备的队列)</li>
<li>僵尸队列</li>
</ul>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><h3 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h3><p>fork()的简单实现</p>
<ul>
<li>对子进程分配内存</li>
<li>复制父进程的内存和CPU寄存器到子进程</li>
<li>开销昂贵</li>
</ul>
<p>在99%的情况下,我们在调用fork()之后调用exec()</p>
<ul>
<li>在fork()操作中内存复制是没有作用的</li>
<li>子进程将可能关闭打开的文件和连接</li>
<li>开销因此是最高的</li>
</ul>
<p>vfork()</p>
<ul>
<li>一个创建进程的系统调用,不需要创建一个同样的内存映像</li>
<li>一些时候称为轻量级fork()</li>
<li>子进程应该几乎立即调用exec()</li>
<li>现在不再使用，如果我们使用 copy on write 技术</li>
</ul>
<h3 id="加载和执行进程"><a href="#加载和执行进程" class="headerlink" title="加载和执行进程"></a>加载和执行进程</h3><p>系统调用exec()加载程序取代当前运行的进程</p>
<p>exec()调用允许一个进程”加载”一个不同的程序并且在main开始执行(事实上 _start)</p>
<p>它允许一个进程指定参数的数量(argc)和它字符串参数数组(argv)</p>
<p>如果调用成功(相同的进程,不同的程序)</p>
<p>代码,stack,heap重写</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> pid = fork(); <span class="comment">//创建子进程</span></span><br><span class="line"><span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;    <span class="comment">//子进程</span></span><br><span class="line">	exec_status = <span class="built_in">exec</span>(<span class="string">&quot;calc&quot;</span>, argc, argv0,argv1,...);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Why would I execute?&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123; <span class="comment">//父进程</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Whose your daddy?&quot;</span>);</span><br><span class="line">	...</span><br><span class="line">	child_status = <span class="built_in">wait</span>(pid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="等待和终止进程"><a href="#等待和终止进程" class="headerlink" title="等待和终止进程"></a>等待和终止进程</h3><p>wait()系统调用是被父进程用来等待子进程的结束</p>
<ul>
<li>一个子进程向父进程返回一个值,所以父进程必须接受这个值并处理</li>
<li>wait()系统调用担任这个要求<ul>
<li>它使父进程去睡眠来等待子进程的结束</li>
<li>当一个子进程调用exit()的时候,操作系统解锁父进程,并且将通过exit()传递得到的返回值作为wait调用的一个结果(连同子进程的pid一起)如果这里没有子进程存活,wait()立刻返回</li>
<li>当然,如果这里有为父进程的僵尸等待,wait()立即返回其中一个值(并且解除僵尸状态)</li>
</ul>
</li>
<li>进程结束执行之后,它调用exit()</li>
<li>这个系统调用:<ul>
<li>将这程序的”结果”作为一个参数</li>
<li>关闭所有打开的文件,连接等等</li>
<li>释放内存</li>
<li>释放大部分支持进程的操作系统结构</li>
<li>检查父进程是存活着的:<ul>
<li>如果是的话,它保留结果的值直到父进程需要它;在这种情况里,进程没有真正死亡,但是它进入了僵尸状态</li>
<li>如果没有,它释放所有的数据结构,这个进程死亡</li>
</ul>
</li>
<li>清理所有等待的僵尸进程</li>
</ul>
</li>
<li>进程终止是最终的垃圾收集(资源回收)</li>
</ul>
<h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><p>由于各进程拥有的内存地址空间相互独立，且为了保证安全，一个进程不能直接访问另一个进程的地址空间，所以操作系统需要提供一些安全的进程间通信：</p>
<ul>
<li><p><strong>共享存储</strong></p>
<p>开辟给若干进程的共享空间，且进程间对共享空间的<strong>访问是互斥</strong>的；</p>
</li>
<li><p><strong>消息传递</strong></p>
<p>进程间传递 结构化的消息（消息头，消息体），系统会提供发送&#x2F;接收的原语</p>
<ul>
<li>直接通信方式：消息直接挂到接收方的消息队列里；</li>
<li>间接通信方式(信箱)：消息先发到中间体(信箱)；</li>
</ul>
</li>
<li><p><strong>管道通信</strong></p>
<p>“管道”是指 用于连接读写进程 的一个共享文件（pipe文件），实质是在内存中开辟一个大小固定的缓冲区。</p>
<ul>
<li><p>管道只能采用半双工通信；如果要双向同时通信，需设置两个管道；</p>
</li>
<li><p>各进程要互斥地访问管道；</p>
</li>
<li><p>数据以字符流的形式写入管道，当管道写满时，写进程的write()会被阻塞，等待读进程将数据取走。</p>
<p>当读进程将数据全部取走后，管道为空，则读进程的read()会被阻塞。</p>
</li>
<li><p>如果管道没写满，则不允许读；管道还没读空，则不允许写。</p>
</li>
<li><p>数据一旦被读出，管道会立刻抛弃这些数据。</p>
</li>
</ul>
</li>
</ul>
<h1 id="八、调度算法"><a href="#八、调度算法" class="headerlink" title="八、调度算法"></a>八、调度算法</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><strong>上下文切换</strong></p>
<ul>
<li>切换CPU的当前任务, 从一个进程&#x2F;线程到另一个</li>
<li>保存当前进程&#x2F;线程在PCB&#x2F;TCB中的执行上下文(CPU状态)</li>
<li>读取下一个进程&#x2F;线程的上下文</li>
</ul>
<p><strong>CPU调度</strong></p>
<ul>
<li>从就绪队列中挑选一个进程&#x2F;线程作为CPU将要运行的下一个进程&#x2F;线程</li>
<li>调度程序: 挑选进程&#x2F;线程的内核函数(通过一些调度策略)</li>
<li>什么时候进行调度?</li>
</ul>
<p><strong>内核运行调度程序的条件(满足一条即可)</strong></p>
<ul>
<li>一个进程从运行状态切换到等待状态</li>
<li>一个进程被终结</li>
</ul>
<p><strong>不可抢占</strong></p>
<ul>
<li>调度程序必须等待事件结束</li>
</ul>
<p><strong>可以抢占</strong></p>
<ul>
<li>调度程序在中断被相应后执行</li>
<li>当前的进程从运行切换到就绪, 或者一个进程从等待切换到就绪</li>
<li>当前运行的进程可以被换出</li>
</ul>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h3><p>从就绪队列中按照一定的算法选择一个进程，并将处理机分配给它，以实现进程的并发执行；</p>
<h3 id="三个层次"><a href="#三个层次" class="headerlink" title="三个层次"></a><strong>三个层次</strong></h3><ul>
<li><p><strong>高级调度（作业调度）</strong>：</p>
<p>从后备队列中选择合适的作业将其调入内存，并为其创建进程；</p>
</li>
<li><p><strong>中级调度（内存调度）</strong>：</p>
<p>从挂起队列中选择合适的进程将其数据调回内存；</p>
</li>
<li><p><strong>低级调度（进程调度）</strong>：</p>
<p>从就绪队列中选择一个进程为其分配处理机；</p>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>地点</th>
<th>频率</th>
<th>进程状态的改变</th>
</tr>
</thead>
<tbody><tr>
<td>高级调度（作业调度）</td>
<td>外存—》内存</td>
<td>最低</td>
<td>无—创建态—就绪态</td>
</tr>
<tr>
<td>中级调度（内存调度）</td>
<td>外存—》内存</td>
<td>中等</td>
<td>挂起态—就绪态（阻塞挂起——阻塞态）</td>
</tr>
<tr>
<td>低级调度（进程调度）</td>
<td>内存—》CPU</td>
<td>频繁</td>
<td>就绪态—运行态</td>
</tr>
</tbody></table>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191730100.png" alt="image-20211217164209134"></p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191730440.png" alt="image-20211217164239810"></p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191730005.png" alt="image-20211217164315314"></p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191730446.png" alt="image-20211217164259133"></p>
<h3 id="调度时机"><a href="#调度时机" class="headerlink" title="调度时机"></a>调度时机</h3><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191730350.png" alt="image-20211217165244133"></p>
<p>例题：</p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191730266.png" alt="image-20211217165357442"></p>
<h3 id="切换与过程"><a href="#切换与过程" class="headerlink" title="切换与过程"></a>切换与过程</h3><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191730741.png" alt="image-20211217165515355"></p>
<h3 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h3><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191730830.png" alt="image-20211217165446842"></p>
<h2 id="调度原则"><a href="#调度原则" class="headerlink" title="调度原则"></a>调度原则</h2><ul>
<li><p><strong>调度策略</strong></p>
<p>人们通常都需要”更快”的服务</p>
<p>什么是更快?</p>
<ul>
<li>传输文件时的高带宽</li>
<li>玩游戏时的低延迟</li>
<li>这两个因素是独立的</li>
</ul>
<p>和水管类比</p>
<ul>
<li>低延迟: 喝水的时候想要一打开水龙头水就流出来</li>
<li>高带宽: 给游泳池充水时希望从水龙头里同时流出大量的水,并且不介意是否存在延迟</li>
</ul>
<p>我们的目标:</p>
<ul>
<li>减少响应时间: 及时处理用户的输出并且尽快将输出提供给用户</li>
<li>减少平均响应时间的波动: 在交互系统中,可预测性比高差异性低平均更重要</li>
<li>增加吞吐量: 减少开销(操作系统开销,上下文切换);系统资源的高效率用(CPU,IO设备)</li>
<li>减少等待时间: 减少每个进程的等待时间</li>
</ul>
</li>
<li><p><strong>程序执行模型</strong></p>
<p>执行模型 : 程序在CPU突发和IO中交替</p>
<ul>
<li>每个调度决定都是关于在下一个CPU突发时将哪个工作交给CPU</li>
<li>在时间分片机制下,线程可能在结束当前CPU突发前被迫放弃CPU</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>公平的目标</strong></p>
<p>举例:</p>
<ul>
<li>保证每个进程占用相同的CPU时间</li>
<li>这公平嘛?如果一个用户比其他用户运行更多的进程怎么办</li>
</ul>
<p>举例:</p>
<ul>
<li>保证每个进程都等待相同的时间</li>
</ul>
<p>公平通常会增加平均响应时间</p>
</li>
</ul>
<h2 id="评价指标"><a href="#评价指标" class="headerlink" title="评价指标"></a>评价指标</h2><ul>
<li><p><strong>CPU使用率</strong>： CPU处于忙状态所占时间的百分比</p>
</li>
<li><p><strong>吞吐量</strong>： 在单位时间内完成的进程&#x2F;作业数量</p>
</li>
<li><p><strong>周转时间</strong>： 一个进程从初始化到结束,包括所有等待时间所花费的时间，即<strong>作业完成时间 - 作业提交时间；</strong></p>
<p>平均周转时间：各作业周转时间之和&#x2F;作业数；</p>
<p><strong>带权周转时间：作业周转时间 &#x2F; 作业实际运行时间；</strong></p>
<p>平均带权周转时间：各作业带权周转时间之和&#x2F;作业数；</p>
</li>
<li><p><strong>等待时间</strong>： 进程在就绪队列中的总时间</p>
</li>
<li><p><strong>响应时间</strong>：  从一个请求被提交到产生第一次相应所花费的总时间</p>
</li>
</ul>
<p>各指标在操作系统上的表现:</p>
<p>低延迟调度增加了交互式表现(如果移动了鼠标,但是屏幕中的光标却没动,我们可能会重启电脑)</p>
<p>操作系统需要保证低吞吐量不受影响(我想要结束长时间的编程,所以操作系统必须不时进行调度,即使存在许多交互任务)</p>
<p>吞吐量是操作系统的计算带宽</p>
<p>响应时间是操作系统的计算延迟</p>
<h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><h3 id="FCFS-先来先服务"><a href="#FCFS-先来先服务" class="headerlink" title="FCFS(先来先服务)"></a>FCFS(先来先服务)</h3><p>First come, First Served</p>
<p>按照作业&#x2F;进程到达的先后顺序进行服务。（是非抢占式的算法，不会导致饥饿）</p>
<p>优点: 简单</p>
<p>缺点:</p>
<ul>
<li>平均等待时间波动较大</li>
<li>花费时间少的任务可能排在花费时间长的任务后面</li>
<li>可能导致IO和CPU之间的重叠处理  (CPU密集型进程会导致IO设备闲置时, IO密集型进程也在等待)</li>
</ul>
<h3 id="SJF-短作业优先"><a href="#SJF-短作业优先" class="headerlink" title="SJF(短作业优先)"></a>SJF(短作业优先)</h3><p><strong>SPN(SJF) SRT(短进程优先(短作业优先)短剩余时间优先)[最优平均等待时间]</strong></p>
<p>Shortest Process Next(<strong>Shortest Job First</strong>) Shortest Remaining Time</p>
<blockquote>
<p>使最短的作业优先得到服务（要求服务时间最短）。</p>
<p>可以是抢占的或者是不可抢占的</p>
<p>可能导致饥饿</p>
<ul>
<li>连续的短任务流会使长任务饥饿</li>
<li>短任务可用时的任何场任务的CPU时间都会增加平均等待时间</li>
</ul>
</blockquote>
<p>需要预测未来</p>
<ul>
<li>怎么预估下一个CPU突发的持续时间</li>
<li>简单的解决: 询问用户</li>
<li>如果用户欺骗就杀死进程</li>
</ul>
<h3 id="HRRN-最高响应比优先"><a href="#HRRN-最高响应比优先" class="headerlink" title="HRRN(最高响应比优先)"></a>HRRN(最高响应比优先)</h3><p>Highest Response Ratio Next</p>
<p>在每次调度时，计算各个作业&#x2F;进程的响应比，选择响应比最高的作业&#x2F;进程为其服务。</p>
<p>响应比：( 等待时间+要求服务时间 )  &#x2F; 要求服务时间</p>
<p>(非抢占式算法，不会导致饥饿)</p>
<h3 id="Round-Robin-轮循"><a href="#Round-Robin-轮循" class="headerlink" title="Round Robin(轮循)"></a>Round Robin(轮循)</h3><p>使用时间切片和抢占来轮流执行任务</p>
<p>在叫做量子(或者时间切片)的离散单元中分配处理器</p>
<p>时间片结束时,切换到下一个准备好的进程</p>
<p>花销: 额外的上下文切换</p>
<p>时间量子太大:</p>
<ul>
<li>等待时间过长</li>
<li>极限情况退化成FCFS</li>
</ul>
<p>时间量子太小:</p>
<ul>
<li>反应迅速</li>
<li>吞吐量由于大量的上下文切换开销受到影响</li>
</ul>
<p>目标:</p>
<ul>
<li>选择一个合适的时间量子</li>
<li>经验规则: 维持上下文切换开销处于1%以内</li>
</ul>
<h3 id="MFQ-多级反馈队列"><a href="#MFQ-多级反馈队列" class="headerlink" title="MFQ(多级反馈队列)"></a>MFQ(多级反馈队列)</h3><p><strong>Multilevel Feedback Queues(多级反馈队列)</strong></p>
<p>就绪队列被划分成多个独立的队列，并设置优先级；每个队列拥有自己的调度策略；</p>
<p>一个进程可以在不同的队列中移动</p>
<p>例如,n级优先级调度在所有级别中,RR在每个级别中</p>
<ul>
<li>时间量子大小随优先级级别增加而增加</li>
<li>如果任务在当前的时间量子中没有完成,则降到下一个优先级</li>
</ul>
<blockquote>
<p>各级队列的优先级越高，其分得的时间片越小；</p>
<p>新进程到达时先进入第1级队列，若用完当前队列分给它的时间片且还没运行完成，则该进程 进入下一级队列；如果以及在最低级队列，则还是在最低级队列重新排队；</p>
<p>如果允许抢占的话，被抢占的进程回重新在原队列排队。</p>
</blockquote>
<p>优点: <strong>CPU密集型任务的优先级下降很快;IO密集型任务停留在高优先级</strong></p>
<h3 id="FSS-公平共享调度"><a href="#FSS-公平共享调度" class="headerlink" title="FSS(公平共享调度)"></a>FSS(公平共享调度)</h3><p><strong>Fair Share Scheduling(公平共享调度)</strong></p>
<p>FSS控制用户对系统资源的访问</p>
<ul>
<li>一些用户组比其他用户组更重要</li>
<li>保证不重要的组无法垄断资源</li>
<li>未使用的资源按照每个组所分配的资源的比例来分配</li>
<li>没有达到资源使用率目标的组获得更高的优先级</li>
</ul>
<h2 id="评价方式"><a href="#评价方式" class="headerlink" title="评价方式"></a>评价方式</h2><p>确定性建模: 确定一个工作量,然后计算每个算法的表现</p>
<p>队列模型: 用来处理随机工作负载的数学方法</p>
<p>实现&#x2F;模拟: 建立一个允许算法运行实际数据的系统;最灵活,最具一般性</p>
<h2 id="实时调度"><a href="#实时调度" class="headerlink" title="实时调度"></a>实时调度</h2><ul>
<li><p>实时系统</p>
<p>定义: 正确性依赖于其时间和功能两方面的一个操作系统</p>
<p>性能指标: 时间约束的及时性;速度和平均性能相对不重要</p>
<p>主要特征: 时间约束的可预测性</p>
<p>分类:</p>
<ul>
<li>强实时系统: 需要在保证时间内完成重要的任务,必须完成</li>
<li>弱实时系统: 要求重要的进程的优先级更高,尽量完成,并非必须</li>
</ul>
<p>任务(工作单元): 一次计算,一次文件读取,一次信息传递等</p>
<p>属性: 去的进展所需要的资源;定时参数.</p>
</li>
<li><p>单调速率(RM)</p>
<ul>
<li>最佳静态优先级调度</li>
<li>通过周期安排优先级</li>
<li>周期越短优先级越高</li>
<li>执行周期最短的任务</li>
</ul>
</li>
<li><p>截止日期最早优先(EDF)</p>
<ul>
<li>最佳的动态优先级调度</li>
<li>Deadline越早优先级越高</li>
<li>执行Deadline最早的任务</li>
</ul>
</li>
</ul>
<h2 id="多处理器调度"><a href="#多处理器调度" class="headerlink" title="多处理器调度"></a>多处理器调度</h2><p>多处理器的CPU调度更复杂:</p>
<ul>
<li>多个相同的单处理器组成一个多处理器</li>
<li>优点: 复杂共享</li>
</ul>
<p>对称多处理器(SMP)</p>
<ul>
<li>每个处理器运行自己的调度程序</li>
<li>需要在调度程序中同步</li>
</ul>
<h2 id="优先级反转"><a href="#优先级反转" class="headerlink" title="优先级反转"></a>优先级反转</h2><p>可以发生在任务基于优先级的可抢占的调度机制中</p>
<p>当系统内的环境强制使高优先级任务等待低优先级任务时发生</p>
<h1 id="九、同步和互斥"><a href="#九、同步和互斥" class="headerlink" title="九、同步和互斥"></a>九、同步和互斥</h1><h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p>并发性带来了异步性，有时需要通过进程同步来解决这种异步问题；一些进程之间需要相互配合地完成工作，或进程共享一个存储区，对其中的操作需要是同步的。</p>
<h2 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h2><p><strong>互斥</strong>(Mutual exclusion)：又称间接制约关系。进程互斥是指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。</p>
<p><strong>临界资源</strong>：一段时间内只允许一个进程使用的资源；对临界资源的访问，必须互斥地进行。</p>
<p><strong>临界区</strong>(Critical section)是指进程中访问临界资源的代码段。（进入区和退出区是负责实现互斥的代码段）</p>
<p><strong>死锁</strong>(Dead lock)是指两个或以上进程,在相互等待完成特定任务,而最终没法将自身任务进行下去。</p>
<p><strong>饥饿</strong>(Starvation)是指一个可执行的进程,被调度器持续忽略,以至于虽然处于可执行状态却不被执行。</p>
<h2 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h2><p>”互斥“要求 同一时间临界区中最多存在一个线程</p>
<p>如果一个线程想要进入临界区,那么它最终会成功；</p>
<ul>
<li><p><strong>空闲让进</strong>：当临界区空闲时，应允许一个进程进入；</p>
</li>
<li><p><strong>有限等待</strong>：在有限时间内进入临界区，保证不会饥饿；</p>
</li>
<li><p><strong>忙则等待</strong>: 如果一个进程在等待进入临界区，那么在它可以进入之前会被挂起；</p>
</li>
<li><p><strong>让权等待</strong>：暂时进不了临界区的进程，要释放处理机，防止忙等；</p>
</li>
</ul>
<h2 id="软件实现互斥"><a href="#软件实现互斥" class="headerlink" title="软件实现互斥"></a>软件实现互斥</h2><ul>
<li><p><strong>单标志法</strong></p>
<p>两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程，即每个进程进入临界区的权限只能被另一个进程赋予。</p>
<p>此算法实现“同一时刻最多只允许一个进程访问临界区”。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> turn = <span class="number">0</span>; <span class="comment">//表示当前允许进入临界区的进程号</span></span><br><span class="line">p0进程:</span><br><span class="line"><span class="keyword">while</span>(turn != <span class="number">0</span>)</span><br><span class="line">临界区</span><br><span class="line">turn = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p1进程:</span><br><span class="line"><span class="keyword">while</span>(turn != <span class="number">1</span>)</span><br><span class="line">临界区</span><br><span class="line">turn = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>缺点：违背了“空闲让进”原则，如果p0一直不访问临界区，则p1也无法访问临界区。</p>
</li>
<li><p><strong>双标志先检查</strong></p>
<p>设置一个布尔类型数组flag[]，用于标记各进程想进入临界区的意愿；每个进程在进入临界区之前，先检查当前是否有别的进程进入临界区。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag[<span class="number">2</span>]; <span class="comment">//表示进程是否进入临界区</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">p0进程:</span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">1</span>]);</span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">true</span>;    </span><br><span class="line">临界区</span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p1进程:</span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">0</span>]);</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">true</span>;    </span><br><span class="line">临界区</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>缺点：违背了“忙则等待”原则，因为进入区的“检查和上锁”不是一气呵成的，“检查”后，“上锁”前可能发生进程切换，导致多个进程同时访问临界区。</p>
</li>
<li><p><strong>双标志后检查</strong></p>
<p>先上锁再检查；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag[<span class="number">2</span>]; <span class="comment">//表示进程是否进入临界区</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">p0进程:</span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">true</span>; <span class="comment">//先上锁</span></span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">1</span>]);</span><br><span class="line">临界区</span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p1进程:</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">true</span>;  <span class="comment">//先上锁 </span></span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">0</span>]);</span><br><span class="line">临界区</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>缺点：虽然解决了“忙则等待”问题，但又违背了“空闲让进”和“有限等待”原则，可能导致进程“饥饿”。</p>
</li>
<li><p><strong>Peterson算法</strong></p>
<p>进程会先进行礼让，主动让对方先使用临界区；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> turn = <span class="number">0</span>; <span class="comment">//表示哪个进程优先进入临界区</span></span><br><span class="line"></span><br><span class="line">p0进程:</span><br><span class="line">flag[<span class="number">0</span>] = ture;<span class="comment">//自己想进临界区</span></span><br><span class="line">turn = <span class="number">1</span>;<span class="comment">//可以优先让对方先进</span></span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">1</span>] &amp;&amp; turn == <span class="number">1</span>); <span class="comment">//对方想进且最后一次是自己进行礼让，则自己等待</span></span><br><span class="line">临界区</span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">p1进程:</span><br><span class="line">flag[<span class="number">1</span>] = ture;</span><br><span class="line">turn = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">0</span>] &amp;&amp; turn == <span class="number">0</span>);</span><br><span class="line">临界区</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>缺点：没遵循”让权等待“原则（上面几个算法都在等待时占用CPU资源来检查），因为没有提供阻塞排队之类的机制，所以等待的时候需要一直检查条件，占用CPU。</p>
</li>
</ul>
<h2 id="硬件实现互斥"><a href="#硬件实现互斥" class="headerlink" title="硬件实现互斥"></a>硬件实现互斥</h2><ul>
<li><p><strong>中断屏蔽方法</strong></p>
<p>利用”开&#x2F;关中断指令“指令，在进入临界区前关闭中断，出临界区打开中断，这样，单个处理机上的进程就不会同时访问一个临界区；</p>
<p>优点：简单，高效；</p>
<p>缺点：不适用于多处理机；只适用于操作系统内核进程，不适用于用户进程（开&#x2F;关中断指令只能在运行在内核态）</p>
</li>
<li><p><strong>TestAndSet（TS指令&#x2F;TSL指令）</strong></p>
<p>TSL指令是用硬件实现，执行的过程不允许被中断，可让”上锁“和”检查“操作一气呵成；</p>
<p>优点：实现简单；适用多处理机；</p>
<p>缺点：不满足”让权等待“原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，导致忙等；</p>
</li>
<li><p><strong>Swap指令（XCHG指令）</strong></p>
<p>Swap指令是用硬件实现，用于交换两个变量的值，执行过程不许打断。</p>
</li>
</ul>
<h1 id="十、信号量、管程"><a href="#十、信号量、管程" class="headerlink" title="十、信号量、管程"></a>十、信号量、管程</h1><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>信号量是一个整数或更复杂的记录型变量，用来表示系统中<strong>某种资源的数量</strong>。</p>
<p>操作信号量的一对<strong>原语</strong>：（S是传入的信号量)</p>
<ul>
<li><strong>wait (S) 原语：S减1，简称P操作</strong></li>
<li><strong>signal (S) 原语：S加1，简称V操作</strong></li>
</ul>
<blockquote>
<p>P()能够阻塞，V()不会阻塞</p>
<p>对信号量的操作只能有：初始化，P(S)，V(S)</p>
</blockquote>
<p><strong>使用记录型信号量可以避免忙等</strong>，即设置一个队列，在P操作时，如果信号量小于0，则主动阻塞并挂到信号量的等待队列中，V操作时，如果信号量小于等于0时，等唤醒一个等待队列中的进程。</p>
<h2 id="信号量使用"><a href="#信号量使用" class="headerlink" title="信号量使用"></a>信号量使用</h2><ol>
<li><p><strong>互斥</strong>信号量：信号量的值只有0和1；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = 1;</span><br><span class="line">p1()&#123;</span><br><span class="line">	...</span><br><span class="line"> 	P(mutex);</span><br><span class="line">    临界区;</span><br><span class="line">    V(mutex);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">p2()&#123;</span><br><span class="line">	...</span><br><span class="line"> 	P(mutex);</span><br><span class="line">    临界区;</span><br><span class="line">    V(mutex);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>同步</strong>信号量：用信号量实现的调度约束，一个线程等待另一个线程处理事务完后再执行；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">semaphore S = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">P1</span>()&#123;</span><br><span class="line">    ... <span class="comment">//需要先执行的代码;</span></span><br><span class="line">    <span class="built_in">V</span>(S);  <span class="comment">//让资源从0到1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">P2</span>()&#123;</span><br><span class="line">    <span class="built_in">P</span>(s);<span class="comment">//等待前代码执行完后的V操作</span></span><br><span class="line">    ...	<span class="comment">//需要后执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现<strong>前驱关系</strong>，前驱关系类似一个有向图，操作之间有前后之分；</p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191730185.png" alt="image-20211219114540945"></p>
</li>
</ol>
<h2 id="信号量实现"><a href="#信号量实现" class="headerlink" title="信号量实现"></a>信号量实现</h2><p>使用硬件原语</p>
<ul>
<li>禁用中断</li>
<li>原子指令</li>
</ul>
<p>类似锁</p>
<ul>
<li>禁用中断</li>
</ul>
<p>信号量的双用途：</p>
<ul>
<li>互斥和条件同步</li>
<li>但等待条件是独立的互斥</li>
</ul>
<p>但使用信号量，使得读、开发代码比较困难，程序员必须非常精通信号量</p>
<blockquote>
<p>容易出错</p>
<ul>
<li>使用的信号量已经被另一个线程占用</li>
<li>忘记释放信号量</li>
</ul>
</blockquote>
<p>使用信号量不能够处理死锁问题</p>
<h2 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h2><p><strong>管程的组成：</strong></p>
<ul>
<li>共享的数据结构；</li>
<li>对数据结构初始化的语句；</li>
<li>一组用来访问数据结构的函数&#x2F;方法；</li>
</ul>
<p><strong>基本特征：</strong></p>
<ul>
<li><strong>各个外部进程&#x2F;线程只能通过管程提供的特定“入口”才能访问共享数据；</strong></li>
<li><strong>每次仅允许一个进程在管程内执行某个内部过程；</strong></li>
</ul>
<p>注：各进程必须互斥访问管程的特性是由编译器实现的；可在管程中设置条件变量及等待&#x2F;唤醒操作以解决同步问题；</p>
<hr>
<p>管程解决生产者-消费者问题</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BoundedBuffer</span>&#123;</span><br><span class="line">		Lock lock;</span><br><span class="line">		<span class="type">int</span> count = <span class="number">0</span>;  <span class="comment">//buffer 为空</span></span><br><span class="line">		Condition notFull, notEmpty;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">BoundedBuffer::<span class="built_in">Deposit</span>(c)&#123;</span><br><span class="line">		lock-&gt;<span class="built_in">Acquire</span>();    <span class="comment">//管程的定义:只有一个线程能够进入管程</span></span><br><span class="line">		<span class="keyword">while</span>(count == n)</span><br><span class="line">				notFull.<span class="built_in">Wait</span>(&amp;lock); <span class="comment">//释放前面的锁</span></span><br><span class="line">		Add c to the buffer;</span><br><span class="line">		count++;</span><br><span class="line">		notEmpty.<span class="built_in">Signal</span>();</span><br><span class="line">		lock-&gt;<span class="built_in">Release</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BoundedBuffer::<span class="built_in">Remove</span>(c)&#123;</span><br><span class="line">		lock-&gt;<span class="built_in">Acquire</span>();</span><br><span class="line">		<span class="keyword">while</span>(count == <span class="number">0</span>)</span><br><span class="line">				notEmpty.<span class="built_in">Wait</span>(&amp;lock);</span><br><span class="line">		Remove c from buffer;</span><br><span class="line">		count--;</span><br><span class="line">		notFull.<span class="built_in">Signal</span>();</span><br><span class="line">		lock-&gt;<span class="built_in">Release</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h2><ol>
<li><p><strong>生产者—消费者问题</strong></p>
</li>
<li><p><strong>吸烟者问题</strong></p>
</li>
<li><p><strong>读者-写者问题</strong></p>
<p>动机: 共享数据的访问</p>
<p>两种类型的使用者: 读者(不修改数据) 写者(读取和修改数据)</p>
<p>问题的约束:</p>
<ul>
<li>允许同一时间有多个读者,但在任何时候只有一个写者</li>
<li>当没有写者时,读者才能访问数据</li>
<li>当没有读者和写者时,写者才能访问数据</li>
<li>在任何时候只能有一个线程可以操作共享变量</li>
</ul>
<p>多个并发进程的数据集共享</p>
<ul>
<li>读者: 只读数据集;他们不执行任何更新</li>
<li>写者: 可以读取和写入</li>
</ul>
<p>共享数据</p>
<ul>
<li>数据集</li>
<li>信号量CountMutex初始化为1</li>
<li>信号量WriteMutex初始化为1</li>
<li>整数Rcount初始化为0(当前读者个数)</li>
</ul>
<p>读者优先设计</p>
<p>只要有一个读者处于活动状态, 后来的读者都会被接纳.如果读者源源不断的出现,那么写者使用处于阻塞状态.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//信号量实现</span></span><br><span class="line"><span class="comment">//writer</span></span><br><span class="line"><span class="built_in">sem_wait</span>(WriteMutex);</span><br><span class="line">write;</span><br><span class="line"><span class="built_in">sem_post</span>(WriteMutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">//reader</span></span><br><span class="line"><span class="built_in">sem_wait</span>(CountMutex);</span><br><span class="line"><span class="keyword">if</span>(Rcount == <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">sem_wait</span>(WriteMutex); <span class="comment">//确保后续不会有写者进入</span></span><br><span class="line">++Rcount;</span><br><span class="line">read;</span><br><span class="line">--Rcount;</span><br><span class="line"><span class="keyword">if</span>(Rcount == <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">sem_post</span>(WriteMutex); <span class="comment">//全部读者全部离开才能唤醒写者</span></span><br><span class="line"><span class="built_in">sem_post</span>(CountMutex);</span><br></pre></td></tr></table></figure>

<p>写者优先设计</p>
<p>一旦写者就绪,那么写者会尽可能的执行写操作.如果写者源源不断的出现的话,那么读者就始终处于阻塞状态.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//writer</span></span><br><span class="line">Database::<span class="built_in">Write</span>()&#123;</span><br><span class="line">		Wait until readers/writers;</span><br><span class="line">		write database;</span><br><span class="line">		check out - wake up waiting readers/writers;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//reader</span></span><br><span class="line">Database::<span class="built_in">Read</span>()&#123;</span><br><span class="line">		Wait until no writers;</span><br><span class="line">		read database;</span><br><span class="line">		check out - wake up waiting writers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//管程实现</span></span><br><span class="line">AR = <span class="number">0</span>; <span class="comment">// # of active readers</span></span><br><span class="line">AW = <span class="number">0</span>; <span class="comment">// # of active writers</span></span><br><span class="line">WR = <span class="number">0</span>; <span class="comment">// # of waiting readers</span></span><br><span class="line">WW = <span class="number">0</span>; <span class="comment">// # of waiting writers</span></span><br><span class="line">Condition okToRead;</span><br><span class="line">Condition okToWrite;</span><br><span class="line">Lock lock;</span><br><span class="line"><span class="comment">//writer</span></span><br><span class="line"><span class="function">Public <span class="title">Database::Write</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//Wait until no readers/writers;</span></span><br><span class="line">		<span class="built_in">StartWrite</span>();</span><br><span class="line">		write database;</span><br><span class="line">		<span class="comment">//check out - wake up waiting readers/writers;</span></span><br><span class="line">		<span class="built_in">DoneWrite</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Private <span class="title">Database::StartWrite</span><span class="params">()</span></span>&#123;</span><br><span class="line">		lock.<span class="built_in">Acquire</span>();</span><br><span class="line">		<span class="keyword">while</span>((AW + AR) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">				WW++;</span><br><span class="line">				okToWrite.<span class="built_in">wait</span>(&amp;lock);</span><br><span class="line">				WW--;		</span><br><span class="line">		&#125;</span><br><span class="line">		AW++;</span><br><span class="line">		lock.<span class="built_in">Release</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Private <span class="title">Database::DoneWrite</span><span class="params">()</span></span>&#123;</span><br><span class="line">		lock.<span class="built_in">Acquire</span>();</span><br><span class="line">		AW--;</span><br><span class="line">		<span class="keyword">if</span>(WW &gt; <span class="number">0</span>)&#123;</span><br><span class="line">				okToWrite.<span class="built_in">signal</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(WR &gt; <span class="number">0</span>)&#123;</span><br><span class="line">				okToRead.<span class="built_in">broadcast</span>(); <span class="comment">//唤醒所有reader </span></span><br><span class="line">		&#125;</span><br><span class="line">		lock.<span class="built_in">Release</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//reader</span></span><br><span class="line"><span class="function">Public <span class="title">Database::Read</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//Wait until no writers;</span></span><br><span class="line">		<span class="built_in">StartRead</span>();</span><br><span class="line">		read database;</span><br><span class="line">		<span class="comment">//check out - wake up waiting writers;</span></span><br><span class="line">		<span class="built_in">DoneRead</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Private <span class="title">Database::StartRead</span><span class="params">()</span></span>&#123;</span><br><span class="line">		lock.<span class="built_in">Acquire</span>();</span><br><span class="line">		<span class="keyword">while</span>(AW + WW &gt; <span class="number">0</span>)&#123;    <span class="comment">//关注等待的writer,体现出写者优先</span></span><br><span class="line">				WR++;</span><br><span class="line">				okToRead.<span class="built_in">wait</span>(&amp;lock);</span><br><span class="line">				WR--;</span><br><span class="line">		&#125;</span><br><span class="line">		AR++;</span><br><span class="line">		lock.<span class="built_in">Release</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Database::DoneRead</span><span class="params">()</span></span>&#123;</span><br><span class="line">		lock.<span class="built_in">Acquire</span>();</span><br><span class="line">		AR--;</span><br><span class="line">		<span class="keyword">if</span>(AR == <span class="number">0</span> &amp;&amp; WW &gt; <span class="number">0</span>)&#123;  <span class="comment">//只有读者全部没有了,才需要唤醒</span></span><br><span class="line">				okToWrite.<span class="built_in">signal</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		lock.<span class="built_in">Release</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>哲学家就餐问题</p>
<p>一圆桌坐着5位哲学家，他们有思考和吃饭两种状态，而每两个人之间有一根筷子，哲学家只有在饥饿时才试图拿起左右的两只筷子去吃饭（一根一根的拿），如果筷子被别人拿了则需要等待，而哲学家在用餐完后会放下筷子继续思考。</p>
<p>思路：</p>
<ol>
<li>最多允许4个哲学家同时进餐，这样就至少保证有一个哲学家可以拿到左右两只筷子；</li>
<li>依次给哲学家和筷子编号，要求奇数号的哲学家先拿左边筷子，偶数号的哲学家先拿右边筷子。这样当相邻两个哲学家都想进餐时，只有一个可以拿起筷子，另一个会直接阻塞，避免了占有一只筷子再等待另一只筷子的情况；</li>
<li>仅当一个哲学家左右两只筷子都可用时才允许他抓起筷子，拿两只筷子的过程应该连续，即拿筷子前加锁，拿完&#x2F;吃完后解锁。</li>
</ol>
<hr>
<p> 共享数据:</p>
<ul>
<li>Bowl of rice(data set)</li>
<li>Semaphone fork [5] initialized to 1</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEFT (i + N - 1) % N <span class="comment">// 左邻居</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RIGHT (i + 1) % N    <span class="comment">// 右邻居</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THINKING 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HUNGRY   1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EATING   2</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> semaphore;</span><br><span class="line"><span class="type">int</span> state[N];                <span class="comment">// 跟踪每个哲学家的状态</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;         <span class="comment">// 临界区的互斥，临界区是 state 数组，对其修改需要互斥</span></span><br><span class="line">semaphore s[N];              <span class="comment">// 每个哲学家一个信号量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">philosopher</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        <span class="built_in">think</span>(i);</span><br><span class="line">        <span class="built_in">take_two</span>(i);</span><br><span class="line">        <span class="built_in">eat</span>(i);</span><br><span class="line">        <span class="built_in">put_two</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">take_two</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">down</span>(&amp;mutex);</span><br><span class="line">    state[i] = HUNGRY;</span><br><span class="line">    <span class="built_in">check</span>(i);</span><br><span class="line">    <span class="built_in">up</span>(&amp;mutex);</span><br><span class="line">    <span class="built_in">down</span>(&amp;s[i]); <span class="comment">// 只有收到通知之后才可以开始吃，否则会一直等下去</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">put_two</span><span class="params">(i)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">down</span>(&amp;mutex);</span><br><span class="line">    state[i] = THINKING;</span><br><span class="line">    <span class="built_in">check</span>(LEFT); <span class="comment">// 尝试通知左右邻居，自己吃完了，你们可以开始吃了</span></span><br><span class="line">    <span class="built_in">check</span>(RIGHT);</span><br><span class="line">    <span class="built_in">up</span>(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">down</span>(&amp;mutex);</span><br><span class="line">    state[i] = EATING;</span><br><span class="line">    <span class="built_in">up</span>(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查两个邻居是否都没有用餐，如果是的话，就 up(&amp;s[i])，使得 down(&amp;s[i]) 能够得到通知并继续执行</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">check</span><span class="params">(i)</span> </span>&#123;         </span><br><span class="line">    <span class="keyword">if</span>(state[i] == HUNGRY &amp;&amp; state[LEFT] != EATING &amp;&amp; state[RIGHT] !=EATING) &#123;</span><br><span class="line">        state[i] = EATING;</span><br><span class="line">        <span class="built_in">up</span>(&amp;s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="十一、死锁，进程通信"><a href="#十一、死锁，进程通信" class="headerlink" title="十一、死锁，进程通信"></a>十一、死锁，进程通信</h1><h2 id="死锁问题"><a href="#死锁问题" class="headerlink" title="死锁问题"></a>死锁问题</h2><p>一组阻塞的进程持有一种资源等待获取另一个进程所占有的一个资源</p>
<p>示例:</p>
<ul>
<li>系统有2个磁带驱动器</li>
<li>P1和P2各有一个,都需要另外一个</li>
</ul>
<h2 id="死锁特征"><a href="#死锁特征" class="headerlink" title="死锁特征"></a>死锁特征</h2><p>死锁出现一定会出现以下四个条件，但是出现以下四个条件不一定死锁：</p>
<ul>
<li><strong>互斥</strong>：在一个时间只能有一个进程使用资源；</li>
<li><strong>持有并等待</strong>：进程持有至少一个资源，并等待获取其他进程持有的资源；</li>
<li><strong>不可剥夺</strong>： 进程所获得的资源在未使用完之前，不能被强行夺走，只能主动释放；</li>
<li>**循环等待(环路条件)**： 存在等待进程集合{P0,P1,…,Pn}，P0正在等待P1所占用的资源，P1正在等待P2占用的资源…Pn-1在等待Pn的资源，Pn正在等待P0所占用的资源</li>
</ul>
<h2 id="死锁处理方法"><a href="#死锁处理方法" class="headerlink" title="死锁处理方法"></a>死锁处理方法</h2><p>常见方法</p>
<ul>
<li>确保系统永远不会进入死锁状态</li>
<li>运行系统进入死锁状态,然后恢复.</li>
<li>忽略这个问题,假装系统中从来没有发生死锁,用于大多数操作系统,包括UNIX</li>
</ul>
<h3 id="Deadlock-Prevention-预防"><a href="#Deadlock-Prevention-预防" class="headerlink" title="Deadlock Prevention    预防"></a>Deadlock Prevention    预防</h3><p>限制申请方式（破环四种条件）：</p>
<ul>
<li>破坏”互斥“ —— 共享资源不是必须的</li>
<li>破坏”占用并等待“ —— 当一个进程请求资源前，它不持有任何其他资源<ul>
<li>一次性申请所需要的所有资源，才开始执行进程；</li>
<li>资源利用率低，可能发生饥饿；</li>
</ul>
</li>
<li>破坏”不可剥夺“——<ul>
<li>如果进程占有某些资源,并请求其他不能被立即分配的资源,则释放当前正占有的资源</li>
<li>被抢占资源添加到资源列表中</li>
<li>只有当它能够获得旧的资源以及它请求新的资源,进程可以得到执行</li>
<li>可能导致饥饿；</li>
</ul>
</li>
<li>破坏”环路条件&#x2F;循环等待“ - 对所有资源类型进行排序,并要求每个进程按照资源的顺序进行申请（顺序资源分配法）<ul>
<li>不方便新增设备；</li>
<li>实际使用资源的顺序和资源的编号&#x2F;申请顺序不一致，导致资源浪费；</li>
</ul>
</li>
</ul>
<h3 id="Deadlock-Avoidance-避免"><a href="#Deadlock-Avoidance-避免" class="headerlink" title="Deadlock Avoidance     避免"></a>Deadlock Avoidance     避免</h3><ul>
<li><p>最简单和最有效的模式是要求每个进程声明它可能需要的每个类型资源的最大数目</p>
</li>
<li><p>资源的分配状态是通过限定提供与分配的资源数量,和进程的最大需求</p>
</li>
<li><p>死锁避免算法动态检查的资源分配状态,以确保永远不会有一个环形等待状态</p>
</li>
<li><p><strong>当一个进程请求可用资源,系统必须判断立即分配是否能使系统处于安全状态</strong></p>
</li>
<li><p>系统<strong>处于安全状态是指: 针对所有进程,存在安全序列</strong></p>
<blockquote>
<p><strong>安全序列：按照此序列分配资源，则最终每个进程都能顺利完成</strong>。安全序列可能有多个；</p>
</blockquote>
</li>
<li><p>序列&lt;P1,P2,…,Pn&gt;是安全的: 针对每个Pi,Pi要求的资源能够由当前可用的资源+所有的Pj持有的资源来满足,其中j&lt;i.</p>
<ul>
<li>如果Pi资源的需求不是立即可用,那么Pi可以等到所有Pj完成</li>
<li>当Pi完成后,Pi+1可以得到所需要的资源,执行,返回所分配的资源,并终止.</li>
<li>用同样的方法,Pi+2,Pi+3和Pn能获得其所需的资源.</li>
</ul>
</li>
<li><p>如果系统处于<strong>安全状态→无死锁</strong></p>
</li>
<li><p>如果系统处于不安全状态→可能死锁</p>
</li>
<li><p>避免死锁: 确保系统永远不会进入不安全状态</p>
</li>
</ul>
<p><strong>银行家算法：</strong></p>
<ol>
<li><p>检查此次申请是否超过之前声明的最大需求数；</p>
</li>
<li><p>检查此时系统剩余的可用资源是否能满足此次申请；</p>
</li>
<li><p>试探性分配，更改数据结构；</p>
</li>
<li><p>用安全性算法检查此次分配是否会让系统进入不安全状态；</p>
<blockquote>
<p>安全性算法：</p>
<p>检查当前的剩余可用资源是否能满足某个进程的最大需求，如果可以，就把该进程加入安全序列，并把该进程持有的资源全部回收；</p>
<p>不断重复上述过程，看最终是否能让所有进程都加入安全序列。</p>
</blockquote>
</li>
</ol>
<h3 id="Deadlock-Detection-检测"><a href="#Deadlock-Detection-检测" class="headerlink" title="Deadlock Detection     检测"></a>Deadlock Detection     检测</h3><p>进行死锁检测，需要：</p>
<ul>
<li>一种数据结构，用来保存资源的请求和分配信息；</li>
<li>提供一种算法，利用上述信息来检测系统是否已进入死锁状态；</li>
</ul>
<p>数据结构：<strong>资源分配图</strong></p>
<ul>
<li>两种节点<ul>
<li>进程节点：对应一个进程；</li>
<li>资源节点：对应一类资源，一类资源可能有多个；</li>
</ul>
</li>
<li>两种边<ul>
<li>进程点—》资源点：表示进程想申请几个资源，一条边代表一个资源；</li>
<li>资源点—》进程点：表示已经为进程分配了几个资源；</li>
</ul>
</li>
<li>示例图：<img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191731864.png" alt="image-20211222100333315"></li>
</ul>
<p>算法：</p>
<ol>
<li>在资源分配图中，找出既不阻塞又不是孤点的进程节点，消去它的所有请求边和分配边，使之成为孤立的点。（如上图中，p1满足条件，于是先将p1的所有边消去）</li>
<li>第一步中进程释放了资源，以此可以唤醒等待这些资源而阻塞的进程，重复第一步，如果最终能消去图中所有的边，则称该图是可完全简化的。（如果某时刻系统的资源分配图不可完全简化，则此时系统死锁）</li>
</ol>
<p>如果检测算法多次被调用,有可能是资源图有多个循环,所以我们无法分辨出多个可能死锁进程中的哪些”造成”死锁</p>
<h3 id="Recovery-from-Deadlock-恢复"><a href="#Recovery-from-Deadlock-恢复" class="headerlink" title="Recovery from Deadlock 恢复"></a>Recovery from Deadlock 恢复</h3><ul>
<li><p>撤销进程法：终止所有的死锁进程</p>
</li>
<li><p>资源剥夺法：抢夺一个或多个死锁进程占有的资源，使死锁消除</p>
</li>
<li><p>进程回退法：让一个或多个死锁进程回退到足以避免死锁的地步（要求系统记录进程的历史信息，设置还原点）</p>
</li>
</ul>
<p>终止进程应该考虑：</p>
<ul>
<li>进程的优先级</li>
<li>进程运行了多久</li>
<li>需要多少时间才能完成</li>
<li>进程占用的资源</li>
<li>进程完成需要的资源</li>
<li>多少进程需要被终止</li>
<li>进程是交互还是批处理</li>
</ul>
<p>选择一个受影响最小的方法</p>
<p>回滚 - 返回到一些安全状态,重启进程到安全状态</p>
<p>饥饿 - 同一进程可能一直被选作受害者,包括回滚的数量</p>
<h2 id="进程间通信-IPC"><a href="#进程间通信-IPC" class="headerlink" title="进程间通信(IPC)"></a>进程间通信(IPC)</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>进程通信的机制及同步</p>
<p>不使用共享变量的进程通信</p>
<p>IPC facility 提供2个操作:</p>
<ul>
<li>send(message) - 消息大小固定或者可变</li>
<li>receive(message)</li>
</ul>
<p>如果P和Q想通信,需要:</p>
<ul>
<li>在它们之间建立通信链路</li>
<li>通过send&#x2F;recevie交换消息</li>
</ul>
<p>通信链路的实现</p>
<ul>
<li>物理(例如,共享内存,硬件总线)</li>
<li>逻辑(例如,逻辑属性)</li>
</ul>
<h3 id="直接通信"><a href="#直接通信" class="headerlink" title="直接通信"></a>直接通信</h3><p>进程必须正确的命名对方:</p>
<ul>
<li>send(P, message) - 发送消息到进程P</li>
<li>receive(Q, message) - 从进程Q接收信息</li>
</ul>
<p>通信链路的属性</p>
<ul>
<li>自动建立链路</li>
<li>一条链路恰好对应一对通信进程</li>
<li>每对进程之间只有一个链路存在</li>
<li>链路可以是单向的,但通常是双向的</li>
</ul>
<h3 id="间接通信"><a href="#间接通信" class="headerlink" title="间接通信"></a>间接通信</h3><p>定向从消息队列接收消息</p>
<ul>
<li>每个消息对垒都有一个唯一的ID</li>
<li>只有它们共享了一个消息队列,进程才能够通信</li>
</ul>
<p>通信链路的属性</p>
<ul>
<li>只有进程共享一个共同的消息队列,才建立链路</li>
<li>链接可以与许多进程相关联</li>
<li>每对进程可以共享多个通信链路</li>
<li>链接可以是单向或者双向</li>
</ul>
<p>操作</p>
<ul>
<li>创建一个新的消息队列</li>
<li>通过消息队列发送和接收消息</li>
<li>销毁消息队列</li>
</ul>
<p>原语的定义如下:</p>
<ul>
<li><p>send(A, message)</p>
</li>
<li><p>receive(A, message)</p>
</li>
<li><p>通信链路缓冲</p>
<p>  通信链路缓存大小:</p>
<ol>
<li>0容量 - 0 message : 发送方必须等待接收方</li>
<li>有限容量 - n messages的有限长度 : 发送方必须等待,如果队列满</li>
<li>无限容量 - 无限长度 : 发送方不需要等待</li>
</ol>
</li>
</ul>
<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>信号Signal</p>
<ul>
<li>软件中断通知事件处理</li>
<li>Examples: SIGFPE, SIGKILL, SIGUSRI, SIGSTOP, SIGCONT</li>
</ul>
<p>接收到信号时会发生什么?</p>
<ul>
<li>catch:  指定信号处理函数被调用</li>
<li>ignore: 依靠操作系统的默认操作(abort, memory dump, suspend or resume process)</li>
<li>mask:   闭塞信号因此不会传送(可能是暂时的,当处理同样类型的信号)</li>
</ul>
<p>不足:</p>
<ul>
<li>不能传输要交换的任何数据</li>
</ul>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>数据交换</p>
<p>子进程从父进程继承文件描述符(0 stdin, 1 stdout, 2 stderr)</p>
<p>进程不知道(或不关心)从键盘,文件,程序读取或写入到终端,文件,程序.</p>
<p>例如: $ ls | more (两个进程, 管道是缓存,对于ls来说是stdout,对于more来说是stdin )</p>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>消息队列按FIFO来管理消息</p>
<ul>
<li>message: 作为一个字节序列存储</li>
<li>message queues: 消息数组</li>
<li>FIFO &amp;  FILO configuration</li>
</ul>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>进程</p>
<ul>
<li>每个进程都有私有地址空间</li>
<li>在每个地址空间内,明确地设置了共享内存段</li>
</ul>
<p>优点</p>
<ul>
<li>快速,方便地共享数据</li>
</ul>
<p>不足</p>
<ul>
<li>必须同步数据访问</li>
</ul>
<p>最快的方法</p>
<p>一个进程写另一个进程立即可见</p>
<p>没有系统调用干预</p>
<p>没有数据复制</p>
<p>不提供同步</p>
<ul>
<li>Socket</li>
</ul>
<h1 id="十二、文件管理"><a href="#十二、文件管理" class="headerlink" title="十二、文件管理"></a>十二、文件管理</h1><h2 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h2><p><strong>无结构文件</strong></p>
<ul>
<li>文件内部的数据就是一系列二进制流或字符流组成，又称“流式文件”，如 .txt文件</li>
</ul>
<p><strong>有结构文件</strong>：由一组相似的记录组成，又称“记录式文件”，每条记录由若干个数据项组成。根据各条记录的长度是否相等，又可分为定长记录和可变长记录。</p>
<ul>
<li><p>顺序文件</p>
<p>文件中的记录一个接一个地顺序排列（逻辑上），记录可以是定长的或可变长的，在物理上可以顺序存储或链式存储。</p>
<ul>
<li><p>链式存储：无法实现随机存取，每次只能从第一个记录开始依次往后查找；</p>
</li>
<li><p>顺序存储：</p>
<ul>
<li><p>可变长记录：</p>
<p>无法实现随机存取，每次只能从第一个记录开始依次往后查找；</p>
</li>
<li><p>定长记录：</p>
<p>可随机存取，能快速找到某关键字对应的记录。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>索引文件</p>
<p>文件的记录在物理上离散地存放，并建立一张索引表，其中<strong>每条</strong>记录对应一个索引项，可以快速找到对应的文件记录。</p>
<p>索引表是定长记录的顺序文件，可以快速查找；</p>
</li>
<li><p>索引顺序文件</p>
<p>索引文件存在缺点：每个记录对应一个索引表项，会使索引表占用较大空间；因此，可以使<strong>一组</strong>顺序的记录对应一个索引表项，这就是索引顺序文件。</p>
<p>当记录过多时，可建立多级索引表。</p>
</li>
</ul>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p><strong>文件控制块（FCB）</strong>：目录文件中的一条记录。</p>
<ul>
<li>基本信息：<strong>文件名、物理地址</strong>、逻辑结构、物理结构等；</li>
<li>存取控制信息：是否可读&#x2F;可写、禁止访问的用户名单等；</li>
<li>使用信息：文件的建立时间、修改时间等；</li>
</ul>
<p><strong>FCB的有序集合称为“文件目录”</strong>，一个FCB就是一个文件目录项。</p>
<hr>
<p><strong>目录操作</strong></p>
<ul>
<li>搜索</li>
<li>创建文件</li>
<li>删除文件</li>
<li>显示文件</li>
<li>修改目录</li>
</ul>
<hr>
<p><strong>目录结构：</strong></p>
<ul>
<li><p>单极目录结构：只有一个目录（不适用）</p>
</li>
<li><p>两级目录结构（早期的多用户操作系统）：主文件目录和用户文件目录，允许不同用户的文件重名，可以添加访问限制。缺乏灵活性，用户不能对自己的文件分类。</p>
</li>
<li><p>多级目录结构（树形目录结构）：有一个根目录，下有多个子目录，子目录也有它的子目录，跟树结构一样。</p>
<p>有相对路径、绝对路径，使用相对路径可以直接从当前目录出发寻找数据，而不用从根目录开始。</p>
<p>缺点：不便于文件的共享。</p>
</li>
<li><p>无环图目录结构：跟多级目录结构很像，只是可以让不同的文件名指向同一个文件，或指向同一个目录（共享同一个目录下的所有内容）；</p>
<p>共享计数器：用于记录有多少个地方在共享该节点。当用户删除节点时，只是删除该用户的FCB，并使共享计数器减1，并不会直接删除该共享节点；只有当共享计数器为0时，才删除节点。</p>
<blockquote>
<p>共享文件不是复制文件，所以当某个用户修改了文件数据，所有用户都可以看到文件数据的变化。</p>
</blockquote>
</li>
</ul>
<hr>
<p><strong>索引节点（FCB的改进）</strong></p>
<p>由于FCB是一张表，记录了每个文件的很多信息，这会占用不少空间，由于磁盘I&#x2F;O每次读入一块磁盘，当需要查询很多表项时，需要启动磁盘多次；因此，应该减少FCB的占用空间，这样在查询时就不用启动磁盘过多次。</p>
<p>由于查找时只使用文件名作为关键字，因此可以建立索引表，用文件名作为关键字，其他文件信息放到索引节点去，这样一个索引表的大小就小很多了。</p>
<hr>
<hr>
<hr>
<h2 id="磁盘块管理"><a href="#磁盘块管理" class="headerlink" title="磁盘块管理"></a>磁盘块管理</h2><ul>
<li>对<strong>非空闲</strong>磁盘块的管理（存放了文件数据的磁盘块）——文件的<strong>物理结构&#x2F;文件分配方式</strong></li>
<li>对<strong>空闲</strong>磁盘块的管理——文件<strong>存储空间管理</strong></li>
</ul>
<h3 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h3><p>（文件的分配方式）</p>
<p>类似于内存分页，磁盘中的存储单元也会被分为一个个 <strong>“磁盘块”</strong>，磁盘块的大小和内存块、页面的大小相同（方便数据交换）。</p>
<p>在外村中，文件的逻辑空间也被分为一个个的 <strong>“文件块”</strong>，文件的逻辑地址也可以表示为 <strong>“逻辑块号，块内地址”</strong> 的形式。</p>
<ul>
<li><p><strong>连续分配</strong></p>
<p>每个文件在磁盘上占用一组连续的块。</p>
<ul>
<li>文件目录中记录了存放的<strong>起始块号 和 长度</strong>；</li>
<li>映射：<strong>（逻辑块号，块内地址）——&gt; （物理块号，块内地址）</strong>；只需转换块号，块内地址不变，<strong>物理块号 &#x3D; 起始块号 + 逻辑块号</strong>。</li>
<li>支持<strong>随机访问</strong>，因为可以直接算出逻辑块号对应的物理块号。</li>
<li>在<strong>顺序读&#x2F;写</strong>时速度<strong>最快</strong>，因为读取磁盘块时需要移动磁头，而相邻两个块距离最近，磁头移动距离最短。</li>
<li>缺点：不方便拓展，存储空间利用率低，会产生难以利用的磁盘碎片。同样可费很大的时间代价，用紧凑来处理碎片。</li>
</ul>
</li>
<li><p><strong>隐式链接</strong></p>
<p>离散存储，指针指向下一个逻辑块号。</p>
<ul>
<li>文件目录记录了存放的 起始块号 和 结束块号；</li>
<li>方便拓展，外存利用率高，不会有碎片问题；</li>
<li>只支持顺序访问，不能随机访问，查找效率低；</li>
</ul>
</li>
<li><p><strong>显式链接</strong></p>
<p>将链接文件各物理块的指针显示地存放在一张表中，即<strong>文件分配表（FAT</strong>，File Allocation Taable），<strong>一个磁盘仅设置一张FAT</strong>，开机时，将FAT读入内存，并<strong>常驻内存</strong>；</p>
<p>如：（物理块号字段可以是隐含的）</p>
<table>
<thead>
<tr>
<th>物理块号</th>
<th>下一块</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>5</td>
</tr>
<tr>
<td>2</td>
<td>-1</td>
</tr>
</tbody></table>
<ul>
<li>文件目录只记录存放的 起始块号；</li>
<li>支持<strong>随机访问</strong>，因为查找物理块号的过程是在内存的FAT表上进行的，不需要读磁盘操作，即通过顺序查找FAT实现随机查找磁盘；</li>
<li>方便拓展，不会有外部碎片；</li>
<li>文件分配表FAT需要<strong>占用额外的存储空间</strong>；</li>
</ul>
</li>
<li><p><strong>索引分配</strong></p>
<p>文件离散分配，系统会为<strong>每个文件</strong>建立<strong>一张索引表</strong>，<strong>索引表记录了文件的各个逻辑块对应的物理块</strong>（逻辑块号顺序分布，可以隐去）。索引表存放的磁盘块称为<strong>索引块</strong>，文件数据存放的磁盘称为<strong>数据块</strong>。</p>
<ul>
<li>目录文件中记录了文件的索引块的物理块号；</li>
<li>支持随机访问，文件拓展方便；</li>
</ul>
<p>当一个文件很大，使一个磁盘块装不下文件的整张索引表时，可以使用：</p>
<ul>
<li><p>链接</p>
<ul>
<li>想找到第 i 号索引块，必须先依次读入 0 ~ i - 1号索引块，磁盘I&#x2F;O次数多，查找效率低。</li>
</ul>
</li>
<li><p>多层索引：</p>
<p>类似多级页表，使第一层索引指向第二层的索引块。</p>
<ul>
<li>使用K层索引，不管大小文件，访问数据块都需要K+1次读磁盘。</li>
</ul>
</li>
<li><p>混合索引：</p>
<p>文件的顶级索引表中，即有 直接地址索引，又有一级间接索引（指向单层索引表），二级间接索引（指向两级索引表）。</p>
<ul>
<li>对小文件，访问数据块所需读磁盘次数更少。</li>
</ul>
</li>
</ul>
</li>
<li><p>重要考点：</p>
<ul>
<li>根据索引的结构，计算出文件的最大长度（各级索引表不能超过一个块）；</li>
<li>访问某个数据结构所需要的读磁盘次数（FCB存有指向顶级索引块的指针，因此可以根据FCB读入顶级索引块，则每次读入下一级的索引块都需要一次读磁盘操作，注意题目有没有说 顶级索引块是否已调入内存）</li>
</ul>
</li>
</ul>
<h3 id="存储空间管理"><a href="#存储空间管理" class="headerlink" title="存储空间管理"></a>存储空间管理</h3><p><strong>存储空间的划分与初始化</strong></p>
<ul>
<li><p>划分：将物理磁盘划分为一个个文件卷（逻辑卷、逻辑盘，如Windows的c盘、d盘）；</p>
<blockquote>
<p>有的系统支持超大型文件，可由多个磁盘组成一个文件卷；</p>
</blockquote>
</li>
<li><p>初始化：将各个文件卷划分为目录区、文件区；</p>
<blockquote>
<p>目录区：存放文件目录信息（FCB），用于磁盘存储空间管理的信息；</p>
<p>文件区：存放文件数据；</p>
</blockquote>
</li>
</ul>
<p><strong>管理方法：</strong></p>
<ul>
<li><p><strong>空闲表法</strong></p>
<p><strong>用表记录空闲区的位置和数量</strong>。适用于“连续分配方式”；</p>
<ul>
<li><p>分配磁盘块：</p>
<p>与内存管理的动态分区分配类似，为一个文件分配连续的存储空间，同样可用首次适应、最佳适应、最坏适应等算法来决定文件的空间如何分配；</p>
</li>
<li><p>回收磁盘块：</p>
<p>与内存管理的动态分区分配类似，回收时要考虑四种情况：</p>
<ul>
<li>回收区的前后都没有相邻空闲区；</li>
<li>回收区的前后都是空闲区；</li>
<li>回收区前面是空闲区；</li>
<li>回收区后面是空闲区；</li>
</ul>
<p>总之，回收时要注意表项的合并问题。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>第一个空闲盘 块号</th>
<th>空闲盘 块数</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>2</td>
</tr>
<tr>
<td>5</td>
<td>1</td>
</tr>
<tr>
<td>13</td>
<td>4</td>
</tr>
</tbody></table>
</li>
<li><p><strong>空闲链表法</strong>：</p>
<ul>
<li><p><strong>空闲盘 块链</strong>：以盘块为单位组成一条空闲链；操作系统保存链头、链尾指针；</p>
<ul>
<li><p>分配：从链头开始依次摘下空闲盘块，并修改空闲链的链头指针；</p>
</li>
<li><p>回收：回收的盘块依次挂到链尾，并修改链尾指针；</p>
</li>
</ul>
</li>
<li><p><strong>空闲盘 区链</strong>：以盘区为单位组成一条空闲链；操作系统保存链头、链尾指针；</p>
<ul>
<li><p>分配：可以按首次适应、最佳适应等算法，从链头开始检索，找到一个大小符合要求的盘曲进行分配；如果没有合适的盘区，也可将不同盘区的盘块同时分配给一个文件，注意要修改相应的链指针和盘区大小等数据；</p>
</li>
<li><p>回收：如果相邻有空闲盘区，则合并，没有的话则单独作为一个盘区挂到链尾</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191731017.png" alt="image-20211223151833561"></p>
</li>
<li><p><strong>位示图法</strong></p>
<p>位示图：每个二进制位对应一个盘块，如用“0”表示盘块空闲，“1”表示盘块已分配。</p>
<table>
<thead>
<tr>
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>…</td>
<td>…</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>…</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>计算：这里用一个字节（8位）表示一行，一般是用一个字（16位）来表示的；</p>
<p>（1，4）&#x3D; b &#x3D; 1 * 8 + 4 &#x3D; 12；</p>
<p>b &#x3D; 13 —— i &#x3D; 13 &#x2F; 8 &#x3D; 1;  j &#x3D; 13% 8 &#x3D; 5;</p>
<ul>
<li>分配：扫描位示图，找到大小符合要求的“0”，分配后，将相应位设为“1”；</li>
<li>回收：将对应盘块号的二进制位设为“0”；</li>
</ul>
</li>
<li><p><strong>成组链接法</strong></p>
<p>（UNIX采用的策略，适合大型文件系统）</p>
<p>在文件卷的目录区中专门有一个磁盘块作为“超级块”，当系统启动时需要将超级块读入内存。</p>
<ul>
<li>“超级块”的首部记录了下一组空闲盘的的块数，后面存放能指向这一组空闲盘块的指针；</li>
<li>在下一组空闲盘块中，它的首个盘块跟“超级块”类似，首部也记录它的下一组空闲盘块数，后面存放能指向这一组空闲盘块的指针；</li>
<li>依次类推，直至最后一个分组，它没有下一组空闲块，则将第一个盘块设为一个特殊值。</li>
</ul>
</li>
</ul>
<h2 id="文件基本操作"><a href="#文件基本操作" class="headerlink" title="文件基本操作"></a>文件基本操作</h2><ul>
<li><p><strong>创建文件</strong></p>
<p>进行 Create系统调用时，需要提供的几个主要参数：</p>
<ol>
<li>所需的外存空间大小 (如：一个盘块，即1KB)</li>
<li>文件存放路径</li>
<li>文件名</li>
</ol>
<p>操作系统在处理 Create系统调用时，主要做了两件事</p>
<ol>
<li><p>在外存中找到文件所需的空间（使用空闲链表法、位示图、成组链接法等管理策略，找到空闲空间）</p>
</li>
<li><p>根据文件存放路径的信息找到该目录对应的目录文件，在目录中创建该文件对应的目录项。目录项中包含了文件名、文件在外存中的存放位置等信息。</p>
</li>
</ol>
</li>
<li><p><strong>删除文件</strong></p>
<p>进行 Delete系统调用时，需要提供的几个主要参数：</p>
<ol>
<li><p>文件存放路径</p>
</li>
<li><p>文件名</p>
</li>
</ol>
<p>操作系统在处理 Delete系统调用时，主要做了几件事：</p>
<ol>
<li><p>根据文件存放路径找到相应的目录文件，从目录中找到文件名对应的目录项。</p>
</li>
<li><p>根据该目录项记录的文件在外存的存放位置文件大小等信息，回收文件占用的磁盘块。<br>(回收磁盘块时，根据空闲表法、空闲链表法、位图法等管理策略的不同，需要做不同的处理）</p>
</li>
<li><p>从目录表中删除文件对应的目录项。</p>
</li>
</ol>
</li>
<li><p><strong>打开文件</strong></p>
<p>在很多操作系统中，在对文件进行操作之前，要求用户先使用open系统调用“打开文件”，需要提供的几个主要参数：</p>
<ol>
<li><p>文件存放路径</p>
</li>
<li><p>文件名</p>
</li>
<li><p>要对文件的操作类型（如：r只读，rw读写等）</p>
</li>
</ol>
<p>操作系统在处理open系统调用时，主要做了几件事：</p>
<ol>
<li><p>根据文件存放路径找到相应的目录文件，从目录中找到文件名对应的的目录项，并检查该用户是否有指定的操作权限。</p>
</li>
<li><p>将目录项复制到内存中的“打开文件表”中。并将对应表目的编号返回给用户。之后用户使用打开文件表的编号来指明要操作的文件。</p>
</li>
</ol>
<blockquote>
<p>整个系统只有一张系统的打开文件表，其中有一项为 ：打开计数器，即有多少各用户进程打开了该文件；如：在Windows中，如果尝试删除某文件，而该系统已被某进程打开，就会提示“暂时无法删除该文件”，这其实是系统先检查了打开文件表，确认是否有进程在使用该文件。</p>
</blockquote>
</li>
<li><p><strong>关闭文件</strong></p>
<p>进程使用完文件后，要“关闭文件”，操作系统在处理Cose系统调用时，主要做了几件事：</p>
<ol>
<li><p>将进程的打开文件表相应表项删除</p>
</li>
<li><p>回收分配给该文件的内存空间等资源</p>
</li>
<li><p>系统打开文件表的打开计数器 count减1,若count &#x3D; 0,则删刑除对应表项。</p>
</li>
</ol>
</li>
<li><p><strong>读文件</strong></p>
<p>进程使用read系统调用完成写操作。需要指明是哪个文件（在支持“打开文件”操作的系统中，只需要提供文件在打开文件表中的索引号即可），还需要指明要读入多少数据、指明读入的数据要放在内存中的什么位置。</p>
<p>操作系统在处理read系统调用时，会从读指针指向的外存中，将用户指定大小的数据读入用户指定的内存区域中。</p>
</li>
<li><p><strong>写文件</strong></p>
<p>进程使用 write系统调用完成写操作，需要指明是哪个文件（在支持“打开文件”操作的系统中，只需要提供文件在打开文件表中的素引号即可），还需要指明要写出多少数据(如：写出1KB)、写回外存的数据放在内存中的什么位置。</p>
<p>操作系统在处理 write系统调用时，会从用户指定的内存区域中，将指定大小的数据写回写指针指向的外存</p>
</li>
</ul>
<h2 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h2><ul>
<li><p><strong>基于索引节点的共享方式（硬链接）</strong></p>
<p>索引节点（文件目录的内容）：是一种文件目录的瘦身策略，因此检索文件时只需用到文件名，因此可以将除了文件名之外的其他信息放到索引节点中，这样目录项就只需包含文件名、索引节点指针。</p>
<p>共享方式：<strong>在索引节点中设置一个链接计数变量 count，用于表示链接到本索引节点上的用户目录项数。</strong></p>
<p>但用户要“删除”文件时，只把该用户目录中与该文件对应的目录项删除，且索引节点的count减1，只有count &#x3D; 0时，系统才会真的删除文件。</p>
</li>
<li><p><strong>基于符号链的共享方式（软链接）</strong></p>
<p>使用 Link类型的文件，记录了想要共享的文件的存放路径，用户进程的文件目录项指向该Link文件，会通过里面的路径，去找到共享的文件。</p>
<p>如：Windows的快捷方式</p>
</li>
</ul>
<h2 id="文件保护"><a href="#文件保护" class="headerlink" title="文件保护"></a>文件保护</h2><ul>
<li><p><strong>口令保护</strong></p>
<p>为文件设置一个“口令”，用户请求访问该文件时必须提供“口令”。口令一般存放在文件对应的FCB或索引节点中。</p>
<ul>
<li>优点：保存口令的空间开销不多，验证口令的时间开销也很小；</li>
<li>缺点：口令被存放在系统内部，不够安全；</li>
</ul>
</li>
<li><p><strong>加密保护</strong></p>
<p>使用某个“密码”对文件进行加密，在访问文件时需要提供正确的“密码”才能对文件进行正确的解读。如：简单的加密算法——异或加密，使用同样的密码对原文件进行异或运算，可以实现加密和解密；</p>
<ul>
<li>优点：保密性强，不需要在系统中存储密码；</li>
<li>缺点：编码&#x2F;译码，即加密&#x2F;解密需要花费一定时间。</li>
</ul>
</li>
<li><p>访问控制</p>
<p>在文件的FCB或索引节点中增加一个访问控制表（ACL，Access-Control），表明用户可以对该文件执行哪些操作。</p>
<p>精简的访问控制表：以组为单位，标记各组 用户的权限。</p>
</li>
</ul>
<h2 id="文件系统的层次结构"><a href="#文件系统的层次结构" class="headerlink" title="文件系统的层次结构"></a>文件系统的层次结构</h2><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191731585.png" alt="image-20211223172034269"></p>
<p>对应关系：</p>
<p>用户接口——文件基本操作</p>
<p>文件目录系统——文件目录</p>
<p>存取控制模块——文件保护</p>
<p>逻辑文件系统与文件信息缓冲区——逻辑结构</p>
<p>物理文件系统——物理结构</p>
<p>辅助分配模块——存储空间管理</p>
<p>设备管理模块——磁盘管理</p>
<p>一个栗子：</p>
<p><img src="D:/Note/Typora_picture/image-20211223172459972.png" alt="image-20211223172459972"></p>
<h2 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h2><h3 id="磁盘的结构"><a href="#磁盘的结构" class="headerlink" title="磁盘的结构"></a>磁盘的结构</h3><ul>
<li><strong>磁盘、磁道、扇区：</strong></li>
</ul>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191731173.png" alt="image-20211223173450194"></p>
<ul>
<li><p><strong>在磁盘中读&#x2F;写数据：</strong></p>
<p>需要把“磁头”移动到想到 读&#x2F;写 的扇区所在的磁道。磁盘会转起来，让目标扇区从磁头下面划过，才能完成对上去的读&#x2F;写操作。</p>
</li>
<li><p><strong>盘面、柱面：</strong></p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191731456.png" alt="image-20211223173946145"></p>
</li>
<li><p><strong>磁盘的物理地址：</strong></p>
<p>可用<strong>（柱面号，盘面号，扇区号）</strong>来定位任意一个<strong>“磁盘块”</strong>。在 “文件的物理结构” 小节中，提到文件数据存放在外存中的几号块，这个块号就可以转换成（柱面号，盘面号，扇区号）的地址形式。<br>可根据该地址读取一个“块”<br>①根据“柱面号”移动磁臂，让磁头指向指定柱面；<br>②激活指定盘面对应的磁头<br>③磁盘旋转的过程中，指定的扇区会从磁头下面划过，这样就完成了对指定扇区的读&#x2F;写。</p>
</li>
</ul>
<h3 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h3><p>依次磁盘读&#x2F;写操作需要的时间：</p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191731946.png" alt="image-20211223182654163"></p>
<p>操作系统只能影响寻道时间，其他两个受硬件影响的。</p>
<ul>
<li><p><strong>先来先服务算法（FCFS）</strong></p>
<p>根据进程请求访问磁盘的先后顺序进行调度。</p>
<ul>
<li>优点：公平</li>
<li>缺点：如果大量进程竞争磁盘，请求访问的磁道很分散，则FCFS性能很差。</li>
</ul>
</li>
<li><p><strong>最短寻找时间优先（SSTF）</strong></p>
<p>优先处理的磁道是当前磁头最近的磁道。可以保证每次的寻道时间最短，但并不能保证总的训道时间最短（贪心算法思想）。</p>
<ul>
<li>优点：性能较好，平均寻道时间短</li>
<li>缺点：可能产生饥饿现象（磁头可能只在一个小区域内移动）</li>
</ul>
</li>
<li><p><strong>扫描算法（SCAN）</strong></p>
<p>只有磁头移动到最外侧磁道时才能往内移动，移动到最内侧磁道时才能往外移动。（由于磁头移动方式很像电梯，也称电梯算法）</p>
<ul>
<li>优点：性能较好，平均寻道时间较短，不会产生饥饿现象；</li>
<li>缺点：只有到最边上的磁道时才能改变磁头移动方向；对各个位置磁道的响应频率不平均。</li>
</ul>
</li>
<li><p><strong>LOOK调度算法</strong></p>
<p>改善扫描算法（必须到最边上），当磁头移动方向上没有别的请求，就可以立即改变磁头移动方向（边移动边观察，所以叫LOOK）。</p>
</li>
<li><p><strong>循环扫描算法（S-SCAN）</strong></p>
<p>改善扫描算法（响应不平均），规定磁头朝某个特定方向移动时，才能处理磁道访问请求，而返回时直接快速移动至起始端而不处理任何请求。</p>
</li>
<li><p><strong>C-LOOK调度算法</strong></p>
<p>结合LOOK算法和S-SCAN算法，只朝特定方向移动时，才处理访问请求，且磁头方向上没有别的请求就可以立即返回，回到最靠近边缘的需要访问的磁道。</p>
</li>
</ul>
<blockquote>
<p>没有特殊说明时，认为SCAN就是LOOK，C-SCAN就是C-LOOK</p>
</blockquote>
<h3 id="减少磁盘延迟时间"><a href="#减少磁盘延迟时间" class="headerlink" title="减少磁盘延迟时间"></a>减少磁盘延迟时间</h3><p>因为磁头在读完一个扇区的信息后，需要一些准备时间，此时不能读取信息，但磁盘是不停旋转的，如果信息存储在相邻的扇区，那么磁头需要转一圈回来才能读取下一信息。</p>
<ul>
<li><p>交替编号：</p>
<p>让编号相邻的扇区在物理上不相邻；</p>
</li>
<li><p>错位命名：</p>
<p>让相邻盘面的扇区编号“错位”；</p>
</li>
</ul>
<p>为什么使用（柱面号，盘面号，扇区号）的结构？ 因为在读取地址连续的磁盘块时，不需要移动磁头。</p>
<h3 id="磁盘管理-1"><a href="#磁盘管理-1" class="headerlink" title="磁盘管理"></a>磁盘管理</h3><p><strong>磁盘初始化：</strong></p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191731811.png" alt="image-20211223190634414"></p>
<p><strong>引导快：</strong></p>
<p>计算机启动时需要运行初始化程序（自举程序）来完成初始化，在ROM中存放很小的自举装入程序，而完整的自举程序存放在初始化块（引导块）中。</p>
<p><strong>坏块的管理：</strong></p>
<p>简单的磁盘在逻辑格式化时会将坏块标记出来。</p>
<p>复杂的磁盘的磁盘控制器会维护一个坏块链，并管理备用扇区。</p>
<h1 id="I-x2F-O设备"><a href="#I-x2F-O设备" class="headerlink" title="I&#x2F;O设备"></a>I&#x2F;O设备</h1><p>I&#x2F;O设备：输入输出设备</p>
<p><strong>分类</strong></p>
<ul>
<li>按使用特性：<ul>
<li>人机交互类外部设备</li>
<li>存储设备</li>
<li>网络通信设备</li>
</ul>
</li>
<li>按传输速率分类：低速，中速，高速</li>
<li><strong>按信息交换的单位分类</strong>：<ul>
<li><strong>块设备</strong>（传输快，可寻址）</li>
<li><strong>字符设备</strong>（传输慢，不可寻址，常采用中断驱动方式）</li>
</ul>
</li>
</ul>
<h2 id="I-x2F-O控制器"><a href="#I-x2F-O控制器" class="headerlink" title="I&#x2F;O控制器"></a>I&#x2F;O控制器</h2><p>I&#x2F;O控制器用于帮助CPU对I&#x2F;O设备的控制，又称设备控制器。</p>
<p><strong>功能：</strong></p>
<ul>
<li><p><strong>接收和识别CPU发出的命令</strong>：</p>
<p>I&#x2F;O控制器会有相应的<strong>控制寄存器</strong>来存放命令和参数（如CPU发来的read&#x2F;weite命令）</p>
</li>
<li><p><strong>向CPU报告设备的状态</strong>：</p>
<p>I&#x2F;O控制器有相应的<strong>状态寄存器</strong>，用于记录I&#x2F;O设备当前状态，如：1表示空闲，0表示忙碌；</p>
</li>
<li><p><strong>数据交换</strong>：</p>
<p>有<strong>数据寄存器</strong>；输出时，数据寄存器能暂存CPU发来的数据，之后再由控制器传送给设备；输入时，数据寄存器用于暂存设备发来的数据，之后CPU从数据寄存器中取走数据。</p>
</li>
<li><p><strong>地址识别</strong>：</p>
<p>类似于内存的地址，为了区分I&#x2F;O控制器的各个寄存器，会为其设置一个特定的“地址”；I&#x2F;O控制器通过CPU提供的“地址”来判断CPU要读&#x2F;写的是哪个寄存器。</p>
</li>
</ul>
<p>组成：</p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191731441.png" alt="image-20211224100021990"></p>
<p>注：</p>
<p>一个I&#x2F;O控制器可能会对应多个设备；</p>
<p>数据、控制、状态寄存器可能有多个，且都要有相应的地址；有的计算机会让这些寄存器占用内存地址的一部分，称为<strong>内存映像I&#x2F;O</strong>，另一些计算机则采用I&#x2F;O专用地址，即<strong>寄存器独立编制</strong>。</p>
<h2 id="I-x2F-O控制方式"><a href="#I-x2F-O控制方式" class="headerlink" title="I&#x2F;O控制方式"></a>I&#x2F;O控制方式</h2><ul>
<li><p><strong>程序直接控制方式</strong></p>
<ol>
<li>一次读&#x2F;写操作的流程：</li>
</ol>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191731893.png" alt="image-20211224104036572"></p>
<ol start="2">
<li><p>CPU干预的频率：很频繁，I&#x2F;O操作开始前、完成之后需要CPU介入，并且在等待I&#x2F;O完成的过程中CPU需要不断地轮询检查。</p>
</li>
<li><p>数据传送的单位：每次读写一个字；</p>
</li>
<li><p>数据的流向：</p>
<p>读操作（输入）：I&#x2F;O设备—&gt;CPU—&gt;内存</p>
<p>写操作（输出）：内存—&gt;CPU—&gt;I&#x2F;O设备</p>
</li>
<li><p>优点：实现简单，在读写指令之后，加上实现循环检查的指令即可（因此被称为程序直接控制方式）</p>
<p>缺点：CPU和I&#x2F;O设备只能串行工作，CPU需要一直轮询检查，长期处于“忙等”状态，利用率低。</p>
</li>
</ol>
</li>
<li><p><strong>中断驱动方式</strong></p>
<p>引入中断机制。在CPU发出读写命令后，可将等待I&#x2F;O的进程阻塞，然后切换到别的进程执行。当I&#x2F;O完成后，控制器会向CPU发出一个中断信号，CPU检测到中断信号后，会先保存现场，然后转去执行中断处理程序，之后会恢复等待I&#x2F;O的进程的运行环境，使其继续执行。</p>
<blockquote>
<p>CPU会在每个指令周期末尾检查中断；中断处理过程需要保存、恢复进程的运行环境，有一定开销。</p>
</blockquote>
<ol>
<li><p>一次读写操作的流程：</p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191731807.png" alt="image-20211224105240366"></p>
</li>
<li><p>CPU干预的频率：I&#x2F;O操作开始前、完成之后需要CPU介入；等待I&#x2F;O完成的过程中，CPU可以切换到别的进程执行。</p>
</li>
<li><p>数据传送的单位：每次读写一个字；</p>
</li>
<li><p>数据的流向：</p>
<p>读操作（输入）：I&#x2F;O设备—&gt;CPU—&gt;内存</p>
<p>写操作（输出）：内存—&gt;CPU—&gt;I&#x2F;O设备</p>
</li>
<li><p>优点：CPU不需要不断轮询，CPU和I&#x2F;O可并行工作，CPU利用率得到明显提升；</p>
<p>缺点：每个字在I&#x2F;O设备于内存之间的传输，都需要经过CPU，而频繁的中断处理会消耗不少CPU时间。</p>
</li>
</ol>
</li>
<li><p><strong>DMA方式</strong></p>
<p>Direct Memory Access，直接存储器存取</p>
<p>改进：</p>
<ul>
<li>数据的传送单位是“块”，不再是一个字地传送；</li>
<li>数据的流向是从设备直接放入内存，或从内存直接到设备，不需要CPU中转；</li>
<li>仅在传送数据块的开始和结束，才需要CPU干预；</li>
</ul>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191731613.png" alt="image-20211224110558917"></p>
<ol>
<li><p>一次读写操作的流程：</p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191731935.png" alt="image-20211224110051104"></p>
</li>
<li><p>CPU干预频率：仅在传送数据的开始和结束，需要CPU干预；</p>
</li>
<li><p>数据传送单位：一个或说个块（每次读写的只能是连续的多个块）</p>
</li>
<li><p>数据的流向：不再需要经过CPU</p>
</li>
<li><p>优点：数据以“块”为单位，使CPU接入频率进一步降低，数据传输效率提高，所以CPU和I&#x2F;O设备的并行性得到提升。</p>
<p>缺点：一次读写的数据块只能是连续的。</p>
</li>
</ol>
</li>
<li><p><strong>通道控制方式</strong></p>
<p>通道：一种硬件，可以识别并执行一系列通道指令。通道可以执行的指令很单一，且通道程序是放在内存中的，也就是和CPU共享内存，所以通道可以理解为 ”弱化的CPU“，</p>
<ol>
<li><p>一次读写操作的流程：</p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191731080.png" alt="image-20211224111407218"></p>
</li>
<li><p>CPU干预频率：极低，CPU可以让通道执行一系列读写操作，只有完成这组读写操作后才会发出中断信号，请求CPU干预；</p>
</li>
<li><p>数据传送的单位：一组数据块</p>
</li>
<li><p>数据的流向：在通道的控制下执行，在I&#x2F;O设备和内存之间</p>
</li>
<li><p>缺点：实现复杂，需要专门的通道硬件支持；</p>
<p>优点：CPU、通道、I&#x2F;O设备可并行工作，资源利用率很高。</p>
</li>
</ol>
</li>
</ul>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191731185.png" alt="image-20211224112004434"></p>
<h2 id="I-x2F-O软件层次结构"><a href="#I-x2F-O软件层次结构" class="headerlink" title="I&#x2F;O软件层次结构"></a>I&#x2F;O软件层次结构</h2><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191731421.png" alt="image-20211224112143179"></p>
<ul>
<li><p><strong>用户层软件</strong></p>
<p><strong>实现了与用户交互的接口</strong>，用户可直接使用该层提供的、与I&#x2F;O操作相关的<strong>库函数</strong>对设备进行操作。</p>
<p>用户层软件通过 “<strong>系统调用</strong>” 请求操作系统内核的服务。</p>
</li>
<li><p><strong>设备独立性软件</strong></p>
<p>又称设备无关性软件。与设备的硬件特性无关的功能几乎都在这一层实现。</p>
<p>功能：</p>
<ul>
<li>向上层提供统一的调用接口（如“系统调用”）；</li>
<li>设备保护（原理类似于文件保护，将设备看作特殊的文件，设置不同的访问权限）；</li>
<li>差错处理（对设备的一些错误进行处理）；</li>
<li>设备的分配与回收；</li>
<li>数据缓冲区管理（可以用于屏蔽设备间数据交换单位大小和传输速度的差异）；</li>
<li>建立逻辑设备名到物理设备名的映射关系，能根据设备类型选择调用相应的驱动程序（需要“逻辑设备表LUT来确定电脑逻辑设备对应的物理设备，并找到对应的设备驱动程序）；</li>
</ul>
<blockquote>
<p>为什么不同的设备需要不同的设备驱动程序？</p>
<p>因为不同厂家、不同型号的设备内部硬件特性不同，这些特性只有厂家知道，因此厂家必须提供相应的驱动程序、CPU执行驱动程序的指令序列，来完成设置设备寄存器，检查设备状态等工作。</p>
</blockquote>
</li>
<li><p><strong>设备驱动程序</strong></p>
<p>主要负责对硬件设备的具体控制，将上层发出的一系列命令转化成 特定设备能”听懂“ 的一系列操作，包括设置设备寄存器，检查设备状态等。</p>
<p>驱动程序一般会以一个独立进程的方式存在；</p>
</li>
<li><p><strong>中断处理程序</strong></p>
<p>当I&#x2F;O任务完成时，I&#x2F;O控制器会发送一个中断信号，系统会根据 中断信号类型 找到相应的 中断处理程序 并执行。</p>
<p>中断处理程序的执行流程：</p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191731589.png" alt="image-20211225092619332"></p>
</li>
<li><p><strong>硬件</strong></p>
<p>不同的I&#x2F;O设备有不同的硬件特性。</p>
</li>
</ul>
<h2 id="I-x2F-O核心子系统"><a href="#I-x2F-O核心子系统" class="headerlink" title="I&#x2F;O核心子系统"></a>I&#x2F;O核心子系统</h2><p>I&#x2F;O系统，或称I&#x2F;O核心子系统： 属于操作系统的内核部分；即软件层次的中三层：设备独立性软件，设备驱动程序，中断处理程序。</p>
<p>（重点掌握 I&#x2F;O调度，设备保护，假脱机计数，设备分配与回收，缓冲区管理）</p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191731829.png" alt="image-20211225093139197"></p>
<p>I&#x2F;O调度：用某种算法确定一个好的顺序来处理各个I&#x2F;O请求。（如：磁盘调度）</p>
<p>设备保护：将设备看作一种特殊的文件，设立不同的访问权限。</p>
<h2 id="假脱机技术"><a href="#假脱机技术" class="headerlink" title="假脱机技术"></a>假脱机技术</h2><ul>
<li>脱机：脱离主机的控制进行的输入&#x2F;输出操作。</li>
</ul>
<p>在批处理阶段引入了 脱机输入&#x2F;输出 技术（用磁带完成）：在外围控制机的控制下，慢速设备的数据先被输入到更快速的磁带上。之后主机可以从快速的磁带上读入数据，缓解速度矛盾。</p>
<ul>
<li><strong>假脱机技术（SPOOLing技术）：用软件的方式模拟脱机技术</strong></li>
</ul>
<p>在磁盘上开辟两个存储区域——输入井和输出井；</p>
<p>输入井：模拟脱机输入时的磁带，用于收容I&#x2F;O设备的输入数据；</p>
<p>输出井：模拟脱机输出时的磁带，用于收容用户进程输出的数据；</p>
<p>输入进程：模拟脱机输入时的外围控制机；</p>
<p>输出进程：模拟脱机输出时的外围控制机；</p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191732450.png" alt="image-20211225094410741"></p>
<h2 id="设备的分配和回收"><a href="#设备的分配和回收" class="headerlink" title="设备的分配和回收"></a>设备的分配和回收</h2><p>从进程运行的安全性上考虑，设备分配有两种方式：</p>
<ul>
<li>安全分配方式：为进程分配一个设备后就将进程阻塞，本次&#x2F;O完成后才将进程唤醒。<br>（一个时段内每个进程只能使用一个设备）<br>优点：破坏了“请求和保持”条件，不会死锁；<br>缺点：对于一个进程来说，CPU和&#x2F;O设备只能串行工作；</li>
<li>不安全分配方式：进程发出I&#x2F;O请求后，系统为其分配&#x2F;O设备，进程可继续执行，之后还可以发出新的I&#x2F;O请求。只有某个&#x2F;O请求得不到满足时才将进程阻塞；<br>（进程可以同时使用多个设备）<br>优点：进程的计算任务和&#x2F;O任务可以并行处理，使进程迅速推进;<br>缺点：有可能发生死锁(死锁避免、死锁的检测和解除);</li>
</ul>
<p><strong>设备分配管理中的数据结构</strong>：</p>
<p><strong>设备控制表（DCT）</strong>：系统为每个设备配置了一张DCT，用于记录设备情况。</p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191732235.png" alt="image-20211225100210496"></p>
<p><strong>控制器控制表（COCT）</strong>：每个设备控制器都有一张对应的COCT，操作系统会根据COCT的信息对控制器进行操作和管理；</p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191732905.png" alt="image-20211225100342240"></p>
<p><strong>通道控制表（CHCT）</strong>：…..</p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191732952.png" alt="image-20211225100440690"></p>
<p>系统设备表（SDT）：记录了系统中全部设备的情况，每个设备对应一个表目；</p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191732460.png" alt="image-20211225100537634"></p>
<p><strong>设备分配步骤：</strong></p>
<p>①根据进程请求的物理设备名査找SDT（注：物理设备名是进程请求分配设备时提供的参数）；</p>
<p>②根据SDT找到DCT,若设备忙碌则将进程PCB挂到设备等待队列中，不忙碌则将设备分配给进程。</p>
<p>③根据DCT找到COCT,若控制器忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配<br>给进程。</p>
<p>④根据COT找到CHCT,若通道忙碌则将进程PCB挂到通道等待队列中，不忙碌则将通道分配给进<br>程。</p>
<p>（只有设备、控制器、通道三者都分配成功时，这次设备分配才算成功，之后就可以启用I&#x2F;O设备进行数据传送）</p>
<p>缺点：用户编程时必须提供物理设备名，不方便编程，且换了物理设备后，程序会无法运行；若进程请求的物理设备正在忙碌，则即使还有其它同类型的设备，进程也必须阻塞。</p>
<p>改进方法：建立逻辑设备名与物理设备名的映射机制，编程时只需提供逻辑设备名。</p>
<p>（改进后，只有第一次使用设备时需要 操作系统根据用户进程指定的设备 去查找系统设备表，找到一个空闲设备分配给进程，并在LUT中增加相应表项。 之后如果用户再次通过相同逻辑设备名请求使用设备，则系统可以直接根据LUT进行分配）</p>
<h2 id="缓冲区管理"><a href="#缓冲区管理" class="headerlink" title="缓冲区管理"></a>缓冲区管理</h2><p>缓冲区是一个存储区域，可以由专门的硬件寄存器组成，也可利用内存作为缓冲区。<br>使用<strong>硬件作为缓冲区的成本较高，容量也较小</strong>，一般仅用在对速度要求非常高的场合（如存储器<br>管理中所用的联想寄存器&#x2F;快表，由于对页表的访问频率极高，因此使用速度很快的联想寄存器来存放页表项的副本）</p>
<p>一般情况下，更多的是利用<strong>内存作为缓冲区</strong>，“设备独立性软件” 的缓冲区管理就是要组织管理好这些缓冲区</p>
<p><strong>缓冲区的作用：</strong></p>
<ul>
<li>缓和CPU与&#x2F;O设备之间速度不匹配的矛盾</li>
<li>减少对CPU的中断频率，放宽对CPU中断相应时间的限制</li>
<li>解决数据粒度不匹配的问题</li>
<li>提高CPU与VO设备之间的并行性</li>
</ul>
<p><strong>单缓冲：</strong></p>
<p>采用单缓冲的策略，操作系统会在主存中为其分配一个缓冲区 (若题目中没有特别说明，一个缓冲区的大小就是一个块) 。</p>
<p>注意：当缓冲区数据非空时，不能往缓冲区冲入数据，只能从缓冲区把数据传出；当缓冲区为空时，<br>可以往缓冲区冲入数据，但必须把缓冲区充满以后，才能从缓冲区把数据传出。</p>
<blockquote>
<p>题：计算每处理一块数据平均需要多久？</p>
<p>技巧：假定一个初始状态，分析下次到达相同状态需要多少时间，这就是处理一块数据平均需要的时间。</p>
<p>如：单缓冲下，假设初始工作区满，缓冲区空，计算到下一个相同状态所用时间。</p>
</blockquote>
<p><strong>双缓冲：</strong></p>
<p>操作系统会在主存中为其分配两个缓冲区。</p>
<blockquote>
<p>单缓冲和双缓冲区别：</p>
<p>两个相互通信的机器只设置单缓冲区，则只能实现单项传输数据；设双缓冲，可以实现双向的数据传输。</p>
<p>注：管道 其实就是缓冲区。</p>
</blockquote>
<p><strong>循环缓冲区：</strong></p>
<p>将多个大小相等的缓冲区链接成一个循环队列。</p>
<p>设两个指针：in指针指向下一个可以冲入数据的空缓冲区，out指针指向下一个可以取出数据的满缓冲区。</p>
<p><strong>缓冲池：</strong></p>
<p>缓冲池由系统中共用的缓冲区组成。</p>
<p>这些缓冲区按使用状况可以分为：</p>
<ul>
<li>空缓冲队列；</li>
<li>装满输入数据的缓冲队列（输入队列）；</li>
<li>装满输出数据的缓冲队列（输出队列）；</li>
</ul>
<p>另外，根据一个缓冲区在实际运算中扮演的功能不同，又设置了四种工作缓冲区：</p>
<ul>
<li>用于收容输入数据的工作缓冲区(hin)</li>
<li>用于提取输入数据的工作缓冲区(sin)</li>
<li>用于收容输出数据的工作缓冲区(hout)</li>
<li>用于提取输出数据的工作缓冲区(sout)</li>
</ul>
<h1 id="练习："><a href="#练习：" class="headerlink" title="练习："></a>练习：</h1><p><strong>网上试题：</strong></p>
<ol>
<li>操作系统具备处理并发活动的能力，其最重要的硬件支持是：中断技术</li>
<li>P操作可能使进程由运行状态变为：等待状态</li>
<li>并发进程失去封闭性特征，是指：并发进程共享公共变量</li>
<li>采用资源有序分配，是破坏了死锁的 环路条件</li>
<li>用户程序在用户态下使用特权指令所引起的中断属于 程序中断</li>
<li>为了实现进程从有到无的变化，操作系统应提供 进程撤销原语（考察：进程控制原语）</li>
</ol>
<p>（中断（时钟，访管），系统功能调用）</p>
<ol>
<li><p>在下列情况(    )，系统需要进行进程调度。</p>
<p>A. 某一进程正访问一临界资源</p>
<p>B．某一进程运行时因缺乏资源进入阻塞状态</p>
<p>C．某一进程处于运行状态，而另一进程处于自由状态</p>
<p>D．某一进程正在访问打印机，而另一进程处于就绪状态</p>
<blockquote>
<p>B</p>
</blockquote>
</li>
<li><p>如果要使装入内存的程序在内存中移动后仍能正常运行，必须要有( 动态重定位 )的支持。</p>
</li>
<li><p><u>分页</u> 存储管理方式能使内存碎片尽可能少，避免内存的整理。</p>
</li>
<li><p>采用 <u>分段式存储管理</u> 不会产生内部碎片。</p>
</li>
<li><p>在单处理机计算机系统中，<u>处理机的操作与通道的操作</u> 是可以并行操作的。</p>
</li>
<li><p>操作系统实现按名存取的关键在于解决 <u>文件的符号名与文件具体的存储地址的转换和映射</u> 。</p>
</li>
<li><p>不让死锁发生的策略可以分为静态和动态两种,死锁避免属于 <u>动态策略</u> 。</p>
<blockquote>
<p>静态策略：死锁预防——设计合适的资源分配算法，保证死锁不发生。</p>
<p>动态策略：死锁避免——根据资源分配过程和结果来决定是否分配。</p>
</blockquote>
</li>
<li><p>若使当前运行的进程总是优先级最高的进程,应选择 <u>剥夺式优先级</u> 进程调度算法。</p>
</li>
<li><p>画出进程三基态状态变化图，以及状态变化原因：</p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191732143.png" alt="image-20220103094842974"></p>
</li>
<li><p>系统中有三个进程GET、PRO和PUT，共用两个缓冲区BUF1和BUF2。假设BUF1中最多可放11个信息，现已放入了两个信息；BUF2最多可放5个信息，目前为空。GET进程负责不断地将输入信息送入BUF1中，PRO进程负责从BUF1中取出信息进行处理，并将处理结果送到BUF2中，PUT进程负责从BUF2中读取结果并输出。试写出正确实现GET、PRO、PUT的同步与互斥的算法（要求：（1）用类C语言描述，条理清楚，注释恰当；（2）信号量原语统一使用wait和signal）。</p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191732151.png" alt="image-20220103095327921"></p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191732034.png" alt="image-20220103095346121"></p>
</li>
<li><p><u>操作接口</u>是操作系统为用户提供的使用计算机系统的手段之一，该接口是指 一组<u>操作控制命令</u>。</p>
<p><u>程序接口</u>，又称应用编程接口（API），由一组<u>系统调用组成</u>；供程序员在编制程序时以程序语句或指令的形式调用操作系统的功能。</p>
</li>
<li><p>基址寄存器和界限寄存器是属于 <u>控制寄存器</u>。</p>
</li>
<li><p>存储管理实际管理的是 主存储器中的用户区。</p>
</li>
<li><p>某文件共占用8个磁盘块B0~B7，磁盘每道有8个扇面，每个扇面可存放一个磁盘块，磁盘旋转一圈的时间是20ms，程序处理一个磁盘块的时间是4ms，B0～B7在一个磁道上优化分布，磁头目前在B0起点处。则把B0～B7全部读出的时间是？</p>
<blockquote>
<p> 答：(2.5+4)* 8 + 1* 7 - 4 &#x3D; 55.<br>因为磁头读取一个扇区需要2.5ms，但是处理一个记录需要4ms，超过了一个扇区的读取时间，而在处理数据时，磁盘不会停转，会继续旋转，于是当下达读取B2的指令时，磁头已经经过第2个扇区，并在第3个扇区中间了。这时，只有等磁盘转到下一个扇区，才能进行读操作。<br>也就是说要满足等待处理时间的要求，必须要让磁头空闲的时间大过处理时间，因此只有连续略掉第2和第3个扇区（这样有5ms的空闲时间），然后再将L2放到第4个扇区，才能保证在有足够处理时间的前提下，又能立刻读到下一条记录。但实际上，还是浪费了1ms的时间。七个扇区就是浪费7秒，而题目问的是“把B0～B7全部读出的时间” 所以不需要处理最后一条，就再减去4秒。</p>
</blockquote>
</li>
<li><p>如果一组并发进程是无关的，则他们 <u>可以包含相同的程序，但没有共享变量</u>。</p>
</li>
<li><p>进程控制块的管理信息包含 <u>队列指针</u> 和 <u>进程优先数</u>。</p>
</li>
<li></li>
</ol>
<p><strong>课程试题：</strong></p>
<ol>
<li><p>实时操作系统必须在（  ）内处理完来自外部的事件。</p>
<ul>
<li>A. 一个机器周期</li>
<li>B. 被控对象规定时间</li>
<li>C. 周转时间 </li>
<li>D. 时间片</li>
</ul>
<blockquote>
<p>B</p>
</blockquote>
</li>
<li><p>课本1-9：设一计算机系统有输入机一台、打印机两台，现有A、B两道程序同时投入运行，且A先运行，B后运行：</p>
<ul>
<li><p>程序A的运行轨迹为：计算50ms，打印信息100ms，再计算50ms，打印信息100ms，结束。</p>
</li>
<li><p>程序B运行的轨迹为：计算50ms，输入数据80ms，再计算100ms，结束。</p>
</li>
</ul>
<p>要求用图画出两道程序并发执行时的工作情况。</p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191732600.png" alt="image-20220103165427922"></p>
</li>
<li><p>课本4-4： 图4.2标明程序段执行的先后次序。 其中，I表示输入操作、 C表示计算操作、 P 表示打印操作、下角标说明是对哪个作业进行上述操作。请指明：（1）哪些操作必须有先后次序，其原因是什么？ （2）哪些操作可以并发执行， 其原因又是什么？</p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191732160.png" alt="image-20220103170627033"></p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191732001.png" alt="image-20220103170644646"></p>
</li>
<li><p>在UNIX中，下列选项中导致创建新进程的操作是（  ）I 用户成功登录II 设备分配III 启动程序执行</p>
<ul>
<li>A. 仅I和II</li>
<li>B. 仅Il和III</li>
<li>C. 仅I和III</li>
<li>D. I，II，III</li>
</ul>
<blockquote>
<p>C</p>
<p>当用户登录后，会启动命令解释程序(SHELL)。</p>
<p>设备分配实际说明已有进程申请设备。</p>
</blockquote>
</li>
<li><p>课本4-12： n 个并发进程共用一个公共变量 Q，写出用信号灯实现 n 个进程互斥时的程序描述，给出信号灯值的取值范围，并说明每个取值的物理意义。</p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191732511.png" alt="image-20220103171010514"></p>
</li>
<li><p>在如图所示的进程流图中，有五个进程合作完成某一任务。说明这五个进程之间的同步关系，并用 P、V 操作实现之，要求写出程序描述。</p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191732319.png" alt="image-20220103171118061"></p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191732255.png" alt="image-20220103171309268"></p>
</li>
<li><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191732864.png" alt="image-20220103171359877"></p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191732213.png" alt="image-20220103171446932"></p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191732078.png" alt="image-20220103171500115"></p>
</li>
<li><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191732642.png" alt="image-20220103172018045"></p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191732321.png" alt="image-20220103172047667"></p>
<blockquote>
<p>D</p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191732571.png" alt="image-20220103172115017"></p>
</blockquote>
</li>
<li><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191733862.png" alt="image-20220103172506105"></p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191733966.png" alt="image-20220103172445881"></p>
</li>
<li><p>操作系统具备处理并发活动的能力，其中最重要的硬件支持是 <u>中断</u>。</p>
</li>
<li><p>所谓操作系统虚拟机的概念，是指 在裸机上配置操作系统。</p>
</li>
<li><p>文件目录采用树型结构而不采用简单结构的最主要原因是 <u>解决重名问题</u>。</p>
</li>
<li><p>在请求分页系统中，为实现淘汰页面的功能，在页表中应增加 <u>引用位</u> 和 <u>改变位</u>。</p>
</li>
<li><p>在磁盘上可以建立的物理文件有：索引文件。</p>
</li>
<li><p>多道运行的特征之一是微观上串行，其含义是：多道程序分时，轮流地占用CPU。</p>
</li>
<li><p>在整个向量中断处理过程，硬件负责 中断响应过程。</p>
</li>
<li><p>进程的结构包括：程序段、数据段、进程控制块PCB。</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/04/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" data-id="cl1ynefmg000eswtue3hffpvh" data-title="计算机操作系统" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-汇编语言" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/Notes/2022/04/14/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/" class="article-date">
  <time class="dt-published" datetime="2022-04-14T06:55:35.260Z" itemprop="datePublished">2022-04-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/Notes/2022/04/14/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/">汇编语言</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="一、访问寄存器和内存"><a href="#一、访问寄存器和内存" class="headerlink" title="一、访问寄存器和内存"></a>一、访问寄存器和内存</h1><p>前提：此汇编语言学习以 Intel 8086 CPU作为示例。</p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191726634.png" alt="image-20211120210722555"></p>
<h2 id="1-寄存器和数据存储"><a href="#1-寄存器和数据存储" class="headerlink" title="1 寄存器和数据存储"></a>1 寄存器和数据存储</h2><p>寄存器是CPU内部的信息存储单元。</p>
<p>一个n位寄存器能存储一个n位的数据，通用寄存器常用X表示；</p>
<p>有时为了向下兼容，会把寄存器<strong>分为高低位</strong>，<strong>如AX 分为 AH,  AL</strong>； <strong>AH表示AX的高位，AL表示AX的低位</strong></p>
<p>（当AL中的数值大于AL所能表示的范围，AL会丢弃溢出位，而<strong>不会将溢出位加到AH上</strong>）</p>
<p>8086CPU有14个寄存器</p>
<p>通用寄存器：AX，BX，CX，DX（累加，基地址，计数，数据）</p>
<p>变址寄存器：SI，DI （源，目标）</p>
<p>指针寄存器：SP，BP（栈顶，基）</p>
<p>指令指针寄存器：IP</p>
<p>段寄存器：CS，SS，DS，ES（代码，数据，栈，附加）</p>
<p>标志寄存器：PSW</p>
<h2 id="2-mov和add指令"><a href="#2-mov和add指令" class="headerlink" title="2 mov和add指令"></a>2 mov和add指令</h2><p>示例：</p>
<blockquote>
<p>mov ax 18	-	将18放入寄存器AX中</p>
<p>add ax 8	   -	将寄存器AX中的值加上8</p>
<p>mov ax bx	-	 将BX中的值放入寄存器AX中</p>
<p>add ax bx 	-	 将AX，BX中的值相加，结果放入AX中</p>
</blockquote>
<h2 id="3-确定物理地址的方法"><a href="#3-确定物理地址的方法" class="headerlink" title="3 确定物理地址的方法"></a>3 确定物理地址的方法</h2><p>物理地址：唯一表示每个内存单元在存储体中的地址。</p>
<p>CPU访问内存单元时要给出内存单元的地址，而所有的内存单元构成的存储空间是一个一维的线性空间。</p>
<p>问题：8086有<strong>20位地址总线，可传送20位地址，寻址能力有1M</strong>；但8086是<strong>16位结构的CPU，其所能处理的地址只有16位，即寻址能力只有64KB</strong>，这就与20位地址总线的1M寻址能力产生矛盾，如何解决？</p>
<p>解决方法：使用 <strong>地址加法器</strong> 可以<strong>将两个16位地址（段地址和偏移地址 ）合成为一个20位的物理地址。</strong></p>
<p><strong>物理地址 &#x3D; 段地址 * 16 + 偏移地址</strong></p>
<p>（乘16 是将段地址左移4位，同一个物理地址可以用不同的段地址和偏移地址表示）</p>
<p>然后 地址加法器 会通过内部总线将这20位物理地址送到 输入输出控制电路，再传到地址总线。</p>
<h2 id="4-内存的分段表示法"><a href="#4-内存的分段表示法" class="headerlink" title="4 内存的分段表示法"></a>4 内存的分段表示法</h2><p>内存中并没有分段，<strong>段的划分是由CPU进行的。</strong></p>
<p>对8086来看：</p>
<ol>
<li>段地址 * 16 必然是16的倍数，所以一个段的起始地址也一定是16的倍数；</li>
<li>偏移地址为16位，16位地址的寻址能力为64k，所以一个段的长度为64k；</li>
</ol>
<p>段地址很重要，有专门的寄存器存放段地址：</p>
<p><strong>CS：代码段寄存器</strong></p>
<p><strong>DS：数据段寄存器</strong></p>
<p><strong>SS：栈段寄存器</strong></p>
<p><strong>ES：附加段寄存器</strong></p>
<h2 id="5-Debug的使用"><a href="#5-Debug的使用" class="headerlink" title="5 Debug的使用"></a>5 Debug的使用</h2><p><strong>-R</strong>：查看寄存器内容；</p>
<p><strong>-R 寄存器名 ：内容</strong>：改变CPU寄存器的内容；</p>
<p><strong>-D</strong>：查看预设地址内存处的128个字节的内容；</p>
<p><strong>-D 段地址 : 偏移地址</strong> ：列出内存中指定地址处的内容；</p>
<p><strong>-D 段地址 : 偏移地址  地址范围</strong>  ：列出内存中指定地址范围内的内容</p>
<p>**-E 段地址 : 偏移地址 数据1 数据2 …….**： 改变指定地址内存中的内容</p>
<p><strong>-E 段地址 : 偏移地址</strong> ：逐个询问式修改内容，使用空格表示接收，回车表示结束</p>
<p><strong>-U 段地址 : 偏移地址</strong>：查看数据，可以将内存中的机器指令翻译成汇编指令显示出来</p>
<p><strong>-A 段地址 : 偏移地址</strong> ：以汇编指令的格式在内存中写入机器指令</p>
<p><strong>-T</strong> ：逐条执行机器指令，从 CS : IP处开始</p>
<p><strong>-P</strong> ：类似于T命令，逐条执行指令，显示结果，但遇到子程序，中断等时，会直接执行，然后显示结果。</p>
<p><strong>-G</strong>：从地址开始处运行命令，直到遇到断点或程序正常结束。</p>
<p>。。。</p>
<h2 id="6-CS、IP与代码段"><a href="#6-CS、IP与代码段" class="headerlink" title="6 CS、IP与代码段"></a>6 CS、IP与代码段</h2><p>CS：代码段寄存器； <strong>IP：指令指针寄存器</strong></p>
<p><strong>CS : IP  —  CPU将内存中CS : IP 指向的内容当作指令执行。</strong></p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191726636.png" alt="image-20211120211501383"></p>
<blockquote>
<p>内存中的数据， 应该用作一般数据，还是指令？</p>
<p>答：CPU会将CS:IP指向的内存单元中的内容看作指令（CPU根据指令周期的不同阶段，可以知道取出的是指令还是数据）</p>
</blockquote>
<h2 id="7-jmp指令"><a href="#7-jmp指令" class="headerlink" title="7 jmp指令"></a>7 jmp指令</h2><p><strong>CS:IP的内容</strong>不能通过mov修改，可以在Debug中用R命令修改（调试手段），而程序手段是可以<strong>用jmp指令进行跳转</strong>：</p>
<ul>
<li><p>同时修改CS : IP 的内容： <strong>jmp 段地址 : 偏移地址</strong>（根据给出的段地址修改CS，偏移地址修改IP）</p>
</li>
<li><p>仅修改IP的内容： <strong>jmp 某一合法寄存器</strong>，如 jmp ax，jmp bx</p>
</li>
</ul>
<h2 id="8-内存中字的存储"><a href="#8-内存中字的存储" class="headerlink" title="8 内存中字的存储"></a>8 内存中字的存储</h2><p>（对8086CPU，16位作为一个字 ）</p>
<p>字单元：由两个地址连续的内存单元组成，存放一个字型数据(16位)。</p>
<blockquote>
<p>在一个字单元中，低地址单元 存放 低位字节，高地址单元 存放 高位字节。</p>
</blockquote>
<h2 id="9-用DS和-address-实现字的传送"><a href="#9-用DS和-address-实现字的传送" class="headerlink" title="9 用DS和[address] 实现字的传送"></a>9 用DS和[address] 实现字的传送</h2><p>CPU要读取一个内存单元的时候，必须先知道这个内存单元的地址：</p>
<p>解决：DS 和 [address] 配合，DS寄存器存放要访问的数据的段地址，偏移地址用[…]形式直接给出。</p>
<blockquote>
<p>注：8086CPU不支持将数据直接送入段寄存器（硬件设计的问题），所以需要<strong>先将数据放入通用寄存器，再放入段寄存器</strong>：</p>
<p>mov bx 1000H</p>
<p>mov ds  bx </p>
</blockquote>
<p>字的传送：</p>
<p>8086CPU可以一次性传送一个字（16位的数据），例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov bx 1000H</span><br><span class="line">mov ds bx</span><br><span class="line">mov ax [0] ;1000:0处的字型数据送入ax</span><br><span class="line">mov [0] cx ;cx中的16位数据送入1000:0处</span><br></pre></td></tr></table></figure>



<h2 id="10-DS与数据段"><a href="#10-DS与数据段" class="headerlink" title="10 DS与数据段"></a>10 DS与数据段</h2><p>对于8086 PC机，可以根据需要将一组内存单元定义为一个段。将一组长度为N (N&lt;64K)、地址连续、起始地址为16的倍数的内存单元当作专门	存储数据的内存空间，从而定义了一个数据段。</p>
<p><strong>DS : [address] —— 用DS存放数据段的段地址，用相关指令访问数据段中的具体单元，单元地址由[address]指出</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#累加数据段中的前 3个单元的数据</span><br><span class="line">mov ax, 1238H</span><br><span class="line">mov ds, ax</span><br><span class="line">mov al, 0</span><br><span class="line">add al,[0]</span><br><span class="line">add al,[1]</span><br><span class="line">add al,[2]</span><br><span class="line">#累加数据段中的前3个 字型数据</span><br><span class="line">mov ax, 1238H</span><br><span class="line">mov ds, ax</span><br><span class="line">mov ax, 0</span><br><span class="line">add ax,[0]</span><br><span class="line">add ax,[2]</span><br><span class="line">add ax,[4]</span><br></pre></td></tr></table></figure>



<h2 id="11-栈及栈操作的实现"><a href="#11-栈及栈操作的实现" class="headerlink" title="11 栈及栈操作的实现"></a>11 栈及栈操作的实现</h2><p>栈：只能在一端进行插入或删除操作的数据结构</p>
<p>栈的操作规则：LIFO（Last In First Out，后进先出）</p>
<p>CPU提供的栈机制：可以将一段内存当作栈来使用，支持用栈的方式访问内存空间。（对于栈溢出的问题，8086CPU不会检查是否越界，需要程序员自己预防栈溢出）</p>
<p>在8086CPU中，有两个与栈相关的寄存器：</p>
<ul>
<li><strong>栈段寄存器SS</strong>  ： 存放栈顶的段地址</li>
<li><strong>栈顶指针寄存器SP</strong>： 存放栈顶的偏移地址</li>
<li>任意时刻，<strong>SS:SP指向栈顶元素</strong></li>
</ul>
<p>PUSH（入栈）和POP（出栈）指令：</p>
<p><strong>push ax：将ax中的数据送入栈中（以字为单位对栈进行操作）</strong></p>
<ul>
<li>(1)SP&#x3D;SP-2；<br>(2)将ax中的内容送入SS : SP指向的内存单元处，SS : SP此时指向新栈顶。</li>
</ul>
<p><strong>pop ax：从栈顶取出数据 放到ax（以字为单位对栈进行操作）</strong></p>
<ul>
<li>(1)将 SS : SP指向的内存单元处的数据送入ax中；<br>(2)SP&#x3D;SP+2，SS:SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1000H</span><br><span class="line">mov ss,ax		#确定栈顶位置</span><br><span class="line">mov sp 0010H	#确定栈底位置/栈空间大小</span><br><span class="line"></span><br><span class="line">mov ax,001AH	</span><br><span class="line">mov bx,001BH</span><br><span class="line"></span><br><span class="line">push ax		#存入位置从栈底开始</span><br><span class="line">push bx		#bx的值最后放入</span><br><span class="line">pop ax		#取出栈顶的值原来是bx的，现在把它放到ax中</span><br><span class="line">pop bx  #经过入栈出栈操作后，ax和bx中的值发生了交换</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191726637.png" alt="image-20211121093822410"></p>
<h1 id="二、汇编语言程序"><a href="#二、汇编语言程序" class="headerlink" title="二、汇编语言程序"></a>二、汇编语言程序</h1><h2 id="1-汇编语言写的源程序"><a href="#1-汇编语言写的源程序" class="headerlink" title="1 汇编语言写的源程序"></a>1 汇编语言写的源程序</h2><p>汇编程序：包含汇编指令和伪指令的文本</p>
<ul>
<li><p><strong>伪指令</strong>：没有对应的机器码，最终是不会被CPU所执行；伪指令是由编译器来执行的，编译器根据伪指令来执行相关的编译工作。</p>
</li>
<li><p><strong>汇编指令</strong>：对应有机器码的指令，可以被编译为机器指令，最终被CPU执行。</p>
</li>
</ul>
<p>过程：汇编程序——编译器编译——机器码——计算机运行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg	#伪指令</span><br><span class="line">codesg segment		#伪指令</span><br><span class="line">	mov ax,0123H	#汇编指令</span><br><span class="line">	mov bx,0456H</span><br><span class="line">	add ax,bx</span><br><span class="line">	add ax,ax</span><br><span class="line">	</span><br><span class="line">	#下面两句，用于程序返回(套路):程序结束运行后，将CPU控制器交还给调用自己的那个程序(常为DOS系统)。</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h		#汇编指令</span><br><span class="line">codesg ends		#伪指令</span><br><span class="line">end			#伪指令</span><br></pre></td></tr></table></figure>

<hr>
<p>程序中的三种伪指令</p>
<ul>
<li><p><strong>段定义</strong></p>
<p>一个汇编程序是由多个段组成的，这些段被用来存放代码，数据或当作栈空间来使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#定义程序中的段：每个段都需要有段名</span><br><span class="line">段名 segment 		#段的开始</span><br><span class="line">	...</span><br><span class="line">段名 ends			#段的结束</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>end</strong> (不是ends)</p>
<p>汇编程序的结束标记。若程序结尾处不加end，编译器在编译程序时，不知道程序在何处结束。</p>
</li>
<li><p><strong>assume</strong> (假设)</p>
<p>让某一个 段寄存器 和程序中的某一个  用segment…ends定义的段 相关联</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#使CS寄存器与codesg关联，将定义的codesg当作程序的代码段使用</span><br><span class="line">assume cs:codesg</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-由源程序到程序运行"><a href="#2-由源程序到程序运行" class="headerlink" title="2 由源程序到程序运行"></a>2 由源程序到程序运行</h2><p>源文件 ( .asm) ——编译——&gt; 目标文件( .obj ) ——连接——&gt; 可执行文件( .exe )</p>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>编译命令：masm + 汇编文件名</p>
<p>编译过程产生的文件：</p>
<ul>
<li><p>目标文件（*.OBJ）**是对一个源程序进行编译后得到的最终结果；</p>
</li>
<li><p>列表文件（*.LST）是编译过程中产生的中间结果；</p>
</li>
<li><p>交叉引用文件（*.CRF）同样是编译过程产生的中间结果；</p>
</li>
</ul>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191726638.png" alt="image-20211121114115020"></p>
<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>连接命令：link + 文件名</p>
<p>连接过程产生的文件：</p>
<ul>
<li>**可执行文件(EXE)**是我们对一个程序进行连接要得到的最终结果。</li>
<li>映像文件(MAP)是连接程序将目标文件连接为可执行文件过程中产生的中间结果。</li>
<li>库文件( .LIB) 里包含了ー些可以调用的子程序，如果我们的程序中调用了某一个库文件中的子程序，就需要在连接的时候，将这个库文件和我们的目标文件连接到一起，生成可执行文件。</li>
<li>如果出现no stack segment，是一个“没有栈段”的警告错误，可以不理会这个错误。</li>
</ul>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191726639.png" alt="image-20211121115724936"></p>
<h2 id="3-用Debug跟踪程序执行"><a href="#3-用Debug跟踪程序执行" class="headerlink" title="3 用Debug跟踪程序执行"></a>3 用Debug跟踪程序执行</h2><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191726640.png" alt="image-20211121144425453"></p>
<h2 id="4-…-和-…"><a href="#4-…-和-…" class="headerlink" title="4 […] 和 (…)"></a>4 […] 和 (…)</h2><p><strong>[…]  ——表示一个内存单元（汇编语法规定）</strong></p>
<table>
<thead>
<tr>
<th>指令</th>
<th>段地址</th>
<th>偏移地址</th>
<th>操作单位</th>
</tr>
</thead>
<tbody><tr>
<td>mov ax，[0]</td>
<td>在DS中</td>
<td>在[0]中</td>
<td>字</td>
</tr>
<tr>
<td>mov al，[0]</td>
<td>在DS中</td>
<td>在[0]中</td>
<td>字节</td>
</tr>
<tr>
<td>mov ax，[bx]</td>
<td>在DS中</td>
<td>在[bx]中</td>
<td>字</td>
</tr>
<tr>
<td>mov al，[bx]</td>
<td>在DS中</td>
<td>在[bx]中</td>
<td>字节</td>
</tr>
</tbody></table>
<p><strong>(…) ——表示一个内存单元或寄存器中的内容（为学习交流方便做出的约定）</strong></p>
<table>
<thead>
<tr>
<th>描述对象</th>
<th>描述方法</th>
<th>描述对象</th>
<th>描述方法</th>
</tr>
</thead>
<tbody><tr>
<td>ax中的内容为0010H</td>
<td>(ax)&#x3D;0010H</td>
<td>2000: 1000处的内容为0010H</td>
<td>(21000H)&#x3D;0010H【20位地址描述只能用于寄存器和物理地址】</td>
</tr>
<tr>
<td>mov ax，[2]</td>
<td>(ax)&#x3D;((ds)*16+2)</td>
<td>mov [2], ax</td>
<td>((ds)*16+2)&#x3D;(ax)</td>
</tr>
<tr>
<td>add as，2</td>
<td>(ax)&#x3D;(ax)+2</td>
<td>add ax, bx</td>
<td>(ax)&#x3D;(ax)+(bx)</td>
</tr>
<tr>
<td>push ax</td>
<td>(sp)&#x3D;sp-2;   ((ss)*16+sp)&#x3D;(ax)</td>
<td>pop ax</td>
<td>(ax)&#x3D;((ss)*16+(sp))；                                    (sp)&#x3D;(sp)+2</td>
</tr>
</tbody></table>
<p>再约定：符号idata表示常量</p>
<p>例：mov ax，[idata] ——代表mov ax, [1]、 mov ax, [1] 等等</p>
<h2 id="5-Loop指令"><a href="#5-Loop指令" class="headerlink" title="5 Loop指令"></a>5 Loop指令</h2><p>Loop指令实现计数型循环，格式：<strong>loop 标号</strong></p>
<p>CPU执行loop指令时要进行的操作：</p>
<ul>
<li>(cx)&#x3D;(cx) - 1；</li>
<li>判断cx中的值，不为0则转至标号处执行程序，为0则向下执行</li>
</ul>
<p>注：要先<strong>定义一个标号，即指定循环开始的地方</strong>；<strong>cx中要提前存放循环次数</strong>，因为(cx) 影响loop指令的执行结果；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">	mov ax,2</span><br><span class="line">	mov cx,11		#</span><br><span class="line">	s:</span><br><span class="line">	add ax,ax 		#</span><br><span class="line">	loop s			#</span><br><span class="line">	</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>



<h2 id="6-Loop指令使用例子"><a href="#6-Loop指令使用例子" class="headerlink" title="6 Loop指令使用例子"></a>6 Loop指令使用例子</h2><p>计算ffff:0000字节单元中的数乘以3，结果存储到dx中。（取出的是字节，而结果要作为字放进dx中）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#先将内存中数据取出，连加上次，即乘以3</span><br><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">	mov ax,0ffffh	#汇编程序中，数据不能以字母开头，所以要在ffff前加0</span><br><span class="line">	mov ds,ax</span><br><span class="line">	mov bx,6</span><br><span class="line">	mov al,[bx]		#</span><br><span class="line">	mov ah,0		#这两步相当于(ax)=((ds)*16+(bx))</span><br><span class="line">	</span><br><span class="line">	mov dx,0</span><br><span class="line">	mov cx,3	#设置循环次数</span><br><span class="line">	s:</span><br><span class="line">	add dx,ax		#结果放在dx中</span><br><span class="line">	loop s</span><br><span class="line">	</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>计算ffff:0 ~ ffff:b <strong>单元</strong>中的数据的和，结果存放在<strong>dx</strong>中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">	mov ax,0ffffh</span><br><span class="line">	mov ds,ax</span><br><span class="line">	</span><br><span class="line">	mov bx,0</span><br><span class="line">	mov dx,0</span><br><span class="line">	mov cx,12</span><br><span class="line">	</span><br><span class="line">	s:</span><br><span class="line">	mov al,[bx]</span><br><span class="line">	mov ah,0</span><br><span class="line">	add dx,ax</span><br><span class="line">	inc bx</span><br><span class="line">	loop s</span><br><span class="line">	</span><br><span class="line">	mov ax,4x00h</span><br><span class="line">	int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>





<h2 id="7-段前缀的使用"><a href="#7-段前缀的使用" class="headerlink" title="7 段前缀的使用"></a>7 段前缀的使用</h2><p>在程序中，如果使用 mov al，[0] 意思应该是将DS:0存储单元的值传给al，但实际编译后，会变成mov al，0，即把常量0放到al里。为了避免这种情况，可以在 […] 前加上段前缀</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al [0]   	#同mov al, 0</span><br><span class="line">mov al ds:[0]	#同(al)=((ds)*16+0)</span><br></pre></td></tr></table></figure>

<p>例题：</p>
<p>将内存 ffff:0 ~ ffff:b 中的数据拷贝到 0:200 ~ 0:20b 单元中中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">	mov ax,0ffffh	</span><br><span class="line">	mov ds,ax	</span><br><span class="line">	mov ax,0020h</span><br><span class="line">	mov es,ax	#额外用一个寄存器放目标地址</span><br><span class="line">	</span><br><span class="line">	mov bx,0	#初始偏移</span><br><span class="line">	mov cx,12	#循环次数</span><br><span class="line">	</span><br><span class="line">	s:</span><br><span class="line">  	mov dl,[bx]	#默认的[bx]是ds:[bx]</span><br><span class="line">	mov es:[bx],dl	#将ds:[bx]的值拷贝到es:[bx]中去</span><br><span class="line">	inc bx		#bx自增1</span><br><span class="line">	loop s</span><br><span class="line">	</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>



<h2 id="8-在代码段中使用数据"><a href="#8-在代码段中使用数据" class="headerlink" title="8 在代码段中使用数据"></a>8 在代码段中使用数据</h2><p>一般的，在程序中直接写地址是很危险的，因为可能会把数据写入到不该写的地方。</p>
<p>对策：可以在程序的段中存放数据，运行时有操作系统分配空间；（段的类别：数据段，代码段，栈段）</p>
<p>程序的一般框架：</p>
<p>当代码段前部 放的是数据而不是执行代码，应该用标号 表明代码开始的地方，不然编译器会把数据部分也当作执行代码来编译，从而造成错误。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">	...</span><br><span class="line">	数据</span><br><span class="line">	...</span><br><span class="line">	start:		#定义一个标号，指示代码开始的位置</span><br><span class="line">	...</span><br><span class="line">	代码</span><br><span class="line">	...</span><br><span class="line">code ends</span><br><span class="line">end start	#end的作用：除了通知编译器程序结束外，还可以通知编译器 程序的入口在什么地方</span><br></pre></td></tr></table></figure>

<p>例题：编程计算以下8个数据的和，结果存在ax寄存器中<br>0123h，0456h，0789h，0abch，odefh，0fedh，0cbah，0987h</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">	#dw：define work，定义字型数据(2字节); db定义一个字节; dd定义一个双字(4字节)</span><br><span class="line">	dw 0123h,0456h,0789h,0abch,odefh,0fedh,0cbah,0987h	#在代码段中定义数据	</span><br><span class="line">	start:			</span><br><span class="line">	mov bx,0</span><br><span class="line">	mov ax,0</span><br><span class="line">	mov cx,8</span><br><span class="line">	</span><br><span class="line">	s:</span><br><span class="line">	add ax,cs:[bx]	#代码段定义的数据是放在和该关联的寄存器中的，这里是cs</span><br><span class="line">	add bx,2</span><br><span class="line">	loop s</span><br><span class="line">	</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<h2 id="9-在代码段中使用栈"><a href="#9-在代码段中使用栈" class="headerlink" title="9 在代码段中使用栈"></a>9 在代码段中使用栈</h2><p>例题：将给定的数据逆序存放（使用栈，数据依次入栈，再依次出栈的数据就是逆序的了）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">	dw 0123H,0456H,0789H,0abcH,0defH,0fedH,0cbaH,098ZH		#给定的数据</span><br><span class="line">	dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0		#留给栈的空余空间</span><br><span class="line">	</span><br><span class="line">	start:</span><br><span class="line">	mov ax,cs	</span><br><span class="line">	mov ss,ax		#确定栈顶位置</span><br><span class="line">	mov sp,30h		#确定栈空间大小</span><br><span class="line">	mov bx,0</span><br><span class="line">	mov cx,8</span><br><span class="line">	s:</span><br><span class="line">	push cs:[bx]	#将cs:[bx]处的数据入栈</span><br><span class="line">	add bx,2		#数据是一个字，所以+2</span><br><span class="line">	loop s</span><br><span class="line">	</span><br><span class="line">	mov bx,0</span><br><span class="line">	mov cx,8</span><br><span class="line">	s0:</span><br><span class="line">	pop cs:[bx]		#将栈中数据依次sh</span><br><span class="line">	add bx,2</span><br><span class="line">	loop s0</span><br><span class="line">	</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>





<h2 id="10-将数据、代码、栈放入不同段"><a href="#10-将数据、代码、栈放入不同段" class="headerlink" title="10 将数据、代码、栈放入不同段"></a>10 将数据、代码、栈放入不同段</h2><p>为了不让程序显得混乱，可以将数据，栈，代码放在不同的段</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#将代码，数据，栈放入不同段</span><br><span class="line">assume cs:code,ds:data,ss:ctack</span><br><span class="line"></span><br><span class="line">data segment	#数据段</span><br><span class="line">	dw 0123H0456H,0789H, 0abch, 0defh, 0fedh0cbah, 0987H</span><br><span class="line">deta ends</span><br><span class="line"></span><br><span class="line">stack segment	#栈段</span><br><span class="line">	dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment	#代码段</span><br><span class="line">start:</span><br><span class="line">	mov ax,stack	#初始化各段寄存器</span><br><span class="line">	mov ss,ax</span><br><span class="line">	mov sp,20h</span><br><span class="line">	mov ax,data</span><br><span class="line">	mov ds,ax</span><br><span class="line">	</span><br><span class="line">	mov bx,0	#入栈</span><br><span class="line">	mov cx,8</span><br><span class="line">	s:</span><br><span class="line">	push [bx]</span><br><span class="line">	add bx,2</span><br><span class="line">	loop s</span><br><span class="line">	</span><br><span class="line">	mov bx,0	#出栈</span><br><span class="line">	mov cx,8</span><br><span class="line">	s0:</span><br><span class="line">	pop [bx]</span><br><span class="line">	add bx,2</span><br><span class="line">	loop s0</span><br><span class="line">	</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<h1 id="三、内存寻址方式"><a href="#三、内存寻址方式" class="headerlink" title="三、内存寻址方式"></a>三、内存寻址方式</h1><h2 id="1-处理字符问题"><a href="#1-处理字符问题" class="headerlink" title="1 处理字符问题"></a>1 处理字符问题</h2><p>用 ‘ ’ 表明字符，</p>
<p>小写字母的ASCII码值比大写字母的ASCII码值大20H；所以：大写+20H &#x3D;&#x3D; 小写，小写-20H &#x3D;&#x3D; 大写 </p>
<p>问：大小写转换问题，将第一个字符串的小写字母转换为大写字母，将第二个字符串的大写字母转换为小写字母</p>
<p>（因为同一个字母大小写的ASCII码的区别只有高位第三位数不同，因此可以不用分支判断，而直接用 位运算 来变换大小写：<strong>转大写</strong>：将字母和<strong>11011111</strong>做<strong>与运算</strong>，<strong>转小写</strong>：将字母与<strong>00100000</strong>做<strong>或运算</strong>）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg</span><br><span class="line">datasg segment</span><br><span class="line">	db &#x27;BaSiC&#x27;</span><br><span class="line">	db &#x27;iNfOrMaTiOn&#x27;</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">start:</span><br><span class="line">	mov ax,datasg</span><br><span class="line">	mov ds,ax</span><br><span class="line">	</span><br><span class="line">	mov bx,0</span><br><span class="line">	mov cx,5</span><br><span class="line">	s:</span><br><span class="line">	mov al,[bx]</span><br><span class="line">	and al,11011111b</span><br><span class="line">	mov [bx],al</span><br><span class="line">	inc bx</span><br><span class="line">	loop s</span><br><span class="line">	</span><br><span class="line">	mov bx,5</span><br><span class="line">	mov cx,11</span><br><span class="line">	s0:</span><br><span class="line">	mov al.[bx]</span><br><span class="line">	or al,00100000b</span><br><span class="line">	mov [bx],al</span><br><span class="line">	inc bx</span><br><span class="line">	loop s0</span><br><span class="line">	</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">codesg end</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<h2 id="2-bx-idata-方式寻址"><a href="#2-bx-idata-方式寻址" class="headerlink" title="2 [bx + idata] 方式寻址"></a>2 [bx + idata] 方式寻址</h2><p> [bx + idata] 表示一个内存单元，它的<strong>偏移地址为 (bx) + idata</strong>（是bx中的数值加上idata)</p>
<p>mov ax, [bx + 200] 的含义：将一个内存单元的内容送入ax，这个内存单元的段地址在ds中，偏移地址为bx的值加上200，*<em>数学化描述：(ax)&#x3D;( (ds)<em>16 + (bx) + 200 )</em></em></p>
<p>对上面的大小写转换问题，如果两个字符串长度相等，可以用[bx + idata] 进行代码简化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg</span><br><span class="line">datasg segment</span><br><span class="line">	db &#x27;BaSiC&#x27;</span><br><span class="line">	db &#x27;MinIX&#x27;</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">start:</span><br><span class="line">	mov ax,datasg</span><br><span class="line">	mov ds,ax</span><br><span class="line">	</span><br><span class="line">	mov bx,0</span><br><span class="line">	mov cx,5</span><br><span class="line">	s:</span><br><span class="line">	mov al,[bx]</span><br><span class="line">	and al,11011111b</span><br><span class="line">	mov [bx],al</span><br><span class="line">	</span><br><span class="line">	mov al.[bx+5]</span><br><span class="line">	or al,00100000b</span><br><span class="line">	mov [bx+5],al</span><br><span class="line">	inc bx</span><br><span class="line">	loop s</span><br><span class="line">	</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">codesg end</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上面的程序就相当于C语言等高级语言的数组机制，实际上，[bx+idata]的方式为高级语言实现数组提供了便利机制</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> a[<span class="number">5</span>] = <span class="string">&quot;BaSiC”</span></span><br><span class="line"><span class="string">	char a[5] = &quot;</span>MinIX<span class="string">&quot;</span></span><br><span class="line"><span class="string">    int i = 0;</span></span><br><span class="line"><span class="string">    do&#123;</span></span><br><span class="line"><span class="string">        a[i]=a[i] &amp; 0xDF;</span></span><br><span class="line"><span class="string">        b[i]=b[i] | 0x20;</span></span><br><span class="line"><span class="string">        i++;</span></span><br><span class="line"><span class="string">    &#125;while(i &lt; 5)</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>



<h2 id="3-SI-和DI-寄存器"><a href="#3-SI-和DI-寄存器" class="headerlink" title="3 SI 和DI 寄存器"></a>3 SI 和DI 寄存器</h2><p> <strong>SI：source index ，源变址寄存器</strong></p>
<p><strong>DI：destination index ，目标变址寄存器</strong></p>
<p>（ SI和DI 是和BX功能相近的寄存器，区别：<strong>SI和DI不能分成两个8位寄存器来使用</strong>）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#下面三组指令实现的功能相同</span><br><span class="line">#1</span><br><span class="line">mov bx,0</span><br><span class="line">mov ax,[bx+123]</span><br><span class="line">#1</span><br><span class="line">mov si,0</span><br><span class="line">mov ax,[si+123]</span><br><span class="line">#1</span><br><span class="line">mov di,0 </span><br><span class="line">mov ax,[di+123]</span><br></pre></td></tr></table></figure>



<p>4 [bx + si] 和[bx + di] 方式寻址</p>
<p>5 [ bx + si + idata ] 和[ bx + di + idata ] 方式寻址</p>
<h2 id="6-不同的寻址方式的灵活应用"><a href="#6-不同的寻址方式的灵活应用" class="headerlink" title="6 不同的寻址方式的灵活应用"></a>6 不同的寻址方式的灵活应用</h2><table>
<thead>
<tr>
<th>形式</th>
<th>名称</th>
<th>特点</th>
<th>意义</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>[idata]</td>
<td>直接寻址</td>
<td>一个常量表示地址</td>
<td>直接定位一个内存单元</td>
<td>mov ax,[200]</td>
</tr>
<tr>
<td>[bx]</td>
<td>寄存器间接寻址</td>
<td>一个变量表示地址</td>
<td>间接定位一个内存单元</td>
<td>mov bx, 0        mov ax,[bx]</td>
</tr>
<tr>
<td>[bx+idata]</td>
<td>寄存器相对寻址</td>
<td>一个常量和变量表示地址</td>
<td>可在一个起始地址的基础上用变量间接定位一个内存单元</td>
<td>mov bx, 4        mov ax,[bx+200]</td>
</tr>
<tr>
<td>[bx+si]</td>
<td>基址变址寻址</td>
<td>两个变量表示地址</td>
<td></td>
<td>mov ax,[bx+si]</td>
</tr>
<tr>
<td>[bx+si+idata]</td>
<td>相对基址变址寻址</td>
<td>两个变量和一个常量表示地址</td>
<td></td>
<td>mov ax,[bx+si+200]</td>
</tr>
</tbody></table>
<p>7 不同寻址方式演示</p>
<h2 id="8-用于内存寻址的寄存器"><a href="#8-用于内存寻址的寄存器" class="headerlink" title="8 用于内存寻址的寄存器"></a>8 用于内存寻址的寄存器</h2><p><strong>只有bx，bp，si，di可以用在 […] 内对内存单元寻址，一般将bx，bp作为基址，si，di作为变址；</strong></p>
<p>bx以外的通用寄存器和段寄存器不可以用在[…]中</p>
<p><strong>bx、bp区别：bx默认在ds段上，bp默认在ss段上</strong></p>
<h2 id="9-数据在哪里？有多长？"><a href="#9-数据在哪里？有多长？" class="headerlink" title="9 数据在哪里？有多长？"></a>9 数据在哪里？有多长？</h2><p>数据位置的表达：</p>
<ol>
<li>立即数：直接包含在机器指令中的数据idata</li>
<li>寄存器：指令要处理的数据在寄存器中</li>
<li>内存：指令要处理的数据放在内存中，内存地址由段地址和偏移地址组合确定。</li>
</ol>
<p>处理的数据有多长：</p>
<ol>
<li>字word操作：利用整个寄存器，如ax</li>
<li>字节byte操作：寄存器拆开用，如al，ah</li>
<li>没有寄存器参与的内存单元访问指令中，用word ptr或byte ptr显性地指明所要访问的内存单元的长度：如：mov word ptr ds:[0]，1 指明了是字操作，而mov byte ptr ds:[0]，1指明了是字节操作</li>
</ol>
<p>10 寻址方式的综合应用</p>
<h2 id="11-用div指令实现除法"><a href="#11-用div指令实现除法" class="headerlink" title="11 用div指令实现除法"></a>11 用div指令实现除法</h2><p><strong>div是除法指令</strong>，使用div作除法时：</p>
<ul>
<li><p><strong>被除数：默认放在AX或 DX和AX中</strong></p>
</li>
<li><p><strong>除数：8位或16位，在寄存器或内存单元中</strong></p>
</li>
<li><table>
<thead>
<tr>
<th>被除数</th>
<th>AX</th>
<th>DX和AX</th>
</tr>
</thead>
<tbody><tr>
<td>除数</td>
<td><strong>8位</strong>内存&#x2F;寄存器</td>
<td><strong>16位</strong>内存&#x2F;寄存器</td>
</tr>
<tr>
<td>商</td>
<td><strong>AL</strong></td>
<td><strong>AX</strong></td>
</tr>
<tr>
<td>余数</td>
<td><strong>AH</strong></td>
<td><strong>DX</strong></td>
</tr>
</tbody></table>
</li>
</ul>
<p>div指令格式：div 寄存器&#x2F;内存单元</p>
<p><strong>切记：提前在默认寄存器中设置好被除数，且默认寄存器不作其他用途。</strong></p>
<p>示例：</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>被除数</th>
<th>除数</th>
<th>商</th>
<th>余数</th>
</tr>
</thead>
<tbody><tr>
<td>div bl</td>
<td>(ax)</td>
<td>(bl)</td>
<td>(al)</td>
<td>(ah)</td>
</tr>
<tr>
<td>div byte ptr ds:[0]</td>
<td>(ax)</td>
<td>((ds)*16+0)</td>
<td>(al)</td>
<td>(ah)</td>
</tr>
<tr>
<td>div bx</td>
<td>(dx)*10000H+(ax)</td>
<td>(bx)</td>
<td>(ax)</td>
<td>(dx)</td>
</tr>
<tr>
<td>div word ptr es:[0]</td>
<td>(dx)*10000H+(ax)</td>
<td>((ds)*16+0)</td>
<td>(ax)</td>
<td>(dx)</td>
</tr>
</tbody></table>
<p>例子：利用除法指令计算 1000001&#x2F;100</p>
<p>分析：1000001D&#x3D;186A1H，需要进行16位的除法，所以用ax和dx联合存放186A1H，用bx存放除数 100D&#x3D;64H。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">	dd 1000001</span><br><span class="line">	dw 100</span><br><span class="line">	dw 0</span><br><span class="line">date ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">	mov ax,data</span><br><span class="line">	mov ds,ax</span><br><span class="line">	mov ax,ds:[0]</span><br><span class="line">	mov dx,ds:[2]</span><br><span class="line">	div word prt ds:[4]</span><br><span class="line">	mov ds:[6],ax	</span><br><span class="line">code ends</span><br></pre></td></tr></table></figure>



<h2 id="12-用dup-复制-设置内存空间"><a href="#12-用dup-复制-设置内存空间" class="headerlink" title="12 用dup(复制)设置内存空间"></a>12 用dup(复制)设置内存空间</h2><p>duplication(复制)</p>
<p><strong>功能：dup和db，dw，dd等数据定义伪指令配合，用于进行数据的重复</strong></p>
<p>如：</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>功能</th>
<th>相当于</th>
</tr>
</thead>
<tbody><tr>
<td>bd 3 dup (0)</td>
<td>定义3个字节，值都为0</td>
<td>db 0,0,0</td>
</tr>
<tr>
<td>bd 3 dup (‘abc’,’ABC’)</td>
<td>定义了18个字节，有’abcABC’重复3次</td>
<td>db ‘abcABCabcABCabcABC’</td>
</tr>
</tbody></table>
<p>定义一个容量为200个字节的栈段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stack segment</span><br><span class="line">	db 200 dup (0)</span><br><span class="line">stack ends</span><br></pre></td></tr></table></figure>







<h1 id="四、流程转移与子程序"><a href="#四、流程转移与子程序" class="headerlink" title="四、流程转移与子程序"></a>四、流程转移与子程序</h1><h2 id="1-”转移“概述"><a href="#1-”转移“概述" class="headerlink" title="1 ”转移“概述"></a>1 ”转移“概述</h2><p> 一般情况下指令是顺序地逐条执行的，而在实际中，常需要改变程序的执行流程。</p>
<p>转移指令：</p>
<ul>
<li>可以控制CPU执行内存中某处代码的指令</li>
<li>可以修改IP，或同时修改CS和IP的指令</li>
</ul>
<p>转移指令的分类：</p>
<ul>
<li>按转移行为<ul>
<li><strong>段内转移：只修改IP</strong>，如jmp ax</li>
<li><strong>段间转移：同时修改CS和IP</strong>，如jmp 1000:0</li>
</ul>
</li>
<li>根据指令对IP修改的范围不同：<ul>
<li>段内短转移：IP修改范围为-128~127</li>
<li><strong>段内近转移</strong>：IP修改范围为-32768~32767</li>
</ul>
</li>
<li>按转移指令<ul>
<li>无条件转移指令，如jmp</li>
<li>条件转移指令，如jcxz</li>
<li>循环指令，如loop</li>
<li>过程调用</li>
<li>中断</li>
</ul>
</li>
</ul>
<h2 id="2-操作符offset"><a href="#2-操作符offset" class="headerlink" title="2 操作符offset"></a>2 操作符offset</h2><p>用<strong>offset可以取得标号的偏移地址</strong></p>
<p>格式：offset 标号</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codeseg</span><br><span class="line">codeseg segment</span><br><span class="line">	start:</span><br><span class="line">	mov ax,offset start	#相当于mov ax,0</span><br><span class="line">	s:</span><br><span class="line">	mov ax,offset s	#相当于mov ax,3</span><br><span class="line">codeseg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>例：使程序在运行时将s处的一条指令复制到s0处</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">assume sc:codeseg</span><br><span class="line">codeseg segment</span><br><span class="line">	s:mov ax,bx</span><br><span class="line">	mov si,offset s	#获得s处的地址</span><br><span class="line">	mov di,offset s0 #获得s0处的地址</span><br><span class="line">	mov ax,cs:[si]	</span><br><span class="line">	mov cs:[di],ax	#将s处的数据放入s0</span><br><span class="line">	s0:nop	#nop的机器码占一个字节，起”占位“作用</span><br><span class="line">codeseg ends</span><br><span class="line">ends</span><br></pre></td></tr></table></figure>



<h2 id="3-jmp指令"><a href="#3-jmp指令" class="headerlink" title="3 jmp指令"></a>3 jmp指令</h2><p>功能：<strong>无条件转移</strong>，可以只修改IP，也可以同时修改CS和IP</p>
<p>使用jmp要给出两种信息：</p>
<ul>
<li>转移的<strong>目的地址</strong>；</li>
<li>转移的<strong>距离</strong>：<ul>
<li><strong>段间转移（远转移）</strong>：<strong>jmp far ptr 标号</strong></li>
<li>段内<strong>短转移：jmp short 标号</strong>；IP的修改范围为-128~127，8位的位移</li>
<li>段内<strong>近转移：jmp near ptr 标号</strong>；IP的修改范围为-32768~32767，16位的位移</li>
</ul>
</li>
</ul>
<p>两种段内转移</p>
<ul>
<li><p><strong>短转移：jmp short 标号</strong></p>
<p>功能：(IP)&#x3D;(ip)+8位位移</p>
<p>原理：</p>
<ol>
<li>8位位移&#x3D;标号处的地址 — jmp指令后的第一个字节的地址；</li>
<li>short指明此处的位移为8位位移；</li>
<li>8位位移的范围为-128~127，用补码表示；</li>
<li>8位<strong>位移由编译器在编译时算出</strong>。</li>
</ol>
</li>
<li><p><strong>近转移：jmp near ptr 标号</strong></p>
<p>功能：(IP)&#x3D;(ip)+<strong>16位位移（相对于当前IP的转移位移）</strong></p>
<p>原理：</p>
<ol>
<li>16位位移&#x3D;标号处的地址 — jmp指令后的第一个字节的地址；</li>
<li><strong>near ptr指明此处的位移为16位位移；</strong></li>
<li>16位位移的范围为-32768~32767，用补码表示；</li>
<li>16位位移由编译器在编译时算出。</li>
</ol>
</li>
</ul>
<p><strong>远转移：jmp far ptr 标号；</strong></p>
<ul>
<li><strong>far ptr指明了跳转到的目的地址，即包含了标号的段地址CS和偏移地址IP</strong></li>
</ul>
<hr>
<p>转移地址放在<strong>寄存器中</strong>的jmp指令</p>
<p>格式：<strong>jmp 16位寄存器</strong></p>
<p>功能：IP &#x3D; (16位寄存器)    如：jmp bx</p>
<hr>
<p>转移地址在<strong>内存中</strong>的jmp地址</p>
<p>段内转移</p>
<ul>
<li><p><strong>jmp word ptr 内存单元地址</strong></p>
</li>
<li><p>功能：从内存单元地址处开始存放的<strong>一个字</strong>，作为转移的目的的<strong>偏移地址</strong></p>
</li>
<li><p>&#96;&#96;&#96;assembly<br>mov ax,0123H<br>mov ds:[0],ax<br>jmp word ptr ds:[0]  #执行后，(IP)&#x3D;0123H</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">段间转移</span><br><span class="line"></span><br><span class="line">* **jmp dword ptr 内存单元地址**</span><br><span class="line"></span><br><span class="line">* 功能：从内存单元地址开始处的**两个字**，**高地址的字**作为转移的目的**段地址**，**低地址**处是转移的目的**偏移地址**</span><br><span class="line"></span><br><span class="line">* ```assembly</span><br><span class="line">  mov ax,0123H</span><br><span class="line">  mov ds:[0],ax</span><br><span class="line">  mov word ptr ds:[2],0</span><br><span class="line">  jmp dword ptr ds:[0]   #执行后，(CS)=0,(IP)=0123H，CS:IP指向0000:0123</span><br><span class="line">  </span><br><span class="line">  mov ax,0123H</span><br><span class="line">  mov bx,ax</span><br><span class="line">  mov word ptr [bx+2],0</span><br><span class="line">  jmp dword ptr [bx]  #执行后，(CS)=0,(IP)=0123H，CS:IP指向0000:0123</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<table>
<thead>
<tr>
<th>jmp指令格式</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>jmp 标号</td>
<td>—段间转移（远转移）：jmp far ptr 标号                                                                                        —段内短转移：jmp short 标号（8位的位移）                                                                                            —段内近转移：jmp near ptr 标号；16位的位移</td>
</tr>
<tr>
<td>jmp 寄存器</td>
<td>—jmp bx；16位的位移</td>
</tr>
<tr>
<td>jmp 内存单元(表示跳转到的地址)</td>
<td>—段内转移：jmp word ptr 内存单元地址；jmp word ptr [bx]      —段间转移：jmp dword ptr 内存单元地址；jmp dword ptr [bx]</td>
</tr>
</tbody></table>
<p>在源程序中，不能使用 jmp 2000:0100 的转移指令进行跳转，这是在Debug中使用的汇编指令，而编译器并不认识，会报错。</p>
<h2 id="4-其他转移指令"><a href="#4-其他转移指令" class="headerlink" title="4 其他转移指令"></a>4 其他转移指令</h2><p>所有的<strong>有条件转移都是短转移</strong>，对IP的修改范围都为-128~127。</p>
<p>位移：是指”相对“转移，好处是：无论s处的指令的实际地址是多少，loop等指令转移的相对位移都是不变的。这样，方便了程序段在内存中的浮动装配。</p>
<p> jcxz指令</p>
<ul>
<li><p>格式：<strong>jcxz 标号</strong>（条件转移）</p>
<p>功能：如果**(cx)&#x3D;0，则转移到标号处执行**；当(cx) !&#x3D; 0时，什么也不做（程序向下执行）</p>
</li>
</ul>
<p>loop指令</p>
<ul>
<li><p>格式：<strong>loop 标号</strong>（条件转移）</p>
<p>功能：(cx) &#x3D; (cx) - 1; 当**(cx) !&#x3D; 0时，则转移到标号处执行**，当(cx) &#x3D; 0时，程序向下执行（cx的值先减1，再判断）</p>
</li>
</ul>
<h2 id="5-call指令和ret指令"><a href="#5-call指令和ret指令" class="headerlink" title="5 call指令和ret指令"></a>5 call指令和ret指令</h2><p>模块化程序设计：调用子程序——call指令；返回——ret指令</p>
<p>实质：流程转移指令，都修改IP，或同时修改CS:IP</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0</span><br><span class="line">call s		#调用子程序</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">s:add ax,1</span><br><span class="line">ret		#返回</span><br></pre></td></tr></table></figure>

<p>call指令</p>
<ul>
<li><p>格式：</p>
<ol>
<li><strong>call 标号（段内转移）</strong>，</li>
<li><strong>call far ptr 标号（段间转移）</strong>，</li>
<li><strong>call 16位寄存器</strong>（转移地址放在寄存器中，段内转移），</li>
<li><strong>call word ptr 内存单元地址（单字，段内转移）；call dword ptr 内存单元地址（双字，段间转移）</strong></li>
</ol>
</li>
<li><p>CPU执行call指令，进行两步操作：</p>
<p>将当前的IP或CS和IP压入栈中；转移到标号处执行指令。</p>
</li>
</ul>
<p>ret，retf指令</p>
<ul>
<li>ret指令：<ul>
<li>功能：用栈中的数据，修改IP的内容，从而实现近转移；</li>
<li>相当pop IP</li>
</ul>
</li>
<li>retf指令( f 意思是far）：<ul>
<li>用栈中的数据，修改CS和IP的内容，从而实现远转移</li>
<li>相当于 pop IP, pop CS</li>
</ul>
</li>
</ul>
<h2 id="6-mul指令"><a href="#6-mul指令" class="headerlink" title="6 mul指令"></a>6 mul指令</h2><p>mul指令用于做乘法运算</p>
<p>格式：mul 寄存器  或者   mul 内存单元</p>
<table>
<thead>
<tr>
<th></th>
<th>8位乘法</th>
<th>16位乘法</th>
</tr>
</thead>
<tbody><tr>
<td>被除数(默认)</td>
<td>AL</td>
<td>AX</td>
</tr>
<tr>
<td>乘法</td>
<td>8位寄存器或内存字节单元</td>
<td>16位寄存器或内存字节单元</td>
</tr>
<tr>
<td>结果</td>
<td>AX</td>
<td>DX(高位)，AX(低位)</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov al,100	#被除数先放到默认寄存器al中</span><br><span class="line">mov bl,10</span><br><span class="line">mul bl  #结果：(ax)=1000</span><br><span class="line"></span><br><span class="line">mov ax,100	#被除数先放到默认寄存器ax中</span><br><span class="line">mov bx,10000</span><br><span class="line">mul bx   #结果：(dx)=000FH,(ax)=4240H</span><br></pre></td></tr></table></figure>



<h2 id="7-汇编语言的模块化程序设计"><a href="#7-汇编语言的模块化程序设计" class="headerlink" title="7 汇编语言的模块化程序设计"></a>7 汇编语言的模块化程序设计</h2><p><strong>模块之间的参数和结果的传递</strong>：1. 用<strong>寄存器</strong>传递参数；2. 用<strong>内存单元</strong>进行参数传递；3. 用<strong>栈</strong>传递参数</p>
<p>用寄存器来存储参数和结果：最常用，但寄存器有限，所以参数不能太多；</p>
<p>用内存单元批量传递数据：将批量数据放在内存中，然后将它们所在内存空间的首地址放在寄存器中，传递给所需的子程序；对于具有批量数据的返回结果，也可以用同样的方法。</p>
<p>用栈传递参数：由调用者将需要传递给子程序的参数压入栈中，子程序从栈中取得参数。</p>
<h2 id="8-寄存器冲突问题"><a href="#8-寄存器冲突问题" class="headerlink" title="8 寄存器冲突问题"></a>8 寄存器冲突问题</h2><p> 在调用的子程序中，如果用到了调用者已经在用的寄存器，可能会会使运行结果错误甚至程序崩溃。</p>
<p>为了不影响调用者在使用的寄存器的值，同时为了避免在编写程序时需时刻注意寄存器的使用这种麻烦情况，因此，制定了<strong>子程序的标准框架</strong>：</p>
<ul>
<li><strong>子程序开始时，将子程序会使用到的寄存器入栈</strong></li>
<li>子程序内容</li>
<li><strong>子程序使用的寄存器出栈（恢复寄存器中的数据）</strong></li>
<li>返回（ret，retf）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">capital:</span><br><span class="line">	push cx		#假设用到了cx和si</span><br><span class="line">	push si</span><br><span class="line">	#子程序内容</span><br><span class="line">	pop si</span><br><span class="line">	pop cx</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>



<h2 id="9-标志寄存器"><a href="#9-标志寄存器" class="headerlink" title="9 标志寄存器"></a>9 标志寄存器</h2><p>结构：</p>
<ul>
<li>flag寄存器是<strong>按 位 起作用的</strong>，也就是说，它的每一位都有专门的含义，记录特定的信息。</li>
<li>8086CPU的16位flag寄存器没有使用1,3,5,12,13,14,15，这些位不具有任何含义</li>
</ul>
<p>作用：</p>
<ul>
<li>用来存储相关指令的某些执行结果（溢出，进位，是否为0…）</li>
<li>用来为CPU执行相关指令提供行为依据（如传送数据的方向…）</li>
<li>用来控制CPU的相关工作方式</li>
</ul>
<p>flag寄存器的值：</p>
<table>
<thead>
<tr>
<th>15</th>
<th>14</th>
<th>13</th>
<th>12</th>
<th>11</th>
<th>10</th>
<th>9</th>
<th>8</th>
<th>7</th>
<th>6</th>
<th>5</th>
<th>4</th>
<th>3</th>
<th>2</th>
<th>1</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td>OF</td>
<td>DF</td>
<td>IF</td>
<td>TF</td>
<td>SF</td>
<td>ZF</td>
<td></td>
<td>AF</td>
<td></td>
<td>PF</td>
<td></td>
<td>CF</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>标志</th>
<th>值为1</th>
<th>值为0</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>OF (Overflow)</td>
<td>OV</td>
<td>NV</td>
<td>溢出</td>
</tr>
<tr>
<td>DF (Direction)</td>
<td>DN</td>
<td>UP</td>
<td>方向</td>
</tr>
<tr>
<td>SF (Sign)</td>
<td>NG</td>
<td>PL</td>
<td>符号</td>
</tr>
<tr>
<td>ZF (Zero)</td>
<td>ZR</td>
<td>NZ</td>
<td>零值</td>
</tr>
<tr>
<td>PF (parity)</td>
<td>PE</td>
<td>PO</td>
<td>奇偶</td>
</tr>
<tr>
<td>CF (Carry)</td>
<td>CY</td>
<td>NC</td>
<td>进位</td>
</tr>
</tbody></table>
<p>直接访问标志寄存器的方法：</p>
<ul>
<li>pushf：将标志寄存器的值压栈。</li>
<li>popf：从栈中弹出数据，送入标志寄存器中。</li>
</ul>
<p>指令影响：</p>
<ul>
<li>在8086CPU的指令集中，有的指令的执行是影响标志寄存器的，如：add，sub，mul，div，inc，or，and等，大都是运算指令，逻辑指令</li>
<li>有的指令的执行对标志寄存器没有影响，如：mov，push，pop等，大都是传送指令。</li>
</ul>
<hr>
<ul>
<li><p><strong>ZF—零标志</strong>（Zero Flag）</p>
<p>ZF&#x3D;<strong>1</strong>，表示 逻辑<strong>真</strong>；ZF&#x3D;<strong>0</strong>，表示逻辑<strong>假</strong></p>
</li>
<li><p><strong>PF—奇偶</strong>标志（Parity Flag）</p>
<p>PF记录指令执行后，结果的所有二进制位中<strong>1的个数</strong>；</p>
<p>1的个数为<strong>偶数</strong>，PF &#x3D; <strong>1</strong></p>
<p>1的个数为<strong>奇数</strong>，PF &#x3D; <strong>0</strong></p>
</li>
<li><p><strong>SF—符号标志</strong>（Sign Flag）</p>
<p>结果为<strong>负</strong>：SF &#x3D; <strong>1</strong></p>
<p>结果为<strong>非负</strong>：SF &#x3D; <strong>0</strong></p>
<p>（将数据当作有符号数来运算时，通过SF可知结果的正负；将数据当作无符号数来运算时，SF的值则没有意义，虽然相关的指令会影响它的值）</p>
</li>
<li><p><strong>CF—进位标志</strong>（Carry Flag）</p>
</li>
</ul>
<p>  在进行无符号数的运算时，CF记录了运算结果的 最高有效位 向更高位（这个更高位是假象的）的进位值。</p>
<p>  <strong>有进位或借位</strong>，CF &#x3D; <strong>1</strong></p>
<p>  <strong>无进位或借位</strong>，CF &#x3D; <strong>0</strong></p>
<ul>
<li><p><strong>OF—溢出标志</strong>（Overflow Flag）</p>
<p>在进行有符号数运算时，如果结果超过了机器所能表示的范围，称为溢出。</p>
<p><strong>有溢出</strong>，OF &#x3D; <strong>1</strong></p>
<p><strong>无溢出</strong>，OF &#x3D; <strong>0</strong></p>
</li>
</ul>
<h2 id="10-带进位的加减法"><a href="#10-带进位的加减法" class="headerlink" title="10 带进位的加减法"></a>10 带进位的加减法</h2><p><strong>adc—带进位加法指令</strong>，利用了CF位上记录的进位值。</p>
<p>格式：<strong>adc 操作对象1，操作对象2</strong></p>
<p>功能：<strong>操作对象1 &#x3D; 操作对象1 + 操作对象2 + CF值</strong></p>
<p>例：adc ax, bx 实现的功能：(ax) &#x3D; (ax) + (bx) + CF</p>
<p>应用：大数相加（先将低16位相加，然后将高16位和进位值相加）</p>
<hr>
<p><strong>sbb—带借位减法指令</strong></p>
<p>格式：<strong>sbb 操作对象1，操作对象2</strong></p>
<p>功能：<strong>操作对象1 &#x3D; 操作对象1 - 操作对象2 - CF值</strong></p>
<p>例：sbb ax, bx  实现的功能：(ax) &#x3D; (ax) - (bx) - CF</p>
<h2 id="11-cmp和条件转移指令"><a href="#11-cmp和条件转移指令" class="headerlink" title="11 cmp和条件转移指令"></a>11 cmp和条件转移指令</h2><p><strong>cmp</strong>指令是<strong>比较指令</strong>，功能<strong>相当于减法指令，只是不保存结果</strong>；cmp指令执行后，会对标志寄存器产生影响，可以<strong>根据标志寄存器来比较结果</strong>，而不影响原值。</p>
<p>格式： <strong>cmp 操作对象1，操作对象2</strong></p>
<p>功能：计算 操作对象1 - 操作对象2</p>
<hr>
<p><strong>无符号数比较</strong>以及标志位取值</p>
<table>
<thead>
<tr>
<th>比较关系</th>
<th>(ax)-(bx)特点</th>
<th>标志寄存器</th>
</tr>
</thead>
<tbody><tr>
<td>等于</td>
<td>(ax)-(bx) &#x3D; 0</td>
<td>ZF&#x3D;1</td>
</tr>
<tr>
<td>不等于</td>
<td>(ax)-(bx) !&#x3D; 0</td>
<td>ZF&#x3D;0</td>
</tr>
<tr>
<td>小于</td>
<td>(ax)-(bx) 产生借位</td>
<td>CF&#x3D;1</td>
</tr>
<tr>
<td>大于等于</td>
<td>(ax)-(bx) 不必借位</td>
<td>CF&#x3D;0</td>
</tr>
<tr>
<td>大于</td>
<td>(ax)-(bx) 即不借位，结果右不为0</td>
<td>CF&#x3D;0且ZF&#x3D;0</td>
</tr>
<tr>
<td>小于等于</td>
<td>(ax)-(bx) 借位 或者 结果为0</td>
<td>CF&#x3D;1或ZF&#x3D;1</td>
</tr>
</tbody></table>
<p> <strong>有符号数比较</strong>以及标志位取值（仅凭结果正负(SF)无法得出结论，需要配合是否溢出(OF)得到结论）</p>
<table>
<thead>
<tr>
<th>比较关系</th>
<th>(ax)-(bx)特点</th>
<th>标志寄存器</th>
</tr>
</thead>
<tbody><tr>
<td>等于</td>
<td>(ax)-(bx) &#x3D; 0</td>
<td>ZF&#x3D;1</td>
</tr>
<tr>
<td>不等于</td>
<td>(ax)-(bx) !&#x3D; 0</td>
<td>ZF&#x3D;0</td>
</tr>
<tr>
<td>小于</td>
<td>(ax)-(bx) 为负，且不溢出</td>
<td>SF&#x3D;1且OF&#x3D;0</td>
</tr>
<tr>
<td>大于等于</td>
<td>(ax)-(bx) 为负，且溢出</td>
<td>SF&#x3D;1且OF&#x3D;1</td>
</tr>
<tr>
<td>大于</td>
<td>(ax)-(bx) 为非负，且无溢出</td>
<td>SF&#x3D;0且OF&#x3D;0</td>
</tr>
<tr>
<td>小于等于</td>
<td>(ax)-(bx) 为非负，或有溢出</td>
<td>SF&#x3D;0或OF&#x3D;1</td>
</tr>
</tbody></table>
<hr>
<p> <strong>条件转移指令</strong></p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191726641.png" alt="image-20211130203630863"></p>
<h2 id="12-DF标志和串传送指令，rep指令"><a href="#12-DF标志和串传送指令，rep指令" class="headerlink" title="12 DF标志和串传送指令，rep指令"></a>12 DF标志和串传送指令，rep指令</h2><p><strong>DF—方向标志位</strong>（Direction Flag）</p>
<ul>
<li><p>功能：在串处理指令中，控制每次操作后 si，di的增减</p>
<p><strong>DF &#x3D; 0，每次操作后 si，di 递增；</strong></p>
<p><strong>DF &#x3D; 1，每次操作后 si，di 递减；</strong></p>
</li>
<li><p>对DF位进行设置：</p>
<p><strong>cld 指令：将标志寄存器的DF位设为0 （clear）</strong></p>
<p><strong>std 指令：将标志寄存器的DF位设为1 （setup）</strong></p>
</li>
</ul>
<hr>
<p><strong>串传送指令：</strong></p>
<ul>
<li><p>movsb：以<strong>字节</strong>为单位传送</p>
<ul>
<li><p>( (es) * 16 + (di) ) &#x3D; ( (ds) * 16 + (si) )，复制字节</p>
</li>
<li><p>如果DF &#x3D; 0，则 (si) &#x3D; (si) + <strong>1</strong>，(di) &#x3D; (di) + <strong>1</strong></p>
<p>如果DF &#x3D; 1，则 (si) &#x3D; (si) - 1，(di) &#x3D; (di) - 1</p>
</li>
</ul>
</li>
<li><p>movsw：以<strong>字</strong>为单位传送</p>
<ul>
<li><p>( (es) * 16 + (di) ) &#x3D; ( (ds) * 16 + (si) )</p>
</li>
<li><p>如果DF &#x3D; 0，则 (si) &#x3D; (si) + <strong>2</strong>，(di) &#x3D; (di) + <strong>2</strong></p>
<p>如果DF &#x3D; 1，则 (si) &#x3D; (si) - 2，(di) &#x3D; (di) - 2</p>
</li>
</ul>
</li>
</ul>
<p>rep指令：</p>
<ul>
<li><p>功能：根据cx的值，重复执行后面的指令</p>
</li>
<li><p>用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rep movsb</span><br><span class="line">#上下两段代码是等价的</span><br><span class="line">s:movsb</span><br><span class="line">  loop s</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="五、中断及外部设备操作"><a href="#五、中断及外部设备操作" class="headerlink" title="五、中断及外部设备操作"></a>五、中断及外部设备操作</h1><h2 id="直接定址表"><a href="#直接定址表" class="headerlink" title="直接定址表"></a>直接定址表</h2><h3 id="1-移位指令"><a href="#1-移位指令" class="headerlink" title="1 移位指令"></a>1 移位指令</h3><p>其中OPR为操作数，CNT为位移位数</p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191726642.png" alt="image-20211201183648230"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#注意点:移位位数大于1时，必须使用cl</span><br><span class="line">mov al,0101000001b</span><br><span class="line">mov cl,3</span><br><span class="line">shl al,cl   #这里位数如果要写立即数，只能写1，即shl al,1</span><br></pre></td></tr></table></figure>

<p>常用法：<strong>将x逻辑左移一位，相当于x&#x3D;x*2；右移一位，相当于x&#x3D;x&#x2F;2</strong></p>
<h3 id="2-操作显存数据"><a href="#2-操作显存数据" class="headerlink" title="2 操作显存数据"></a>2 操作显存数据</h3><p>显存数据，即屏幕上显示的内容。</p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191726643.png" alt="image-20211201184646183"></p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191726644.png" alt="image-20211201190344885"></p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191726645.png" alt="image-20211201190441592"></p>
<h3 id="3-描述内存单元的标号"><a href="#3-描述内存单元的标号" class="headerlink" title="3 描述内存单元的标号"></a>3 描述内存单元的标号</h3><p>地址标号：仅仅表示地址，标号后要加冒号</p>
<p>数据标号：标记了存储数据的单元的地址和长度。</p>
<p>注意：地址标号只能在代码段中使用，数据标号在代码段，数据段等都可以使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">	a ab 1,2,3,4,5,6	#a为数据标号，标号后面不加冒号</span><br><span class="line">	b bw 0		</span><br><span class="line">start: mov si,0</span><br><span class="line">	mov cx,8</span><br><span class="line">	s:</span><br><span class="line">	mov al,a[si]	#数据标号 可以当作 地址值 用</span><br><span class="line">	mov,ah,0</span><br><span class="line">	add b,ax	</span><br><span class="line">	inc si</span><br><span class="line">	loop s</span><br><span class="line">	....</span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line">#b代表地址为code:8,长度为字的内存单元</span><br><span class="line">#mov ax,b 相当于 mov ax,cx:[8]</span><br><span class="line">#mov b,2  相当于 mov word ptr cs:[8],2</span><br><span class="line">#inc b    相当于 inc word ptr cs:[8]</span><br><span class="line">#mov al,b (error!)</span><br></pre></td></tr></table></figure>



<h3 id="4-数据的直接定址表"><a href="#4-数据的直接定址表" class="headerlink" title="4 数据的直接定址表"></a>4 数据的直接定址表</h3><p>利用表，在两个数据集合之间建立一种映射关系，用查表的方法根据给出的数据得到另一集合中的对应数据。</p>
<p>例：计算sin(x)的值（x为有限个度数值），而计算过程需要多个乘除运算，代价颇高，所以可以考虑使用映射表。</p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191726646.png" alt="image-20211201200817089"></p>
<p>5 代码的直接定址表</p>
<p>通过查表的方式，通过依据数据，直接计算出所要找的元素的位置。</p>
<p>如：要实现一个子程序，它提供四种功能，利用定址表的方案：将<strong>4个功能写成4个子程序，将这些功能子程序的入口地址存到一个表中</strong>，其对应关系：功能号*2&#x3D;对应的功能子程序在地址表中的偏移。这样就方便许多，不用很多分支选择</p>
<h2 id="内中断"><a href="#内中断" class="headerlink" title="内中断"></a>内中断</h2><p>1 中断及其处理</p>
<p>中断：CPU不再接着（刚执行完的指令）向下执行，而是转去处理中断信息。</p>
<p>内中断：由CPU内部发生的事件而引起的中断</p>
<p>外中断：由外部设备发生的事件而引起的中断</p>
<hr>
<p>内中断：</p>
<ul>
<li>除法错误：0（中断码）</li>
<li>单步执行：1</li>
<li>执行into指令：4</li>
<li>执行int n指令：立即数n为中断类型码</li>
</ul>
<hr>
<p>CPU接到中断信息后，会立即执行中断处理程序；</p>
<p>中断处理程序在哪里？中断信息和处理程序的入口地址之间有联系，CPU根据中断信息可查找中断向量表，找到要执行的处理程序。</p>
<p>中断向量表：中断类型码 与 中断处理程序地址入口 的映射表</p>
<hr>
<p>中断过程</p>
<p>中断过程由CPU的硬件自动完成，由中断类型码找到中断向量，并用它设置CS和IP</p>
<p>8086CPU的中断过程：</p>
<ol>
<li>从中断信息中取得中断类型码；</li>
<li>标志寄存器的值入栈：中断过程要改变标志寄存器的值，所以需要先行保护；</li>
<li>设置标志寄存器的第8位TF 和第9位IF的值为 0；</li>
<li>CS的内容入栈，IP的内容入栈（先行保护）</li>
<li>从中断向量表读取处理程序的入口地址，设置IP和CS</li>
</ol>
<p>2 编制中断处理程序</p>
<ul>
<li>CPU随时可能检测到中断信息，所以中断处理程序必须常驻内存中。</li>
<li>中断处理程序的入口地址，即中断向量，必须存储在对应的 中断向量表中（入口地址为IP和CS应该修改的值）。</li>
</ul>
<p>如果是自己编制的中断处理程序，应该放在内存的确定位置，且不破坏系统（向操作系统申请获得存放 程序的内存空间）；</p>
<p>3 单步中断</p>
<p>从Debug中断的t命令，即让CPU能执行一条指令就停下来：</p>
<ul>
<li>Debug利用了CPU提供的单步中断功能；</li>
<li>使用t命令，Debug将TF标志设为1，使CPU工作在单步中断方式下。</li>
</ul>
<p>两个和中断相关的寄存器标志位：</p>
<ul>
<li>TF—陷阱标志（Trap flag）：用于调试时的单步方式操作。<ul>
<li>当TF&#x3D;1时，每条指令执行完后产生陷阱，由系统控制计算机；</li>
<li>当TF&#x3D;0时，CPU正常工作，不产生陷阱。</li>
</ul>
</li>
<li>IF—中断标志（Interrupt flag）：<ul>
<li>当IF&#x3D;1时，允许CPU响应可屏蔽中断请求；</li>
<li>当IF&#x3D;0时，关闭中断。</li>
<li>设置IP的指令：sti，置IF&#x3D;1；cli，置IF&#x3D;0。</li>
</ul>
</li>
</ul>
<p>单步中断过程：</p>
<p>CPU在执行完一条指令后，如果检测到标志寄存器的TF位为1，则产生单步中断（中断类型码为1）：</p>
<ol>
<li><p>取得中断类型码1；</p>
</li>
<li><p>标志寄存器入栈，TF和IF设置为0；</p>
<blockquote>
<p>为什么TF要设置为0？</p>
<p>因为中断处理程序也由一条条指令组成。如果在执行中断处理程序之前，TF&#x3D;1，则CPU在执行完中断处理程序的第一条指令后，又要产生单步中断，转去执行单步中断的中断处理程序的第一条指令….这样会陷入一个死循环，CPU一直在执行单步中断处理程序的第一条指令。所以，在进入中断处理程序前，设置TF为0。</p>
</blockquote>
</li>
<li><p>CS，IP入栈；</p>
</li>
<li><p>设置CS，IP的值，使CPU执行中断处理程序；</p>
</li>
</ol>
<hr>
<p>中断不响应的情况：</p>
<p>一般来说，CPU在执行完当前指令后，如果检测到中断信息，就响应中断，当有些情况下，CPU不会响应中断：</p>
<p>例：在执行完向ss寄存器传送数据的指令后，即使发生中断，CPU也不会响应。</p>
<blockquote>
<p>原因：因为ss:sp是联合指向栈顶，而对它们的设置应该连续完成，依次保证对栈的正确操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#设置ss寄存器后的下一条指令会连续执行，不会单步执行，所以正确操作是将 设置ss和sp寄存器的两条指令放在一起</span><br><span class="line">mov ax,1000</span><br><span class="line">mov ss,ax</span><br><span class="line">....		#不要在设置ss和sp的指令中将插入其他操作</span><br><span class="line">mov sp,10</span><br></pre></td></tr></table></figure>
</blockquote>
<p>4 由int指令引发的中断</p>
<p>格式：int n （n为中断类型码）</p>
<p>功能：引发特定中断过程。int指令的功能和call指令相似，都是调用一段程序，一般来说，系统将一些具有一定功能的子程序，以中断处理程序的方式提供给应用程序调用。</p>
<p>应用：因为int指令可以调用子程序（中断处理程序&#x2F;中断例程），所以可以自定义中断例程，由int调用，实现特定功能。</p>
<p>5 BIOS和DOS中断处理</p>
<p>BIOS和DOS在所提供的中断例程中包含了许多编程时可以用到的功能子程序。</p>
<p>BIOS——基本输入输出系统，存放在系统板的ROM中。</p>
<p>BIOS功能：</p>
<ul>
<li>硬件系统的检测和初始化程序；</li>
<li>外部中断和内部中断的中断例程；</li>
<li>用于对硬件设备进行I&#x2F;O操作的中断例程；</li>
<li>其他和硬件系统相关的中断例程。</li>
</ul>
<p>意义：使用BIOS功能调用，程序员就不用了解硬件操作细节，直接使用指令设置参数，并使用BIOS的中断例程，即可完成工作。更方便编程，写处简洁，可读性号，易于移植的程序。</p>
<p>具体的BIOS和DOS中断例程可以查看手册。</p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191726647.png" alt="image-20211202172321228"></p>
<p>DOS中断</p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191726648.png" alt="image-20211202172548837"></p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191726649.png" alt="image-20211202172452826"></p>
<h2 id="端口及外设控制"><a href="#端口及外设控制" class="headerlink" title="端口及外设控制"></a>端口及外设控制</h2><p>1 端口的读写</p>
<p>CPU可以直接读写3个地方的数据：CPU内寄存器，内存单元，端口。（端口指各种接口卡，网卡，显卡，主板的接口芯片等等）</p>
<p>端口的地址：各种芯片工作时，芯片上的一些寄存器由CPU读写，即CPU将这些寄存器当作端口并统一编址。</p>
<p>指令格式：in：CPU从端口读取数据；out：CPU往端口写入数据</p>
<p>端口的读写：</p>
<blockquote>
<p>例 ：in al，60h   从60h号端口读入一个字节</p>
<p>执行时相关的操作：</p>
<ol>
<li>CPU通过地址线将地址信息60h发出；</li>
<li>CPU通过控制线发出端口读命令，选中端口所在的芯片，并通知要从中读取数据；</li>
<li>端口所在的芯片将60H对应端口中的数据通过数据总线送入CPU</li>
</ol>
</blockquote>
<p>端口读写规定：</p>
<ul>
<li>对0~255以内的端口进行读写，端口号用立即数给出</li>
<li>对256~65535的端口进行读写，端口号放在dx中</li>
<li>在in和out指令中，只能使用ax或al来存放从端口中读入的数或要发送到端口中的数据：访问8位端口上时用al，访问16位端口时用ax。</li>
</ul>
<p>2 操作CMOS RAM芯片</p>
<p>CMOS RAM芯片：包含一个实时时钟和一个128个存储单元的RAM存储器。</p>
<ul>
<li>128个字节的RAM存储器包含：内部实时钟，系统配置信息，相关的程序（用于开机时配置系统信息）</li>
<li>CMOS RAM芯片靠电池供电，关机后其内部的实时钟仍可正常工作，RAM中的信息不丢失。</li>
<li>芯片内部有两个端口，端口地址为70h和71h，CPU通过这两个读写CMOS RAM。<ul>
<li>70h地址端口：存放要访问的CMOS RAM单元的地址；</li>
<li>71h数据端口：存放从选定的单元中读取的数据，或要写入到其中的数据。</li>
</ul>
</li>
</ul>
<p>读取CMOS RAM：将要读取的单元地址送入70h地址端口，再从71h数据端口读出指定单元的内容。</p>
<p>3 外设连接与中断</p>
<p>CPU在执行指令过程中，可以检测到端口(外设)发送过来的中断信息，引发中断过程，处理外设的输入。</p>
<p>外中断：由外部设备发生的事件引起的中断。</p>
<p>可屏蔽中断：</p>
<ul>
<li>可屏蔽中断是CPU可以不响应的外中断。</li>
<li>CPU是否响应可屏蔽中断，要看标志寄存器的IF位：IF&#x3D;1时，执行完当前指令后引发中断过程；IF&#x3D;0时，不响应中断。</li>
<li>几乎所有由外设引发的外中断，都是可屏蔽中断。</li>
</ul>
<p>不可屏蔽中断：</p>
<ul>
<li>不可屏蔽中断是CPU必须响应的外中断。</li>
<li>8086CPU不可屏蔽中断的中断类型码固定为2。</li>
<li>不可屏蔽中断在 系统中有必须畜栏里的经济情况发生时 用来通知CPU的中断信息，如：突然掉电时，进行保护性工作。</li>
</ul>
<p>9 磁盘读写</p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191726650.png" alt="image-20211202195502858"></p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191726651.png" alt="image-20211202195721926"></p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191726652.png" alt="image-20211202195822939"></p>
<h1 id="六、高级汇编语言技术"><a href="#六、高级汇编语言技术" class="headerlink" title="六、高级汇编语言技术"></a>六、高级汇编语言技术</h1><h2 id="8086拓展"><a href="#8086拓展" class="headerlink" title="8086拓展"></a>8086拓展</h2><p>子程序的<strong>可读性更好的写法</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#相当于高级语言中对子程序的包装：&#123; &#125;</span><br><span class="line">名称 proc</span><br><span class="line">	.... #内容</span><br><span class="line">	(ret)</span><br><span class="line">名称 endp</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>程序的多文件组织</strong>：</p>
<p>可以将程序放到不同地方，再进行连接编译，调用者需要声明调用了其他程序，被调用程序需要声明为共有的；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#调用者</span><br><span class="line">extrn 被调用程序的名称:far  #神明有子程序来自外部</span><br><span class="line">程序....</span><br><span class="line"></span><br><span class="line">#被调用者</span><br><span class="line">public 被调用程序的名称    #声明为共有的，允许外部调用</span><br><span class="line">子程序....</span><br></pre></td></tr></table></figure>



<h2 id="8086总结"><a href="#8086总结" class="headerlink" title="8086总结"></a>8086总结</h2><h3 id="一些名词缩写"><a href="#一些名词缩写" class="headerlink" title="一些名词缩写"></a>一些名词缩写</h3><blockquote>
<p>reg：寄存器</p>
<p>src：标号</p>
<p>opr：操作数</p>
<p>flags：标志寄存器</p>
</blockquote>
<h3 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h3><h4 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h4><ul>
<li><p>通用数据传送指令：mov，push，pop，xchg</p>
<blockquote>
<p>xchg是交换指令：xchg  操作数1 操作数2 ——将两个操作数作交换</p>
<p>注：不影响标志位，不允许使用段寄存器</p>
</blockquote>
</li>
<li><p>累加器专用传送指令：in，out，xlat</p>
<blockquote>
<ul>
<li><p>in，out是用于端口读写的指令</p>
</li>
<li><p>xlat是换码指令：xlat 或者 xlat 操作数</p>
<p>执行的操作是： (al) &lt;— ( (bx) + (al) )</p>
<p>用法：bx放一个数据段的首地址，al放偏移量，根据基地址和偏移地址，取出对应位置的数据，放到al里。一开始 al 放偏移量，最后 al 放数据。</p>
<p>注：不影响标志位，只用于字节表格(长度不超过256)，执行指令前需要先把首地址放进bx中，位移量放进al中</p>
</li>
</ul>
</blockquote>
</li>
<li><p>地址传送指令：lea，lds，les</p>
<blockquote>
<ul>
<li><p>lea：有效地址送寄存器指令</p>
<p>lea 寄存器  标号 ，将标号的偏移地址放入寄存器中</p>
</li>
<li><p>lds：指针送寄存器和DS指令</p>
<p>lds 寄存器 标号 ，将代表标号处的4字节地址取出，低2字节放入寄存器，高2字节放入DS中</p>
</li>
<li><p>les：指针送寄存器和ES指令（与lds类似）</p>
</li>
</ul>
</blockquote>
</li>
<li><p>标志寄存器传送指令：lahf，sahf，pushf，popf</p>
<blockquote>
<p>lahf：标志送ah指令（l 指load，ah是ah寄存器，f是标志寄存器），效果：将 标志寄存器的低字节送入ah中。</p>
<p>sahf：ah送标志寄存器指令（s指 send），效果：将ah的内容送入标志寄存器的低字节。</p>
</blockquote>
</li>
<li><p>类型转换指令：cbw，cwd</p>
<blockquote>
<p>c指change，转换的意思，b指byte，w指word(单字)，d是双字</p>
<p>cbw：将一个字节数据转换为字数据—— al —&gt; ax </p>
<p>cwd：将一个字数据转换为双字数据—— ax —&gt; (dx,ax)</p>
<p>注：是无操作数指令，隐含对al或ax进行符号拓展，执行指令前先把数据放入al或ax中，不影响条件标志位</p>
</blockquote>
</li>
</ul>
<h4 id="算术指令"><a href="#算术指令" class="headerlink" title="算术指令"></a>算术指令</h4><ul>
<li><p>加法指令：add，adc，inc</p>
<blockquote>
<p>adc：带进位加法； inc：加1操作</p>
</blockquote>
</li>
<li><p>减法指令：sub，sbb，dec，neg，cmp</p>
<blockquote>
<p>sbb：带借位减法； dec：减1操作；</p>
<p>neg：取负的； cmp：比较大小(用的是减法操作)</p>
</blockquote>
</li>
<li><p>乘法指令：mul，imul</p>
<blockquote>
<p>带 i 表示有符号的</p>
</blockquote>
</li>
<li><p>除法指令：div，idiv</p>
</li>
<li><p>十进制调整指令：daa，das，aaa，aas，aam，aad</p>
<blockquote>
<p>BCD码：用二进制编码的十进制数</p>
<ul>
<li><p>压缩的BCD码：用4位二进制数表示1位十进制数</p>
<p>如： (59)<del>10</del> &#x3D; ( 0101 1001)<del>BCD</del></p>
</li>
<li><p>非压缩的BCD码：用8位二进制数表示1位十进制数</p>
<p>如：(59)<del>10</del> &#x3D; ( 0000 0101   0000 1001)<del>BCD</del></p>
</li>
</ul>
<p>当BCD码进行算术运算时，可能会出现错位，借位等问题，所以需要进行调整。</p>
<ol>
<li>压缩的BCD码调整指令：<ul>
<li>DAA：加法的十进制调整指令</li>
<li>DAS：减法的十进制调整指令</li>
</ul>
</li>
<li>非压缩的BCD码调整指令：<ul>
<li>AAA：加法的ASCII码调整指令</li>
<li>AAS：减法的ASCII码调整指令</li>
<li>AAM：乘法的ASCII码调整指令</li>
<li>AAD：除法的ASCII码调整指令</li>
</ul>
</li>
</ol>
</blockquote>
</li>
</ul>
<h4 id="逻辑指令"><a href="#逻辑指令" class="headerlink" title="逻辑指令"></a>逻辑指令</h4><ul>
<li><p>逻辑运算指令：and，or，not，xor，test</p>
<blockquote>
<p>xor——异或；</p>
<p>test——测试，做 与运算，但不保存结果，只影响标志位；</p>
</blockquote>
</li>
<li><p>移位指令：shl，shr，sal，sar，rol，ror，rcl，rcr</p>
<blockquote>
<p>shl——逻辑左移</p>
<p>shr——逻辑右移</p>
<p>sal——算术左移</p>
<p>sar——算术右移</p>
<p>rol——循环左移</p>
<p>ror——循环右移</p>
<p>rcl——带进位循环左移</p>
<p>rcr——带进位循环右移</p>
</blockquote>
</li>
</ul>
<h4 id="串处理指令"><a href="#串处理指令" class="headerlink" title="串处理指令"></a>串处理指令</h4><ul>
<li>设置方向标志指令：cld，std</li>
<li>串处理指令：movsb&#x2F;movsw，stosb&#x2F;stosw，lodsb&#x2F;lodsw，cmpsb&#x2F;cmpsw，scasb&#x2F;scasw</li>
</ul>
<h4 id="控制转移指令"><a href="#控制转移指令" class="headerlink" title="控制转移指令"></a>控制转移指令</h4><ul>
<li>无条件转移指令：jmp</li>
<li>条件转移指令：jz，je，js，jo，jp，jb，jl，jbe，jle，jcxz</li>
<li>循环指令：loop，loopz，loopnz</li>
<li>子程序调用和返回指令：call，ret</li>
<li>中断与中断返回指令：int，into，iret</li>
</ul>
<p>处理机控制与杂项操作指令</p>
<ul>
<li>标志处理指令：clc，stc，cmc，cld，std，cli，sti</li>
<li>其他：<ul>
<li>nop（无操作，占位1字节）</li>
<li>hlt（暂停机，等待一次外中断，之后继续执行程序）</li>
<li>wait（等待，等待外中断，之后仍继续等待）</li>
<li>esc（换码）</li>
<li>lock（封锁，维持总线的锁存信号，直到其他的指令执行完）</li>
</ul>
</li>
</ul>
<h3 id="伪操作"><a href="#伪操作" class="headerlink" title="伪操作"></a>伪操作</h3><p>汇编指令是指：与机器指令一一对应，在程序运行期间由计算机执行。</p>
<p>伪操作是指：在汇编程序对源程序汇编期间，由汇编程序处理的操作&#x2F;指令（只在汇编期间其作用，伪指令不会产生机器码），可以完成如数据定义，分配存储区，指示程序结束等功能。</p>
<p>处理器选择伪操作，段定义伪操作，程序开始和结束伪操作，数据定义及存储器分配伪操作，表达式赋值伪操作，地址计数器与对准伪操作，基数控制伪操作</p>
<p>（具体的暂略）</p>
<p>操作符</p>
<p>操作符：用于操作数中，通过操作符，将常数，寄存器，标号，变量等，组合成表达式，实现求值的目的（还是将汇编期间进行的）。</p>
<p>算术操作符：+，-，*，&#x2F;，mod</p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191726653.png" alt="image-20211206181250064"></p>
<p>逻辑和移位操作符：and，or，xor，not，shl，shr</p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191726654.png" alt="image-20211206181409612"></p>
<p>关系操作符：eq，nf，lt，le，gt，ge</p>
<p>数值回送操作符：offset，seg，type，length，size</p>
<p>属性操作符：ptr，段操作符，short，this，high，low，highword，lowword</p>
<h3 id="宏汇编"><a href="#宏汇编" class="headerlink" title="宏汇编"></a>宏汇编</h3><p>汇编过程：有两次汇编</p>
<ul>
<li>第一次汇编：确定地址，翻译成各条机器码，字符标号原样写出；</li>
<li>第二次汇编：标号代真，将字符标号用计算出的地址值或偏移量代换。</li>
</ul>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191726655.png" alt="image-20211206184340760"></p>
<p>32位汇编</p>
<p>实用技术</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/04/14/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/" data-id="cl1ynefm40009swtu5sftb296" data-title="汇编语言" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-MySQL" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/Notes/2022/04/14/MySQL/" class="article-date">
  <time class="dt-published" datetime="2022-04-14T06:55:35.236Z" itemprop="datePublished">2022-04-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/Notes/2022/04/14/MySQL/">Mysql</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><p>连接MySQL的指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h 127.0.0.1 -P 3306 -u root -p密码</span><br></pre></td></tr></table></figure>

<p>-p密码不要有空格；</p>
<p>-h 后没有写ip地址，默认就是主机</p>
<p>-P 后没有写端口，默认就是3306</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u 用户名 -p密码  //直接进默认的MySQL？</span><br></pre></td></tr></table></figure>

<p>启动mysql服务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net start mysql</span><br></pre></td></tr></table></figure>

<blockquote>
<p>进入mysql </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p</span><br><span class="line">输入密码 zzc</span><br></pre></td></tr></table></figure>
</blockquote>
<p>快捷键：</p>
<p>注释：shift + ctrl + c ； 注销注释：shift + ctrl + r</p>
<blockquote>
<p>注：</p>
<p>MySQL在&#x3D;&#x3D;Linux下&#x3D;&#x3D;数据库名、表名、列名、别名大小写规则是这样的：</p>
<ul>
<li>&#x3D;&#x3D;数据库名、表名、表的别名、变量名是严格区分大小写的&#x3D;&#x3D;；</li>
<li>关键字、函数名称在 SQL 中不区分大小写； </li>
<li>列名（或字段名）与列的别名（或字段别名）在所有的情况下均是忽略大小写的；</li>
</ul>
<p>MySQL在Windows的环境下全部不区分大小写</p>
</blockquote>
<blockquote>
<p>utf8mb4 能使用1~ 4个字节表示字符，utf8是utf8mb3的别名，能使用1 ~ 3个字节表示字符；</p>
<p>MySQL中有4个级别的字符集和计较规则：</p>
<ul>
<li>服务器级别 </li>
<li>数据库级别 </li>
<li>表级别 </li>
<li>列级别</li>
</ul>
<p>执行如下SQL语句： </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;character%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>会得到一些信息：</p>
<p>character_set_server：服务器级别的字符集<br>character_set_database：当前数据库的字符集<br>character_set_client：服务器解码请求时使用的字符集<br>character_set_connection：服务器处理请求时会把请求字符串从character_set_client转为character_set_connection<br>character_set_results：服务器向客户端返回数据时使用的字符集</p>
</blockquote>
<h1 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h1><p>创建与删除</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#删除数据库指令	</span><br><span class="line"><span class="keyword">DROP</span> DATABASE 数据库名</span><br><span class="line"><span class="keyword">DROP</span> DATABASE IF <span class="keyword">EXISTS</span> 数据库名 <span class="comment">-- 推荐</span></span><br><span class="line">    </span><br><span class="line">#创建数据库指令	</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE 数据库名</span><br><span class="line"># 判断数据库是否已经存在，不存在则创建数据库（推荐）</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> 数据库名;</span><br><span class="line"></span><br><span class="line">#创建一个使用utf8字符集的数据库</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE 数据库名 <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8</span><br><span class="line">#创建一个使用utf8字符集，并带校对规则的数据库 </span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> DATABASE 数据库名 <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_bin</span><br><span class="line">#校对规则 utf8_bin区分大小写，默认utf8_general_ci 不区分大小写</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：DATABASE不能改名，一些可视化工具可以改名，是新建一个库，把所有表复制过去，再删旧库完成。</p>
</blockquote>
<p>查看数据库</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#查看当前数据库服务器中的所有数据库</span><br><span class="line"><span class="keyword">SHOW</span> DATABASES</span><br><span class="line">#查看当前正在使用的数据库，使用的一个mysql的全局函数</span><br><span class="line"><span class="keyword">SELECT</span> DATABASE()</span><br><span class="line"></span><br><span class="line"># 查看指定库下所有的表</span><br><span class="line"><span class="keyword">SHOW</span> TABLES <span class="keyword">FROM</span> 数据库名</span><br><span class="line"></span><br><span class="line">#查看前面创建的zzc_db01数据库的定义信息</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> DATABASE zzc_db01</span><br><span class="line"></span><br><span class="line"># 切换数据库</span><br><span class="line">USE 数据库名</span><br></pre></td></tr></table></figure>

<p>修改数据库</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> DATABASE 数据库名 <span class="type">CHARACTER</span> <span class="keyword">SET</span> 字符集</span><br></pre></td></tr></table></figure>

<p>使用反引号</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#在创建数据库，表时，为了规避关键字，可以使用反引号解决,删除的时候也要带反引号</span><br><span class="line">#平时用的时候，带反引号更安全</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE `<span class="keyword">CREATE</span>`</span><br></pre></td></tr></table></figure>

<p>备份与恢复</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#备份数据库（注意：在DOS执行; 这个备份的文件就是对应的<span class="keyword">sql</span>语句）:</span><br><span class="line">mysqldump <span class="operator">-</span>u 用户名 <span class="operator">-</span>p <span class="operator">-</span>B 数据库<span class="number">1</span> 数据库<span class="number">2</span> 数据库n <span class="operator">&gt;</span> 文件路径名.spl</span><br><span class="line">#备份一个数据库中的若干表 (在DOS下执行)</span><br><span class="line">mysqldump <span class="operator">-</span>u 用户名 <span class="operator">-</span>p 数据库 表<span class="number">1</span> 表<span class="number">2</span> 表n <span class="operator">&gt;</span> 文件路径名.<span class="keyword">sql</span></span><br><span class="line">    </span><br><span class="line">#恢复数据库（注意：进入Mysql命令行再执行）：Source 文件路径名.<span class="keyword">sql</span></span><br><span class="line">source 文件路径名.<span class="keyword">sql</span></span><br><span class="line">#第二个恢复办法：将整个备份文件的内容放到查询编辑器中 执行一遍</span><br></pre></td></tr></table></figure>

<p>数据库CRUD</p>
<p>create，read，update，delete</p>
<hr>
<h1 id="表"><a href="#表" class="headerlink" title="表"></a>表</h1><h2 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h2><blockquote>
<p>DUAL表是一个虚拟的表，很特殊，是建立数据库的时候随数据字典创建而建立的，它是单行单列的一个表，一般称为“哑表、虚表等”，列名DUMMY，类型VARCHAR2(1)，值为’X’，</p>
</blockquote>
<h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><p> creat table 表名</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] 表名</span><br><span class="line">(</span><br><span class="line">	field1 datatype,</span><br><span class="line">	field2 datatype</span><br><span class="line">)<span class="type">CHARACTER</span> <span class="keyword">SET</span> 字符集 <span class="keyword">COLLATE</span> 校对规则 ENGINE 存储引擎</span><br><span class="line">#field : 指定列名	datatype : 指定列类型（字段类型）</span><br><span class="line">#<span class="type">character</span> <span class="keyword">set</span> : 如果没有指定，则默认为所在数据库的字符集</span><br><span class="line">#<span class="keyword">collate</span> : 如果没有指定，则默认为所在数据库的校对规则</span><br><span class="line">#engine : 引擎</span><br><span class="line">#加上了IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>关键字，则表示：如果当前数据库中不存在要创建的数据表，则创建数据表；如果当前数据库中已经存在要创建的数据表，则忽略建表语句，不再创建数据表。</span><br><span class="line"></span><br><span class="line"># 将其他表的查询结果集作为新表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">AS</span> 查询语句</span><br><span class="line"></span><br><span class="line"># 查看表的数据结构</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#示例：</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t2`(</span><br><span class="line">	id <span class="type">INT</span> AUTO_INCREMENT, #自增</span><br><span class="line">	`name` <span class="type">VARCHAR</span>(<span class="number">255</span>),	 #name和password是关键字，要用反引号包起来</span><br><span class="line">	`password` <span class="type">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">	birthday <span class="type">DATE</span></span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id)  #主键</span><br><span class="line">)<span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_bin ENGINE INNODB;	</span><br></pre></td></tr></table></figure>

<blockquote>
<p>创建表——方式2，基于现有的表创建</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">AS</span> 其他表<span class="operator">/</span>结果集</span><br><span class="line"></span><br><span class="line">#例子:</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> myemp</span><br><span class="line"><span class="keyword">AS</span> </span><br><span class="line"><span class="keyword">SELECT</span> employee_id,name,salary <span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<p>mysql8新特性：计算列 </p>
<p>—— 列名 generated always 公式 virtual</p>
<p>可以在create table 和 alter teble中使用</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tb1(</span><br><span class="line">	a <span class="type">INT</span>,</span><br><span class="line">	b <span class="type">INT</span>,</span><br><span class="line">	c <span class="type">INT</span> GENERATED ALWAYS <span class="keyword">AS</span> (a <span class="operator">+</span> b) VIRTUAL	<span class="comment">-- 字段c为计算列</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>


</blockquote>
<h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><p>drop table 表名</p>
<p>drop是删除整个表，包括表的结构，约束，索引等。并释放掉所占的空间。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> 表名</span><br></pre></td></tr></table></figure>

<p>删除表的数据 : delete from 表名</p>
<p>delete不会减少表或索引占用的空间。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> t7 </span><br><span class="line">	<span class="keyword">WHERE</span> `<span class="keyword">day</span>` <span class="operator">=</span> <span class="number">1988</span>		#删除哪一行</span><br><span class="line">#如果没有<span class="keyword">where</span>语句，则删除表中的所有记录，<span class="keyword">delete</span>语句不会删除表本身</span><br><span class="line">#只能删行，不能删列（删列操作时<span class="keyword">alter</span> <span class="keyword">table</span>..drop..）</span><br></pre></td></tr></table></figure>

<p>TRUNCATE TABLE： truncate table语句删除表中所有的数据，重置表的自增值，会保留表结构及其约束，索引等。并使表和索引占用的空间恢复到初始大小。</p>
<h3 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h3><p> **insert table 表名 (可选列名) values (数据)，(数据) **</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t6`(	<span class="comment">--创建表</span></span><br><span class="line">	birthday <span class="type">DATE</span>,</span><br><span class="line">	job_time DATETIME,</span><br><span class="line">	login_time <span class="type">TIMESTAMP</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>		<span class="comment">--自动更新时间戳为登陆时间</span></span><br><span class="line">			     <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span>);</span><br><span class="line">			     </span><br><span class="line">#添加数据：</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `t6`(birthday, job_time)</span><br><span class="line">	<span class="keyword">VALUES</span>(<span class="string">&#x27;2020-11-11&#x27;</span>,<span class="string">&#x27;2022-12-12 12:12:12&#x27;</span>),(....),(...);	<span class="comment">--往表中添加数据,可以一次添加多条数据，字符串类型和日期类应该用单引号包起来</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：如果是将查询结果插入表中，则不必写values：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名 (可选列名) <span class="keyword">SELECT</span> ...</span><br><span class="line">#子查询中的列表应与<span class="keyword">INSERT</span>句中的列名对应</span><br></pre></td></tr></table></figure>


</blockquote>
<h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><p><strong>select , desc</strong> </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">select</span> 查询；<span class="operator">*</span> 表示所有字段，可改为具体的多个列名； <span class="keyword">FROM</span> 从哪个表；<span class="keyword">WHERE</span> 从哪个字段(按条件查询)； </span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `t1` <span class="keyword">WHERE</span> 列名 <span class="operator">=</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">#查询整张表</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `t1`</span><br><span class="line"></span><br><span class="line"># <span class="keyword">distinct</span>用于去重</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> 列名 <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 条件 </span><br><span class="line"></span><br><span class="line">#<span class="keyword">order</span> <span class="keyword">by</span> : 可以指定列名按值升序<span class="keyword">asc</span>或降序<span class="keyword">desc</span>排列</span><br><span class="line">#<span class="keyword">asc</span>：ascending <span class="keyword">order</span> 升序; <span class="keyword">desc</span>：descending <span class="keyword">order</span> 降序</span><br><span class="line"><span class="keyword">SELECT</span> 列名，运算表达式 <span class="keyword">FROM</span> 表m <span class="keyword">ORDER</span> <span class="keyword">BY</span> 列名<span class="operator">/</span>表达式<span class="operator">/</span>别名 <span class="keyword">asc</span><span class="operator">|</span><span class="keyword">desc</span> #没写，默认升序</span><br><span class="line"></span><br><span class="line">#使用表达式对查询的列进行运算，可以用<span class="keyword">as</span>为列名和表达式换上别名，<span class="keyword">as</span>可以省略，直接后接别名</span><br><span class="line"><span class="keyword">SELECT</span> 列名 <span class="keyword">AS</span> 列别名, 运算表达式 <span class="keyword">AS</span> 表达式别名 <span class="keyword">FROM</span> 表名</span><br><span class="line"></span><br><span class="line">#查看表结构，可以看所有列</span><br><span class="line"><span class="keyword">DESC</span> 表名</span><br></pre></td></tr></table></figure>

<p>where子语句中常用的</p>
<ul>
<li><p>比较运算符： <strong>&gt;	&lt;	 &lt;&#x3D;	&gt;&#x3D;	&#x3D;	&lt;&gt; 或 !&#x3D;</strong> (不等于，两种写法)	**between…and…**（显示在某一区间的值）	<strong>in(set)<strong>（显示在int列表中的值，如：in(10,20,30)）	<strong>like ‘赵%’    not like ‘赵%’</strong> （模糊查询：</strong>%匹配0到多个字符，_ 单个下划线匹配单个字符</strong>）	  <strong>is null</strong>（判断是否为空）	</p>
</li>
<li><p>xx  <strong>all</strong> ( … )： all前的xx数据要大于括号内的所有数据，相当于 xx &gt; max ( … )</p>
<p>xx  <strong>any</strong> ( … )： all前的xx数据只要大于括号内的任一数据，相当于 xx &gt; min ( … )</p>
</li>
<li><p>逻辑运算符：<strong>and</strong>（多个条件同时成立）    <strong>or</strong>（多个条件任一成立）     <strong>not</strong>（条件需不成立）</p>
</li>
</ul>
<blockquote>
<p>注意：列的别名不能在where中使用。</p>
<p>因为select语句的执行顺序：</p>
<p>1.from语句<br>2.where语句（结合条件）<br>3.start with语句<br>4.connect by语句<br>6.group byi语句<br>7.having语句<br>8.model语句<br>9.select语句<br>10.union、ninus、intersect等集合演算演算<br>11.order by语句</p>
<p>12.limit语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#查询结构:</span><br><span class="line">方式<span class="number">1</span>：</span><br><span class="line"><span class="keyword">SELECT</span> ...,....,...</span><br><span class="line">	<span class="keyword">FROM</span> ...,...,....</span><br><span class="line">	<span class="keyword">WHERE</span> 多表的连接条件</span><br><span class="line">	<span class="keyword">AND</span> 不包含组函数的过滤条件</span><br><span class="line">	<span class="keyword">GROUP</span> <span class="keyword">BY</span> ...,...</span><br><span class="line">	<span class="keyword">HAVING</span> 包含组函数的过滤条件</span><br><span class="line">	<span class="keyword">ORDER</span> <span class="keyword">BY</span> ... <span class="keyword">ASC</span><span class="operator">/</span><span class="keyword">DESC</span></span><br><span class="line">	LIMIT ...,...</span><br><span class="line">#方式<span class="number">2</span>：</span><br><span class="line"><span class="keyword">SELECT</span> ...,....,...</span><br><span class="line">	<span class="keyword">FROM</span> ... </span><br><span class="line">	<span class="keyword">JOIN</span> ... <span class="keyword">ON</span> 多表的连接条件</span><br><span class="line">	<span class="keyword">JOIN</span> ... <span class="keyword">ON</span> ...</span><br><span class="line">	<span class="keyword">WHERE</span> 不包含组函数的过滤条件</span><br><span class="line">	<span class="keyword">AND</span><span class="operator">/</span><span class="keyword">OR</span> 不包含组函数的过滤条件</span><br><span class="line">	<span class="keyword">GROUP</span> <span class="keyword">BY</span> ...,...</span><br><span class="line">	<span class="keyword">HAVING</span> 包含组函数的过滤条件</span><br><span class="line">	<span class="keyword">ORDER</span> <span class="keyword">BY</span> ... <span class="keyword">ASC</span><span class="operator">/</span><span class="keyword">DESC</span></span><br><span class="line">	LIMIT ...,...</span><br><span class="line">#其中：</span><br><span class="line">#（<span class="number">1</span>）<span class="keyword">from</span>：从哪些表中筛选</span><br><span class="line">#（<span class="number">2</span>）<span class="keyword">on</span>：关联多表查询时，去除笛卡尔积</span><br><span class="line">#（<span class="number">3</span>）<span class="keyword">where</span>：从表中筛选的条件</span><br><span class="line">#（<span class="number">4</span>）<span class="keyword">group</span> <span class="keyword">by</span>：分组依据</span><br><span class="line">#（<span class="number">5</span>）<span class="keyword">having</span>：在统计结果中再次筛选</span><br><span class="line">#（<span class="number">6</span>）<span class="keyword">order</span> <span class="keyword">by</span>：排序</span><br><span class="line">#（<span class="number">7</span>）limit：分页</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203192147883.png" alt="image-20220319214731765"></p>
</blockquote>
<h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">select</span> ... limit <span class="keyword">start</span>, <span class="keyword">rows</span> </span><br><span class="line">#表示从<span class="keyword">start</span><span class="operator">+</span><span class="number">1</span>行开始取，取出<span class="keyword">rows</span>行，<span class="keyword">start</span>从<span class="number">0</span>开始计算</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名</span><br><span class="line">	<span class="keyword">ORDER</span> <span class="keyword">BY</span> 列</span><br><span class="line">	LIMIT <span class="keyword">start</span>, <span class="keyword">rows</span></span><br></pre></td></tr></table></figure>

<p>select语句中如果包含了group by，having，order by，limit：则<strong>书写顺序为group by，having，order by，limit</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2... <span class="keyword">FROM</span> <span class="keyword">table</span> </span><br><span class="line">	<span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">column</span></span><br><span class="line">	<span class="keyword">HAVING</span> <span class="keyword">condition</span></span><br><span class="line">	<span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">column</span></span><br><span class="line">	LIMIT <span class="keyword">start</span>,<span class="keyword">rows</span>;</span><br></pre></td></tr></table></figure>



<h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><p><strong>多表查询</strong>是基于两个或以上的表的查询，查询所规定的条件不能少于表的个数-1，否则会出现笛卡尔集</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ename,sal,dname,emp.deptno</span><br><span class="line">	<span class="keyword">FROM</span> emp, dept	<span class="comment">-- 查询两张表</span></span><br><span class="line">	<span class="keyword">WHERE</span> emp.deptno <span class="operator">=</span> dept.deptno <span class="keyword">AND</span> emp.deptno <span class="operator">=</span> <span class="number">10</span>	<span class="comment">-- 不同表的列有同一名称时，要说明所属：表名.列名</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>表连接的约束条件可以有三种方式：WHERE, ON, USING</p>
</blockquote>
<h4 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h4><p>自连接是指在同一张表的连接查询：将同一张表看作两张表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 给同一张表起不同别名，以达到自连接的目的</span><br><span class="line"><span class="keyword">SELECT</span> worker.ename, boss.ename </span><br><span class="line">	<span class="keyword">FROM</span> emp worker, emp boss  <span class="comment">-- 同一张表起不同的别名</span></span><br><span class="line">	<span class="keyword">WHERE</span> worker.mgr <span class="operator">=</span> boss.empno</span><br><span class="line">#也可使用 <span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line"><span class="keyword">SELECT</span> 字段列表</span><br><span class="line">	<span class="keyword">FROM</span> A表 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> B表</span><br><span class="line">	<span class="keyword">ON</span> 关联条件</span><br><span class="line">	<span class="keyword">WHERE</span> 等其他子句;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h4><p>使用多表查询时，会根据关联条件显示匹配记录，而那些没有匹配到的记录则不会显示，如果在多表查询中至少需要显示表的全部内容，就要用到外连接。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> 表<span class="number">1</span></span><br><span class="line">	<span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 表<span class="number">1</span> 和 表<span class="number">2</span> 的连接条件</span><br><span class="line">	<span class="keyword">JOIN</span> 表<span class="number">3</span> <span class="keyword">ON</span> 表<span class="number">2</span> 和 表<span class="number">3</span> 的连接条件</span><br></pre></td></tr></table></figure>

<p>左外连接：让左侧的表完全显示，即左表为主表；</p>
<p>右外连接：让右侧的表完全显示；即右表为主表；</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#左外连接</span><br><span class="line"><span class="keyword">SELECT</span> ... </span><br><span class="line">	<span class="keyword">FROM</span> 表<span class="number">1</span> <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> 表<span class="number">2</span> </span><br><span class="line">	<span class="keyword">ON</span> 条件</span><br><span class="line">#右外连接	</span><br><span class="line"><span class="keyword">SELECT</span> ... </span><br><span class="line">	<span class="keyword">FROM</span> 表<span class="number">1</span> <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> 表<span class="number">2</span> </span><br><span class="line">	<span class="keyword">ON</span> 条件	</span><br></pre></td></tr></table></figure>

<p>或者使用符号 (+) </p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191935503.png" alt="image-20220319193504406"></p>
<blockquote>
<p>满外连接 FULL JOIN</p>
<p>满外连接的结果 &#x3D; 左右表匹配的数据 + 左表没有匹配到的数据 + 右表没有匹配到的数据。</p>
</blockquote>
<blockquote>
<p>各种关系的实现：</p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191951879.png" alt="image-20220319195143639"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#中图：内连接 A∩B</span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line">	<span class="keyword">FROM</span> employees e <span class="keyword">JOIN</span> departments d</span><br><span class="line">	<span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id`;</span><br><span class="line"></span><br><span class="line">#左上图：左外连接</span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line">	<span class="keyword">FROM</span> employees e <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> departments d</span><br><span class="line">	<span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id`;</span><br><span class="line"></span><br><span class="line">#右上图：右外连接</span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line">	<span class="keyword">FROM</span> employees e <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> departments d</span><br><span class="line">	<span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id`;</span><br><span class="line"></span><br><span class="line">#左中图：A <span class="operator">-</span> A∩B</span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line">	<span class="keyword">FROM</span> employees e <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> departments d</span><br><span class="line">	<span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id`</span><br><span class="line">	<span class="keyword">WHERE</span> d.`department_id` <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br><span class="line"></span><br><span class="line">#右中图：B<span class="operator">-</span>A∩B</span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line">	<span class="keyword">FROM</span> employees e <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> departments d</span><br><span class="line">	<span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id`</span><br><span class="line">	<span class="keyword">WHERE</span> e.`department_id` <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br><span class="line"></span><br><span class="line">#左下图：满外连接</span><br><span class="line"># 左中图 <span class="operator">+</span> 右上图 A∪B</span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line">	<span class="keyword">FROM</span> employees e <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> departments d</span><br><span class="line">	<span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id`</span><br><span class="line">	<span class="keyword">WHERE</span> d.`department_id` <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span> #没有去重操作，效率高</span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line">	<span class="keyword">FROM</span> employees e <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> departments d</span><br><span class="line">	<span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id`;</span><br><span class="line"></span><br><span class="line">#右下图</span><br><span class="line">#左中图 <span class="operator">+</span> 右中图 A ∪B<span class="operator">-</span> A∩B 或者 (A <span class="operator">-</span> A∩B) ∪ （B <span class="operator">-</span> A∩B）</span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line">	<span class="keyword">FROM</span> employees e <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> departments d</span><br><span class="line">	<span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id`</span><br><span class="line">	<span class="keyword">WHERE</span> d.`department_id` <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line">	<span class="keyword">FROM</span> employees e <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> departments d</span><br><span class="line">	<span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id`</span><br><span class="line">	<span class="keyword">WHERE</span> e.`department_id` <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="自然连接"><a href="#自然连接" class="headerlink" title="自然连接"></a>自然连接</h4><p>natural join 用来表示自然连接。我们可以把 自然连接理解为 SQL92 中的等值连接。它会帮你自动查询两张连接表中 所有相同的字段 ，然后进行 等值连接 。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#在SQL92中</span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line">	<span class="keyword">FROM</span> employees e <span class="keyword">JOIN</span> departments d</span><br><span class="line">	<span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id`</span><br><span class="line">	<span class="keyword">AND</span> e.`manager_id` <span class="operator">=</span> d.`manager_id`;</span><br><span class="line">#使用自然连接:</span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line">	<span class="keyword">FROM</span> employees e <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> departments d;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>USING</p>
<p>SQL99还支持使用 USING 指定数据表里的 同名字段 进行等值连接。但是只能配合JOIN一起使用。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line">	<span class="keyword">FROM</span> employees e <span class="keyword">JOIN</span> departments d</span><br><span class="line">	<span class="keyword">USING</span> (department_id);</span><br><span class="line">#等值于</span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line">	<span class="keyword">FROM</span> employees e ,departments d</span><br><span class="line">	<span class="keyword">WHERE</span> e.department_id <span class="operator">=</span> d.department_id;</span><br></pre></td></tr></table></figure>


</blockquote>
<h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><p>子查询是指嵌入其他sql语句中的select语句，也叫嵌套查询</p>
<p>单行子查询：只返回一行数据的子查询语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 单行子查询：只返回一行数据的子查询语句</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line">	<span class="keyword">FROM</span> emp</span><br><span class="line">	<span class="keyword">WHERE</span> deptno <span class="operator">=</span> (   <span class="comment">-- 只返回一行数据</span></span><br><span class="line">		<span class="keyword">SELECT</span> deptno</span><br><span class="line">			<span class="keyword">FROM</span> emp</span><br><span class="line">			<span class="keyword">WHERE</span> ename <span class="operator">=</span> <span class="string">&#x27;SMITH&#x27;</span> )</span><br><span class="line"></span><br><span class="line"># 多行子查询：返回多行数据的子查询语句</span><br><span class="line"><span class="keyword">select</span> ename, job, sal, deptno</span><br><span class="line">	<span class="keyword">from</span> emp</span><br><span class="line">	<span class="keyword">where</span> job <span class="keyword">in</span> (	<span class="comment">-- 返回了多行数据</span></span><br><span class="line">		<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> job</span><br><span class="line">			<span class="keyword">FROM</span> emp</span><br><span class="line">			<span class="keyword">WHERE</span> deptno <span class="operator">=</span> <span class="number">10</span></span><br><span class="line">	) <span class="keyword">and</span> deptno <span class="operator">!=</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>还可以把子查询当作一张临时表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> goods_id, ecs_goods.cat_id, goods_name, shop_price</span><br><span class="line">	<span class="keyword">from</span> (</span><br><span class="line">		<span class="keyword">SELECT</span> cat_id , <span class="built_in">MAX</span>(shop_price) <span class="keyword">as</span> max_price	<span class="comment">-- 子查询结果被当作临时表</span></span><br><span class="line">			<span class="keyword">FROM</span> ecs_goods </span><br><span class="line">        	<span class="keyword">GROUP</span> <span class="keyword">BY</span> cat_id</span><br><span class="line">	) temp , ecs_goods		<span class="comment">-- 其他表</span></span><br><span class="line">	<span class="keyword">where</span> temp.cat_id <span class="operator">=</span> ecs_goods.cat_id <span class="keyword">and</span> temp.max_price <span class="operator">=</span> ecs_goods.shop_priceQ</span><br></pre></td></tr></table></figure>

<blockquote>
<p>空值问题：</p>
<p>如果子查询的表中有NULL值，则使用NOT IN筛选子表时会出现问题：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">	<span class="keyword">WHERE</span> employee_id <span class="keyword">NOT</span> <span class="keyword">IN</span> (</span><br><span class="line">		<span class="keyword">SELECT</span> manager_id</span><br><span class="line">		<span class="keyword">FROM</span> employees</span><br><span class="line">        <span class="comment">-- WHERE manager_id is not  NULL</span></span><br><span class="line">		);</span><br><span class="line"># 结果应该是排除子表筛出来的元素，但因为子表的结果集有<span class="keyword">NULL</span>值，所以最后结果是什么都没筛出来。	</span><br></pre></td></tr></table></figure>


</blockquote>
<h4 id="合并查询"><a href="#合并查询" class="headerlink" title="合并查询"></a>合并查询</h4><p>操作符 union，union all 可以取得两个结果集的并集；</p>
<p>其中 union all 不会去重， union 会去重</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> `name`, id <span class="keyword">FROM</span> table01 <span class="keyword">WHERE</span> id <span class="operator">&gt;</span> <span class="number">2500</span> </span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> `name`, id <span class="keyword">FROM</span> table01 <span class="keyword">WHERE</span> `name`<span class="operator">=</span><span class="string">&#x27;abab&#x27;</span></span><br></pre></td></tr></table></figure>



<h3 id="表复制"><a href="#表复制" class="headerlink" title="表复制"></a>表复制</h3><p>表的复制</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#将表<span class="number">1</span>的数据复制添加到表<span class="number">2</span>，如果两表相同，则相当于自我复制</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表<span class="number">2</span></span><br><span class="line">	<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表<span class="number">1</span></span><br><span class="line">#只复制部分数据：</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表<span class="number">2</span></span><br><span class="line">	(列，列 ...)</span><br><span class="line">	<span class="keyword">SELECT</span> 列，列... <span class="keyword">FROM</span> 表<span class="number">1</span></span><br><span class="line"></span><br><span class="line">#删除表<span class="number">1</span>中的重复记录</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表<span class="number">2</span> <span class="keyword">LIKE</span> 表<span class="number">1</span>	<span class="comment">-- 创建临时表2，于表1有相同的结构</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表<span class="number">2</span> 		</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表<span class="number">1</span>; <span class="comment">-- 将表1的数据复制到表2，同时去重(不重复添加)</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> 表<span class="number">1</span>;	<span class="comment">-- 删除表1的全部数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表<span class="number">1</span> 	</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表<span class="number">2</span>; <span class="comment">-- 将表2去重后的数据复制到表1</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> 表<span class="number">2</span>; <span class="comment">-- 删除临时表</span></span><br></pre></td></tr></table></figure>



<h3 id="修改列属性"><a href="#修改列属性" class="headerlink" title="修改列属性"></a>修改列属性</h3><p><strong>alter table</strong> 表名 <strong>add</strong> 内容 <strong>after</strong> 在哪之后&#x2F; <strong>modify</strong> 列名 属性更改&#x2F; <strong>drop</strong> 列名 &#x2F; <strong>character</strong> 字符集 &#x2F; <strong>change</strong> 旧名 新名 属性更改 ； <strong>rename</strong> 表名</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#添加列</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `t6` 		<span class="comment">--往表t6中添加</span></span><br><span class="line">	<span class="keyword">ADD</span> `name` <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>		<span class="comment">--添加列名：name，类型：VARCHAR，不允许为NULL，默认为&#x27;&#x27;</span></span><br><span class="line">	AFTER birthday				<span class="comment">--在列名birthday之后</span></span><br><span class="line">#修改列（的属性）</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `t6`</span><br><span class="line">	MODIFY `name` <span class="type">VARCHAR</span>(<span class="number">60</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>		<span class="comment">--修改name</span></span><br><span class="line">#删除列</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `t6`</span><br><span class="line">	<span class="keyword">DROP</span> `name`		<span class="comment">--删去name	</span></span><br><span class="line">#修改表名</span><br><span class="line">RENAME <span class="keyword">TABLE</span> t6 <span class="keyword">TO</span> t7			<span class="comment">--表明t6改为t7</span></span><br><span class="line">#修改表的字符集为utf8</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> t7 </span><br><span class="line">	<span class="type">CHARACTER</span> utf8	</span><br><span class="line">#列名birthday修改为<span class="keyword">day</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> t7 </span><br><span class="line">	CHANGE birthday `<span class="keyword">day</span>` <span class="type">VARCHAR</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>	</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 删除表 （不能回滚）</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> 表名</span><br><span class="line">#清空表   （<span class="keyword">truncate</span>不能回滚，用<span class="keyword">delete</span>语句删除数据就可以回滚）</span><br><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> 表名</span><br></pre></td></tr></table></figure>



<h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><p>update  表名 set 修改内容 where  位置</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> t7 			</span><br><span class="line">	<span class="keyword">SET</span> salary <span class="operator">=</span> salary <span class="operator">+</span> <span class="number">1000</span>		#<span class="keyword">set</span>后接要更新的数据，可以有多个，用逗号分隔</span><br><span class="line">	<span class="keyword">WHERE</span> `name` <span class="operator">=</span> <span class="string">&#x27;aaa&#x27;</span>		#<span class="keyword">where</span>用于指定位置</span><br><span class="line">#如果没有<span class="keyword">where</span>语句,则更新所有的行(记录)	</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果需要回滚数据，需要保证在DML前进行设置：set autocommit &#x3D; false;</p>
</blockquote>
<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>delete from 表名 where …</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> departments</span><br><span class="line">	<span class="keyword">WHERE</span> department_id <span class="operator">=</span> <span class="number">60</span>;</span><br><span class="line">#如果没有<span class="keyword">where</span>语句，则删除表中全部数据</span><br></pre></td></tr></table></figure>





<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p>约束用于确保数据库的数据满足特定的商业规则；为保证数据完整性，一般从以下四个方面考虑限制：</p>
<ul>
<li><p>实体完整性（Entity Integrity） </p>
<p>例如：同一个表中，不能存在两条完全相同无法区分的记录 </p>
</li>
<li><p>域完整性（Domain Integrity） </p>
<p>例如：年龄范围0-120，性别范围“男&#x2F;女” </p>
</li>
<li><p>引用完整性（Referential Integrity） </p>
<p>例如：员工所在部门，在部门表中要能找到这个部门 </p>
</li>
<li><p>用户自定义完整性（User-defined Integrity） </p>
<p>例如：用户名唯一、密码不能为空等，本部门经理的工资不得高于本部门职工的平均工资的5倍。</p>
</li>
</ul>
<p>mysq的约束包括：</p>
<ul>
<li>not null，非空约束，规定某字段不能为空</li>
<li>unique，唯一约束，规定某字段在表中唯一</li>
<li>primary key， 主键约束（非空且唯一）</li>
<li>foreign key，外键约束</li>
<li>check，检查约束</li>
<li>default，默认值约束</li>
</ul>
<blockquote>
<p>查看某个表已有的约束：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.table_constraints</span><br><span class="line">	<span class="keyword">WHERE</span> table_name <span class="operator">=</span> &quot;表名&quot;;</span><br><span class="line"># information_schema 系统库</span><br><span class="line"># table_constraints 专门存储各表的约束</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>注：MySQL不支持check约束，可以用，但没效果。</p>
</blockquote>
<h4 id="primary-key-主键"><a href="#primary-key-主键" class="headerlink" title="primary key (主键)"></a>primary key (主键)</h4><p>用于唯一的标识表行的数据，当定义主键约束后，该列不能重复；</p>
<ul>
<li>primary key约束列的数据不能重复，且不能为null</li>
<li>一张表最多只能有一个主键，但可以是复合主键：比如有列：name和id，可以将两者用一个主键约束，单个name或id可以重复，但name+id的组合不能有重复；</li>
<li>主键的指定方式有两种：<ul>
<li>在列定义 后指定：列定义  primary key</li>
<li>在表定义最后写 ：primary key (列名)</li>
</ul>
</li>
<li>主键名总是PRIMAR，对主键定义约束名没用；</li>
<li>使用desc 表名，可以看到primary key的情况；</li>
<li>开发中，每个表往往会设计一个主键，且建议不要修改主键字段的值，否则有破坏数据完整性的危险；</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#字段后 定义主键</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1(</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    `name` <span class="type">VARCHAR</span>(<span class="number">32</span>)</span><br><span class="line">);</span><br><span class="line">#表定义末尾 定义主键    </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1(</span><br><span class="line">    id <span class="type">INT</span>,</span><br><span class="line">    `name` <span class="type">VARCHAR</span>(<span class="number">32</span>)</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY(id,`name`)</span><br><span class="line">);    </span><br><span class="line"># 建表后</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名称 <span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> KEY (字段列表); </span><br></pre></td></tr></table></figure>

<p>删除主键约束：</p>
<p>删除主键时，不需指定主键名，因为一个表只有一个主键；删除主键约束后，非空约束会存在。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名称 <span class="keyword">drop</span> <span class="keyword">primary</span> key；</span><br></pre></td></tr></table></figure>

<p><strong>自增列 auto_increment</strong></p>
<ul>
<li><p>一个表最多只能有一个自增列；</p>
</li>
<li><p>自增列约束的必须是键列（主键列、唯一键列，即 primary key 或 unique ）；</p>
</li>
<li><p>自增列约束的列的数据类型必须是整数类型；</p>
</li>
<li><p>默认从1开始，也可用：alter table 表名auto_increment &#x3D; 新的开始值；</p>
<p>如果自增列指定了 0 和 null，会在当前基础上继续自增，如果指定了具体值，直接赋值为具体值。</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 设置自增列</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名称(</span><br><span class="line">	字段名 数据类型 <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名称(</span><br><span class="line">	字段名 数据类型 <span class="keyword">unique</span> key auto_increment,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名称 modify 字段名 数据类型 auto_increment;</span><br><span class="line"></span><br><span class="line"># 删除自增列</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名称 modify 字段名 数据类型; #修改有自增列的字段，不加auto_increment就相当于删除</span><br></pre></td></tr></table></figure>





<h4 id="not-null-非空"><a href="#not-null-非空" class="headerlink" title="not null (非空)"></a>not null (非空)</h4><p>在列上定义了not null，那么当插入数据时，必须为列提供数据</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字段名 字段类型 <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 建表时</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp(</span><br><span class="line">	id <span class="type">INT</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">	NAME <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">	sex <span class="type">CHAR</span> <span class="keyword">NULL</span></span><br><span class="line">);</span><br><span class="line"># 建表后 </span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> emp</span><br><span class="line">	MODIFY sex <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 删除非空约束</span><br><span class="line"># 去掉<span class="keyword">not</span> <span class="keyword">null</span>，相当于修改某个非注解字段，该字段允许为空</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名称 modify 字段名 数据类型 <span class="keyword">NULL</span>;	</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名称 modify 字段名 数据类型;</span><br></pre></td></tr></table></figure>



<h4 id="unique-唯一"><a href="#unique-唯一" class="headerlink" title="unique (唯一)"></a>unique (唯一)</h4><p>当定义了唯一约束后，该列的数据不能重复。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字段名 字段类型 <span class="keyword">UNIQUE</span></span><br></pre></td></tr></table></figure>

<ul>
<li>没有指定not null时，unique字段允许有多个null；</li>
<li>如果一个列， 约束了 unique not null ，则使用效果类似主键 primary key；</li>
<li>MySQL会给唯一约束的列上默认创建一个唯一索引。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 建表时</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名称(</span><br><span class="line">	字段名 数据类型,</span><br><span class="line">	字段名 数据类型 <span class="keyword">unique</span>,</span><br><span class="line">	字段名 数据类型 <span class="keyword">unique</span> key,</span><br><span class="line">);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名称(</span><br><span class="line">	字段名 数据类型,</span><br><span class="line">	字段名 数据类型,</span><br><span class="line">	字段名 数据类型,</span><br><span class="line">	[<span class="keyword">constraint</span> 约束名] <span class="keyword">unique</span>(字段名)</span><br><span class="line">);</span><br><span class="line">#建表后</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名称 <span class="keyword">add</span> <span class="keyword">unique</span> (字段列表);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名称 modify 字段名 字段类型 <span class="keyword">unique</span>；</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 复合唯一约束</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名(</span><br><span class="line">	字段名 数据类型,</span><br><span class="line">	字段名 数据类型,</span><br><span class="line">	字段名 数据类型,</span><br><span class="line">	<span class="keyword">unique</span> key(字段列表) #字段列表中写的是多个字段名，多个字段名用逗号分隔，表示那么是复合唯一，即多个字段的组合是唯一的</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>删除唯一约束：</p>
<p>删除时需要指定唯一索引名（唯一索引名 和 唯一约束名一样，如果是复合约束且没有指定约束名，则默认为组合里的第一列的名）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">DROP</span> INDEX 唯一索引名</span><br></pre></td></tr></table></figure>



<h4 id="foreign-key-外键"><a href="#foreign-key-外键" class="headerlink" title="foreign key (外键)"></a>foreign key (外键)</h4><p>用于定义主表和从表之间的关系：’</p>
<p>外键约束主要定义在从表上，主表则必须具有主键约束或unique约束，当定义外键约束后，要求 外键列的数据必须在主表的主键列存在 或为null；</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">foreign</span> key(...) <span class="keyword">references</span> 主表(...)</span><br><span class="line"><span class="keyword">FOREIGN</span> KEY(本表列名) <span class="keyword">REFERENCES</span> 主表名(主键名<span class="operator">/</span><span class="keyword">unique</span>字段名)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 主表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> class (</span><br><span class="line">	id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY , <span class="comment">-- 班级编号</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 从表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> stuent (</span><br><span class="line">	id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY , </span><br><span class="line">    class_id <span class="type">INT</span> , <span class="comment">-- 学生所在班级的编号</span></span><br><span class="line">	<span class="keyword">FOREIGN</span> KEY (class_id) <span class="keyword">REFERENCES</span> class(id)	<span class="comment">-- 指定外键关系</span></span><br><span class="line">) </span><br><span class="line"></span><br><span class="line"># 建表后</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 从表名 <span class="keyword">ADD</span> [<span class="keyword">CONSTRAINT</span> 约束名] <span class="keyword">FOREIGN</span> KEY (从表的字段) <span class="keyword">REFERENCES</span> 主表名(被引用字段) [<span class="keyword">on</span> <span class="keyword">update</span> xx][<span class="keyword">on</span> <span class="keyword">delete</span> xx];</span><br></pre></td></tr></table></figure>

<ul>
<li>表的类型需要是innodb，这样的表才支持外键；一个表可以有多个 外键；</li>
<li>外键列的类型要和主键列的类型一致(长度可以不同)；</li>
<li>一旦建立主外键关系，主键列数据就不能随意删除，需要先删除依赖该记录的数据，即对应外键列的所有同一数据，才能删除主键的这一数据。</li>
<li>当创建外键约束时，系统会默认在所在的列上建立对应的普通索引，索引名是外键的约束名（根据外键查询效率很高）；删除外键约束后，必须手动删除对应的索引。</li>
</ul>
<p><strong>约束等级：</strong></p>
<ul>
<li>Cascade方式 ：在父表上update&#x2F;delete记录时，同步update&#x2F;delete子表的匹配记录 </li>
<li>Set null方式 ：在父表上update&#x2F;delete记录时，将子表上匹配记录的列设为null，但是要注意子 表的外键列不能为not null </li>
<li>No action方式 ：如果子表中有匹配的记录，则不允许对父表对应候选键进行update&#x2F;delete操作 </li>
<li>Restrict方式 ：同no action， 都是立即检查外键约束 </li>
<li>Set default方式（在可视化工具SQLyog中可能显示空白）：父表有变更时，子表将外键列设置成一个默认的值，但Innodb不能识别。</li>
</ul>
<blockquote>
<p>对于外键约束，最好是采用: on update cascade on delete restrict 的方式。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> dept(</span><br><span class="line">	did <span class="type">int</span> <span class="keyword">primary</span> key, #部门编号</span><br><span class="line">	dname <span class="type">varchar</span>(<span class="number">50</span>) #部门名称</span><br><span class="line">);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> emp(</span><br><span class="line">	eid <span class="type">int</span> <span class="keyword">primary</span> key, #员工编号</span><br><span class="line">	ename <span class="type">varchar</span>(<span class="number">5</span>), #员工姓名</span><br><span class="line">	deptid <span class="type">int</span>, #员工所在的部门</span><br><span class="line">	<span class="keyword">foreign</span> key (deptid) <span class="keyword">references</span> dept(did) <span class="keyword">on</span> <span class="keyword">update</span> cascade <span class="keyword">on</span> <span class="keyword">delete</span> restrict	#把修改操作设置为级联修改等级，把删除操作设置为restrict等级</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>删除外键约束： </p>
<p>查看约束名——删除外键约束——查看索引名——删除外键索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 第一步先查看约束名和删除外键约束</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.table_constraints <span class="keyword">WHERE</span> table_name <span class="operator">=</span> <span class="string">&#x27;表名称&#x27;</span>; #查看某个表的约束名</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 从表名 <span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> KEY 外键约束名;</span><br><span class="line"># 第二步查看索引名和删除索引。（注意，只能手动删除）</span><br><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> 表名称;  #查看某个表的索引名</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 从表名 <span class="keyword">DROP</span> INDEX 索引名;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>外键约束是用于保证数据的参照完整性的，因此主表与从表的存储引擎需要一致。</p>
<p>建不建外键约束和查询有没有关系。</p>
<blockquote>
<p>在 MySQL 里，外键约束是有成本的，需要消耗系统资源。对于大并发的 SQL 操作，有可能会不适 合。比如大型网站的中央数据库，可能会因为外键约束的系统开销而变得非常慢 。</p>
<p>所以，MySQL 允许不使用系统自带的外键约束，在应用层面完成检查数据一致性的逻辑。</p>
</blockquote>
<p><strong>阿里开发规范：不得使用外键与级联，一切外键概念必须在应用层解决。</strong></p>
<blockquote>
<p>级联更新：主键更新，外键跟着更新；</p>
<p>外键与级联更新 适用于单机低并发 ，不适合 分布式 、 高并发集群 ；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度 。</p>
</blockquote>
</blockquote>
<p>​                  </p>
<h4 id="check"><a href="#check" class="headerlink" title="check"></a>check</h4><p>用于强制数据必须满足的条件</p>
<p>（oracle和sql server支持check，mysql8.0才支持check）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">列名 类型 <span class="keyword">CHECK</span>(<span class="keyword">check</span>条件)</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> temp(</span><br><span class="line">	id <span class="type">INT</span> AUTO_INCREMENT,</span><br><span class="line">	NAME <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">	age <span class="type">INT</span> <span class="keyword">CHECK</span>(age <span class="operator">&gt;</span> <span class="number">20</span>),</span><br><span class="line">	<span class="keyword">PRIMARY</span> KEY(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<h4 id="default"><a href="#default" class="headerlink" title="default"></a>default</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 默认值一般不加在唯一键和主键列上</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名称(</span><br><span class="line">	字段名 数据类型 <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> 默认值,</span><br><span class="line">);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名称 modify 字段名 数据类型 <span class="keyword">default</span> 默认值; #如果字段原来有非空约束，并且要保留，需要在此句加上<span class="keyword">not</span> <span class="keyword">null</span>，否则非空约束会被删除</span><br></pre></td></tr></table></figure>

<blockquote>
<p>建表时，通常会加 not null default ‘’ 或  default 0，因为：</p>
<ul>
<li>null是特殊的值，比较时只能用专门的 is null 和 is not null 来比较。碰到运算符，通 常返回null。 </li>
<li>效率不高，影响提高索引效果。</li>
</ul>
</blockquote>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>索引可以极大加快查询的速度；</p>
<ul>
<li><p>使用索引会为该列形成一个索引的数据结构，如索引二叉树；</p>
</li>
<li><p>代价：额外占用磁盘空间；对dml语句(update, delete, insert) 的效率有影响，因为数据变动时需要重新维护索引结构</p>
</li>
<li><p>一般使用中，查询操作比增删改操作要多很多，因此索引很有必要</p>
</li>
</ul>
<p>索引的类型：</p>
<ul>
<li>主键索引：主键就是一个索引</li>
<li>唯一索引（unique）</li>
<li>普通索引（index）</li>
<li>全文索引：不适用mysql自带的fulltext，而是使用全文搜索Solr和ElasticSearch（ES）</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#为列创建索引：</span><br><span class="line"><span class="comment">-- create index .. on ..</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX 索引名 <span class="keyword">ON</span> 表(列) <span class="comment">-- 唯一索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX 索引名 <span class="keyword">ON</span> 表(列) <span class="comment">-- 普通索引</span></span><br><span class="line"><span class="comment">-- alter table .. add index ..</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表 <span class="keyword">ADD</span> INDEX 索引名(列)</span><br><span class="line"></span><br><span class="line">#删除索引</span><br><span class="line"><span class="keyword">DROP</span> INDEX 索引名 <span class="keyword">ON</span> 表</span><br><span class="line">#删除主键索引</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表 <span class="keyword">DROP</span> <span class="keyword">PRIMARY</span> KEY</span><br><span class="line"></span><br><span class="line">#修改索引：先删除，再修改</span><br><span class="line"></span><br><span class="line">#查询索引</span><br><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> 表</span><br><span class="line"><span class="keyword">SHOW</span> INDEXES <span class="keyword">FROM</span> 表</span><br><span class="line"><span class="keyword">SHOW</span> KEYS <span class="keyword">FROM</span> 表</span><br><span class="line"><span class="keyword">DESC</span> 表</span><br></pre></td></tr></table></figure>

<p>索引使用：</p>
<p>频繁的作为查询条件的字段应创建索引；</p>
<p>唯一性太差的字段不适合单独创建索引，即使频繁查询；更新很频繁的字段也不适合创建索引（因为维护索引结构需要额外开销）；不会或极少作为查询条件出现的字段也不用创建索引</p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>事务用于保证数据的一致性，事务期间的操作要么全部成，要么全部失败。</p>
<p>当执行事务操作时（dml语句），mysql会在表上加锁，防止其他用户修改表；</p>
<p>mysql的事务机制需要设置innodb的存储引擎才能使用</p>
<p><strong>事务ACID特性</strong>：</p>
<ul>
<li><strong>原子性（Atomicity）</strong>：原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生；</li>
<li><strong>一致性（Consistency）</strong>：事务必须使数据库从一个一致性状态变换到另一个一致性状态</li>
<li><strong>隔离性（Isolation）</strong>：事务的隔离性使多个用户并发访问数据库时，数据库未每个用户开启的事务不能被其他事务的操作所干扰，多个并发事务之间要相互隔离；</li>
<li><strong>持久性（Durability）</strong>：持久性是指一个事务一旦被提交，它对数据库中数据的改变是永久性的，即使数据库发生故障也不应该对其有影响</li>
</ul>
<h4 id="事务操作"><a href="#事务操作" class="headerlink" title="事务操作"></a>事务操作</h4><ul>
<li><p><strong>start transaction</strong> ：开启一个事务 （或者：set autocommit &#x3D; off ，即关闭自动提交）</p>
</li>
<li><p><strong>savepoint</strong>：设置保存点</p>
</li>
<li><p><strong>rollback to</strong> ：回退到某个保存点，回退后，会删除此保存点 以及 在其之后设置的保存点</p>
</li>
<li><p><strong>rollback</strong> ：回退全部事务，即回到事务开始的时候</p>
</li>
<li><p><strong>commit</strong>：提交事务，所有操作生效，不能再回退（确认事务的变化—结束事务—删除保存点—释放锁—数据生效）</p>
</li>
</ul>
<blockquote>
<p>DDL和DML的说明：</p>
<ul>
<li>DDL的操作一旦执行，就不可回滚；</li>
<li>DML的操作默认情况也不可回滚；想要回滚，需要在操作前设置：SET autocommit &#x3D; FALSE；</li>
</ul>
</blockquote>
<h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h4><table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
<th>加锁读</th>
</tr>
</thead>
<tbody><tr>
<td>读未提交(Read uncommitted)</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>不加锁</td>
</tr>
<tr>
<td>读已提交(Read committed)</td>
<td>N</td>
<td>Y</td>
<td>Y</td>
<td>不加锁</td>
</tr>
<tr>
<td>可重复读(Repeatable read)</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>不加锁</td>
</tr>
<tr>
<td>可串行化(Serializable)</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>加锁</td>
</tr>
</tbody></table>
<p>脏读：当一个事务读取另一个事务还未提交的改变时，产生脏读</p>
<p>不可重复读：由于其他事务所提交的修改或删除操作，致使在同一事务中的同一查询返回不同结果，即发生不可重复读</p>
<p>幻读：由于其他事务所提交的插入操作，致使在同一事务中的同一查询返回不同结果，即发生幻读</p>
<p><strong>事务隔离级别操作：</strong></p>
<ul>
<li><p>设置当前会话隔离级别：</p>
<p><code>set session transaction isolation level &lt;u&gt;repeattable read&lt;/u&gt;;</code></p>
<p>设置系统当前隔离级别：</p>
<p><code>set global transaction isolation level &lt;u&gt;repeattable read&lt;/u&gt;;</code></p>
</li>
<li><p>查看当前会话隔离级别：</p>
<p><code>select @@tx_isolation;</code></p>
<p>查看系统当前隔离级别：</p>
<p><code>select @@global.tx_isolation;</code></p>
</li>
<li><p>mysql默认的事务隔离级别是repeatable read，一般都用，无需修改；</p>
</li>
<li><p>全局修改：直接修改my.ini配置文件，在末尾加上：</p>
<p><code>#可选参数有：READ-UNCOMMITTED, READ-COMMITTED, REPEATABLE-READ, SERIALIZABLE</code></p>
<p><code>[mysqld]</code></p>
<p><code>transaction-isolation = REPEATABLE-READ</code></p>
</li>
</ul>
<h2 id="表类型-x2F-存储引擎"><a href="#表类型-x2F-存储引擎" class="headerlink" title="表类型&#x2F;存储引擎"></a>表类型&#x2F;存储引擎</h2><p>mysql的表类型由存储引擎（Storage Engines）决定，</p>
<p>MySQL数据表主要支持六种类型：CSV，Memory，ARCHIVE，MRG_MYISAM，MYISAM，InnoBD；</p>
<p>其中<strong>InnoBD为事务安全型</strong>，其他五种为非事务安全型；</p>
<p>MYISAM：不支持事务，不支持外键，但访问速度快</p>
<p>InnoBD：支持事务安全，但读写的处理效率相比MYISAM差一些，且会占用更多的磁盘空间以保留数据和索引；</p>
<p>MEMORY：使用存在内存中的内容来创建表，每个MEMORY表实际对应一个磁盘文件。MEMORY类型的表访问非常快，因为它的数据放在内存中，且默认使用hash索引；但如果MySQL服务关闭，表中的数据就会丢失，而表的结构还在</p>
<p>修改存储引擎：</p>
<p><code>alter table 表名 engine = 存储引擎</code></p>
<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>视图是一个虚拟表，其内容由查询定义，同真实的表一样，视图包括列，其数据来自对应的基表（可以是多个基表）。通过视图可以修改基表的数据，基表的改变也会影响视图的数据。（视图中可以再使用视图，数据仍来自基表）</p>
<p>操作：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#创建：</span><br><span class="line">creat <span class="keyword">view</span> 视图名 <span class="keyword">as</span> <span class="keyword">select</span> 语句</span><br><span class="line"></span><br><span class="line">#修改：</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">view</span> 视图名 <span class="keyword">as</span> <span class="keyword">select</span></span><br><span class="line"></span><br><span class="line">#显示创建视图的指令：</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">view</span> 视图名</span><br><span class="line"></span><br><span class="line">#删除视图：</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">view</span> 视图名<span class="number">1</span>,视图名<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>视图的好处：</p>
<ul>
<li>安全：可以只让用户查询到需要的字段，一些保密的字段不能查看。</li>
<li>性能：视图存储的是查询语句，本身并不占用数据存储资源，减少了数据冗余。</li>
<li>灵活：可以在旧表上建立一张视图，然后映射到新表上，达到升级数据表的目的。</li>
</ul>
<p>视图的不足：</p>
<p>如果实际数据表的结构变更了，我们就需要及时对相关的视图进行相应的维护。特别是嵌套的视图（就是在视图的基础上创建视图），维护会变得比较复杂， 可读性不好 ，容易变成系统的潜在隐患。</p>
<p>实际项目中，如果视图过多，会导致数据库维护成本的问题。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#查看视图</span><br><span class="line"># 查看数据库的表对象、视图对象</span><br><span class="line"><span class="keyword">SHOW</span> TABLES;</span><br><span class="line"></span><br><span class="line"># 查看视图的结构</span><br><span class="line"><span class="keyword">DESC</span> 视图名;</span><br><span class="line"></span><br><span class="line"># 查看视图的属性信息</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">TABLE</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;视图名&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># 查看视图的详细定义信息</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">VIEW</span> 视图名;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 更新视图，跟更新表一样</span><br><span class="line"><span class="keyword">update</span> 视图名 <span class="keyword">set</span> 更新内容 <span class="keyword">where</span> ...</span><br><span class="line"></span><br><span class="line"># 删除数据，跟删除表数据一样</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 视图名 <span class="keyword">where</span> ...</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 修改视图</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> 视图名 <span class="keyword">as</span> 查询语句</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">view</span> 视图名称 <span class="keyword">as</span> 查询语句</span><br><span class="line"># 删除视图</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">view</span> if <span class="keyword">exists</span> 视图<span class="number">1</span>，视图<span class="number">2</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>视图作为虚拟表，主要用于 方便查询，不建议更新视图数据。</p>
</li>
<li><p>对视图数据的更改，都是通过对实际数据表的更新来完成。</p>
</li>
</ul>
<blockquote>
<p>一些不可更新的视图：</p>
<p>要使视图可更新，视图中的行和底层基本表中的行之间必须存在 一对一 的关系。</p>
<p>另外当视图定义出现如下情况时，视图不支持更新操作：</p>
<ul>
<li>在定义视图的时候指定了“ALGORITHM &#x3D; TEMPTABLE”，视图将不支持INSERT和DELETE操作； </li>
<li>视图中不包含基表中所有被定义为非空又未指定默认值的列，视图将不支持INSERT操作；</li>
<li>在定义视图的SELECT语句中使用了 JOIN联合查询 ，视图将不支持INSERT和DELETE操作； </li>
<li>在定义视图的SELECT语句后的字段列表中使用了 数学表达式 或 子查询 ，视图将不支持INSERT，也不支持UPDATE使用了数学表达式、子查询的字段值； </li>
<li>在定义视图的SELECT语句后的字段列表中使用 DISTINCT 、 聚合函数 、 GROUP BY 、 HAVING 、 UNION 等，视图将不支持INSERT、UPDATE、DELETE；</li>
<li>在定义视图的SELECT语句中包含了子查询，而子查询中引用了FROM后面的表，视图将不支持 INSERT、UPDATE、DELETE； </li>
<li>视图定义基于一个 不可更新视图 ； </li>
<li>常量视图。</li>
</ul>
</blockquote>
<h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><p>mysql的用户，都存储在系统数据库mysql中的user表中;</p>
<p>user表的重要字段说明：</p>
<ul>
<li><strong>host</strong>：允许登录的“位置”&#x2F;IP，可以指定ip地址登录；其中localhost表示该用户只允许本机登录；</li>
<li><strong>user</strong>：用户名；</li>
<li><strong>authentication_string</strong>：密码，用mysql的password()函数加密过的密码字段</li>
</ul>
<p><strong>操作：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#创建用户，并指定密码：</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;用户名&#x27;</span> @<span class="string">&#x27;允许登录位置&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;密码&#x27;</span></span><br><span class="line"><span class="comment">-- 指定host时，可以写 % ，表示所有IP都有连接权限;IP也可以写成 192.168.1.% , 表示某用户的ip为 192.168.1.% z</span></span><br><span class="line"></span><br><span class="line">#删除用户：</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">user</span> <span class="string">&#x27;用户名&#x27;</span> @<span class="string">&#x27;允许登录位置&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#修改密码：</span><br><span class="line"><span class="comment">-- 修改自己的密码：</span></span><br><span class="line"><span class="keyword">set</span> password <span class="operator">=</span> password(<span class="string">&#x27;密码&#x27;</span>);</span><br><span class="line"><span class="comment">-- 修改他人的密码(需要有修改用户密码的权限):</span></span><br><span class="line"><span class="keyword">set</span> password <span class="keyword">for</span> <span class="string">&#x27;用户名&#x27;</span> @<span class="string">&#x27;登录位置&#x27;</span> <span class="operator">=</span> password(<span class="string">&#x27;密码&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>用户权限</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 给用户权限：</span><br><span class="line"><span class="keyword">grant</span> 权限列表 <span class="keyword">on</span> 库.对象名 <span class="keyword">to</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;登录位置&#x27;</span> [identified <span class="keyword">by</span> <span class="string">&#x27;密码&#x27;</span>]</span><br><span class="line"><span class="comment">-- 说明：权限列表写all表示赋予该用户在该对象上的所有权限</span></span><br><span class="line"><span class="comment">-- 库.对象名 写成 *.* : 代表系统中的所有数据库的所有对象(表，视图，存储过程); 写成 库.* : 代表某个数据库的所有数据对象(表，视图，存储过程);</span></span><br><span class="line"><span class="comment">-- identified by 可以省略，1.如果用户存在，就是修改该用户的密码; 2.如果该用户不存在，就是创建该用户;</span></span><br><span class="line"></span><br><span class="line">#回收用户权限：</span><br><span class="line"><span class="keyword">revoke</span> 权限列表 <span class="keyword">on</span> 库.对象名 <span class="keyword">from</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;登录位置&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#权限生效指令(如果权限没有生效，可以执行此命令)</span><br><span class="line">flush privileges</span><br></pre></td></tr></table></figure>









<hr>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><blockquote>
<p>不同DBMS采用的函数有所不同，因此使用了SQL函数的代码，往往可移植性较差。</p>
</blockquote>
<h2 id="统计函数"><a href="#统计函数" class="headerlink" title="统计函数"></a>统计函数</h2><p>count, sum, avg, max, min</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#<span class="built_in">count</span>(<span class="operator">*</span>)会返回满足条件的记录的个数，<span class="built_in">count</span>(列名)同样返回满足条件的列的个数，但会排除为<span class="keyword">null</span>的情况</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 条件</span><br><span class="line"></span><br><span class="line">#<span class="built_in">sum</span>(列)返回满足条件的列的所有数值的总和(sum仅对数值起作用，对字符等没有意义; 对多列求和，逗号不能少)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(列名)，<span class="built_in">SUM</span>(列名)...<span class="keyword">FROM</span> 表明；</span><br><span class="line"></span><br><span class="line">#avg返回满足条件的列的平均值</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(列名) <span class="keyword">FROM</span> 表名</span><br><span class="line"></span><br><span class="line">#max<span class="operator">/</span>min 返回满足列的最高值<span class="operator">/</span>最低值</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(列名) <span class="keyword">FROM</span> 表名</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MIN</span>(列名) <span class="keyword">FROM</span> 表名</span><br></pre></td></tr></table></figure>

<blockquote>
<p>where 不能使用统计函数。</p>
</blockquote>
<h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p>group by .. having …. （having可对分组后结果进行过滤）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 列, 列(可以是函数), 分组的列名 <span class="keyword">FROM</span> 表名 </span><br><span class="line">	<span class="keyword">GROUP</span> <span class="keyword">BY</span> 分组的列名 <span class="keyword">HAVING</span> 过滤条件</span><br></pre></td></tr></table></figure>

<p>对比where和having：</p>
<table>
<thead>
<tr>
<th></th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>WHERE</td>
<td>先筛选数据再关联，执行效率高</td>
<td>不能使用分组中的计算函数进行筛选</td>
</tr>
<tr>
<td>HAVING</td>
<td>可以使用分组中的计算函数</td>
<td>在最后的结果集中进行筛选，执行效率较低</td>
</tr>
</tbody></table>
<h2 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#charset(str) 返回字串的字符集</span><br><span class="line"><span class="keyword">SELECT</span> CHARSET(列名) <span class="keyword">FROM</span> 表名</span><br><span class="line"></span><br><span class="line">#concat(string1,string2...) 连接字符，可将多个列拼接成一列</span><br><span class="line"><span class="keyword">SELECT</span> CONCAT(列名,<span class="string">&#x27;string&#x27;</span>,列名) <span class="keyword">FROM</span> 表名</span><br><span class="line"></span><br><span class="line">#instr(stirng, substring) 返回substring在string中出现的位置，没有则放回<span class="number">0</span></span><br><span class="line"><span class="keyword">SELECT</span> INSTR(<span class="string">&#x27;STRING&#x27;</span>,<span class="string">&#x27;RING&#x27;</span>) <span class="keyword">FROM</span> DUAL  #dual 亚元表，是系统表，可用于测试表使用</span><br><span class="line"></span><br><span class="line">#ucase(stirng) 转换成大写</span><br><span class="line">#lcase(stirng) 转换成小写</span><br><span class="line"><span class="keyword">SELECT</span> UCASE(列名) <span class="keyword">FROM</span> 表名</span><br><span class="line"></span><br><span class="line">#<span class="keyword">left</span>(string, length) 从string中的左边起取length个字符</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">LEFT</span>(列名，<span class="number">2</span>) <span class="keyword">FROM</span> 表名</span><br><span class="line"></span><br><span class="line">#length(string) 返回string长度(按字节算)</span><br><span class="line"></span><br><span class="line">#replace(str, search_str, replace_str) 在str中用replace_str替换search_str</span><br><span class="line"><span class="keyword">SELECT</span> 列名<span class="number">1</span>， REPLACE(列名<span class="number">2</span>，<span class="string">&#x27;search_str&#x27;</span>,<span class="string">&#x27;replace_str&#x27;</span>) <span class="keyword">FROM</span> 表名 </span><br><span class="line"><span class="comment">/*搜索列名1，如果每行的列名2中有search_str，就用replace_str替换*/</span></span><br><span class="line"></span><br><span class="line">#strcmp(srting1, string2) 逐字符比较两字符大小</span><br><span class="line"></span><br><span class="line">#<span class="built_in">substring</span>(str, position, length) 从str的position开始(从<span class="number">1</span>开始计算)，取length个字符</span><br><span class="line"></span><br><span class="line">#ltrim(string) <span class="operator">/</span> rtrim(string) 取出前端空格<span class="operator">/</span>后端空格</span><br></pre></td></tr></table></figure>

<h2 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- abs(num) 绝对值</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">ABS</span>(<span class="number">-10</span>) <span class="keyword">FROM</span> DUAL; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- bin(decimal_number )十进制转二进制</span></span><br><span class="line"><span class="keyword">SELECT</span> BIN(<span class="number">10</span>) <span class="keyword">FROM</span> DUAL; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- hex(DecimalNumber ) 转十六进制</span></span><br><span class="line"><span class="comment">-- oct(DecimalNumber ) 转八进制</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- ceiling(number2 ) 向上取整, 得到比 num2 大的最小整数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CEILING</span>(<span class="number">-1.1</span>) <span class="keyword">FROM</span> DUAL;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- floor(number2 ) 向下取整,得到比 num2 小的最大数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">FLOOR</span>(<span class="number">-1.1</span>) <span class="keyword">FROM</span> DUAL;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- conv(number2,from_base,to_base) 进制转换</span></span><br><span class="line"><span class="comment">-- 下面的含义是: 8 是十进制的, 转成 二进制输出</span></span><br><span class="line"><span class="keyword">SELECT</span> CONV(<span class="number">8</span>, <span class="number">10</span>, <span class="number">2</span>) <span class="keyword">FROM</span> DUAL;</span><br><span class="line"><span class="comment">-- 下面的含义是: 8 是 16 进制的, 转成 十进制输出</span></span><br><span class="line"><span class="keyword">SELECT</span> CONV(<span class="number">16</span>, <span class="number">16</span>, <span class="number">10</span>) <span class="keyword">FROM</span> DUAL;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- format(number,decimal_places ) 保留小数位数(四舍五入)</span></span><br><span class="line"><span class="keyword">SELECT</span> FORMAT(<span class="number">78.125458</span>,<span class="number">2</span>) <span class="keyword">FROM</span> DUAL; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- least(number , number2 [,..]) 求最小值</span></span><br><span class="line"><span class="keyword">SELECT</span> LEAST(<span class="number">0</span>,<span class="number">1</span>, <span class="number">-10</span>, <span class="number">4</span>) <span class="keyword">FROM</span> DUAL;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- mod(numerator ,denominator)  求余</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MOD</span>(<span class="number">10</span>, <span class="number">3</span>) <span class="keyword">FROM</span> DUAL;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- rand([seed]) RAND([seed]) 返回随机数 其范围为 0 ≤ v ≤ 1.0</span></span><br><span class="line"><span class="comment">-- 1. 如果使用 rand(), 每次返回不同的随机数 ，在 0 ≤ v ≤ 1.0</span></span><br><span class="line"><span class="comment">-- 2. 如果使用 rand(seed) 返回随机数, 范围 0 ≤ v ≤ 1.0, 如果seed不变，该随机数也不变(固定了)</span></span><br><span class="line"><span class="keyword">SELECT</span> RAND() <span class="keyword">FROM</span> DUAL;</span><br></pre></td></tr></table></figure>

<h2 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- CURRENT_DATE ( ) 当前日期</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CURRENT_DATE</span>() <span class="keyword">FROM</span> DUAL; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- CURRENT_TIME ( )当前时间</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CURRENT_TIME</span>() <span class="keyword">FROM</span> DUAL;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- CURRENT_TIMESTAMP ( ) 当前时间戳</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CURRENT_TIMESTAMP</span>() <span class="keyword">FROM</span> DUAL;</span><br><span class="line"></span><br><span class="line">#NOW() 返回当前时间</span><br><span class="line"><span class="keyword">SELECT</span> NOW() <span class="keyword">FROM</span> DUAL; </span><br><span class="line"></span><br><span class="line">#date_add(data,<span class="type">interval</span> d_value d_type) 在<span class="type">date</span>中加上日期或时间</span><br><span class="line">#<span class="type">interval</span> 后可以是 <span class="keyword">year</span>，<span class="keyword">minute</span>，<span class="keyword">second</span>，<span class="keyword">day</span>等</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> mes <span class="keyword">WHERE</span> DATE_ADD(send_time, <span class="type">INTERVAL</span> <span class="number">10</span> <span class="keyword">MINUTE</span>) <span class="operator">&gt;=</span> NOW()</span><br><span class="line">#date_sub(data,<span class="type">interval</span> d_value d_type) 在<span class="type">date</span>中减去日期或时间</span><br><span class="line">#<span class="type">interval</span> 后可以是 <span class="keyword">year</span>，<span class="keyword">minute</span>，<span class="keyword">second</span>，<span class="keyword">hour</span>，<span class="keyword">day</span>等</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> mes <span class="keyword">WHERE</span> send_time <span class="operator">&gt;=</span> DATE_SUB(NOW(), <span class="type">INTERVAL</span> <span class="number">10</span> <span class="keyword">MINUTE</span>)</span><br><span class="line"></span><br><span class="line">#datediff(date1, date2) 两个日期差(天)</span><br><span class="line"><span class="keyword">SELECT</span> DATEDIFF(<span class="string">&#x27;2011-11-11&#x27;</span>, <span class="string">&#x27;1990-01-01&#x27;</span>) <span class="keyword">FROM</span> DUAL; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- YEAR|Month|DAY| DATE (datetime )</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">YEAR</span>(NOW()) <span class="keyword">FROM</span> DUAL;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MONTH</span>(NOW()) <span class="keyword">FROM</span> DUAL;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DAY</span>(NOW()) <span class="keyword">FROM</span> DUAL;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MONTH</span>(<span class="string">&#x27;2013-11-10&#x27;</span>) <span class="keyword">FROM</span> DUAL; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- unix_timestamp() : 返回的是 1970-1-1 到现在的秒数</span></span><br><span class="line"><span class="keyword">SELECT</span> UNIX_TIMESTAMP() <span class="keyword">FROM</span> DUAL; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 格式化日期</span></span><br><span class="line">DATE_FORMAT(<span class="type">date</span>,fmt) <span class="comment">-- 按照字符串fmt格式化日期date值</span></span><br><span class="line">TIME_FORMAT(<span class="type">time</span>,fmt) <span class="comment">-- 按照字符串fmt格式化时间time值</span></span><br><span class="line">GET_FORMAT(date_type,format_type) <span class="comment">-- 返回日期字符串的显示格式</span></span><br><span class="line">STR_TO_DATE(str, fmt) <span class="comment">-- 按照字符串fmt对str进行解析，解析为一个日期</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>常用格式符:</p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203192048867.png" alt="image-20220319204809732"></p>
<p>常用取值：</p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203192049029.png" alt="image-20220319204902891"></p>
</blockquote>
<p>例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建测试表 信息表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mes(</span><br><span class="line">    id <span class="type">INT</span> ,</span><br><span class="line">    content <span class="type">VARCHAR</span>(<span class="number">30</span>), </span><br><span class="line">    send_time DATETIME</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 添加一条记录</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mes <span class="keyword">VALUES</span>(<span class="number">1</span>, <span class="string">&#x27;北京新闻&#x27;</span>, <span class="built_in">CURRENT_TIMESTAMP</span>());</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mes <span class="keyword">VALUES</span>(<span class="number">2</span>, <span class="string">&#x27;上海新闻&#x27;</span>, NOW());</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mes <span class="keyword">VALUES</span>(<span class="number">3</span>, <span class="string">&#x27;广州新闻&#x27;</span>, NOW());</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> mes;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 显示所有新闻信息，发布日期只显示 日期，不用显示时间. </span></span><br><span class="line"><span class="keyword">SELECT</span> id, content, <span class="type">DATE</span>(send_time) <span class="keyword">FROM</span> mes; </span><br><span class="line"><span class="comment">-- 查询在 10 分钟内发布的新闻</span></span><br><span class="line">#date_add(data,<span class="type">interval</span> d_value d_type) 在<span class="type">date</span>中加上日期或时间</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> mes <span class="keyword">WHERE</span> DATE_ADD(send_time, <span class="type">INTERVAL</span> <span class="number">10</span> <span class="keyword">MINUTE</span>) <span class="operator">&gt;=</span> NOW()</span><br><span class="line">#date_sub(data,<span class="type">interval</span> d_value d_type) 在<span class="type">date</span>中减去日期或时间</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> mes <span class="keyword">WHERE</span> send_time <span class="operator">&gt;=</span> DATE_SUB(NOW(), <span class="type">INTERVAL</span> <span class="number">10</span> <span class="keyword">MINUTE</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 求出 2011-11-11 和 1990-1-1 相差多少天</span></span><br><span class="line">#datediff(date1, date2) 两个日期差(天)</span><br><span class="line"><span class="keyword">SELECT</span> DATEDIFF(<span class="string">&#x27;2011-11-11&#x27;</span>, <span class="string">&#x27;1990-01-01&#x27;</span>) <span class="keyword">FROM</span> DUAL; </span><br><span class="line"><span class="comment">-- 求出你活了多少天? (假如1986-11-11 出生)</span></span><br><span class="line"><span class="keyword">SELECT</span> DATEDIFF(NOW(), <span class="string">&#x27;1986-11-11&#x27;</span>) <span class="keyword">FROM</span> DUAL;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 如果你能活 80 岁，求出你还能活多少天. (1986-11-11 出生)</span></span><br><span class="line"><span class="comment">-- 先求出活 80 岁 时, 是什么日期 X</span></span><br><span class="line"><span class="comment">-- 然后在使用 datediff(x, now()); 1986-11-11-&gt;datetime</span></span><br><span class="line"><span class="comment">-- INTERVAL 80 YEAR ： YEAR 可以是 年月日，时分秒</span></span><br><span class="line"><span class="comment">-- &#x27;1986-11-11&#x27; 可以 date,datetime timestamp</span></span><br><span class="line"><span class="keyword">SELECT</span> DATEDIFF(DATE_ADD(<span class="string">&#x27;1986-11-11&#x27;</span>, <span class="type">INTERVAL</span> <span class="number">80</span> <span class="keyword">YEAR</span>), NOW()) <span class="keyword">FROM</span> DUAL;</span><br><span class="line"><span class="keyword">SELECT</span> TIMEDIFF(<span class="string">&#x27;10:11:11&#x27;</span>, <span class="string">&#x27;06:10:10&#x27;</span>) <span class="keyword">FROM</span> DUAL; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- FROM_UNIXTIME() : 可以把一个 unix_timestamp 秒数[时间戳]，转成指定格式的日期</span></span><br><span class="line"><span class="comment">-- %Y-%m-%d 格式是规定好的，表示年月日</span></span><br><span class="line"><span class="comment">-- 意义：在开发中，可以存放一个整数，然后表示时间，通过 FROM_UNIXTIME 转换</span></span><br><span class="line"><span class="keyword">SELECT</span> FROM_UNIXTIME(<span class="number">1618483484</span>, <span class="string">&#x27;%Y-%m-%d&#x27;</span>) <span class="keyword">FROM</span> DUAL;</span><br><span class="line"><span class="keyword">SELECT</span> FROM_UNIXTIME(<span class="number">1618483100</span>, <span class="string">&#x27;%Y-%m-%d %H:%i:%s&#x27;</span>) <span class="keyword">FROM</span> DUAL;</span><br></pre></td></tr></table></figure>



<h2 id="加密函数"><a href="#加密函数" class="headerlink" title="加密函数"></a>加密函数</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">user</span>() 查询用户，可以查看登录到mysql的有哪些用户，以及登录的IP</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span>() <span class="keyword">FROM</span> DUAL;</span><br><span class="line">#database()查询当前使用的数据库名称</span><br><span class="line"><span class="keyword">SELECT</span> DATABASE();</span><br><span class="line"></span><br><span class="line"># MD5(str) 为字符串算出一个MD5(<span class="number">32</span>位)字符串，常用于(用户密码)加密</span><br><span class="line"># 在数据库中存放的应该是加密后的密码</span><br><span class="line"><span class="keyword">SELECT</span> MD5(<span class="string">&#x27;zzc&#x27;</span>) <span class="keyword">FROM</span> DUAL;</span><br><span class="line"></span><br><span class="line"># SHA(STR),根据密码str计算并返回加密后的密码字符串，当参数为<span class="keyword">NULL</span>时，返回<span class="keyword">NULL</span>;</span><br><span class="line"># SHA加密算法比MD5更加安全 。</span><br><span class="line"><span class="keyword">SELECT</span> SHA(<span class="string">&#x27;zzc&#x27;</span>) <span class="keyword">FROM</span> DUAL;</span><br><span class="line"></span><br><span class="line"># password(str)根据密码str计算并返回密码字符串，常用于数据库的用户密码加密</span><br><span class="line"><span class="keyword">SELECT</span> PASSWORD(<span class="string">&#x27;zzc&#x27;</span>) <span class="keyword">FROM</span> DUAL</span><br><span class="line"></span><br><span class="line"># encode(v,p):返回使用password_seed作为加密密码 加密<span class="keyword">value</span></span><br><span class="line">ENCODE(<span class="keyword">value</span>,password_seed) </span><br><span class="line">#返回使用password_seed作为加密密码 解密<span class="keyword">value</span></span><br><span class="line">DECODE(<span class="keyword">value</span>,password_seed) 返回使用password_seed作为加密密码解密<span class="keyword">value</span></span><br></pre></td></tr></table></figure>



<h2 id="流程函数"><a href="#流程函数" class="headerlink" title="流程函数"></a>流程函数</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># IF(expr1,expr2,expr3) 如果 expr1 为 <span class="literal">True</span> ,则返回 expr2 否则返回 expr3</span><br><span class="line"><span class="keyword">SELECT</span> IF(<span class="literal">TRUE</span>, <span class="string">&#x27;北京&#x27;</span>, <span class="string">&#x27;上海&#x27;</span>) <span class="keyword">FROM</span> DUAL;</span><br><span class="line"></span><br><span class="line"># IFNULL(expr1,expr2) 如果expr1不为空,返回expr1, 否则返回expr2</span><br><span class="line"><span class="keyword">SELECT</span> IFNULL( <span class="keyword">NULL</span>, <span class="string">&#x27;mysql学习&#x27;</span>) <span class="keyword">FROM</span> DUAL;</span><br><span class="line"></span><br><span class="line"># <span class="keyword">case</span> <span class="keyword">when</span> 条件<span class="number">1</span> <span class="keyword">then</span> 结果<span class="number">1</span> <span class="keyword">when</span> 条件<span class="number">2</span> <span class="keyword">then</span> 结果<span class="number">2</span> <span class="keyword">else</span> 结果<span class="number">3</span> <span class="keyword">end</span>; [类似多重分支.]</span><br><span class="line"># 类似: if...else if...else..</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CASE</span></span><br><span class="line">	<span class="keyword">WHEN</span> job <span class="operator">=</span> <span class="string">&#x27;CLERK&#x27;</span> <span class="keyword">THEN</span> <span class="string">&#x27;职员&#x27;</span></span><br><span class="line">   	<span class="keyword">WHEN</span> job <span class="operator">=</span> <span class="string">&#x27;MANAGER&#x27;</span> <span class="keyword">THEN</span> <span class="string">&#x27;经理&#x27;</span> 		</span><br><span class="line">    <span class="keyword">WHEN</span> job <span class="operator">=</span> <span class="string">&#x27;SALESMAN&#x27;</span> <span class="keyword">THEN</span> <span class="string">&#x27;销售人员&#x27;</span> 	  </span><br><span class="line">    <span class="keyword">ELSE</span> job <span class="keyword">END</span></span><br><span class="line">	</span><br><span class="line"># <span class="keyword">case</span> expr <span class="keyword">when</span> 常量<span class="number">1</span> <span class="keyword">then</span> 值<span class="number">1</span> <span class="keyword">when</span> 常量<span class="number">2</span> <span class="keyword">then</span> 值<span class="number">2</span> <span class="keyword">else</span> 值<span class="number">3</span> <span class="keyword">end</span>; </span><br><span class="line"># 类似: switch...case...</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CASE</span> x</span><br><span class="line">	<span class="keyword">WHEN</span> <span class="number">1</span> <span class="keyword">THEN</span> <span class="string">&#x27;我是1&#x27;</span></span><br><span class="line">	<span class="keyword">WHEN</span> <span class="number">2</span> <span class="keyword">THEN</span> <span class="string">&#x27;我是2&#x27;</span></span><br><span class="line">	<span class="keyword">ELSE</span> <span class="string">&#x27;你是谁&#x27;</span></span><br></pre></td></tr></table></figure>



<h2 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FORMAT(<span class="keyword">value</span>,n) <span class="comment">-- 返回对数字value进行格式化后的结果数据。n表示 四舍五入 后保留到小数点后n位</span></span><br><span class="line">CONV(<span class="keyword">value</span>,<span class="keyword">from</span>,<span class="keyword">to</span>) <span class="comment">-- 将value的值进行不同进制之间的转换</span></span><br><span class="line">INET_ATON(ipvalue) <span class="comment">-- inet_aton(i): 将以点分隔的IP地址转化为一个数字</span></span><br><span class="line">INET_NTOA(<span class="keyword">value</span>) <span class="comment">-- inet_ntoa(v): 将数字形式的IP地址转化为以点分隔的IP地址</span></span><br><span class="line">BENCHMARK(n,expr) <span class="comment">-- benchmark(n,e): 将表达式expr重复执行n次。用于测试MySQL处理expr表达式所耗费的时间</span></span><br><span class="line"><span class="keyword">CONVERT</span>(<span class="keyword">value</span> <span class="keyword">USING</span> char_code) <span class="comment">-- 将value所使用的字符编码修改为char_code</span></span><br></pre></td></tr></table></figure>





<h1 id="存储过程和存储函数"><a href="#存储过程和存储函数" class="headerlink" title="存储过程和存储函数"></a>存储过程和存储函数</h1><h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><p>存储过程 就是将一组经过预先编译的SQL语句封装。</p>
<p>执行流程：存储过程预先存储在mysql服务器上，用户需要的时候，只需要向服务器发出调用存储过程的命令，就像调用一个封装的方法一样，之后服务器就可以把预先存储好的这一系列SQL语句全部执行。</p>
<p>好处：</p>
<ul>
<li>简化操作，提高sql语言的重用性；</li>
<li>减少失误；</li>
<li>减少网络传输量，用户只需使用存储过程的名字即可；</li>
<li>减少sql语句暴露在网络上的风险，也提高数据查询的安全性；</li>
</ul>
<p>不足：</p>
<ul>
<li><p>可移植性差：</p>
<p>存储过程程不能跨数据库移植，比如在 MySQL、Oracle 和 SQL Server 里编写的存储过程，在换成其他数据库时都需要重新编写。</p>
</li>
<li><p>调试困难：</p>
<p>只有少数 DBMS 支持存储过程的调试。对于复杂的存储过程来说，开发和维护都不容 易。</p>
</li>
<li><p>版本管理困难：</p>
<p>比如数据表索引发生变化了，可能会导致存储过程失效。在开发软件的时候往往需要进行版本管理，但是存储过程本身没有版本控制，版本迭代更新的时候很麻烦。</p>
</li>
<li><p>不适合高并发：</p>
<p>高并发的场景需要减少数据库的压力，有时数据库会采用分库分表的方式，而且对可扩展性要求很高，在这种情况下，存储过程会变得难以维护，增加数据库的压力，显然就 不适用了。</p>
</li>
</ul>
<p>分类：</p>
<p>存储过程的参数有：IN，OUT，INOUT</p>
<ul>
<li>没有参数（无参数无返回）</li>
<li>仅带IN（有参数无返回）</li>
<li>仅带OUT（无参数有返回）</li>
<li>带IN，OUT（有参数有返回）</li>
<li>带INOUT（有参数有返回）</li>
</ul>
<blockquote>
<p>注：IN、OUT、INOUT 都可以在一个存储过程中带多个。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 创建 </span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> 存储过程名 (<span class="keyword">IN</span><span class="operator">|</span><span class="keyword">OUT</span><span class="operator">|</span><span class="keyword">INOUT</span> 参数名 参数类型, ....) </span><br><span class="line">[charcateristics...]</span><br><span class="line"><span class="keyword">begin</span> </span><br><span class="line">	存储过程体</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"># 调用</span><br><span class="line"><span class="keyword">call</span> 存储过程名(实参列表)</span><br><span class="line"># 调用<span class="keyword">in</span>模式的参数</span><br><span class="line"><span class="keyword">CALL</span> sp1(<span class="string">&#x27;值&#x27;</span>);</span><br><span class="line"># 调用<span class="keyword">out</span>模式的参数</span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@name</span>;</span><br><span class="line"><span class="keyword">CALL</span> SPQ(<span class="variable">@name</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="variable">@name</span>;</span><br><span class="line">#调用<span class="keyword">inout</span>模式的参数</span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@name</span><span class="operator">=</span>值;</span><br><span class="line"><span class="keyword">CALL</span> sp1(<span class="variable">@name</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="variable">@name</span>;</span><br></pre></td></tr></table></figure>

<p>因为mysql默认的语句结束符号为分号 ‘；‘，为了避免与存储过程的sql语句冲突，需要使用delimiter改变存储过程的结束符；</p>
<blockquote>
<p>如果使用的Navicat工具，那么在编写存储过程时，Navicat会自动设置 DELIMITER ，不需要自己再额外设置了。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> 存储过程名(<span class="keyword">IN</span><span class="operator">|</span><span class="keyword">OUT</span><span class="operator">|</span><span class="keyword">INOUT</span> 参数名 参数类型,...)</span><br><span class="line">[characteristics ...]</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">sql</span>语句<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">sql</span>语句<span class="number">2</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>IN：当前函数为输入参数；存储过程只是读取这个参数的值。没有定义参数种类时，默认为IN；</p>
<p>OUT：当前参数为输出参数；执行完毕后，执行调用的客户端可以读取这个这个参数返回的值。</p>
<p>INOUT：当前参数即可为输入参数，也可为输出参数；</p>
<p>characteristics：表示创建存储过程时指定的对存储过程的约束条件，取值如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">language</span> <span class="keyword">sql</span></span><br><span class="line"><span class="operator">|</span> [<span class="keyword">not</span>] <span class="keyword">deterministic</span></span><br><span class="line"><span class="operator">|</span> &#123;<span class="keyword">contains</span> <span class="keyword">sql</span> <span class="operator">|</span> <span class="keyword">no</span> <span class="keyword">sql</span> <span class="operator">|</span> <span class="keyword">reads</span> <span class="keyword">sql</span> data <span class="operator">|</span> <span class="keyword">modifies</span> <span class="keyword">sql</span> data&#125;</span><br><span class="line"><span class="operator">|</span> <span class="keyword">sql</span> security &#123; definer <span class="operator">|</span> invoker &#125;</span><br><span class="line"><span class="operator">|</span> comment <span class="string">&#x27;string&#x27;</span></span><br></pre></td></tr></table></figure>

<p>LANGUAGE SQL ：说明存储过程执行体是由SQL语句组成的，当前系统支持的语言为SQL。</p>
<p>[NOT] DETERMINISTIC ：指明存储过程执行的结果是否确定。DETERMINISTIC表示结果是确定 的。每次执行存储过程时，相同的输入会得到相同的输出。NOT DETERMINISTIC表示结果是不确定的，相同的输入可能得到不同的输出。如果没有指定任意一个值，默认为NOT DETERMINISTIC。</p>
<p>{ CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA } ：指明子程序使 用SQL语句的限制。</p>
<ul>
<li>CONTAINS SQL表示当前存储过程的子程序包含SQL语句，但是并不包含读写数据的SQL语句； </li>
<li>NO SQL表示当前存储过程的子程序中不包含任何SQL语句； </li>
<li>READS SQL DATA表示当前存储过程的子程序中包含读数据的SQL语句； </li>
<li>MODIFIES SQL DATA表示当前存储过程的子程序中包含写数据的SQL语句。 </li>
<li>默认情况下，系统会指定为CONTAINS SQL。</li>
</ul>
<p>SQL SECURITY { DEFINER | INVOKER } ：执行当前存储过程的权限，即指明哪些用户能够执 行当前存储过程。</p>
<ul>
<li>DEFINER 表示只有当前存储过程的创建者或者定义者才能执行当前存储过程； </li>
<li>INVOKER 表示拥有当前存储过程的访问权限的用户能够执行当前存储过程。 </li>
<li>如果没有设置相关的值，则MySQL默认指定值为DEFINER。</li>
</ul>
<p>COMMENT ‘string’ ：注释信息，可以用来描述存储过程。</p>
</blockquote>
<h2 id="存储函数"><a href="#存储函数" class="headerlink" title="存储函数"></a>存储函数</h2><p>mysql允许自定义函数，调用方式与调用mysql的系统函数一样。</p>
<p>语法格式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> 函数名(参数名 参数类型, ...)</span><br><span class="line"><span class="keyword">returns</span> 返回值类型</span><br><span class="line">[characteristics ...]</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	函数体</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"># <span class="keyword">returns</span>对函数而言是强制的，函数体必须包含一个<span class="keyword">RETURN</span> <span class="keyword">value</span>语句；</span><br><span class="line"># characteristic是创建函数时指定的对函数的约束。取值与创建存储过程时相同。</span><br></pre></td></tr></table></figure>

<p>调用：与调用mysql内部函数是一样的 </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 函数名(实参列表)</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<p>创建存储函数count_by_id()，参数传入dept_id，该函数查询dept_id部门的员工人数，并返回，数据类型 为整型。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> count_by_id(dept_id <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">RETURNS</span> <span class="type">INT</span></span><br><span class="line">	<span class="keyword">LANGUAGE</span> <span class="keyword">SQL</span></span><br><span class="line">	<span class="keyword">NOT</span> <span class="keyword">DETERMINISTIC</span></span><br><span class="line">	<span class="keyword">READS</span> <span class="keyword">SQL</span> DATA</span><br><span class="line">	<span class="keyword">SQL</span> SECURITY DEFINER</span><br><span class="line">	COMMENT <span class="string">&#x27;查询部门平均工资&#x27;</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">RETURN</span> (<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> department_id <span class="operator">=</span> dept_id);</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"># 调用</span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@dept</span>_id <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line"><span class="keyword">SELECT</span> count_by_id(<span class="variable">@dept</span>_id);</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th>关键字</th>
<th>调用语法</th>
<th>返回值</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td>存储过程</td>
<td>procedure</td>
<td>call 存储过程()</td>
<td>0个或多个</td>
<td>一般用于更新</td>
</tr>
<tr>
<td>存储函数</td>
<td>function</td>
<td>select 函数()</td>
<td>只能一个</td>
<td>一般用于查询结果为一个值并返回时</td>
</tr>
</tbody></table>
<p><strong>查看存储过程和存储函数的</strong></p>
<p><strong>创建信息：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> &#123;<span class="keyword">procedure</span> <span class="operator">|</span> <span class="keyword">function</span>&#125; 存储过程名或函数名</span><br></pre></td></tr></table></figure>

<p><strong>状态信息：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 返回子程序的特征，如数据库，名字，类型，创建者，创建、修改日期</span><br><span class="line"><span class="keyword">show</span> &#123;<span class="keyword">procedure</span> <span class="operator">|</span> <span class="keyword">function</span>&#125; status [<span class="keyword">like</span> <span class="string">&#x27;pattern&#x27;</span>]</span><br><span class="line"># [<span class="keyword">LIKE</span> <span class="string">&#x27;pattern&#x27;</span>] 匹配存储过程或函数的名称，可省略。省略时，列出数据库中存在的所有存储过程和函数的信息。</span><br></pre></td></tr></table></figure>

<p><strong>存储信息：</strong></p>
<p>MySQL中存储过程和函数的信息放在 infornation_schema 数据库下的 Routines 表中。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.Routines</span><br><span class="line">	<span class="keyword">WHERE</span> ROUTINE_NAME<span class="operator">=</span><span class="string">&#x27;存储过程或函数名&#x27;</span> [<span class="keyword">AND</span> ROUNTINE_TYPE <span class="operator">=</span> &#123;<span class="string">&#x27;PROCEDURE | FUNCTION&#x27;</span>&#125;];</span><br><span class="line"># 如果存储过程和函数有同名的情况，可以指定routine_type来指明查的是存储过程还是函数。</span><br></pre></td></tr></table></figure>



<p><strong>修改：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> &#123;<span class="keyword">PROCEDURE</span> <span class="operator">|</span> <span class="keyword">FUNCTION</span>&#125; 存储过程或函数的名 [characteristic]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>characteristic指定存储过程或函数的特性，其取值信息与创建存储过程、函数时的取值信息略有不同。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="keyword">CONTAINS</span> <span class="keyword">SQL</span> <span class="operator">|</span> <span class="keyword">NO</span> <span class="keyword">SQL</span> <span class="operator">|</span> <span class="keyword">READS</span> <span class="keyword">SQL</span> DATA <span class="operator">|</span> <span class="keyword">MODIFIES</span> <span class="keyword">SQL</span> DATA &#125; </span><br><span class="line"><span class="operator">|</span> <span class="keyword">SQL</span> SECURITY &#123; DEFINER <span class="operator">|</span> INVOKER &#125;</span><br><span class="line"><span class="operator">|</span> COMMENT <span class="string">&#x27;string&#x27;</span></span><br></pre></td></tr></table></figure>

<p>CONTAINS SQL ，表示子程序包含SQL语句，但不包含读或写数据的语句。</p>
<p>NO SQL ，表示子程序中不包含SQL语句。 </p>
<p>READS SQL DATA ，表示子程序中包含读数据的语句。 </p>
<p>MODIFIES SQL DATA ，表示子程序中包含写数据的语句。 </p>
<p>SQL SECURITY { DEFINER | INVOKER } ，指明谁有权限来执行。</p>
<ul>
<li>DEFINER ，表示只有定义者自己才能够执行。</li>
<li>INVOKER ，表示调用者可以执行。</li>
</ul>
<p>COMMENT ‘string’ ，表示注释信息。</p>
</blockquote>
<p><strong>删除：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> &#123;<span class="keyword">PROCEDURE</span> <span class="operator">|</span> <span class="keyword">FUNCTION</span>&#125; [IF <span class="keyword">EXISTS</span>] 存储过程或函数的名</span><br></pre></td></tr></table></figure>

<blockquote>
<p>IF EXISTS：如果程序或函数不存储，它可以防止发生错误，产生一个用SHOW WARNINGS查看的警告。</p>
</blockquote>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>MySQL常用列类型(数据类型)</p>
<ul>
<li>数值类型<ul>
<li>整型：tinyint（1个字节）smallint（2个字节）mediumint（3个字节）<strong>int</strong>（4个字节）bigint（8个字节）decimal[M, 0]（数值长度为M）</li>
<li>小数类型：float（单精度4字节）<strong>double</strong>（双精度8字节）**decimal[M,D]**（数值长度M，小数部分长度D；M最大65，D最大30；M被省略则默认为10，D被省略则默认为0)</li>
</ul>
</li>
<li>文本类型（字符串类型）<ul>
<li><strong>char</strong> （0~255字符，固定长）</li>
<li><strong>varchar</strong> （0<del>65535 即 最大放0</del>2^16 - 1字节，可变长，实际占用空间看存放多少数据，varchar本身需要占用1~3个字节来记录存放内容的长度）<ul>
<li>查询速度：char &gt; varchar</li>
<li>varchar 存放大小的单位写的仍是字符，但存放上下限是按字节算的</li>
</ul>
</li>
<li><strong>text</strong>  （0~ 2^16 - 1）</li>
<li>longtext （0~2^32 - 1）</li>
</ul>
</li>
<li>二进制数据类型<ul>
<li>blob （0~2^16 - 1）</li>
<li>longblob （0~2^32 - 1）</li>
</ul>
</li>
<li>日期类型<ul>
<li>date （日期 年月日   3字节）</li>
<li>time （时间 时分秒   3字节）</li>
<li><strong>datetime</strong> （年月日 时分秒  YYYY-MM-DD HH:mm:ss    8字节）</li>
<li><strong>timestamp</strong> （时间戳，会自动更新   4字节）<ul>
<li>自动更新时间戳为当前时间：login_time（列名） TIMESTAMP（数据类型：时间戳） NOT NULL DEFAULT CURRENT_TIMESTAMP  ON UPDATE CURRENT_TIMESTAMP</li>
</ul>
</li>
<li>year (年   1字节)</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203211046909.png" alt="image-20220321104640615"></p>
<p>常用的类型介绍：</p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203211047881.png" alt="image-20220321104728683"></p>
<blockquote>
<p>MySQL在执行建表语句时，将id字段的类型默认设置为int(11)，这里的11是指int类型的显示宽度，默认的显示宽度为11。</p>
</blockquote>
<p>使用建议：</p>
<ul>
<li><p>任何字段如果为非负数，应该加unsigned</p>
</li>
<li><p>整数：int</p>
</li>
<li><p>小数：decimal，如果存储的数据范围超过，建议将数据拆成整数和小数并分开存储。</p>
</li>
<li><p>日期时间：datetime</p>
</li>
<li><p>字符串：</p>
<ul>
<li>如果存储的字符串长度几乎相等，使用char定长字符串类型；</li>
<li>varchar不预先分配存储空间，长度不要超过5000，如果超过，应该定义为text，并独立出来一张表，用主键来对应，避免影响其他字段索引效率。</li>
</ul>
</li>
</ul>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h2><p>变量由系统定义，属于服务器层面。启动MySQL服务，生成MySQL服务实例期间， MySQL将为MySQL服务器内存中的系统变量赋值，这些系统变量定义了当前MySQL服务实例的属性、特征。</p>
<blockquote>
<p>系统变量的值大都是 编译MySQL时参数的默认值，或配置文件(如 .ini)中的参数值。</p>
</blockquote>
<ul>
<li><p><strong>global 全局系统变量</strong>，也简称全局变量</p>
</li>
<li><p><strong>session 会话系统变量</strong>，也可称 local变量，</p>
</li>
</ul>
<blockquote>
<p>如果没有加global关键字，则默认为会话级别。</p>
<p>静态变量属于特殊的全局系统变量。</p>
</blockquote>
<p>每个客户机功连接MySQL服务器后，都会产生与之对应的会话。</p>
<p>会话期间，MySQL服务实例 会在MySQL服务器内存中生成与该会话对应的会话系统变量，这些会话系统变量的初始值是全局系统变量值的复制。</p>
<ul>
<li>全局系统变量针对于所有会话（连接）有效，但不能 跨重启 (即重启服务);</li>
<li>修改会话变量仅影响当前的会话&#x2F;连接， 不会影响其他会话的同一会话系统变量的值。</li>
<li>修改全局系统变量的值会导致 同一会话系统的其他会话 的全局系统变量改变。</li>
</ul>
<p>查看系统变量：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 查看所有全局变量</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> VARIABLES;</span><br><span class="line"># 查看所有会话变量</span><br><span class="line"><span class="keyword">SHOW</span> SESSION VARIABLES;</span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES;</span><br><span class="line"></span><br><span class="line"># 查看满足条件的系统<span class="operator">/</span>会话变量</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%标识符%&#x27;</span>;</span><br><span class="line"><span class="keyword">SHOW</span> SESSION VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%标识符%&#x27;</span></span><br><span class="line"># 例如:</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;ADMIN_%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># 查看指定的系统变量的值</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@global</span>.变量名;</span><br><span class="line"></span><br><span class="line"># 查看指定的会话变量的值</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@session</span>.变量名;</span><br><span class="line"><span class="keyword">SELECT</span> @@变量名;</span><br></pre></td></tr></table></figure>

<p>修改系统变量的值：</p>
<p>方法1：修改MySQL配置文件，继而修改MySQL系统变量的值（需要重启MySQL服务）</p>
<p>方法2：使用 set命令 重新设置系统变量的值</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#为某个系统变量赋值</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@global</span>.变量名<span class="operator">=</span>变量值;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> 变量名<span class="operator">=</span>变量值;</span><br><span class="line"></span><br><span class="line">#为某个会话变量赋值</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@session</span>.变量名<span class="operator">=</span>变量值;</span><br><span class="line"><span class="keyword">SET</span> SESSION 变量名<span class="operator">=</span>变量值;</span><br><span class="line"></span><br><span class="line"># 例如：</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@global</span>.autocommit;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> autocommit<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> max_connections<span class="operator">=</span><span class="number">1000</span>;</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@global</span>.max_connections;</span><br></pre></td></tr></table></figure>

<hr>
<p>MySQL8.0新特性：全局变量的持久化</p>
<p>使用 set global 语句设置的变量值只会 临时生效，数据库重启后又变成默认值。</p>
<p>而使用 set persist 命令，会将该命令的配置保存到数据目录下的musql-auto.cnf文件中，下次数据库重启时会读取该文件，用其中的配置来覆盖默认的配置文件。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 例：设服务器最大连接数为1000</span></span><br><span class="line"><span class="keyword">SET</span> PERSIST <span class="keyword">global</span> max_connections <span class="operator">=</span> <span class="number">1000</span>;</span><br></pre></td></tr></table></figure>







<h2 id="用户变量"><a href="#用户变量" class="headerlink" title="用户变量"></a>用户变量</h2><p>mysql中的用户变量以 一个 @ 开头，分为 会话用户变量和局部变量。</p>
<ul>
<li>会话用户变量：作用域和会话变量一样，只对 当前连接 会话有效。</li>
<li>局部变量：只在 BEGIN 和 END 语句块中有效。局部变量只能在 存储过程和函数 中使用。</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>作用域</th>
<th>定义位置</th>
<th>语法</th>
</tr>
</thead>
<tbody><tr>
<td>会话用户变量</td>
<td>当前会话</td>
<td>会话的任何地方</td>
<td>加@符号，不用指定类型</td>
</tr>
<tr>
<td>局部变量</td>
<td>定义它的begin end中</td>
<td>begin end的第一句话</td>
<td>一般不加@，需指定类型</td>
</tr>
</tbody></table>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 会话用户变量的定义</span><br><span class="line">#方式<span class="number">1</span>：“<span class="operator">=</span>”或“:<span class="operator">=</span>”</span><br><span class="line"><span class="keyword">SET</span> @用户变量 <span class="operator">=</span> 值;</span><br><span class="line"><span class="keyword">SET</span> @用户变量 :<span class="operator">=</span> 值;</span><br><span class="line"></span><br><span class="line">#方式<span class="number">2</span>：“:<span class="operator">=</span>” 或 <span class="keyword">INTO</span>关键字</span><br><span class="line"><span class="keyword">SELECT</span> @用户变量 :<span class="operator">=</span> 表达式 [<span class="keyword">FROM</span> 等子句];</span><br><span class="line"><span class="keyword">SELECT</span> 表达式 <span class="keyword">INTO</span> @用户变量 [<span class="keyword">FROM</span> 等子句];</span><br><span class="line"></span><br><span class="line"># 查看</span><br><span class="line"><span class="keyword">SELECT</span> @用户变量</span><br><span class="line"></span><br><span class="line"># 例：</span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="variable">@a</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="variable">@num</span> :<span class="operator">=</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> employee;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="variable">@num</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) <span class="keyword">INTO</span> <span class="variable">@avgSalary</span> <span class="keyword">FROM</span> employee;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="variable">@avgSalary</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="variable">@big</span>;   <span class="comment">-- 查看未声明变量时，得到NULL值</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"># 局部变量 的定义 <span class="keyword">declare</span>只能放在begin...end中的第一句</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	# 声明</span><br><span class="line">	<span class="keyword">DECLARE</span> 变量<span class="number">1</span> 变量数据类型 [<span class="keyword">DEFAULT</span> 变量默认值];  <span class="comment">-- 默认初始值是NULL</span></span><br><span class="line">	<span class="keyword">DECLARE</span> 变量<span class="number">2</span>,变量<span class="number">3</span>,... 变量数据类型 [<span class="keyword">DEFAULT</span> 变量默认值];</span><br><span class="line">	</span><br><span class="line">	# 赋值</span><br><span class="line">	<span class="keyword">SET</span> 变量名<span class="number">1</span> <span class="operator">=</span> 值;</span><br><span class="line">	<span class="keyword">SET</span> 变量名<span class="number">1</span> :<span class="operator">=</span> 值;</span><br><span class="line">	<span class="keyword">SELECT</span> 值 <span class="keyword">INTO</span> 变量名<span class="number">2</span> [<span class="keyword">FROM</span> 子句];</span><br><span class="line">	<span class="keyword">SELECT</span> 字段名或表达式 <span class="keyword">INTO</span> 变量名<span class="number">2</span> <span class="keyword">FROM</span> 表;</span><br><span class="line">	</span><br><span class="line">	# 查看</span><br><span class="line">	<span class="keyword">SELECT</span> 变量<span class="number">1</span>,变量<span class="number">2</span>,变量<span class="number">3</span>;</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"></span><br><span class="line"># 例：</span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> set_value()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">DECLARE</span> emp_name <span class="type">VARCHAR</span>(<span class="number">25</span>);</span><br><span class="line">	<span class="keyword">DECLARE</span> sal <span class="keyword">DOUBLE</span>(<span class="number">10</span>,<span class="number">2</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">SELECT</span> last_name,salary <span class="keyword">INTO</span> emp_name,sal</span><br><span class="line">		<span class="keyword">FROM</span> employees</span><br><span class="line">		<span class="keyword">WHERE</span> employee_id <span class="operator">=</span> <span class="number">102</span>;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">SELECT</span> emp_name,sal;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line">DELIMITER ; </span><br></pre></td></tr></table></figure>





<h1 id="处理错误"><a href="#处理错误" class="headerlink" title="处理错误"></a>处理错误</h1><p><strong>定义条件</strong>：事先定义程序执行过程中可能遇到的问题；</p>
<p><strong>处理程序</strong>：定义了在遇到问题时应当采取的处理方式，并且保证存储过程或函数在遇到警告或错误时能继续执行。——增强了处理问题的能力，避免程序异常停止运行。</p>
<blockquote>
<p>定义条件和处理程序在存储过程、存储函数中都是支持的。</p>
</blockquote>
<p>在存储过程中未定义条件和处理程序，且当存储过程中执行的SQL语句报错时，MySQL数据库会抛出错误，并退出当前SQL逻辑， 不再向下继续执行。</p>
<h3 id="定义条件"><a href="#定义条件" class="headerlink" title="定义条件"></a>定义条件</h3><p>定义条件就是给MySQL中的错误码 命名，它将一个错误名字和指定的错误条件关联起来。这个名字随后被用在定义处理程序的 declare handler 语句中。</p>
<p>语法格式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> 错误名称 <span class="keyword">condition</span> <span class="keyword">for</span> 错误码(或错误条件)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>错误码的说明：</p>
<p>MySQL_error_code 和 sqlstate_value 都可以表示MySQL的错误。</p>
<ul>
<li>MySQL_error_code是数值类型错误代码。 </li>
<li>sqlstate_value是长度为5的字符串类型错误代码。</li>
</ul>
<p>例如：</p>
<p>在ERROR 1418 (HY000)中，1418是MySQL_error_code，’HY000’是sqlstate_value。 </p>
<p>在ERROR 1142（42000）中，1142是MySQL_error_code，’42000’是sqlstate_value。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 例: 给违反非空约束的错误类型“ERROR <span class="number">1048</span>(<span class="number">23000</span>)”定义</span><br><span class="line">#使用MySQL_error_code</span><br><span class="line"><span class="keyword">DECLARE</span> Field_Not_Be_NULL <span class="keyword">CONDITION</span> <span class="keyword">FOR</span> <span class="number">1048</span>;</span><br><span class="line">#使用sqlstate_value</span><br><span class="line"><span class="keyword">DECLARE</span> Field_Not_Be_NULL <span class="keyword">CONDITION</span> <span class="keyword">FOR</span> <span class="keyword">SQLSTATE</span> <span class="string">&#x27;23000&#x27;</span>;</span><br></pre></td></tr></table></figure>



<h3 id="定义处理程序"><a href="#定义处理程序" class="headerlink" title="定义处理程序"></a>定义处理程序</h3><p>为SQL执行过程中发生的某种类型的错误定义特殊的处理程序。</p>
<p>语法格式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> 处理方式 HANDLER <span class="keyword">FOR</span> 错误类型 处理语句</span><br></pre></td></tr></table></figure>

<p>处理方式有三种：continue，exit，undo</p>
<ul>
<li>CONTINUE：遇到错误不处理，继续执行；</li>
<li>EXIT：遇到错误马上退出；</li>
<li>UNDO：遇到错误后撤回之前的操作，MySQL中暂时不支持。</li>
</ul>
<p>错误类型：</p>
<ul>
<li>SQLSTATE ‘字符串错误码’ ：表示长度为5的sqlstate_value类型的错误代码； </li>
<li>MySQL_error_code ：匹配数值类型错误代码； </li>
<li>错误名称 ：表示DECLARE … CONDITION定义的错误条件名称。 </li>
<li>SQLWARNING ：匹配所有以01开头的SQLSTATE错误代码； </li>
<li>NOT FOUND ：匹配所有以02开头的SQLSTATE错误代码； </li>
<li>SQLEXCEPTION ：匹配所有没有被SQLWARNING或NOT FOUND捕获的SQLSTATE错误代码；</li>
</ul>
<p>处理语句：可以是“set 变量 &#x3D; 值”这样简单的语句，也可以是使用“begin….end”的复合语句。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 定义处理程序的几种方式举例：</span><br><span class="line">#方法<span class="number">1</span>：捕获sqlstate_value</span><br><span class="line"><span class="keyword">DECLARE</span> CONTINUE HANDLER <span class="keyword">FOR</span> <span class="keyword">SQLSTATE</span> <span class="string">&#x27;42S02&#x27;</span> <span class="keyword">SET</span> <span class="variable">@info</span> <span class="operator">=</span> <span class="string">&#x27;NO_SUCH_TABLE&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#方法<span class="number">2</span>：捕获mysql_error_value</span><br><span class="line"><span class="keyword">DECLARE</span> CONTINUE HANDLER <span class="keyword">FOR</span> <span class="number">1146</span> <span class="keyword">SET</span> <span class="variable">@info</span> <span class="operator">=</span> <span class="string">&#x27;NO_SUCH_TABLE&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#方法<span class="number">3</span>：先定义条件，再调用</span><br><span class="line"><span class="keyword">DECLARE</span> no_such_table <span class="keyword">CONDITION</span> <span class="keyword">FOR</span> <span class="number">1146</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> CONTINUE HANDLER <span class="keyword">FOR</span> NO_SUCH_TABLE <span class="keyword">SET</span> <span class="variable">@info</span> <span class="operator">=</span> <span class="string">&#x27;NO_SUCH_TABLE&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#方法<span class="number">4</span>：使用<span class="keyword">SQLWARNING</span></span><br><span class="line"><span class="keyword">DECLARE</span> EXIT HANDLER <span class="keyword">FOR</span> <span class="keyword">SQLWARNING</span> <span class="keyword">SET</span> <span class="variable">@info</span> <span class="operator">=</span> <span class="string">&#x27;ERROR&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#方法<span class="number">5</span>：使用<span class="keyword">NOT</span> FOUND</span><br><span class="line"><span class="keyword">DECLARE</span> EXIT HANDLER <span class="keyword">FOR</span> <span class="keyword">NOT</span> FOUND <span class="keyword">SET</span> <span class="variable">@info</span> <span class="operator">=</span> <span class="string">&#x27;NO_SUCH_TABLE&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#方法<span class="number">6</span>：使用<span class="keyword">SQLEXCEPTION</span></span><br><span class="line"><span class="keyword">DECLARE</span> EXIT HANDLER <span class="keyword">FOR</span> <span class="keyword">SQLEXCEPTION</span> <span class="keyword">SET</span> <span class="variable">@info</span> <span class="operator">=</span> <span class="string">&#x27;ERROR&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<p>创建一个名称为“InsertDataWithCondition”的存储过程：在存储过程中，定义处理程序，捕获sqlstate_value值，当遇到sqlstate_value值为23000（重复条目错误）时，执行EXIT操 作，并且将@proc_value的值设置为-1。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> InsertDataWithCondition()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">DECLARE</span> duplicate_entry <span class="keyword">CONDITION</span> <span class="keyword">FOR</span> <span class="keyword">SQLSTATE</span> <span class="string">&#x27;23000&#x27;</span> ;</span><br><span class="line">	<span class="keyword">DECLARE</span> EXIT HANDLER <span class="keyword">FOR</span> duplicate_entry <span class="keyword">SET</span> <span class="variable">@proc</span>_value <span class="operator">=</span> <span class="number">-1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">SET</span> <span class="variable">@x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">INSERT</span> <span class="keyword">INTO</span> departments(department_name) <span class="keyword">VALUES</span>(<span class="string">&#x27;测试&#x27;</span>);</span><br><span class="line">	<span class="keyword">SET</span> <span class="variable">@x</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">INSERT</span> <span class="keyword">INTO</span> departments(department_name) <span class="keyword">VALUES</span>(<span class="string">&#x27;测试&#x27;</span>);</span><br><span class="line">	<span class="keyword">SET</span> <span class="variable">@x</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>







<h1 id="流程控制与游标"><a href="#流程控制与游标" class="headerlink" title="流程控制与游标"></a>流程控制与游标</h1><p>流程控制：控制存储过程中sql语句的执行顺序。分别有三大类：顺序结构，分支结构，循环结构。</p>
<p>流程控制语句（只能用于存储程序）：</p>
<ul>
<li>条件判断语句：if 和 case语句</li>
<li>循环语句：loop，while，repeat语句</li>
<li>跳转语句：iterate 和 leave语句</li>
</ul>
<p><strong>分支结构—— IF</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># if</span><br><span class="line">IF 表达式<span class="number">1</span> <span class="keyword">THEN</span> 操作<span class="number">1</span></span><br><span class="line">[ELSEIF 表达式<span class="number">2</span> <span class="keyword">THEN</span> 操作<span class="number">2</span>]....</span><br><span class="line">[<span class="keyword">ELSE</span> 操作n]</span><br><span class="line"><span class="keyword">END</span> IF</span><br><span class="line"></span><br><span class="line"># 例：</span><br><span class="line">IF val <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br><span class="line">	<span class="keyword">THEN</span> <span class="keyword">SELECT</span> <span class="string">&#x27;val is null&#x27;</span>;</span><br><span class="line"><span class="keyword">ELSE</span> <span class="keyword">SELECT</span> <span class="string">&#x27;val is not null&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span> IF;</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> update_salary_by_eid2(<span class="keyword">IN</span> emp_id <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">DECLARE</span> emp_salary <span class="keyword">DOUBLE</span>;</span><br><span class="line">	<span class="keyword">DECLARE</span> hire_year <span class="keyword">DOUBLE</span>;</span><br><span class="line">	<span class="keyword">SELECT</span> salary <span class="keyword">INTO</span> emp_salary <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> employee_id <span class="operator">=</span> emp_id;</span><br><span class="line">	<span class="keyword">SELECT</span> DATEDIFF(CURDATE(),hire_date)<span class="operator">/</span><span class="number">365</span> <span class="keyword">INTO</span> hire_year <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> employee_id <span class="operator">=</span> emp_id;	<span class="comment">-- DATEDIFF()判断日期差，curdate()获取当前日期</span></span><br><span class="line">	IF emp_salary <span class="operator">&lt;</span> <span class="number">8000</span> <span class="keyword">AND</span> hire_year <span class="operator">&gt;</span> <span class="number">5</span></span><br><span class="line">		<span class="keyword">THEN</span> <span class="keyword">UPDATE</span> employees <span class="keyword">SET</span> salary <span class="operator">=</span> salary <span class="operator">+</span> <span class="number">500</span> <span class="keyword">WHERE</span> employee_id <span class="operator">=</span></span><br><span class="line">emp_id;</span><br><span class="line">	<span class="keyword">ELSE</span></span><br><span class="line">		<span class="keyword">UPDATE</span> employees <span class="keyword">SET</span> salary <span class="operator">=</span> salary <span class="operator">+</span> <span class="number">100</span> <span class="keyword">WHERE</span> employee_id <span class="operator">=</span> emp_id;</span><br><span class="line">	<span class="keyword">END</span> IF;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<p><strong>分支结构——CASE</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">case</span></span><br><span class="line"># <span class="number">1.</span>类似于switch</span><br><span class="line"><span class="keyword">CASE</span> 表达式</span><br><span class="line"><span class="keyword">WHEN</span> 值<span class="number">1</span> <span class="keyword">THEN</span> 结果<span class="number">1</span>或语句<span class="number">1</span> <span class="comment">-- 如果是语句，需要加分号</span></span><br><span class="line"><span class="keyword">WHEN</span> 值<span class="number">2</span> <span class="keyword">THEN</span> 结果<span class="number">2</span>或语句<span class="number">2</span> <span class="comment">-- 如果是语句，需要加分号</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">ELSE</span> 结果n或语句n <span class="comment">-- 如果是语句，需要加分号</span></span><br><span class="line"><span class="keyword">END</span> [<span class="keyword">case</span>] <span class="comment">-- 如果是放在begin end中需要加上case，如果放在select后面不需要</span></span><br><span class="line"></span><br><span class="line"># <span class="number">2.</span>类似于多重if</span><br><span class="line"><span class="keyword">CASE</span></span><br><span class="line"><span class="keyword">WHEN</span> 条件<span class="number">1</span> <span class="keyword">THEN</span> 结果<span class="number">1</span>或语句<span class="number">1</span> <span class="comment">-- 如果是语句，需要加分号</span></span><br><span class="line"><span class="keyword">WHEN</span> 条件<span class="number">2</span> <span class="keyword">THEN</span> 结果<span class="number">2</span>或语句<span class="number">2</span> <span class="comment">-- 如果是语句，需要加分号</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">ELSE</span> 结果n或语句n <span class="comment">-- 如果是语句，需要加分号</span></span><br><span class="line"><span class="keyword">END</span> [<span class="keyword">case</span>] <span class="comment">-- 如果是放在begin end中需要加上case，如果放在select后面不需要</span></span><br></pre></td></tr></table></figure>

<p><strong>循环结构——LOOP</strong></p>
<p>LOOP内的语句一直重复执行直到循环被退出（使用LEAVE子句）。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[loop_label:] LOOP</span><br><span class="line">	循环执行的语句</span><br><span class="line"><span class="keyword">END</span> LOOP [loop_label]</span><br><span class="line"><span class="comment">-- loop_label表示LOOP语句的标注名称，参数可省略。</span></span><br></pre></td></tr></table></figure>

<p>示例：</p>
<p>涨工资—— 声明存储过程 “update_salary_loop()”，声明OUT参数num，输出循环次数。存储过程中实现循环给大家涨薪，薪资涨为 原来的1.1倍。直到全公司的平均薪资达到12000结束。并统计循环次数。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> update_salary_loop(<span class="keyword">OUT</span> num <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">DECLARE</span> avg_salary <span class="keyword">DOUBLE</span>;</span><br><span class="line">	<span class="keyword">DECLARE</span> loop_count <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) <span class="keyword">INTO</span> avg_salary <span class="keyword">FROM</span> employees;</span><br><span class="line">	</span><br><span class="line">	label_loop:LOOP</span><br><span class="line">		IF avg_salary <span class="operator">&gt;=</span> <span class="number">12000</span> <span class="keyword">THEN</span> LEAVE label_loop;</span><br><span class="line">		<span class="keyword">END</span> IF;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">UPDATE</span> employees <span class="keyword">SET</span> salary <span class="operator">=</span> salary <span class="operator">*</span> <span class="number">1.1</span>;</span><br><span class="line">		<span class="keyword">SET</span> loop_count <span class="operator">=</span> loop_count <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) <span class="keyword">INTO</span> avg_salary <span class="keyword">FROM</span> employees;</span><br><span class="line">	<span class="keyword">END</span> LOOP label_loop;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">SET</span> num <span class="operator">=</span> loop_count;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<p><strong>循环结构——WHILE</strong></p>
<p>WHILE语句创建一个带条件判断的循环过程。WHILE在执行语句执行时，先对指定的表达式进行判断，如 果为真，就执行循环内的语句，否则退出循环。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[while_label:] WHILE 循环条件 DO</span><br><span class="line">	循环体</span><br><span class="line"><span class="keyword">END</span> WHILE [while_label];</span><br></pre></td></tr></table></figure>

<p><strong>循环结构——REPEAT</strong></p>
<p>REPEAT语句创建一个带条件判断的循环过程。与WHILE循环不同的是，REPEAT 循环首先会执行一次循环，然后在 UNTIL 中进行表达式的判断，如果满足条件就退出 。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[repeat_label:] REPEAT</span><br><span class="line">	循环体</span><br><span class="line">UNTIL 结束循环的条件表达式</span><br><span class="line"><span class="keyword">END</span> REPEAT [repeat_label]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>三种循环的对比：</p>
<ul>
<li><p>都可以省略名称，但如果循环中添加了循环控制语句（LEAVE或ITERATE）则必须添加名称。</p>
</li>
<li><p>LOOP：一般用于实现简单的”死”循环 </p>
<p>WHILE：先判断后执行 </p>
<p>REPEAT：先执行后判断，无条件至少执行一次</p>
</li>
</ul>
</blockquote>
<p><strong>跳转语句——LEAVE</strong></p>
<p>LEAVE语句：可以用在循环语句内，或者以 BEGIN 和 END 包裹起来的程序体内，表示跳出循环或者跳出 程序体的操作。(类似于编程语言的break)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LEAVE 标记名</span><br></pre></td></tr></table></figure>

<p><strong>跳转语句——ITERATE</strong></p>
<p>iterate语句只能用在循环语句（LOOP、REPEAT和WHILE语句）内，表示重新开始循环，将执行顺序转到语句段开头处。（类似于编程语言的continue）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ITERATE label</span><br></pre></td></tr></table></figure>



<h2 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h2><p>游标提供一种灵活的操作方式，能够对结果集中的每一条记录 进行定位，并对指向的记录中的数据进行操作的数据结构。</p>
<blockquote>
<p>在SQL中，游标是一种临时的数据库对象，可以指向存储在数据库表中的数据行指针。即<strong>充当了指针的作用</strong>。</p>
<p>游标让 面向集合的SQL语言有了面向过程开发的能力。</p>
</blockquote>
<blockquote>
<p>一些性能问题：</p>
<p>游标可以在存储程序中使用，效率高，程序也更加简洁，比在应用层实现相同的功能要好。</p>
<p>但在使用游标的过程中，会对数据行进行 加锁 ，这样在业务并发量大的时候，不仅会影响业务之间的效率，还会消耗系统资源 ，造成内存不足，这是因为游标是在内存中进 行的处理。</p>
<p>所以要在用完后及时关闭，这样才能提高系统整体效率。</p>
</blockquote>
<p>使用步骤：</p>
<p>游标必须在 声明处理程序之前 被声明，且 变量和条件必须在声明游标&#x2F;处理程序之前 被声明。</p>
<ul>
<li><p>第一步：声明游标</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 适用于MySQL,<span class="keyword">SQL</span> Server,DB2 和 MariaDB</span><br><span class="line"><span class="keyword">DECLARE</span> 游标名 <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> 查询语句<span class="operator">/</span>结果集</span><br><span class="line"></span><br><span class="line"># 适用于Oricle,PostgreSQL</span><br><span class="line"><span class="keyword">DECLARE</span> 有标明 <span class="keyword">CURSOR</span> <span class="keyword">IS</span> 查询语句<span class="operator">/</span>结果集</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二步：打开游标</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">OPEN</span> 游标名</span><br></pre></td></tr></table></figure>

<p>打开游标时， SELECT 语句的查询结果集就会送到游标工作区，为后面游标的 <u>逐条读取</u> 结果集中的记录做准备。</p>
</li>
<li><p>第三步：使用游标（从游标中取得数据）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FETCH</span> 游标名 <span class="keyword">INTO</span> 变量名[,变量名...]</span><br></pre></td></tr></table></figure>

<p>将游标读取到的行数据 保存到变量名中，然后指针指向下一行。</p>
<blockquote>
<p>查询结果集的字段数，必须与into后的变量数一致。</p>
</blockquote>
</li>
<li><p>第四步：关闭游标</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CLOSE</span> 游标名</span><br></pre></td></tr></table></figure>

<p>游标会占用系统资源，不关闭的话，会保持到存储过程结束。</p>
</li>
</ul>
<p>示例：</p>
<p>创建存储过程“get_count_by_limit_total_salary()”，声明IN参数 limit_total_salary，DOUBLE类型；声明OUT参数total_count，INT类型。函数的功能可以实现累加薪资最高的几个员工的薪资值，直到薪资总和 达到limit_total_salary参数的值，返回累加的人数给total_count。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> get_count_by_limit_total_salary(<span class="keyword">IN</span> limit_total_salary <span class="keyword">DOUBLE</span>,<span class="keyword">OUT</span></span><br><span class="line">total_count <span class="type">INT</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">DECLARE</span> sum_salary <span class="keyword">DOUBLE</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>; #记录累加的总工资</span><br><span class="line">	<span class="keyword">DECLARE</span> cursor_salary <span class="keyword">DOUBLE</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>; #记录某一个工资值</span><br><span class="line">	<span class="keyword">DECLARE</span> emp_count <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>; #记录循环个数</span><br><span class="line">	#定义游标</span><br><span class="line">	<span class="keyword">DECLARE</span> emp_cursor <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> <span class="keyword">SELECT</span> salary <span class="keyword">FROM</span> employees <span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span>;</span><br><span class="line">	#打开游标</span><br><span class="line">	<span class="keyword">OPEN</span> emp_cursor;</span><br><span class="line">	</span><br><span class="line">	REPEAT</span><br><span class="line">		#使用游标（从游标中获取数据）</span><br><span class="line">		<span class="keyword">FETCH</span> emp_cursor <span class="keyword">INTO</span> cursor_salary;</span><br><span class="line">		<span class="keyword">SET</span> sum_salary <span class="operator">=</span> sum_salary <span class="operator">+</span> cursor_salary;</span><br><span class="line">		<span class="keyword">SET</span> emp_count <span class="operator">=</span> emp_count <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">		UNTIL sum_salary <span class="operator">&gt;=</span> limit_total_salary</span><br><span class="line">	<span class="keyword">END</span> REPEAT;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">SET</span> total_count <span class="operator">=</span> emp_count;</span><br><span class="line">	#关闭游标</span><br><span class="line">	<span class="keyword">CLOSE</span> emp_cursor;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>



<h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><p>触发器是由事件 来触发某个操作，这些事件包括 INSERT 、 UPDATE 、 DELETE 事件。</p>
<p>如果定义了触发程序，当数据库执行这些语句时候，就相当于事件发生 了，就会 自动 激发触发器执行相应的操作。</p>
<p>当对数据表中的数据执行插入、更新和删除操作，需要自动执行一些数据库逻辑时，可以使用触发器来 实现。</p>
<p>优点：</p>
<ul>
<li>可以确保数据的完整性；—— 比如一张表的修改会影响其他表的数据，则使用触发器就可以同步多个表了。</li>
<li>可以记录操作日志；—— 利用触发器，可以具体记录什么时间发生了什么。</li>
<li>操作数据前对数据进行合法性检查；</li>
</ul>
<p>缺点：</p>
<ul>
<li>可读性差；—— 因为 触发器存储在数据库中，且由事件驱动，这意味着触发器可以不受应用层的控制。使得触发器发生错误时可能难以发现。</li>
<li>相关数据的变更，可能导致触发器出错；—— 特别是表结构的变更，都可能导致触发器的出错。</li>
</ul>
<p><strong>创建：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> 触发器名称</span><br><span class="line">&#123;BEFORE<span class="operator">|</span>AFTER&#125; &#123;<span class="keyword">INSERT</span><span class="operator">|</span><span class="keyword">UPDATE</span><span class="operator">|</span><span class="keyword">DELETE</span>&#125; <span class="keyword">ON</span> 表名</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line">触发器执行的语句快;</span><br><span class="line"> <span class="comment">-- 表名：是触发器监控的对象;  </span></span><br><span class="line"> <span class="comment">-- before|after:触发的事件，before指在事件之前触发，after指在事件之后触发</span></span><br><span class="line"> <span class="comment">-- INSERT|UPDATE|DELETE ：表示触发的事件。</span></span><br><span class="line"> 	<span class="comment">-- INSERT 表示插入记录时触发；</span></span><br><span class="line">	<span class="comment">-- UPDATE 表示更新记录时触发；</span></span><br><span class="line"> 	<span class="comment">-- DELETE 表示删除记录时触发。 </span></span><br><span class="line"> <span class="comment">-- 触发器执行的语句块：可以是单条SQL语句，也可以是由BEGIN…END结构组成的复合语句块。</span></span><br></pre></td></tr></table></figure>

<p>示例：</p>
<p>定义触发器“salary_check_trigger”，基于员表“employees”的INSERT事件，在INSERT之前检查 将要添加的新员工薪资是否大于他领导的薪资，如果大于领导薪资，则报sqlstate_value为’HY000’的错 误，从而使得添加失败。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> salary_check_trigger</span><br><span class="line">BEFORE <span class="keyword">INSERT</span> <span class="keyword">ON</span> employees <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">DECLARE</span> mgrsalary <span class="keyword">DOUBLE</span>;</span><br><span class="line">	<span class="keyword">SELECT</span> salary <span class="keyword">INTO</span> mgrsalary <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> employee_id <span class="operator">=</span> NEW.manager_id;</span><br><span class="line">	</span><br><span class="line">	IF NEW.salary <span class="operator">&gt;</span> mgrsalary <span class="keyword">THEN</span></span><br><span class="line">		SIGNAL <span class="keyword">SQLSTATE</span> <span class="string">&#x27;HY000&#x27;</span> <span class="keyword">SET</span> MESSAGE_TEXT <span class="operator">=</span> <span class="string">&#x27;薪资高于领导薪资错误&#x27;</span>;</span><br><span class="line">	<span class="keyword">END</span> IF;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在触发器的执行语句块中，可以使用 NEW. 指代被监听的表发生添加或修改的那条记录；</p>
<p>要自定义错误，则使用以下格式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SIGNAL <span class="keyword">SQLSTATE</span> <span class="string">&#x27;HY000&#x27;</span> <span class="keyword">SET</span> MESSAGE_TEXT <span class="operator">=</span> <span class="string">&#x27;...&#x27;</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>查看：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 语句结尾不加；加\G，数据显示较清晰直观，但SQLyog不识别</span></span><br><span class="line"># 查看当前数据库的所有触发器的定义</span><br><span class="line"><span class="keyword">SHOW</span> TRIGGERS</span><br><span class="line"></span><br><span class="line"># 查看当前数据库中某个触发器的定义</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> 触发器名</span><br><span class="line"></span><br><span class="line"># 从系统库information_schema的TRIGGERS表中查询所有触发器的信息</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.TRIGGERS;</span><br></pre></td></tr></table></figure>

<p><strong>删除：</strong></p>
<p>触发器也是数据库对象，所以也用DROP语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> IF <span class="keyword">EXISTS</span> 触发器名称;</span><br></pre></td></tr></table></figure>









<h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><p>JDBC是java提供的一套用于数据库操作的接口API，不同的数据库厂商会针对这套接口，提供不同实现。</p>
<p>JDBC 为访问不同的数据库提供了统一的接口，为使用者屏蔽了细节问题（JDBC统一和规范了应用程序和数据库的连接，执行SQL语句，并得到返回结果等操作）；</p>
<p>使用JDBC可以连接任何提供了JDBC驱动程序的数据库系。</p>
<h3 id="JDBC程序编写步骤"><a href="#JDBC程序编写步骤" class="headerlink" title="JDBC程序编写步骤"></a>JDBC程序编写步骤</h3><ol>
<li>注册驱动 – 加载Driver类</li>
<li>获取连接 – 得到Connection</li>
<li>执行增删改查 – 发送SQL给mysql执行</li>
<li>释放资源 – 关闭相关连接</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">       <span class="comment">// 前置工作: 在项目下创建一个文件夹比如 libs</span></span><br><span class="line">       <span class="comment">// 将 mysql.jar 拷贝到该目录下，并将其添加为库</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//1. 注册驱动</span></span><br><span class="line">       <span class="type">Driver</span> <span class="variable">driver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Driver</span>();</span><br><span class="line"></span><br><span class="line">       <span class="comment">//2. 得到连接:</span></span><br><span class="line">       <span class="comment">// jdbc:mysql:// 规定好协议，通过jdbc方式连接mysql</span></span><br><span class="line">       <span class="comment">// localhost  指主机，可以是ip地址</span></span><br><span class="line">       <span class="comment">// 3306 表示mysql监听的端口</span></span><br><span class="line">       <span class="comment">// zzc_db02 连接到mysql的哪个数据库</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/zzc_db02&quot;</span>;</span><br><span class="line">       <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">       properties.setProperty(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br><span class="line">       properties.setProperty(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;zzc&quot;</span>);</span><br><span class="line">       <span class="type">Connection</span> <span class="variable">connect</span> <span class="operator">=</span> driver.connect(url, properties);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//3. 执行sql</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;delete from actor where id = 1&quot;</span>;</span><br><span class="line">       <span class="comment">//statement 用于执行静态SQL语句并返回其生成的结果的对象</span></span><br><span class="line">       <span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> connect.createStatement();</span><br><span class="line">       <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> statement.executeUpdate(sql);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//4. 关闭连接资源</span></span><br><span class="line">       statement.close();</span><br><span class="line">       connect.close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>





<h3 id="获取数据库连接"><a href="#获取数据库连接" class="headerlink" title="获取数据库连接"></a>获取数据库连接</h3><p>获取数据库连接的5种方法，常用方法4，5：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式 1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect01</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="type">Driver</span> <span class="variable">driver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Driver</span>(); <span class="comment">//创建 driver 对象</span></span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/hsp_db02&quot;</span>;</span><br><span class="line">    <span class="comment">//将 用户名和密码放入到 Properties 对象</span></span><br><span class="line">    <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    <span class="comment">//说明 user 和 password 是规定好，后面的值根据实际情况写</span></span><br><span class="line">    properties.setProperty(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;root&quot;</span>);<span class="comment">// 用户</span></span><br><span class="line">    properties.setProperty(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;zzc&quot;</span>); <span class="comment">//密码</span></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connect</span> <span class="operator">=</span> driver.connect(url, properties);</span><br><span class="line">    System.out.println(connect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式 2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect02</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException, SQLException &#123;</span><br><span class="line">    <span class="comment">//使用反射加载 Driver 类 , 动态加载，更加的灵活，减少依赖性</span></span><br><span class="line">    Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">    <span class="type">Driver</span> <span class="variable">driver</span> <span class="operator">=</span> (Driver) aClass.newInstance();</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/hsp_db02&quot;</span>;</span><br><span class="line">    <span class="comment">//将 用户名和密码放入到 Properties 对象</span></span><br><span class="line">    <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    <span class="comment">//说明 user 和 password 是规定好，后面的值根据实际情况写</span></span><br><span class="line">    properties.setProperty(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;root&quot;</span>);<span class="comment">// 用户</span></span><br><span class="line">    properties.setProperty(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;zzc&quot;</span>); <span class="comment">//密码</span></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connect</span> <span class="operator">=</span> driver.connect(url, properties);</span><br><span class="line">    System.out.println(<span class="string">&quot;方式 2=&quot;</span> + connect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式 3 使用 DriverManager 替代 driver 进行统一管理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect03</span><span class="params">()</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException, ClassNotFoundException, SQLException &#123;</span><br><span class="line">    <span class="comment">//使用反射加载 Driver</span></span><br><span class="line">    Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">    <span class="type">Driver</span> <span class="variable">driver</span> <span class="operator">=</span> (Driver) aClass.newInstance();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建 url 和 user 和 password</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/hsp_db02&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;zzc&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册 Driver 驱动</span></span><br><span class="line">    DriverManager.registerDriver(driver);</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url, user, password);</span><br><span class="line">    System.out.println(<span class="string">&quot;第三种方式=&quot;</span> + connection);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式 4: 使用 Class.forName 自动完成注册驱动，简化代码</span></span><br><span class="line"><span class="comment">//这种方式获取连接是使用的最多，推荐使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect04</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, SQLException &#123;</span><br><span class="line">    <span class="comment">// 使用反射加载了 Driver 类</span></span><br><span class="line">    <span class="comment">// 在加载 Driver 类时，完成注册</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    源码:</span></span><br><span class="line"><span class="comment">    1. 静态代码块，在类加载时，会执行一次.</span></span><br><span class="line"><span class="comment">    2. DriverManager.registerDriver(new Driver());</span></span><br><span class="line"><span class="comment">    3. 因此注册 driver 的工作已经完成</span></span><br><span class="line"><span class="comment">        static &#123;</span></span><br><span class="line"><span class="comment">            try &#123;</span></span><br><span class="line"><span class="comment">                DriverManager.registerDriver(new Driver());</span></span><br><span class="line"><span class="comment">            &#125; catch (SQLException var1) &#123;</span></span><br><span class="line"><span class="comment">                throw new RuntimeException(&quot;Can&#x27;t register driver!&quot;);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">    <span class="comment">//创建 url 和 user 和 password</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/hsp_db02&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;zzc&quot;</span>;</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url, user, password);</span><br><span class="line">    System.out.println(<span class="string">&quot;第 4 种方式~ &quot;</span> + connection);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式 5 , 在方式 4 的基础上改进，增加配置文件，让连接 mysql 更加灵活</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect05</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, SQLException &#123;</span><br><span class="line">    <span class="comment">//通过 Properties 对象获取配置文件的信息</span></span><br><span class="line">    <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    properties.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src\\mysql.properties&quot;</span>));</span><br><span class="line">    <span class="comment">//获取相关的值</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">driver</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;driver&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">    Class.forName(driver);<span class="comment">//建议写上</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url, user, password);</span><br><span class="line">    System.out.println(<span class="string">&quot;方式 5 &quot;</span> + connection);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="JDBC-API"><a href="#JDBC-API" class="headerlink" title="JDBC API"></a>JDBC API</h3><h4 id="DriverManger"><a href="#DriverManger" class="headerlink" title="DriverManger"></a>DriverManger</h4><p>驱动管理类</p>
<p><strong>getConnection(url, user, pwd)</strong> : 获取到连接</p>
<hr>
<h4 id="Connection-接口"><a href="#Connection-接口" class="headerlink" title="Connection 接口"></a>Connection 接口</h4><p><strong>createStatement()</strong> ：创建Statement对象</p>
<hr>
<h4 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h4><p>Statement对象用于执行静态SQL语句并返回其生成的结果的对象；</p>
<p>但使用Statement存在SQL注入的风险：SQL注入是利用利用某些系统没有对用户输入数据进行充分检查，而在输入数据中注入非法的SQL语句，恶意攻击数据库；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM admin</span><br><span class="line">	WHERE NAME = &#x27;1&#x27; OR&#x27; AND pwd = &#x27;OR &#x27;1&#x27;= &#x27;1&#x27;</span><br><span class="line"># SQL注入例子：万能密码 or &#x27;1&#x27;= &#x27;1</span><br><span class="line"># 后面的 &#x27;1&#x27;=&#x27;1&#x27; 必定为真，且前面都是OR，所以这条语句查询的内容在数据库中没有，但它依然能通过</span><br></pre></td></tr></table></figure>

<p>推荐使用<strong>PreparedStatement取代</strong>Statement，可以防止SQL注入；</p>
<p>方法：</p>
<p><strong>executeUpdate(sql)</strong> ：执行dml语句，返回影响的行数；</p>
<p>**executeQuery(sql)**：执行查询，返回ResultSet对象；</p>
<p>**execute(sql)**：执行任意的sql，返回布尔值；</p>
<p>Statement使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Statement01</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">//让用户输入管理员名和密码</span></span><br><span class="line">        System.out.print(<span class="string">&quot;请输入管理员的名字: &quot;</span>); <span class="comment">//</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">admin_name</span> <span class="operator">=</span> scanner.nextLine(); <span class="comment">//如果希望看到SQL注入，这里需要用 nextLine; 因为用next():当接收到 空格或者 &#x27;就是表示结束</span></span><br><span class="line">        System.out.print(<span class="string">&quot;请输入管理员的密码: &quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">admin_pwd</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">        <span class="comment">//通过 Properties 对象获取配置文件的信息</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        properties.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src\\mysql.properties&quot;</span>));</span><br><span class="line">        <span class="comment">//获取相关的值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">driver</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;driver&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">        <span class="comment">//1. 注册驱动</span></span><br><span class="line">        Class.forName(driver);<span class="comment">//建议写上</span></span><br><span class="line">        <span class="comment">//2. 得到连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url, user, password);</span><br><span class="line">        <span class="comment">//3. 得到 Statement</span></span><br><span class="line">        <span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.createStatement();</span><br><span class="line">        <span class="comment">//4. 组织 SqL</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select name , pwd from admin where name =&#x27;&quot;</span> </span><br><span class="line">                + admin_name + <span class="string">&quot;&#x27; and pwd = &#x27;&quot;</span> + admin_pwd + <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> statement.executeQuery(sql);</span><br><span class="line">        <span class="keyword">if</span> (resultSet.next()) &#123; <span class="comment">//如果查询到一条记录，则说明该管理存在</span></span><br><span class="line">            System.out.println(<span class="string">&quot;恭喜， 登录成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;对不起，登录失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭连接</span></span><br><span class="line">        resultSet.close();</span><br><span class="line">        statement.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="PreparedStatement"><a href="#PreparedStatement" class="headerlink" title="PreparedStatement"></a>PreparedStatement</h4><p>PreparedStatement 执行的SQL语句中的参数用问号(?)来表示；</p>
<p>调用 PreparedStatement 对象的 setXxx() 方法来设置这些参数， .setXxx() 方法有两个参数，第一个参数是SQL语句中的参数的索引（从1开始，第几个问号），第二个参数是设置的 SQL语句中的参数的值；</p>
<p>方法：</p>
<p><strong>executeUpdate(sql)</strong> ：执行dml语句，返回影响的行数；</p>
<p>**executeQuery(sql)**：执行查询，返回ResultSet对象；</p>
<p>**execute(sql)**：执行任意的sql，返回布尔值；</p>
<p>**setXxx(占位符索引，占位符的值)**：将指定位置的参数设置为给定值（解决了SQL注入）</p>
<p>**setObject(占位符索引，占位符的值)**：将指定位置的参数设置为给定的对象</p>
<p>PreparedStatement使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preparedStatement</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="comment">//让用户输入管理员名和密码</span></span><br><span class="line">    System.out.print(<span class="string">&quot;请输入管理员的名字: &quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">admin_name</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">    System.out.print(<span class="string">&quot;请输入管理员的密码: &quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">admin_pwd</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">    <span class="comment">//通过 Properties 对象获取配置文件的信息</span></span><br><span class="line">    <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"></span><br><span class="line">    properties.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src\\mysql.properties&quot;</span>));</span><br><span class="line">    <span class="comment">//获取相关的值</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">driver</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;driver&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">    <span class="comment">//1. 注册驱动</span></span><br><span class="line">    Class.forName(driver);<span class="comment">//建议写上</span></span><br><span class="line">    <span class="comment">//2. 得到连接</span></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url, user, password);</span><br><span class="line">    <span class="comment">//3. 得到 PreparedStatement</span></span><br><span class="line">    <span class="comment">//3.1 组织SqL, 其中，Sql语句的 ? 就相当于占位符</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select name , pwd from admin where name =? and pwd = ?&quot;</span>;</span><br><span class="line">    <span class="comment">//3.2 preparedStatement 对象实现了 PreparedStatement 接口的实现类的对象</span></span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">preparedStatement</span> <span class="operator">=</span> connection.prepareStatement(sql);</span><br><span class="line">    <span class="comment">//3.3 给 ? 赋值</span></span><br><span class="line">    preparedStatement.setString(<span class="number">1</span>, admin_name);</span><br><span class="line">    preparedStatement.setString(<span class="number">2</span>, admin_pwd);</span><br><span class="line">    <span class="comment">//4. 执行 select 语句使用 executeQuery</span></span><br><span class="line">    <span class="comment">// 如果执行的是 dml(update, insert ,delete) executeUpdate()</span></span><br><span class="line">    <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> preparedStatement.executeQuery(sql);</span><br><span class="line">    <span class="keyword">if</span> (resultSet.next()) &#123;     <span class="comment">//如果查询到一条记录，则说明该管理存在</span></span><br><span class="line">        System.out.println(<span class="string">&quot;恭喜， 登录成功&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;对不起，登录失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭连接</span></span><br><span class="line">    resultSet.close();</span><br><span class="line">    preparedStatement.close();</span><br><span class="line">    connection.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="ResultSet"><a href="#ResultSet" class="headerlink" title="ResultSet"></a>ResultSet</h4><p>ResultSet是结果集，表示数据库结果集的数据表，通常通过执行查询数据库的语句生成；</p>
<p>ResultSet对象保持一个光标指向当前的数据行，最初，光标位于第一行之前，next方法将光标移到下一行，且在ResultSet对象中没有更多行时返回false，因此可以在while循环中用来遍历结果集</p>
<p>方法：</p>
<p>**next()**：向下移动一行，如果没有下一行，返回false；</p>
<p>**previous()**：向上移动一行，如果没有上一行，返回false；</p>
<p><strong>getXxx( 列的索引 &#x2F; 列名)</strong> ：返回对应列的值，接收类型是Xxx</p>
<p><strong>getObject(列的索引&#x2F; 列名)</strong> ：返回索引对应的值，接收类型为Object</p>
<p>ResultSet使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ResultSet01</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//通过 Properties 对象获取配置文件的信息</span></span><br><span class="line">    <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    properties.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src\\mysql.properties&quot;</span>));</span><br><span class="line">    <span class="comment">//获取相关的值</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">driver</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;driver&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">    <span class="comment">//1. 注册驱动</span></span><br><span class="line">    Class.forName(driver);<span class="comment">//建议写上</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 得到连接</span></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url, user, password);</span><br><span class="line">    <span class="comment">//3. 得到 Statement</span></span><br><span class="line">    <span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.createStatement();</span><br><span class="line">    <span class="comment">//4. 组织 SqL</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select id, name , sex, borndate from actor&quot;</span>;</span><br><span class="line">    <span class="comment">//执行给定的 SQL 语句，该语句返回单个 ResultSet 对象</span></span><br><span class="line">    <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> statement.executeQuery(sql);</span><br><span class="line">    <span class="comment">//5. 使用 while 取出数据</span></span><br><span class="line">    <span class="keyword">while</span> (resultSet.next()) &#123; <span class="comment">// 让光标向后移动，如果没有更多行，则返回 false</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> resultSet.getInt(<span class="number">1</span>); <span class="comment">//获取该行的第 1 列</span></span><br><span class="line">        <span class="comment">//int id1 = resultSet.getInt(&quot;id&quot;); 通过列名来获取值, 推荐</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> resultSet.getString(<span class="number">2</span>);<span class="comment">//获取该行的第 2 列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sex</span> <span class="operator">=</span> resultSet.getString(<span class="number">3</span>);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> resultSet.getDate(<span class="number">4</span>);</span><br><span class="line">        System.out.println(id + <span class="string">&quot;\t&quot;</span> + name + <span class="string">&quot;\t&quot;</span> + sex + <span class="string">&quot;\t&quot;</span> + date);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6. 关闭连接</span></span><br><span class="line">    resultSet.close();</span><br><span class="line">    statement.close();</span><br><span class="line">    connection.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="JDBCUtils-封装"><a href="#JDBCUtils-封装" class="headerlink" title="JDBCUtils(封装)"></a>JDBCUtils(封装)</h3><p>在jdbc操作中，获取连接和释放资源 是经常使用到的，可以将其封装到  JDBC连接的工具类JDBCUtils中。</p>
<p>JDBCUtils 实现示例 以及 使用 ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JDBCUtils实现实例:</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JDBCUtils</span> &#123;</span><br><span class="line">    <span class="comment">//定义相关的属性(4个), 因为只需要一份，因此，我们做出 static</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String user; <span class="comment">//用户名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String password; <span class="comment">//密码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String url; <span class="comment">//url</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String driver; <span class="comment">//驱动名</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//在static代码块中进行初始化</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">            properties.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src\\mysql.properties&quot;</span>));</span><br><span class="line">            <span class="comment">//读取相关的属性值</span></span><br><span class="line">            user = properties.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">            password = properties.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">            url = properties.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">            driver = properties.getProperty(<span class="string">&quot;driver&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">//在实际开发中，我们可以这样处理</span></span><br><span class="line">            <span class="comment">//1. 将编译异常转成 运行异常</span></span><br><span class="line">            <span class="comment">//2. 调用者 可以选择捕获该异常，也可以选择默认处理该异常，比较方便.</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//连接数据库, 返回 Connection</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> DriverManager.getConnection(url, user, password);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="comment">//1. 将编译异常转成 运行异常</span></span><br><span class="line">            <span class="comment">//2. 调用者，可以选择捕获该异常，也可以选择默认处理该异常，比较方便.</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭相关资源</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. ResultSet 结果集</span></span><br><span class="line"><span class="comment">    2. Statement 或者 PreparedStatement</span></span><br><span class="line"><span class="comment">    3. Connection</span></span><br><span class="line"><span class="comment">    4. 如果需要关闭资源，就传入对象，否则传入 null</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">(ResultSet set, Statement statement, Connection connection)</span> &#123;</span><br><span class="line">        <span class="comment">//判断是否为 null</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (set != <span class="literal">null</span>) &#123;</span><br><span class="line">                set.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (statement != <span class="literal">null</span>) &#123;</span><br><span class="line">                statement.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="literal">null</span>) &#123;</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="comment">//将编译异常转成运行异常抛出</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用实例:</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JDBCUtils_Use</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelect</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1. 得到连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//2. 组织一个 sql</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from actor where id = ?&quot;</span>;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">preparedStatement</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//3. 创建 PreparedStatement 对象</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = JDBCUtils.getConnection();</span><br><span class="line">            preparedStatement = connection.prepareStatement(sql);</span><br><span class="line">            preparedStatement.setInt(<span class="number">1</span>, <span class="number">5</span>);<span class="comment">//给?号赋值</span></span><br><span class="line">            <span class="comment">//执行, 得到结果集</span></span><br><span class="line">            set = preparedStatement.executeQuery();</span><br><span class="line">            <span class="comment">//遍历该结果集</span></span><br><span class="line">            <span class="keyword">while</span> (set.next()) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> set.getInt(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> set.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">sex</span> <span class="operator">=</span> set.getString(<span class="string">&quot;sex&quot;</span>);</span><br><span class="line">                <span class="type">Date</span> <span class="variable">borndate</span> <span class="operator">=</span> set.getDate(<span class="string">&quot;borndate&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> set.getString(<span class="string">&quot;phone&quot;</span>);</span><br><span class="line">                System.out.println(id + <span class="string">&quot;\t&quot;</span> + name + <span class="string">&quot;\t&quot;</span> + sex + <span class="string">&quot;\t&quot;</span> + borndate + <span class="string">&quot;\t&quot;</span> + phone);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭资源</span></span><br><span class="line">            JDBCUtils.close(set, preparedStatement, connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<p>使用Druid实现JDBCUtils</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用Druid实现JDBCUtils</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCUtilsByDruid</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DataSource ds;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在静态代码块完成 ds 初始化</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            properties.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src\\druid.properties&quot;</span>));</span><br><span class="line">            ds = DruidDataSourceFactory.createDataSource(properties);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写 getConnection 方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="keyword">return</span> ds.getConnection();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭连接, 注意：在数据库连接池技术中，close不是真的断掉连接，而是把使用的 Connection 对象放回连接池</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">(ResultSet resultSet, Statement statement, Connection connection)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (resultSet != <span class="literal">null</span>) &#123;</span><br><span class="line">                resultSet.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (statement != <span class="literal">null</span>) &#123;</span><br><span class="line">                statement.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="literal">null</span>) &#123;</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCUtilsByDruid_USE</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelect</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1. 得到连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//2. 组织一个 sql</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from actor where id &gt;= ?&quot;</span>;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">preparedStatement</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//3. 创建 PreparedStatement 对象</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = JDBCUtilsByDruid.getConnection();</span><br><span class="line">            <span class="comment">// System.out.println(connection.getClass());  运行类型 com.alibaba.druid.pool.DruidPooledConnection</span></span><br><span class="line">            preparedStatement = connection.prepareStatement(sql);</span><br><span class="line">            preparedStatement.setInt(<span class="number">1</span>, <span class="number">1</span>);<span class="comment">//给问号赋值</span></span><br><span class="line">            <span class="comment">//执行, 得到结果集</span></span><br><span class="line">            set = preparedStatement.executeQuery();</span><br><span class="line">            <span class="comment">//遍历该结果集</span></span><br><span class="line">            <span class="keyword">while</span> (set.next()) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> set.getInt(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> set.getString(<span class="string">&quot;name&quot;</span>);<span class="comment">//getName()</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">sex</span> <span class="operator">=</span> set.getString(<span class="string">&quot;sex&quot;</span>);<span class="comment">//getSex()</span></span><br><span class="line">                <span class="type">Date</span> <span class="variable">borndate</span> <span class="operator">=</span> set.getDate(<span class="string">&quot;borndate&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> set.getString(<span class="string">&quot;phone&quot;</span>);</span><br><span class="line">                System.out.println(id + <span class="string">&quot;\t&quot;</span> + name + <span class="string">&quot;\t&quot;</span> + sex + <span class="string">&quot;\t&quot;</span> + borndate + <span class="string">&quot;\t&quot;</span> + phone);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭资源</span></span><br><span class="line">            JDBCUtilsByDruid.close(set, preparedStatement, connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="事务-1"><a href="#事务-1" class="headerlink" title="事务"></a>事务</h3><p>JDBC程序中当一个Connection对象创建时，默认是自动提交事务的（语句执行成功，就会向数据库自动提交，而不能回滚）。</p>
<p>JDBC 使用事务：</p>
<ul>
<li>使用Connection的setAutoCommit (false) 可以取消自动提交事务；</li>
<li>在所有sql语句成功执行后，调用Connection的commit() 方法提交事务；</li>
<li>当其中某个操作失败或出现异常，调用Connection的rollback() 方法回滚事务；</li>
</ul>
<blockquote>
<p>在异常捕获中，可以将 setAutoCommit (false) 方法和 commit() 方法放在try语句块中，将 rollback() 方法放在catch中，当出现异常时，就可以进行回滚</p>
</blockquote>
<h3 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h3><p>当需要成批插入或者更新记录时，可以采用Java的批量更新机制，这一机制允许多条语句一次性提交给数据库批量处理。</p>
<p>JDBC连接MySQL时，如果要使用批处理功能，要在url中加参数： <strong>rewriteBatchedStatements&#x3D;true</strong></p>
<p>批处理往往和PreparedStatement搭配使用，可以减少编译次数，运行次数，提高效率；</p>
<p>方法：</p>
<p>addBatch() ：添加需要批量处理的SQL语句或参数；</p>
<p>executeBatch() ：执行批量处理语句；</p>
<p>clearBatch() ：清空批处理包的语句；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">batch</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> JDBCUtils.getConnection();</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into admin2 values(null, ?, ?)&quot;</span>;</span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">preparedStatement</span> <span class="operator">=</span> connection.prepareStatement(sql);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;    <span class="comment">//5000次执行</span></span><br><span class="line">        preparedStatement.setString(<span class="number">1</span>, <span class="string">&quot;jack&quot;</span> + i);</span><br><span class="line">        preparedStatement.setString(<span class="number">2</span>, <span class="string">&quot;666&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        //addBatch源码:</span></span><br><span class="line"><span class="comment">        public void addBatch () throws SQLException &#123;</span></span><br><span class="line"><span class="comment">            synchronized (this.checkClosed().getConnectionMutex()) &#123;</span></span><br><span class="line"><span class="comment">                if (this.batchedArgs == null) &#123;</span></span><br><span class="line"><span class="comment">                    this.batchedArgs = new ArrayList();</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                for (int i = 0; i &lt; this.parameterValues.length; ++i) &#123;</span></span><br><span class="line"><span class="comment">                    this.checkAllParametersSet(this.parameterValues[i], this.parameterStreams[i], i);</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                this.batchedArgs.add(new PreparedStatement.BatchParams(this.parameterValues, this.parameterStreams, this.isStream, this.streamLengths, this.isNull));</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        preparedStatement.addBatch();</span><br><span class="line">        <span class="comment">//当有 1000 条记录时，再批量执行，并清空批处理包</span></span><br><span class="line">        <span class="keyword">if</span> ((i + <span class="number">1</span>) % <span class="number">1000</span> == <span class="number">0</span>) &#123;<span class="comment">//满 1000 条 sql</span></span><br><span class="line">            preparedStatement.executeBatch();</span><br><span class="line">            preparedStatement.clearBatch();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭连接</span></span><br><span class="line">    JDBCUtils.close(<span class="literal">null</span>, preparedStatement, connection);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h3><p>传统的 JDBC数据库使用DriverManager来获取连接的弊端：</p>
<ul>
<li>每次向数据库建立连接都要将Connection加载到内存中，再验证IP地址，用户名和密码(0.05~1s)。</li>
<li>频繁的进行数据库连接操作将占用很多的系统资源，容易造成服务器崩溃。</li>
<li>每一次数据库连接，使用完后都得断开，如果程序出现异常而未能关闭，将导致数据库内存泄漏。</li>
<li>不能控制连接的方式，不能控制创建的连接数量，如果连接过多，会导致内存泄漏，MySQL崩溃。</li>
</ul>
<p>因此有了数据库连接池技术（connection pool）。</p>
<p>JDBC的数据库连接池使用javax.sql.DataSource来表示， DataSource只是一个接口，该接口通常由第三方提供实现；</p>
<ul>
<li><strong>C3P0</strong> 数据库连接池：速度相对较慢，稳定性不错；</li>
<li>DBCP 数据库连接池：速度较C3P0快，但不稳定；</li>
<li>Proxool 数据库连接池：有监控连接池状态的功能，稳定性较C3P0差一些；</li>
<li>BoneCp 数据库连接池：速度快；</li>
<li>**Druid(德鲁伊)**是阿里提供的数据库连接池，集DBCP，C3P0，Proxool有点于一身的数据库连接池；</li>
</ul>
<h4 id="C3P0"><a href="#C3P0" class="headerlink" title="C3P0"></a>C3P0</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式 1： 相关参数，在程序中指定 user, url , password 等</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testC3P0_01</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1. 创建一个数据源对象</span></span><br><span class="line">        <span class="type">ComboPooledDataSource</span> <span class="variable">comboPooledDataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComboPooledDataSource</span>();</span><br><span class="line">        <span class="comment">//2. 通过配置文件 mysql.properties 获取相关连接的信息</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        properties.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src\\mysql.properties&quot;</span>));</span><br><span class="line">        <span class="comment">//读取相关的属性值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">driver</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;driver&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//给数据源 comboPooledDataSource 设置相关的参数</span></span><br><span class="line">        <span class="comment">//注意：连接管理是由 comboPooledDataSource 来管理</span></span><br><span class="line">        comboPooledDataSource.setDriverClass(driver);</span><br><span class="line">        comboPooledDataSource.setJdbcUrl(url);</span><br><span class="line">        comboPooledDataSource.setUser(user);</span><br><span class="line">        comboPooledDataSource.setPassword(password);</span><br><span class="line">        <span class="comment">//设置初始化连接数</span></span><br><span class="line">        comboPooledDataSource.setInitialPoolSize(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//最大连接数</span></span><br><span class="line">        comboPooledDataSource.setMaxPoolSize(<span class="number">50</span>);</span><br><span class="line">        <span class="comment">//测试连接池的效率, 测试对 mysql 5000 次操作</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">            <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> comboPooledDataSource.getConnection(); <span class="comment">//这个方法就是从 DataSource 接口实现的</span></span><br><span class="line">            <span class="comment">//其他操作略</span></span><br><span class="line">            connection.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;c3p0 5000 连接 mysql 耗时=&quot;</span> + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二种方式 使用配置文件模板来完成</span></span><br><span class="line">    <span class="comment">//1. 将 c3p0 提供的 c3p0.config.xml 拷贝到 src 目录下</span></span><br><span class="line">    <span class="comment">//2. 该文件指定了连接数据库和连接池的相关参数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testC3P0_02</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">ComboPooledDataSource</span> <span class="variable">comboPooledDataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComboPooledDataSource</span>(<span class="string">&quot;hsp_edu&quot;</span>);</span><br><span class="line">        <span class="comment">//测试 5000 次连接 mysql</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;开始执行....&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">500000</span>; i++) &#123;</span><br><span class="line">            <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> comboPooledDataSource.getConnection();</span><br><span class="line">            connection.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;c3p0 的第二种方式(500000) 耗时=&quot;</span> + (end - start));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>







<h4 id="Druid"><a href="#Druid" class="headerlink" title="Druid"></a>Druid</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDruid</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       <span class="comment">//1. 加入 Druid.jar 包</span></span><br><span class="line">       <span class="comment">//2. 加入 配置文件 druid.properties (将该文件拷贝项目的src目录)</span></span><br><span class="line">       <span class="comment">//3. 创建 Properties 对象, 读取配置文件</span></span><br><span class="line">       <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">       properties.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src\\druid.properties&quot;</span>));</span><br><span class="line">       <span class="comment">//4. 创建一个指定参数的数据库连接池, Druid 连接池</span></span><br><span class="line">       <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> DruidDataSourceFactory.createDataSource(properties);</span><br><span class="line">       <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">500000</span>; i++) &#123;</span><br><span class="line">           <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> dataSource.getConnection();</span><br><span class="line">           <span class="comment">//其他操作</span></span><br><span class="line">           connection.close();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">       System.out.println(<span class="string">&quot;druid 连接池 操作 500000 耗时=&quot;</span> + (end - start));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>







<h3 id="DBUtils"><a href="#DBUtils" class="headerlink" title="DBUtils"></a>DBUtils</h3><p>DBUtils是对JDBC的封装，使用dbutils可以极大简化jdbc的编码的工作量。</p>
<p>DBUtils类：</p>
<ul>
<li><strong>QueryRunner</strong>类：该类封装了SQL的执行，是线程安全的。可以实现 增，删，改，查，批处理；</li>
<li><strong>ResultSetHandler</strong>接口：该接口用于处理java.sql.ResultSet，将数据按要求转换为另一种形式；<ul>
<li>ArrayHandler：把结果集中的第一行转成对象数组；</li>
<li>ArrayListHandler：把结果集中的每一行数据都转成一个数组，再存放到List中；</li>
<li>BeanHandler：把结果集中的第一行数据封装到一个对应的 JavaBean实例中；</li>
<li>BeanListHandler：把结果集中的每一行数据封装到一个对应的 JavaBean实例中，存放到List里；</li>
<li>ColumnListHandler：将结果集中某一列的数据存放到List中；</li>
<li>KeyedHandler(name)：将结果集中的每一行数据都封装到Map里，再把这些map再存到一个map里，其key为指定的key；</li>
<li>MapHandler：将结果集中的第一行数据封装到一个Map里，key是列名，value就是对应的值；</li>
<li>MapListHandler：将结果集中的每一行数据都封装到一个Map里，再存放到list</li>
</ul>
</li>
</ul>
<p>DBUtils和Druid搭配使用例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DBUtils_USE</span> &#123;</span><br><span class="line">    <span class="comment">//使用 apache-DBUtils 工具类 + druid 完成对表的 crud 操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQueryMany</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123; <span class="comment">//返回结果是多行的情况</span></span><br><span class="line">        <span class="comment">//1. 得到 连接 (druid)</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> JDBCUtilsByDruid.getConnection();</span><br><span class="line">        <span class="comment">//2. 使用 DBUtils 类和接口 , 先引入 DBUtils 相关的 jar , 加入到本 Project</span></span><br><span class="line">        <span class="comment">//3. 创建 QueryRunner</span></span><br><span class="line">        <span class="type">QueryRunner</span> <span class="variable">queryRunner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryRunner</span>();</span><br><span class="line">        <span class="comment">//4. 就可以执行相关的方法，返回 ArrayList 结果集</span></span><br><span class="line">        <span class="comment">//String sql = &quot;select * from actor where id &gt;= ?&quot;;</span></span><br><span class="line">        <span class="comment">// 注意: sql 语句也可以查询部分列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select id, name from actor where id &gt;= ?&quot;</span>;</span><br><span class="line">        <span class="comment">//(1) query 方法就是执行 sql 语句，得到 resultset ---封装到 --&gt; ArrayList 集合中</span></span><br><span class="line">        <span class="comment">//(2) 返回集合</span></span><br><span class="line">        <span class="comment">//(3) connection: 连接</span></span><br><span class="line">        <span class="comment">//(4) sql : 执行的 sql 语句</span></span><br><span class="line">        <span class="comment">//(5) new BeanListHandler&lt;&gt;(Actor.class): 在将 resultset -&gt; Actor 对象 -&gt; 封装到 ArrayList</span></span><br><span class="line">        <span class="comment">// 底层使用反射机制 去获取 Actor 类的属性，然后进行封装</span></span><br><span class="line">        <span class="comment">//(6) 1 就是给 sql 语句中的第一个 ? 赋值，可以有多个值，因为此处是可变参数 Object... params</span></span><br><span class="line">        <span class="comment">//(7) PreparedStatment, 以及底层得到的 resultset ,会在 query 中关闭, 所以最后只需关闭连接connection就行</span></span><br><span class="line">        List&lt;Actor&gt; list = queryRunner.query(connection, sql, <span class="keyword">new</span> <span class="title class_">BeanListHandler</span>&lt;&gt;(Actor.class), <span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;输出集合的信息&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Actor actor : list) &#123;</span><br><span class="line">            System.out.print(actor);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        JDBCUtilsByDruid.close(<span class="literal">null</span>, <span class="literal">null</span>, connection);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//演示 apache-dbutils + druid 完成 返回的结果是单行记录(单个对象)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQuerySingle</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="comment">//1. 得到 连接 (druid)</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> JDBCUtilsByDruid.getConnection();</span><br><span class="line">        <span class="comment">//2. 使用 DBUtils 类和接口 , 先引入 DBUtils 相关的 jar , 加入到本 Project</span></span><br><span class="line">        <span class="comment">//3. 创建 QueryRunner</span></span><br><span class="line">        <span class="type">QueryRunner</span> <span class="variable">queryRunner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryRunner</span>();</span><br><span class="line">        <span class="comment">//4. 就可以执行相关的方法，返回单个对象</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from actor where id = ?&quot;</span>;</span><br><span class="line">        <span class="comment">// 因为我们返回的单行记录&lt;---&gt;单个对象 , 使用的 Hander 是 BeanHandler</span></span><br><span class="line">        <span class="type">Actor</span> <span class="variable">actor</span> <span class="operator">=</span> queryRunner.query(connection, sql, <span class="keyword">new</span> <span class="title class_">BeanHandler</span>&lt;&gt;(Actor.class), <span class="number">10</span>);</span><br><span class="line">        System.out.println(actor);</span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        JDBCUtilsByDruid.close(<span class="literal">null</span>, <span class="literal">null</span>, connection);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//演示 apache-dbutils + druid 完成查询结果是单行单列-返回的就是 object</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testScalar</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="comment">//1. 得到 连接 (druid)</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> JDBCUtilsByDruid.getConnection();</span><br><span class="line">        <span class="comment">//2. 使用 DBUtils 类和接口 , 先引入 DBUtils 相关的 jar , 加入到本 Project</span></span><br><span class="line">        <span class="comment">//3. 创建 QueryRunner</span></span><br><span class="line">        <span class="type">QueryRunner</span> <span class="variable">queryRunner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryRunner</span>();</span><br><span class="line">        <span class="comment">//4. 就可以执行相关的方法，返回单行单列 , 返回的就是 Object</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select name from actor where id = ?&quot;</span>;</span><br><span class="line">        <span class="comment">// 因为返回的是一个对象, 使用的 handler 就是 ScalarHandler</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> queryRunner.query(connection, sql, <span class="keyword">new</span> <span class="title class_">ScalarHandler</span>(), <span class="number">4</span>);</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        JDBCUtilsByDruid.close(<span class="literal">null</span>, <span class="literal">null</span>, connection);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//演示 apache-dbutils + druid 完成 dml (update, insert ,delete)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDML</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="comment">//1. 得到 连接 (druid)</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> JDBCUtilsByDruid.getConnection();</span><br><span class="line">        <span class="comment">//3. 创建 QueryRunner</span></span><br><span class="line">        <span class="type">QueryRunner</span> <span class="variable">queryRunner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryRunner</span>();</span><br><span class="line">        <span class="comment">//4. 这里组织 sql 完成 update, insert delete</span></span><br><span class="line">        <span class="comment">//String sql = &quot;update actor set name = ? where id = ?&quot;;</span></span><br><span class="line">        <span class="comment">//String sql = &quot;insert into actor values(null, ?, ?, ?, ?)&quot;;</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;delete from actor where id = ?&quot;</span>;</span><br><span class="line">        <span class="comment">//(1) 执行 dml 操作是 queryRunner.update()</span></span><br><span class="line">        <span class="comment">//(2) 返回的值是受影响的行数 (affected: 受影响)</span></span><br><span class="line">        <span class="comment">//int affectedRow = queryRunner.update(connection, sql, &quot;林青霞&quot;, &quot;116&quot;);</span></span><br><span class="line">        <span class="comment">//int affectedRow = queryRunner.update(connection, sql, &quot;林青霞&quot;, &quot;女&quot;, &quot;1966-10-10&quot;, &quot;116&quot;);</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">affectedRow</span> <span class="operator">=</span> queryRunner.update(connection, sql, <span class="number">1000</span>);</span><br><span class="line">        System.out.println(affectedRow &gt; <span class="number">0</span> ? <span class="string">&quot;执行成功&quot;</span> : <span class="string">&quot;执行没有影响到表&quot;</span>);</span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        JDBCUtilsByDruid.close(<span class="literal">null</span>, <span class="literal">null</span>, connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h3 id="DAO"><a href="#DAO" class="headerlink" title="DAO"></a>DAO</h3><p>DAO：data access object 数据访问对象</p>
<p>这样的通用类，称为BasicDao，是专门和数据库交互的，即完成对数据库(表)的crud操作；</p>
<p>编写DAO的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BasicDAO</span>&lt;T&gt; &#123; <span class="comment">//泛型指定具体类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">QueryRunner</span> <span class="variable">qr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryRunner</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开发通用的 dml 方法, 针对任意的表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">(String sql, Object... parameters)</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = JDBCUtilsByDruid.getConnection();</span><br><span class="line">            <span class="type">int</span> <span class="variable">update</span> <span class="operator">=</span> qr.update(connection, sql, parameters);</span><br><span class="line">            <span class="keyword">return</span> update;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e); <span class="comment">//将编译异常-&gt;运行异常 ,抛出</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JDBCUtilsByDruid.close(<span class="literal">null</span>, <span class="literal">null</span>, connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回多个对象(即查询的结果是多行), 针对任意表</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;T&gt; <span class="title function_">queryMulti</span><span class="params">(String sql, Class&lt;T&gt; clazz, Object... parameters)</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = JDBCUtilsByDruid.getConnection();</span><br><span class="line">            <span class="keyword">return</span> qr.query(connection, sql, <span class="keyword">new</span> <span class="title class_">BeanListHandler</span>&lt;T&gt;(clazz), parameters);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e); <span class="comment">//将编译异常-&gt;运行异常 ,抛出</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JDBCUtilsByDruid.close(<span class="literal">null</span>, <span class="literal">null</span>, connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询单行结果 的通用方法</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">querySingle</span><span class="params">(String sql, Class&lt;T&gt; clazz, Object... parameters)</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = JDBCUtilsByDruid.getConnection();</span><br><span class="line">            <span class="keyword">return</span> qr.query(connection, sql, <span class="keyword">new</span> <span class="title class_">BeanHandler</span>&lt;T&gt;(clazz), parameters);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e); <span class="comment">//将编译异常-&gt;运行异常 ,抛出</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JDBCUtilsByDruid.close(<span class="literal">null</span>, <span class="literal">null</span>, connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询单行单列的方法,即返回单值的方法</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">queryScalar</span><span class="params">(String sql, Object... parameters)</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = JDBCUtilsByDruid.getConnection();</span><br><span class="line">            <span class="keyword">return</span> qr.query(connection, sql, <span class="keyword">new</span> <span class="title class_">ScalarHandler</span>(), parameters);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e); <span class="comment">//将编译异常-&gt;运行异常 ,抛出</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JDBCUtilsByDruid.close(<span class="literal">null</span>, <span class="literal">null</span>, connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ActorDAO</span> <span class="keyword">extends</span> <span class="title class_">BasicDAO</span>&lt;Actor&gt; &#123;</span><br><span class="line">    <span class="comment">// 根据业务需求，可以编写特有的方法. </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDAO</span> &#123;</span><br><span class="line">        <span class="comment">//测试 ActorDAO 对 actor 表 crud 操作</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testActorDAO</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">ActorDAO</span> <span class="variable">actorDAO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ActorDAO</span>();</span><br><span class="line">            <span class="comment">//1. 查询</span></span><br><span class="line">            List&lt;Actor&gt; actors = actorDAO.queryMulti(<span class="string">&quot;select * from actor where id &gt;= ?&quot;</span>, Actor.class, <span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;===查询结果===&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (Actor actor : actors) &#123;</span><br><span class="line">                System.out.println(actor);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2. 查询单行记录</span></span><br><span class="line">            <span class="type">Actor</span> <span class="variable">actor</span> <span class="operator">=</span> actorDAO.querySingle(<span class="string">&quot;select * from actor where id = ?&quot;</span>, Actor.class, <span class="number">6</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;====查询单行结果====&quot;</span>);</span><br><span class="line">            System.out.println(actor);</span><br><span class="line">            <span class="comment">//3. 查询单行单列</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> actorDAO.queryScalar(<span class="string">&quot;select name from actor where id = ?&quot;</span>, <span class="number">6</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;====查询单行单列值===&quot;</span>);</span><br><span class="line">            System.out.println(o);</span><br><span class="line">            <span class="comment">//4. dml 操作 insert ,update, delete</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">update</span> <span class="operator">=</span> actorDAO.update(<span class="string">&quot;insert into actor values(null, ?, ?, ?, ?)&quot;</span>, <span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;男&quot;</span>, <span class="string">&quot;2000-11-11&quot;</span>, <span class="string">&quot;999&quot;</span>);</span><br><span class="line">            System.out.println(update &gt; <span class="number">0</span> ? <span class="string">&quot;执行成功&quot;</span> : <span class="string">&quot;执行没有影响表&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><h2 id="MySQL的数据目录"><a href="#MySQL的数据目录" class="headerlink" title="MySQL的数据目录"></a>MySQL的数据目录</h2><p>MySQL数据库文件的存放路径：&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;</p>
<p>相关命令目录：&#x2F;usr&#x2F;bin 和 &#x2F;usr&#x2F;sbin。</p>
<p>配置文件目录：&#x2F;usr&#x2F;share&#x2F;mysql-8.0（命令及配置文件），&#x2F;etc&#x2F;mysql（如my.cnf）</p>
<hr>
<p><strong>数据库和文件系统的关系：</strong></p>
<p>MySQL有4个自带的系统数据库：mysql，information_schema，performance_schema，sys</p>
<ul>
<li><p><strong>mysql</strong></p>
<p>MySQL 系统自带的核心数据库，它存储了MySQL的用户账户和权限信息，一些存储过程、事件的定义信息，一些运行过程中产生的日志信息，一些帮助信息以及时区信息等。</p>
</li>
<li><p><strong>information_schema</strong></p>
<p>保存mysql服务器维护其他所有数据库的信息，比如有哪些表，哪些触发器等等，是一些描述性信息，称之为元数据。</p>
<p>information_schema还提供了一些以innodb_sys开头的表，用于表示内部系统表。</p>
</li>
<li><p><strong>performance_schema</strong></p>
<p>保存MySQL服务器运行过程中的一些状态信息，可以用来 监控 MySQL 服务的各类性能指标 。包括统计最近执行了哪些语句，在执行过程的每个阶段都 花费了多长时间，内存的使用情况等信息。</p>
</li>
<li><p><strong>sys</strong></p>
<p>这个数据库主要是通过 视图 的形式把 information_schema 和 performance_schema 结合起来，帮助系统管理员和开发人员监控 MySQL 的技术性能。</p>
</li>
</ul>
<hr>
<p><strong>表在文件系统中的表示：</strong></p>
<ul>
<li><p>InnoDB存储引擎模式：</p>
<ul>
<li><p><strong>表结构</strong>：</p>
<p>为了保存表结构， InnoDB 在 数据目录 下对应的数据库子目录下创建了一个专门用于 <code>描述表结构的文件</code> ，文件名是这样：<strong>表名.frm</strong></p>
</li>
<li><p><strong>表的数据和索引</strong>：</p>
<ul>
<li><p>系统表空间（5.6.6版本以前）</p>
<p>默认情况下，InnoDB会在数据目录下创建一个名为 ibdata1 、大小为 12M 的文件，这个文件就是对应 的 系统表空间 在文件系统上的表示。它是一个自扩展文件。</p>
</li>
<li><p>独立表空间（5.6.6版本以后）</p>
<p>InnoDB 为每一个表建立一个独立表空间 ，表现为：在该表所属数据库对应的子目录下创建一个表示该独立表空间的文件，文件名和表名相同，为：<strong>表名.ibd</strong></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>MyISAM存储引擎模式：</p>
<ul>
<li><p>表结构：</p>
<p>（同InnoDB一样）</p>
</li>
<li><p>表数据和索引：</p>
<p>在MyISAM中的索引全部都是 <u>二级索引</u> ，该存储引擎的 数据和索引是<u>分开存放</u> 的。所以在文件系统中也是 使用不同的文件来存储数据文件和索引文件，同时表数据都存放在对应的数据库子目录下。</p>
<p>MyISAM存储引擎 会在 表所在数据库对应的 atguigu 目录下 创建这三个文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">表名.frm 存储表结构</span><br><span class="line">表名.MYD 存储数据 (MYData)</span><br><span class="line">表名.MYI 存储索引 (MYIndex)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="用户与权限管理"><a href="#用户与权限管理" class="headerlink" title="用户与权限管理"></a>用户与权限管理</h2><h2 id="逻辑架构"><a href="#逻辑架构" class="headerlink" title="逻辑架构"></a>逻辑架构</h2><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><h1 id="索引调优"><a href="#索引调优" class="headerlink" title="索引调优"></a>索引调优</h1><h2 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h2><h2 id="InnoDB数据存储结构"><a href="#InnoDB数据存储结构" class="headerlink" title="InnoDB数据存储结构"></a>InnoDB数据存储结构</h2><h2 id="索引的创建与设计原则"><a href="#索引的创建与设计原则" class="headerlink" title="索引的创建与设计原则"></a>索引的创建与设计原则</h2><h2 id="性能分析工具的使用"><a href="#性能分析工具的使用" class="headerlink" title="性能分析工具的使用"></a>性能分析工具的使用</h2><h2 id="索引优化与查询优化"><a href="#索引优化与查询优化" class="headerlink" title="索引优化与查询优化"></a>索引优化与查询优化</h2><h2 id="数据库的设计规范"><a href="#数据库的设计规范" class="headerlink" title="数据库的设计规范"></a>数据库的设计规范</h2><h2 id="数据库其他调优策略"><a href="#数据库其他调优策略" class="headerlink" title="数据库其他调优策略"></a>数据库其他调优策略</h2><h1 id="事务-2"><a href="#事务-2" class="headerlink" title="事务"></a>事务</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h2 id="MySQL事务日志"><a href="#MySQL事务日志" class="headerlink" title="MySQL事务日志"></a>MySQL事务日志</h2><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h2 id="多版本并发控制-MVCC"><a href="#多版本并发控制-MVCC" class="headerlink" title="多版本并发控制(MVCC)"></a>多版本并发控制(MVCC)</h2><h1 id="日志与备份"><a href="#日志与备份" class="headerlink" title="日志与备份"></a>日志与备份</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/04/14/MySQL/" data-id="cl1ynefm10006swtuf3ag24ha" data-title="Mysql" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/Notes/page/2/">2</a><a class="extend next" rel="next" href="/Notes/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/Notes/archives/2022/04/">April 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/Notes/2022/04/14/%E7%AE%97%E6%B3%95/">算法</a>
          </li>
        
          <li>
            <a href="/Notes/2022/04/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
          </li>
        
          <li>
            <a href="/Notes/2022/04/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
          </li>
        
          <li>
            <a href="/Notes/2022/04/14/%E5%BF%AB%E6%8D%B7%E9%94%AE/">快捷键</a>
          </li>
        
          <li>
            <a href="/Notes/2022/04/14/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/">面试相关</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/Notes/" class="mobile-nav-link">Home</a>
  
    <a href="/Notes/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/Notes/js/jquery-3.4.1.min.js"></script>



  
<script src="/Notes/fancybox/jquery.fancybox.min.js"></script>




<script src="/Notes/js/script.js"></script>





  </div>
</body>
</html>