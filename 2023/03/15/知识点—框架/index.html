<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>知识点—框架 | ValcanoZz Blog</title><meta name="keywords" content="知识点"><meta name="author" content="ValcanoZz"><meta name="copyright" content="ValcanoZz"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="SpingSpring 是一款开源的轻量级 Java 开发框架，旨在提高开发人员的开发效率以及系统的可维护性。 一般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发。 IoCInversion of Control，控制反转，是一种设计思想，而不是具体的思想。 其思想就是将原本在程序手中手动创建对象的控制权，交由Spir">
<meta property="og:type" content="article">
<meta property="og:title" content="知识点—框架">
<meta property="og:url" content="http://example.com/2023/03/15/%E7%9F%A5%E8%AF%86%E7%82%B9%E2%80%94%E6%A1%86%E6%9E%B6/index.html">
<meta property="og:site_name" content="ValcanoZz Blog">
<meta property="og:description" content="SpingSpring 是一款开源的轻量级 Java 开发框架，旨在提高开发人员的开发效率以及系统的可维护性。 一般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发。 IoCInversion of Control，控制反转，是一种设计思想，而不是具体的思想。 其思想就是将原本在程序手中手动创建对象的控制权，交由Spir">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7">
<meta property="article:published_time" content="2023-03-15T12:34:28.000Z">
<meta property="article:modified_time" content="2023-11-26T07:23:13.190Z">
<meta property="article:author" content="ValcanoZz">
<meta property="article:tag" content="知识点">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"><link rel="shortcut icon" href="/Notes/./img/favicon7.png"><link rel="canonical" href="http://example.com/2023/03/15/%E7%9F%A5%E8%AF%86%E7%82%B9%E2%80%94%E6%A1%86%E6%9E%B6/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/Notes/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/Notes/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '知识点—框架',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-11-26 15:23:13'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="./css/v_footer.css"><link rel="stylesheet" href="./css/v_blog.css"><link rel="stylesheet" href="./css/v_cursors.css"><link rel="stylesheet" href="./css/v_opacity.css"><link rel="stylesheet" href="./css/v_scrollbar.css"><meta name="generator" content="Hexo 6.1.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/Notes/./img/avatar1.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/Notes/archives/"><div class="headline">文章</div><div class="length-num">33</div></a></div><div class="data-item"><a href="/Notes/tags/"><div class="headline">标签</div><div class="length-num">16</div></a></div><div class="data-item"><a href="/Notes/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/Notes/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/Notes/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/Notes/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/Notes/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/Notes/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/Notes/about/"><i class="fa-fw fas fa- heart"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/Notes/">ValcanoZz Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/Notes/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/Notes/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/Notes/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/Notes/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/Notes/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/Notes/about/"><i class="fa-fw fas fa- heart"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">知识点—框架</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-15T12:34:28.000Z" title="发表于 2023-03-15 20:34:28">2023-03-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-11-26T07:23:13.190Z" title="更新于 2023-11-26 15:23:13">2023-11-26</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">17.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>60分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="知识点—框架"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Sping"><a href="#Sping" class="headerlink" title="Sping"></a>Sping</h1><p>Spring 是一款开源的轻量级 Java 开发框架，旨在提高开发人员的开发效率以及系统的可维护性。</p>
<p>一般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发。</p>
<h2 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h2><p>Inversion of Control，控制反转，是一种设计思想，而不是具体的思想。 其思想就是将原本在程序手中手动创建对象的控制权，交由Spirng框架来管理。</p>
<ul>
<li>控制： 指的是对象创建（实例化、管理）的权利。</li>
<li>反转：将控制权交给外部环境。</li>
</ul>
<p>Spring对IoC思想的实现：</p>
<ul>
<li><p>提供了IoC容器，充当“外部”：</p>
<p>IoC容器负责对象的创建、初始化等一系列工作，被创建或被管理的对象在Ioc容器中统称为 <code>Bean</code>。</p>
<p>IoC容器实际上是个Map，Map中存放的是各种对象。</p>
</li>
<li><p>提供实现方式： 依赖注入（DI，Dependency Injection）：</p>
<p>在容器中建立bean与bean之间的依赖关系，直接将对象作为外部输入传递给组件，就是依赖注入。</p>
</li>
</ul>
<h3 id="IoC容器"><a href="#IoC容器" class="headerlink" title="IoC容器"></a>IoC容器</h3><p>容器管理着 Bean 的生命周期，控制着 Bean 的依赖注入，可以说容器是Spring IoC 最重要的部分，其设计主要是基于以下两个接口：</p>
<ul>
<li><p>实现<strong>BeanFactory</strong>接口的简单容器：</p>
<p>—— BeanFactory 是Spring IoC容器的最底层接口，它只提供了IOC容器最基本的功能，给具体的IOC容器的实现提供了规范，所以我们称它为简单容器。</p>
<p>—— 它主要是负责配置、生产和管理bean，其内部定义了对单个bean的获取，对bean的作用域判断，获取bean类型，获取bean别名等功能。</p>
</li>
<li><p>实现<strong>ApplicationContext</strong>接口的高级容器：（一般用这个，需要更灵活地定制容器才用BeanFactory接口）</p>
<p>—— ApplicationContext 扩展(继承)了 BeanFactory，它不仅包含BeanFactory的所有功能，同时它又继承了MessageSource、ListableBeanFactory、ResourceLoader、ApplicationEventPublisher 等接口，这样ApplicationContext 就拥有更高级的IOC容器特性，我们称它为高级容器。</p>
</li>
</ul>
<p>实现类：<strong>DefaultListableBeanFactory</strong>类 实现了 BeanFactory接口，是spring中默认的IoC容器。</p>
<p>BeanDefinition在Spring中是用来描述Bean对象的，它本身并不是一个Bean实例，而是包含了Bean实例的所有信息，比如类名、属性值、构造器参数、scope、依赖的bean、是否是单例类、是否是懒加载以及其它信息。其实就是将Bean实例定义的信息存储到这个BeanDefinition相应的属性中，后面Bean对象的创建是根据BeanDefinition中描述的信息来创建的，例如拿到这个BeanDefinition后，可以根据里面的类名、构造函数、构造函数参数，使用反射进行对象创建。也就是说 IOC容器可以有多个BeanDefinition，并且一个BeanDefinition对象对应一个<code>&lt;bean&gt;</code>标签中的信息。</p>
<p>当然BeanDefinition的最终目的不只是用来存储Bean实例的所有信息，而是为了可以方便的进行修改属性值和其他元信息</p>
<p>IoC容器的启动步骤：</p>
<ol>
<li>解析本地配置文件；</li>
<li>调用 refresh() 方法， refresh方法涉及容器启动的一系列操作；<ul>
<li>其中 IOC 容器初始化包括 BeanDefinition 的 资源定位、载入和注册三个基本过程（走完这三步，就是Bean被定义了，但还没有被初始化）：<ol>
<li><strong>Resource定位</strong>：指的是对开发者的配置文件(Xml)进行资源的定位，并将其封装成Resource对象。它由ResourceLoader通过统一的Resource接口来完成（这个Resource对各种形式的BeanDefinition的使用都提供了统一接口）。这个定位过程类似于容器寻找数据的过程，就像用水捅装水先要把水找到一样。</li>
<li><strong>BeanDefinition的载入</strong>：这个载入过程是将 Resource 定位到的信息 表示成IoC容器内部的数据结构，而这个容器内部的数据结构就是BeanDefinition。</li>
<li><strong>BeanDefinition的注册</strong>：这个注册过程把上面载入过程中解析得到的BeanDeftnition向IoC容器进行注册。注册过程是通过调用BeanDefinitionRegistry接口的实现来完成的。在IoC容器内部将BeanDefinition注人到一个HashMap中去，IoC容器就是通过这个HashMap来持有这些BeanDefinition数据的。</li>
</ol>
</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractApplicationContext.refresh()方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">        <span class="comment">//为刷新准备上下文环境</span></span><br><span class="line">        <span class="comment">// 主要设置状态量（是否关闭，是否激活），记录启动时间，初始化属性资源占位符、校验必填属性是否配置及初始化用于存储早期应用事件的容器。</span></span><br><span class="line">        prepareRefresh();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里是在子类中启动 refreshBeanFactory() 的地方,获得新的BeanFactory</span></span><br><span class="line">        <span class="comment">// 并解析XML、Java类，并加载BeanDefinition</span></span><br><span class="line">        <span class="comment">// 如果BeanFactory已存在，则将其销毁并重建</span></span><br><span class="line">        <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//准备bean工厂，以便在此上下文中使用</span></span><br><span class="line">        <span class="comment">// 如配置上下文的类加载器、后处理程序（post-processors,如设置如总感知接口）。</span></span><br><span class="line">        prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//设置 beanFactory 的后置处理</span></span><br><span class="line">            <span class="comment">// 此时所有的BeanDefinition已被加载,但bean还没有实例化</span></span><br><span class="line">            <span class="comment">// 此时可以注册一些特殊的BeanPostFactory，如web应用会注册ServletContextAwareProcessor等。</span></span><br><span class="line">            postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//调用注册在上下文的 BeanFactory 的后处理器，这些处理器是在Bean定义中向容器注册的</span></span><br><span class="line">            invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//注册Bean的后处理器，在Bean创建过程中调用</span></span><br><span class="line">            registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//对上下文中的消息源进行初始化</span></span><br><span class="line">            initMessageSource();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//初始化上下文中的事件机制, 主要用于广播ApplicationEvent。</span></span><br><span class="line">            initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//初始化其他特殊的Bean</span></span><br><span class="line">            onRefresh();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//检查监听Bean并且将这些监听Bean向容器注册</span></span><br><span class="line">            registerListeners();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//实例化所有非（non-lazy-init）单件</span></span><br><span class="line">            finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//上下文刷新完成, 发布容器事件，结束Refresh过程</span></span><br><span class="line">            finishRefresh();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">            destroyBeans();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">            cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//重置Spring公共的缓存</span></span><br><span class="line">            resetCommonCaches();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Bean"><a href="#Bean" class="headerlink" title="Bean"></a>Bean</h2><p>Bean就是被IoC容器所管理的对象。 我们可以通过XML，注解或Java配置的方式来告诉IoC容器需要管理的对象。</p>
<blockquote>
<p><code>org.springframework.beans</code>和 <code>org.springframework.context</code> 这两个包是 IoC 实现的基础</p>
</blockquote>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>Bean注解声明方式：</p>
<ul>
<li><p><code>@Component</code> ：通用的注解，可标注任意类为 <code>Spring</code> 组件。如果一个 Bean 不知道属于哪个层，可以使用<code>@Component</code> 注解标注。</p>
</li>
<li><p><code>@Repository</code> : 对应持久层即 Dao 层，主要用于数据库相关操作。</p>
</li>
<li><p><code>@Service</code> : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。</p>
</li>
<li><p><code>@Controller</code> : 对应 Spring MVC 控制层，主要用于接受用户请求并调用 <code>Service</code> 层返回数据给前端页面。</p>
</li>
<li><p><code>@Bean</code>：作用于方法， 此方法返回的实例对象作为Bean交给IoC容器。很多时候只能通过@Bean来注册Bean，如引用第三方库的类要装配到IoC容器中时。</p>
</li>
</ul>
<p>注入Bean的注解方法：</p>
<ul>
<li><p><code>@Autowired</code>： 属于 org.springframework.bean.factory，是Spring内置的注解，默认注入方式是 <code>byType</code>（根据类型匹配）。</p>
<p>当一个接口存在多个实现类时，byType方法就无法正确注入对象，此时，注入方式会变成 <code>byName</code>（根据名称匹配，名称通常是类名，首字母小写）。一般还是要用 <code>@Qualifier</code> 来显示指定名称，而不是依赖变量的名称。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错，byName 和 byType 都无法匹配到 bean</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> SmsService smsService;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确注入 SmsServiceImpl1 对象对应的 bean</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> SmsService smsServiceImpl1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确注入  SmsServiceImpl1 对象对应的 bean</span></span><br><span class="line"><span class="comment">// smsServiceImpl1 就是上述所说的名称</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(value = &quot;smsServiceImpl1&quot;)</span></span><br><span class="line"><span class="keyword">private</span> SmsService smsService;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>@Resource</code>：属于 javax.annotation，是 JDK提供的注解，默认注入方式为 <code>byName</code>，如果无法通过名称匹配，注入方式会变成 <code>byType</code>。 @Resource有两个常用属性：name，type，分别指定名称和类型，同时指定的话注入方式会是byType+byName，不推荐。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错，byName 和 byType 都无法匹配到 bean</span></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> SmsService smsService;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确注入 SmsServiceImpl1 对象对应的 bean</span></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> SmsService smsServiceImpl1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确注入 SmsServiceImpl1 对象对应的 bean（比较推荐这种方式）</span></span><br><span class="line"><span class="meta">@Resource(name = &quot;smsServiceImpl1&quot;)</span></span><br><span class="line"><span class="keyword">private</span> SmsService smsService;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>@Inject</code>：属于 javax.inject。</p>
</li>
</ul>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><ul>
<li><strong>singleton</strong> : IoC 容器中只有唯一的 bean 实例。Spring 中的 bean 默认都是单例的，是对单例设计模式的应用。</li>
<li><strong>prototype</strong> : 每次获取都会创建一个新的 bean 实例。也就是说，连续 <code>getBean()</code> 两次，得到的是不同的 Bean 实例。</li>
<li><strong>request</strong> （仅 Web 应用可用）: 每一次 HTTP 请求都会产生一个新的 bean（请求 bean），该 bean 仅在当前 HTTP request 内有效。</li>
<li><strong>session</strong> （仅 Web 应用可用） : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean（会话 bean），该 bean 仅在当前 HTTP session 内有效。</li>
<li><strong>application&#x2F;global-session</strong> （仅 Web 应用可用）： 每个 Web 应用在启动时创建一个 Bean（应用 Bean），该 bean 仅在当前应用启动时间内有效。</li>
<li><strong>websocket</strong> （仅 Web 应用可用）：每一次 WebSocket 会话产生一个新的 bean。</li>
</ul>
<p>配置作用域，字段为scope：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span></span><br><span class="line"><span class="keyword">public</span> Person <span class="title function_">personPrototype</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;...&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>单例 Bean 存在线程问题，主要是因为当多个线程操作同一个对象的时候是存在资源竞争的。</p>
<p>常见的有两种解决办法：</p>
<ol>
<li>在 Bean 中尽量避免定义可变的成员变量。</li>
<li>在类中定义一个 <code>ThreadLocal</code> 成员变量，将需要的可变成员变量保存在 <code>ThreadLocal</code> 中（推荐的一种方式）。</li>
</ol>
<p>不过，大部分 Bean 实际都是无状态（没有实例变量）的（比如 Dao、Service），这种情况下， Bean 是线程安全的。</p>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><ol>
<li><p>加载Bean定义</p>
<p>调用 loadBeanDefinitions方法，扫描所有xml配置、注解，将Bean记录在beanDefinitionMap中。</p>
</li>
<li><p>创建Bean对象 </p>
<p>调用 createBean方法 遍历 beanDefinitionMap 创建bean。</p>
<ol>
<li><p>构建对象</p>
<ul>
<li><p>利用反射机制从 Bean定义中获取类的构造方法。 （优先使用带@Autowired的构造方法，其次是无参构造方法，最后是有参构造方法）</p>
</li>
<li><p>寻找构造方法的参数： 根据类查找&gt;参数名查找（先byType再byName）</p>
</li>
<li><p>构造对象&#x2F;实例化</p>
</li>
</ul>
</li>
<li><p>填充属性：为Bean内部所需的属性进行赋值，通常是类中 @Autowired 注解的变量。</p>
</li>
<li><p>初始化Bean对象：通过initializeBean对填充后的实例进行初始化</p>
</li>
</ol>
</li>
<li><p>添加到单例池</p>
<p>通过 addSingleton 方法，将Bean 加入到单例池 <strong>singleObjects</strong> </p>
</li>
<li><p>销毁 </p>
<ol>
<li>销毁前调用 bean中@PreDestory 注解的方法，通过 postProcessBeforeDestruction 方法调用destoryBean逐一销毁Bean</li>
<li>销毁：调用 destoryBeans</li>
<li>执行客户自定义销毁：调用 invokeCustomDestoryMethod</li>
</ol>
</li>
</ol>
<blockquote>
<p>填充初始化容器相关信息：</p>
<p>通过 <strong>invokeAwareMethods</strong> 方法：为实现aware接口【信息感知接口】的Bean 设置注入beanName、beanFactory等容器信息</p>
<p>初始化构造方法：</p>
<ul>
<li>通过 <strong>invokeInitMethods</strong> 方法进行初始化：</li>
</ul>
<p>如果Bean实现InitializingBean接口进行处理【未实现则不进行】</p>
<ul>
<li>afterPropertiesSet方法【bean填充属性后执行】</li>
<li>initMethod 方法</li>
</ul>
<p>Bean的后置处理：</p>
<p>在<strong>invokeInitMethods</strong> 的前后进行</p>
<ul>
<li>applyBeanPostProcessorsBeforeInitialization</li>
<li><strong>invokeInitMethods</strong> </li>
<li>applyBeanPostProcessorsAfterInitialization</li>
</ul>
<p>在后置处理中处理了包括：AOP【AnnotationAwareAspectJAutoProxyCreator】，负责 <strong>构造后@PostConstruct</strong> 和 <strong>销毁前@PreDestroy</strong> 的  InitDestoryAnnotationBeanPostProcessor 等</p>
<p>注册销毁：</p>
<p>通过reigsterDisposableBean处理实现了DisposableBean接口的Bean的注册</p>
</blockquote>
<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>Aspect-Oriented Programming，面向切面编程。</p>
<p>首先，面向对象编程OOP可以利用继承的方式实现代码复用，当对于同一个类中的不同方法的特定位置，都出现的重复代码，却没办法复用。</p>
<p>于是，AOP要做的就是将 与业务无关，却为业务模块共用的逻辑封装起来（如 事务处理，日志管理，权限控制）。</p>
<p>AOP是基于动态代理的，代理的对象如果有实现某个接口，就用JDK Proxy，没有实现接口的就用Cglib。</p>
<blockquote>
<p>更多使用详情在 Java—SSM笔记中  </p>
</blockquote>
<ul>
<li><p>Spirng AOP 和 AspectJ AOP 的区别：</p>
<p>Spirng AOP 是运行时增强，基于代理；  AspectJ AOP是编译时增强，基于字节码操作。 在切面较少时两者差距不大，当切面太多的话，应当选择用AspectJ。</p>
<blockquote>
<p>Spring AOP 已经集成了 AspectJ</p>
</blockquote>
</li>
</ul>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>Spring 使用工厂模式可以通过 <code>BeanFactory</code> 或 <code>ApplicationContext</code> 创建 bean 对象。</p>
<p><strong>比如：</strong></p>
<ul>
<li><p><code>BeanFactory</code> ：延迟注入（使用到某个 bean 的时候才会注入)，相比于<code>ApplicationContext</code> 来说会占用更少的内存，程序启动速度更快。</p>
</li>
<li><p><code>ApplicationContext</code> ：容器启动的时候，不管你用没用到，一次性创建所有 bean 。<code>BeanFactory</code> 仅提供了最基本的依赖注入支持，<code>ApplicationContext</code> 扩展了 <code>BeanFactory</code> ,除了有<code>BeanFactory</code>的功能还有额外更多功能，所以一般开发人员使用<code>ApplicationContext</code>会更多。</p>
<p>三个实现类： </p>
<ol>
<li><code>ClassPathXmlApplication</code>：把上下文文件当成类路径资源。</li>
<li><code>FileSystemXmlApplication</code>：从文件系统中的 XML 文件载入上下文定义信息。</li>
<li><code>XmlWebApplicationContext</code>：从 Web 系统中的 XML 文件载入上下文定义信息。</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileSystemXmlApplicationContext</span>(</span><br><span class="line">    <span class="string">&quot;x:/xxx/src/main/resources/bean-factory-config.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Hello</span> <span class="variable">obj</span> <span class="operator">=</span> (Hello) context.getBean(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">obj.getMsg();</span><br></pre></td></tr></table></figure>



<h3 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h3><p>如 线程池，缓冲，对话框，注册表等都是只能有一个实例，多个实例可能会造成程序的行为异常，结果不一致，资源使用过量等。</p>
<p><strong>Spring 中 bean 的默认作用域就是 singleton(单例)的。</strong></p>
<h3 id="代理设计模式"><a href="#代理设计模式" class="headerlink" title="代理设计模式"></a>代理设计模式</h3><p><strong>Spring AOP就是基于动态代理实现</strong>。</p>
<p>注：AspectJ AOP不是基于动态代理， 而是使用编译时织入或者运行时织入的方式来实现AOP。—— 在编译时织入，会在编译阶段把切面织入到目标代码中，生成织入切面后的class文件。—— 在运行时织入，会在应用启动时或者类加载时动态地把切面织入到目标对象的字节码中。</p>
<h3 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h3><p>Spring中的 <code>JdbcTemplate</code>、<code>HibernateTemplate</code> 等<strong>以 Template 结尾的对数据库操作的类</strong>，它们就使用到了模板模式。</p>
<p>一般情况下，我们都是使用继承的方式来实现模板模式，但是 Spring 并没有使用这种方式，而是使用 Callback 模式与模板方法模式配合，既达到了代码复用的效果，同时增加了灵活性。</p>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>Spring 的<strong>事件驱动模型</strong>就是观察者模式很经典的一个应用。</p>
<p>Spring 事件驱动模型非常有用，在很多场景都可以解耦我们的代码。比如我们每次添加商品的时候都需要重新更新商品索引，这个时候就可以利用观察者模式来解决这个问题。 </p>
<p>使用：</p>
<ul>
<li>定义 事件角色 继承 ApplicationEvent 抽象类，重写构造函数；</li>
<li>定义 事件监听者 实现 ApplicationListener 接口，重写 onApplicationEvent() 方法 实现监听；</li>
<li>定义 事件发布者 实现 ApplicationEventPublisher 接口， Spring中的 ApplicationContext 就实现了这个接口，通过publishEvent() 方法发布消息；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个事件,继承自ApplicationEvent并且写相应的构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoEvent</span> <span class="keyword">extends</span> <span class="title class_">ApplicationEvent</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DemoEvent</span><span class="params">(Object source,String message)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(source);</span><br><span class="line">        <span class="built_in">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMessage</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个事件监听者,实现ApplicationListener接口，重写 onApplicationEvent() 方法；</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoListener</span> <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;DemoEvent&gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用onApplicationEvent接收消息</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(DemoEvent event)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> event.getMessage();</span><br><span class="line">        System.out.println(<span class="string">&quot;接收到的信息是：&quot;</span>+msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布事件，可以通过ApplicationEventPublisher  的 publishEvent() 方法发布消息。</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoPublisher</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publish</span><span class="params">(String message)</span>&#123;</span><br><span class="line">        <span class="comment">//发布事件</span></span><br><span class="line">        applicationContext.publishEvent(<span class="keyword">new</span> <span class="title class_">DemoEvent</span>(<span class="built_in">this</span>, message));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>Spring AOP 的实现是基于代理模式，但是 Spring AOP 的增强或通知(Advice)使用到了适配器模式，与之相关的接口是<code>AdvisorAdapter</code> 。</p>
<p>因为 通知Advice 和 切点Join Point 两者的接口不匹配，适配器（Adapter）将Advice对象转换为 Adapter对象，这样就可以将Advice对象应用于任何类型的切点（Join Point）上。</p>
<p>如： <code>MethodBeforeAdviceAdapter</code> 通过调用 <code>getInterceptor</code> 方法，将 <code>MethodBeforeAdvice</code> 适配成 <code>MethodBeforeAdviceInterceptor</code> ）。</p>
<hr>
<p>Spring MVC的适配器模式：</p>
<p>在 Spring MVC 中，<code>DispatcherServlet</code> 根据请求信息调用 <code>HandlerMapping</code>，解析请求对应的 <code>Handler</code>。解析到对应的 <code>Handler</code>（即<code>Controller</code>控制器）后，开始由<code>HandlerAdapter</code> 适配器处理。</p>
<p>因为Spring MVC中的Controller种类众多，不同类型的 Controller 通过不同的方法来对请求进行处理。如果不利用适配器模式的话，DispatcherServlet 直接获取对应类型的 Controller，需要判断获取到的具体是哪个 Controller，这样会有很多判断语句，使程序难以维护，不好拓展。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DispatcherServlet自己判断Controller类型</span></span><br><span class="line"><span class="keyword">if</span>(mappedHandler.getHandler() <span class="keyword">instanceof</span> MultiActionController)&#123;</span><br><span class="line">   ((MultiActionController)mappedHandler.getHandler()).xxx</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(mappedHandler.getHandler() <span class="keyword">instanceof</span> XXX)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(...)&#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="装饰者模式？"><a href="#装饰者模式？" class="headerlink" title="装饰者模式？"></a>装饰者模式？</h3><h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><p><strong>传统Spring框架存在的弊端：</strong></p>
<ul>
<li>Spring事物管理，MVC，启用第三方库都需要XML或Java进行显示配置，配置过重</li>
<li>写配置挤占了实际写应用的逻辑的时间 </li>
<li>项目依赖管理，要考虑用那些库，还要知道哪些版本和库不会有冲突，影响开发效率</li>
</ul>
<p><strong>SpringBoot的优势：</strong></p>
<ul>
<li>自动配置：针对很多Spring常见的应用功能，SpringBoot能自动提供相关配置</li>
<li>起步依赖：告诉SpringBoot需要什么功能，它就能引入需要的库</li>
<li>内置tomcat等服务器，可以直接达成jar包运行 </li>
<li>CLI命令行界面：通过SpringBootCLI，借此你只需写代码就能完成完整的应用程序，无须传统项目构建</li>
<li>Actuator: 提供在运行时检视应用程序内部情况的能力</li>
</ul>
<p><strong>Springbooot两大特性</strong>：</p>
<ul>
<li>依赖管理</li>
<li>自动装配</li>
</ul>
<h2 id="常用注解说明"><a href="#常用注解说明" class="headerlink" title="常用注解说明"></a>常用注解说明</h2><blockquote>
<ul>
<li><p>@Controller标记此类是一个控制器，可以返回视图解析器指定的html，通过@ResponseBody可以将结果以json、xml形式返回；</p>
</li>
<li><p>@RestController &#x3D; @Controller + @ResponseBody，实现rest接口开发，只能返回json数据，不能返回html页面；</p>
</li>
<li><p>@RequestMapping：定义接口地址，可以标记在类上、方法上，支持http的post、get、put等方法；</p>
</li>
<li><p>@GetMapping、xxxMapping：定义对应的get或其他方法，只能标记在方法上；</p>
</li>
<li><p>@RequestBody：定义在方法参数上，将json传参转成java对象；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/book&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookController</span> &#123;</span><br><span class="line">	.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>@PathVarible：接口请求路径中占位符的值；</p>
</li>
</ul>
</blockquote>
<h3 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h3><p>创建SpringBoot项目会默认在主类加上。 可以把@SpringBootApplication 看作是 @SpringBootConfiguration、@EnableAutoConfiguration、@ComponentScan 的集合。</p>
<ul>
<li>@SpringBootConfiguration：等价于@Configuration，标注当前类是一个配置类并注入到 IOC容器中。</li>
<li>@EnableAutoConfiguration：启动SpringBoot的自动配置机制</li>
<li>@ComponentScan：允许在Spring上下文注册额外的bean或导入其他配置类。</li>
</ul>
<h3 id="Bean相关"><a href="#Bean相关" class="headerlink" title="Bean相关"></a>Bean相关</h3><ul>
<li><p><strong>@Autowired</strong></p>
<p>自动导入对象到类中，要求被注入的类要被Spring容器管理。</p>
</li>
<li><p>@Component、@Repository、@Service、@Controller </p>
<p>将类交由Spring容器管理：</p>
<ul>
<li><strong>@Component</strong> ：通用的注解，可标注任意类为 <code>Spring</code> 组件。如果一个 Bean 不知道属于哪个层，可以使用<code>@Component</code> 注解标注。</li>
<li><strong>@Repository</strong> : 对应持久层即 Dao 层，主要用于数据库相关操作。</li>
<li><strong>@Service</strong> : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层的Bean。</li>
<li><strong>@Controller</strong> : 对应 Spring MVC 控制层，主要用于接受用户请求并调用 Service 层返回数据给前端页面</li>
</ul>
</li>
<li><p><strong>@RestController</strong></p>
<p>@RestController是 @Controller和@ResponseBody的合集。表示这是 控制器bean，将函数返回值直接填入HTTP响应体中，是REST风格的控制器。</p>
</li>
<li><p><strong>@Scope</strong></p>
<p>声明bean的作用域。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Scope(&quot;singleton&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Person <span class="title function_">personSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>常见的作用域有：</p>
<ul>
<li>singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。</li>
<li>prototype : 每次请求都会创建一个新的 bean 实例。</li>
<li>request : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。</li>
<li>session : 每一个 HTTP Session 会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。</li>
</ul>
</li>
<li><p><strong>@Configuration</strong></p>
<p>用于声明配置类，也可以使用@Component代替，不过@Configuration更加语义化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TransferService <span class="title function_">transferService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TransferServiceImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="处理常见的HTTP请求"><a href="#处理常见的HTTP请求" class="headerlink" title="处理常见的HTTP请求"></a>处理常见的HTTP请求</h3><p>有5种常见的请求类型：GET—请求资源，POST—创建资源，PUT—更新资源，DELETE—删除资源，PATCH—更新资源（客户端提供部分更改的属性）</p>
<ul>
<li><p>GET请求</p>
<p>@GetMapping(“users”) 等价于 @RequestMapping(value&#x3D;”&#x2F;users”,method&#x3D;RequestMethod.GET) </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;List&lt;User&gt;&gt; <span class="title function_">getAllUsers</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> userRepository.findAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>POST请求</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;User&gt; <span class="title function_">createUser</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@RequestBody</span> UserCreateRequest userCreateRequest)</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> userRespository.save(userCreateRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>PUT请求</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PutMapping(&quot;/users/&#123;userId&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;User&gt; <span class="title function_">updateUser</span><span class="params">(<span class="meta">@PathVariable(value = &quot;userId&quot;)</span> Long userId,</span></span><br><span class="line"><span class="params">  <span class="meta">@Valid</span> <span class="meta">@RequestBody</span> UserUpdateRequest userUpdateRequest)</span> &#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>DELETE请求</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DeleteMapping(&quot;/users/&#123;userId&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity <span class="title function_">deleteUser</span><span class="params">(<span class="meta">@PathVariable(value = &quot;userId&quot;)</span> Long userId)</span>&#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>PATCH请求</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PatchMapping(&quot;/profile&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity <span class="title function_">updateStudent</span><span class="params">(<span class="meta">@RequestBody</span> StudentUpdateRequest studentUpdate)</span> &#123;</span><br><span class="line">    studentRepository.updateDetail(studentUpdate);</span><br><span class="line">    <span class="keyword">return</span> ResponseEntity.ok().build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="前后端传值"><a href="#前后端传值" class="headerlink" title="前后端传值"></a>前后端传值</h3><ul>
<li><p><strong>@PathVariable</strong> 和 <strong>@RequestParam</strong></p>
<p>@PathVariable用于获取路径参数， @RequestParam用于获取查询参数。</p>
<p>假设请求的url是：&#x2F;klasses&#x2F;123456&#x2F;teachers?type&#x3D;web；—— 那么以下代码获取到的参数是 klassId&#x3D;123456, type&#x3D;web。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/klasses/&#123;klassId&#125;/teachers&quot;)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Teacher&gt; <span class="title function_">getKlassRelatedTeachers</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="meta">@PathVariable(&quot;klassId&quot;)</span> Long klassId,</span></span><br><span class="line"><span class="params">    <span class="meta">@RequestParam(value = &quot;type&quot;, required = false)</span> String type )</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>@RequestBody</strong></p>
<p>用于读取Request请求的body部分，并且 Content-Type 为 application&#x2F;json 格式，接收数据之后会自动将数据绑定到 Java对象上去。</p>
<p>系统会使用 HttpMessageConverter 或者自定义的HttpMessageConverter 将请求的 body 中的 json 字符串转换为 java 对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserRegisterRequest</span> &#123;</span><br><span class="line">    <span class="meta">@NotBlank</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="meta">@NotBlank</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="meta">@NotBlank</span></span><br><span class="line">    <span class="keyword">private</span> String fullName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请求参数body部分携带的JSON数据</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;userName&quot;</span><span class="punctuation">:</span><span class="string">&quot;coder&quot;</span><span class="punctuation">,</span><span class="attr">&quot;fullName&quot;</span><span class="punctuation">:</span><span class="string">&quot;shuangkou&quot;</span><span class="punctuation">,</span><span class="attr">&quot;password&quot;</span><span class="punctuation">:</span><span class="string">&quot;123456&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/sign-up&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity <span class="title function_">signUp</span><span class="params">(<span class="meta">@RequestBody</span> <span class="meta">@Valid</span> UserRegisterRequest userRegisterRequest)</span> &#123;</span><br><span class="line">  userService.save(userRegisterRequest);</span><br><span class="line">  <span class="keyword">return</span> ResponseEntity.ok().build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>注意： 一个请求方法只能有一个 @RequestBody，但可以有@RequestParam 和 @PathVaiable。</p>
<h3 id="读取配置信息"><a href="#读取配置信息" class="headerlink" title="读取配置信息"></a>读取配置信息</h3><ul>
<li><p><strong>@Value</strong> （常用）</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">wuhan2020:</span> <span class="number">2020</span><span class="string">年初武汉爆发了新型冠状病毒，疫情严重，但是，我相信一切都会过去！武汉加油！中国加油！</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;wuhan2020&#125;&quot;)</span></span><br><span class="line">String wuhan2020;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>@ConfigurationProperties</strong> （常用）</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">library:</span></span><br><span class="line">  <span class="attr">location:</span> <span class="string">湖北武汉加油中国加油</span></span><br><span class="line">  <span class="attr">books:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">天才基本法</span></span><br><span class="line">      <span class="attr">description:</span> <span class="string">二十二岁的林朝夕。。。</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">时间的秩序</span></span><br><span class="line">      <span class="attr">description:</span> <span class="string">为什么我们记得过去，而非未来？。。。</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">了不起的我</span></span><br><span class="line">      <span class="attr">description:</span> <span class="string">如何养成一个新习惯？如何让。。。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;library&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LibraryProperties</span> &#123;</span><br><span class="line">    <span class="meta">@NotEmpty</span></span><br><span class="line">    <span class="keyword">private</span> String location;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Book&gt; books;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Setter</span></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="meta">@ToString</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">        String name;</span><br><span class="line">        String description;</span><br><span class="line">    &#125;</span><br><span class="line">  	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>@PropertySource</strong> （不常用）</p>
<p>读取指定properties文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:website.properties&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WebSite</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line"></span><br><span class="line">  	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="参数校验"><a href="#参数校验" class="headerlink" title="参数校验"></a>参数校验</h3><p><strong>JSR(Java Specification Requests）</strong> 是一套 JavaBean 参数校验的标准，它定义了很多常用的校验注解，我们可以直接将这些注解加在 Bean 的属性上面。</p>
<p>一般使用的是JSR注解，即 <strong><code>javax.validation.constraints</code></strong> 。</p>
<ol>
<li><p>验证请求体（RequestBody）：</p>
<p>先在对应的Bean中加上字段对应的校验注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull(message = &quot;classId 不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String classId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Size(max = 33)</span></span><br><span class="line">    <span class="meta">@NotNull(message = &quot;name 不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pattern(regexp = &quot;((^Man$|^Woman$|^UGM$))&quot;, message = &quot;sex 值不在可选范围&quot;)</span></span><br><span class="line">    <span class="meta">@NotNull(message = &quot;sex 不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在需要验证的参数上加上@Valid注解。如果验证失败，它将抛出<code>MethodArgumentNotValidException</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/person&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getPerson</span><span class="params">(<span class="meta">@RequestBody</span> <span class="meta">@Valid</span> Person person)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>验证请求参数：</p>
<p>在类上加上 <strong>@Validated</strong> 注解，Spring才知道要验证参数。参数上加 @Valid 和对应的验证注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api&quot;)</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/person/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getPersonByID</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="meta">@Max(value = 5,message = &quot;超过 id 的范围了&quot;)</span> Integer id)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><strong>字段验证：</strong><ul>
<li><code>@NotEmpty</code> 被注释的字符串的不能为 null 也不能为空</li>
<li><code>@NotBlank</code> 被注释的字符串非 null，并且必须包含一个非空白字符</li>
<li><code>@Null</code> 被注释的元素必须为 null</li>
<li><code>@NotNull</code> 被注释的元素必须不为 null</li>
<li><code>@AssertTrue</code> 被注释的元素必须为 true</li>
<li><code>@AssertFalse</code> 被注释的元素必须为 false</li>
<li><code>@Pattern(regex=,flag=)</code>被注释的元素必须符合指定的正则表达式</li>
<li><code>@Email</code> 被注释的元素必须是 Email 格式。</li>
<li><code>@Min(value)</code>被注释的元素必须是一个数字，其值必须大于等于指定的最小值</li>
<li><code>@Max(value)</code>被注释的元素必须是一个数字，其值必须小于等于指定的最大值</li>
<li><code>@DecimalMin(value)</code>被注释的元素必须是一个数字，其值必须大于等于指定的最小值</li>
<li><code>@DecimalMax(value)</code> 被注释的元素必须是一个数字，其值必须小于等于指定的最大值</li>
<li><code>@Size(max=, min=)</code>被注释的元素的大小必须在指定的范围内</li>
<li><code>@Digits(integer, fraction)</code>被注释的元素必须是一个数字，其值必须在可接受的范围内</li>
<li><code>@Past</code>被注释的元素必须是一个过去的日期</li>
<li><code>@Future</code> 被注释的元素必须是一个将来的日期</li>
<li>…</li>
</ul>
</li>
</ul>
<h3 id="全局处理Controller层异常"><a href="#全局处理Controller层异常" class="headerlink" title="全局处理Controller层异常"></a>全局处理Controller层异常</h3><p>相关注解：</p>
<ul>
<li>@ControllerAdvice： 定义全局异常处理类。</li>
<li>@ExceptionHandler：声明异常处理方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求参数异常处理</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(MethodArgumentNotValidException.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMethodArgumentNotValidException</span><span class="params">(MethodArgumentNotValidException ex, HttpServletRequest request)</span> &#123;</span><br><span class="line">       ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="JPA（TODO）"><a href="#JPA（TODO）" class="headerlink" title="JPA（TODO）"></a>JPA（TODO）</h3><p>Java Persistence API， 允许Java程序使用 类 来表示 数据库表，使用java对象来执行数据库操作，而不必编写SQL语句。</p>
<p>。。。</p>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>在要开启事务的public方法上使用 @Transactional 即可。 （事务所在的类，必须被Spring管理，否则不生效）</p>
<p>@Transactional 常用配置参数：propagation, isolation, timeout, rollbackFor</p>
<ul>
<li><p><strong>propagation</strong> —— 事务传播行为，默认为REQUIRED。以下是可能的值：</p>
<p>（写法： propagation &#x3D; Propagation.REQUIRED。虽然TransactionDefinition里面定义了传播行为的常量，不过为了方便使用，Spring又定义一个枚举类Propagation来使用）</p>
<ul>
<li><p><strong><code>TransactionDefinition.PROPAGATION_REQUIRED</code></strong> </p>
<p>​	默认使用，如果当前存在事务，则加入该事务； 否则创建一个新事务。 （两个方法都是PROPAGATION_REQUIRED传播行为的话，两者使用同一个事务，其中一个方法回滚，整个事务都会回滚）</p>
</li>
<li><p><strong><code>TransactionDefinition.PROPAGATION_REQUIRES_NEW</code></strong> </p>
<p>​	直接创建新事务，与其他事务相互独立，互不干扰。</p>
<p>（假如外部方法使用PROPAGATION_REQUIRED修饰， 当前方法使用PROPAGATION_REQUIRES_NEW修饰，如果外部方法发生异常回滚了，当前方法不会回滚； 如果当前方法抛出未捕获的异常且满足回滚规则，那么外部方法会检测到异常，发生回滚）</p>
</li>
<li><p><strong><code>TransactionDefinition.PROPAGATION_NESTED</code></strong></p>
<p>​	如果当前存在事务，则在其内部开启新事务，作为嵌套事务存在，否则创建一个新事务。</p>
<p>（内部方法发生回滚，外部方法也会回滚）</p>
</li>
<li><blockquote>
<p>还有四种用的很少的传播行为：</p>
<ul>
<li>TransactionDefinition.PROPAGATION_MANDATORY —— 当前存在事务，则加入； 否则直接抛出异常</li>
<li>TransactionDefinition.PROPAGATION_SUPPORTS —— 当前存在事务，则加入； 否则以非事务的方式继续运行。</li>
<li>TransactionDefinition.PROPAGATION_NOT_SUPPORTED: 以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li>
<li>TransactionDefinition.PROPAGATION_NEVER: 以非事务方式运行，如果当前存在事务，则抛出异常。</li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>isolation</strong> —— 事务隔离级别，默认为DEFAULT。</p>
<p>（同样有枚举类：Isolation，如  isolation &#x3D; Isolation.REPEATABLE_READ）</p>
<ul>
<li><strong><code>TransactionDefinition.ISOLATION_DEFAULT</code></strong> —— 使用后端数据库默认的隔离级别。</li>
<li><strong><code>TransactionDefinition.ISOLATION_READ_UNCOMMITTED</code></strong> —— 读未提交。（极少用）</li>
<li><strong><code>TransactionDefinition.ISOLATION_READ_COMMITTED</code></strong>  —— 读已提交</li>
<li><strong><code>TransactionDefinition.ISOLATION_READ_COMMITTED</code></strong>  —— 可重复读</li>
<li><strong><code>TransactionDefinition.ISOLATION_SERIALIZABLE</code></strong> —— 可串行化</li>
</ul>
</li>
<li><p><strong>timeout</strong> —— 事务的超时时间，单位是秒，默认值-1，表示不会超时。如果超过该时间还未完成事务，则回滚事务。</p>
</li>
<li><p><strong>rollbackFor</strong> —— 指定能触发回滚的异常类型，可以指定多个。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(</span></span><br><span class="line"><span class="meta">    rollbackFor = Exception.class,</span></span><br><span class="line"><span class="meta">	propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Transactional 注解原理： 是基于AOP实现的，AOP又是使用动态代理实现。目标对象有实现接口，默认使用 JDK动态代理，没有实现接口，则使用CGLIB动态代理。</p>
<p>注意点：</p>
<ul>
<li><p>@Transactional 如果不配置 rollbackFor 属性的话，那么事务只有遇到运行时异常才会回滚。 加上 rollbackFor &#x3D; Exception.class ，可以让事务在遇到非运行时异常时也回滚。</p>
</li>
<li><p>@Transactional 加在类上，表示类的所有Public方法都配置相同的事务属性信息。 方法和类都加@Transactional，方法的事务优先。</p>
</li>
<li><p>自调用问题： 使用Spring AOP时，同一类中没有@Transactional的方法调用有@Transactional注解的方法， 被调用方法的事务会失效。 只有在类以外被调用，才不会失效。</p>
<p>解决：避免同一类中自调用，或用AspectJ 取代之。</p>
</li>
</ul>
<h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><ul>
<li><p>过滤 json 数据： @JsonIgnoreProperties 放在类上， @JsonIgnore 放在属性字段上。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生成json时将userRoles属性过滤</span></span><br><span class="line"><span class="meta">@JsonIgnoreProperties(&#123;&quot;userRoles&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String fullName;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> List&lt;UserRole&gt; userRoles = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上下两个作用一样</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String fullName;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//生成json时将userRoles属性过滤</span></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;UserRole&gt; userRoles = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>格式化 json： @JsonFormat</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonFormat(shape=JsonFormat.Shape.STRING, pattern=&quot;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSS&#x27;Z&#x27;&quot;, timezone=&quot;GMT&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Date date;</span><br></pre></td></tr></table></figure>
</li>
<li><p>扁平化类中的对象： @JsonUnwrapped</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="meta">@JsonUnwrapped</span></span><br><span class="line">    <span class="keyword">private</span> Location location;</span><br><span class="line">    <span class="meta">@JsonUnwrapped</span></span><br><span class="line">    <span class="keyword">private</span> PersonInfo personInfo;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扁平化前</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;location&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;provinceName&quot;</span><span class="punctuation">:</span><span class="string">&quot;湖北&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;countyName&quot;</span><span class="punctuation">:</span><span class="string">&quot;武汉&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;personInfo&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;userName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;coder1234&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;fullName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;shaungkou&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="comment">// 扁平化后</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;provinceName&quot;</span><span class="punctuation">:</span><span class="string">&quot;湖北&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;countyName&quot;</span><span class="punctuation">:</span><span class="string">&quot;武汉&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;userName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;coder1234&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;fullName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;shaungkou&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="测试相关"><a href="#测试相关" class="headerlink" title="测试相关"></a>测试相关</h3><ul>
<li><p><strong>@ ActiveProfiles</strong> —— 作用于测试类上，用于声明生效的Spring配置文件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest(webEnvironment = RANDOM_PORT)</span></span><br><span class="line"><span class="meta">@ActiveProfiles(&quot;test&quot;)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">TestBase</span> &#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>@Test</strong> —— 声明当前方法为测试方法。</p>
</li>
<li><p><strong>@Transactional</strong> —— 声明测试方法的数据需要回滚，避免污染测试数据。</p>
</li>
<li><p><strong>@WithMockUser</strong> —— Spring Security 提供，用来模拟一个真实用户，并且可以赋予权限。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@WithMockUser(username = &quot;user-id-18163138155&quot;, authorities = &quot;ROLE_TEACHER&quot;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">should_import_student_success</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h2><p>SpringBoot 定义了一套接口规范，这套规范规定：SpringBoot 在启动时会扫描外部引用 jar 包中的<code>META-INF/spring.factories</code>文件，将文件中配置的类型信息加载到 Spring 容器，并执行类中定义的各种操作。</p>
<p>通过<code>@EnableAutoConfiguration</code>开启自动装配，通过 SpringFactoriesLoader 最终加载<code>META-INF/spring.factories</code>中的自动配置类实现自动装配，自动配置类其实就是通过<code>@Conditional</code>按需加载的配置类，想要其生效必须引入<code>spring-boot-starter-xxx</code>包实现起步依赖。</p>
<blockquote>
<p>根据导入依赖，来自动装配tomcat，springMVC，web常见功能（如编码问题），默认包结构 等，就是按需加载所有自动配置项。</p>
</blockquote>
<h2 id="约定大于配置"><a href="#约定大于配置" class="headerlink" title="约定大于配置"></a>约定大于配置</h2><p>意思是通过约定来减少配置。</p>
<p>例如，在 Spring Boot 中，当我们导入一个 <code>spring-boot-starter-web</code> 后，就会自动的帮我们导入 Spring MVC 的相关依赖（包括 Json 支持的 Jackson 和数据校验的 Hibernate Validator）和一个内置的 Tomcat 容器，这使得在开发阶段可以直接通过 main 方法或是 JAR 包独立运行一个 Web 项目。</p>
<p>类似的，新建项目时默认的 <code>application.properties</code>或<code>application.yml</code>文件，默认的包目录（main，resources，target）等</p>
<h2 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h2><p>Springboot启动类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplication</span> &#123;</span><br><span class="line">    <span class="comment">// 运行main方法启动Springboot</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MyApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只需在启动类上标注@SpringBootApplication，再调用 SpringApplication.run(MyApplication.class, args) 就可以完成Srpingboot的启动流程了。</p>
<ul>
<li>其中 @SpringBootApplication 可以看作是 @Configuration、@EnableAutoConfiguration、@ComponentScan 的集合。 能够触发 包扫描和自动配置，让相关的bean被注册进spring容器。</li>
</ul>
<p>具体的流程：</p>
<ol start="0">
<li><strong>启动main方法开始</strong></li>
<li><strong>初始化配置：</strong>  通过类加载器（loadFactories）读取classpath下所有的spring.factories配置文件，创建一些初始配置对象；通知监听者应用程序启动开始，创建环境对象environment，用于读取环境配置 如 application.yml </li>
<li><strong>创建应用程序上下文</strong>createApplicationContext，同时创建 bean工厂对象</li>
<li><strong>刷新上下文（启动核心）：</strong><ol>
<li>配置工厂对象，包括上下文类加载器，对象发布处理器，beanFactoryPostProcessor </li>
<li>注册并实例化bean工厂发布处理器，并且调用这些处理器，对包扫描解析(主要是class文件) </li>
<li>注册并实例化bean发布处理器 beanPostProcessor</li>
<li>初始化一些与上下文有特别关系的bean对象（创建tomcat服务器）</li>
<li>实例化所有bean工厂缓存的bean对象（剩下的）</li>
<li>发布通知-通知上下文刷新完成（启动tomcat服务器）</li>
</ol>
</li>
<li><strong>通知监听者 —— 启动程序完成</strong></li>
</ol>
<p>源码：</p>
<p>SpringApplication的构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> &#123;</span><br><span class="line">    <span class="comment">// 赋值资源加载器和主方法类</span></span><br><span class="line">    <span class="built_in">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">    Assert.notNull(primarySources, <span class="string">&quot;PrimarySources must not be null&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.primarySources = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(Arrays.asList(primarySources));</span><br><span class="line">    <span class="comment">// 确定web服务类型, 默认是servlet</span></span><br><span class="line">    <span class="built_in">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line">    <span class="comment">// 1.(loadFactories)读取classpath下所有的spring.factories配置文件</span></span><br><span class="line">    <span class="comment">// 配置 注册初始化对象</span></span><br><span class="line">    <span class="built_in">this</span>.bootstrapRegistryInitializers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(</span><br><span class="line">        getSpringFactoriesInstances(BootstrapRegistryInitializer.class)</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 配置 上下文初始化对象</span></span><br><span class="line">    setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));</span><br><span class="line">    <span class="comment">// 配置 监听器</span></span><br><span class="line">    setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line">    <span class="built_in">this</span>.mainApplicationClass = deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SpringApplication最终调用的run方法： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title function_">run</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">    <span class="comment">// 启动器上下文对象</span></span><br><span class="line">    <span class="type">DefaultBootstrapContext</span> <span class="variable">bootstrapContext</span> <span class="operator">=</span> createBootstrapContext();</span><br><span class="line">    <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 配置headless属性(java.wat.headless, 默认为true), 让程序没检测到显示器、键盘等设备也能启动</span></span><br><span class="line">    configureHeadlessProperty();</span><br><span class="line">    <span class="comment">// 从spring.factories配置文件中加载EvenPublishingRunListener对象并赋值给SpringApplicationRunListeners (用于标志不同的生命周期事件)</span></span><br><span class="line">    <span class="type">SpringApplicationRunListeners</span> <span class="variable">listeners</span> <span class="operator">=</span> getRunListeners(args);</span><br><span class="line">    <span class="comment">//// 通知监听器, SpringApplication启动开始: 发射【ApplicationStartingEvent】事件</span></span><br><span class="line">    listeners.starting(bootstrapContext, <span class="built_in">this</span>.mainApplicationClass);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 将 args参数 封装为对象</span></span><br><span class="line">        <span class="type">ApplicationArguments</span> <span class="variable">applicationArguments</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultApplicationArguments</span>(args);</span><br><span class="line">        <span class="comment">//// 创建应用程序环境 配置文件在此处读取(application.properties和application.yml); 发射【ApplicationEnvironmentPreparedEvent】事件</span></span><br><span class="line">        <span class="type">ConfigurableEnvironment</span> <span class="variable">environment</span> <span class="operator">=</span> prepareEnvironment(listeners, bootstrapContext, applicationArguments);</span><br><span class="line">        <span class="comment">// 配置spring.beaninfo.ignore属性, 默认为true, 表示不加载bean的元数据信息</span></span><br><span class="line">        configureIgnoreBeanInfo(environment);</span><br><span class="line">        <span class="type">Banner</span> <span class="variable">printedBanner</span> <span class="operator">=</span> printBanner(environment);  <span class="comment">// 控制台打印springboot的banner标志</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//// 2.根据不同类型创建不同的应用程序上下文(此处还创建了beanfactory), 默认的服务是servlet对应的上下文容器是 AnnotationConfigServletWebServerApplicationContext</span></span><br><span class="line">        context = createApplicationContext();</span><br><span class="line">        context.setApplicationStartup(<span class="built_in">this</span>.applicationStartup);</span><br><span class="line">        <span class="comment">// 为上下文context进行一些初始化工作, 准备一些容器属性值等; 完成后发射【ApplicationContextInitializedEvent】事件, 标志context已经初始化;</span></span><br><span class="line">        <span class="comment">// 从context中获取beanFactory, 并向beanFactory注册一些单例bean; 完成后发射【ApplicationPreparedEvent】事件, 标志context容器已准备完成.</span></span><br><span class="line">        prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line">        <span class="comment">//// 3.自动装配（spring启动核心）, 完成后发布【ContextRefreshedEvent】事件, 标志context容器刷新完成</span></span><br><span class="line">        refreshContext(context);</span><br><span class="line">        <span class="comment">// 刷新容器的后置处理逻辑, 这里是空方法</span></span><br><span class="line">        afterRefresh(context, applicationArguments);</span><br><span class="line">        <span class="type">Duration</span> <span class="variable">timeTakenToStartup</span> <span class="operator">=</span> Duration.ofNanos(System.nanoTime() - startTime);</span><br><span class="line">        <span class="comment">// 打印日志</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.logStartupInfo) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">StartupInfoLogger</span>(<span class="built_in">this</span>.mainApplicationClass).logStarted(getApplicationLog(), timeTakenToStartup);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//// 4.启动完成通知: 发射【ApplicationStartedEvent】事件, 标志spring容器已经刷新, 所有bean实例均已加载</span></span><br><span class="line">        listeners.started(context, timeTakenToStartup);</span><br><span class="line">        callRunners(context, applicationArguments);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        handleRunFailure(context, ex, listeners);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Duration</span> <span class="variable">timeTakenToReady</span> <span class="operator">=</span> Duration.ofNanos(System.nanoTime() - startTime);</span><br><span class="line">        listeners.ready(context, timeTakenToReady);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        handleRunFailure(context, ex, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>刷新上下文方法 refreshContext(context) 做了很多重要行为：</p>
<p>工厂配置，bean处理器配置，类的扫描，解析，bean定义，bean类信息缓存，服务器创建，bean实例化，动态代理对象的创建等。</p>
<blockquote>
<p><strong>spring中注册bean信息和实例化bean是两件事情。</strong></p>
<ul>
<li><p>注册bean信息不是创建bean对象，是解析bean类获取详细信息，会创建BeanDefinition对象，携带bean类的字节码和方法等信息，把BeanDefinition对象注册保存到工厂BeanDefinitionMap中。</p>
</li>
<li><p>工厂实例化bean时直接BeanDefinitionMap.get(beanName) 获取bean的字节码信息，通过反射创建对象，然后将bean对象保存到singletonObjects中。</p>
</li>
</ul>
</blockquote>
<p>大体分为11步：</p>
<ol>
<li><p>通过prepareRefresh方法 ，<strong>在已有环境配置上，准备servlet相关的环境Environment</strong>。</p>
<ul>
<li>调用 initServletPropertySources方法 对servlet初始化参数 servletContextInitParams 和 servletConfigInitParams 进行赋值。</li>
<li>调用validateRequiredProperties方法检验是否有必填的环境变量</li>
</ul>
</li>
<li><p>调用obtainFreshBeanFactory获取BeanFactory容器，调用prepareBeanFactory方法，在<strong>使用BeanFactory前进行准备工作</strong>，主要<strong>准备以下处理器和Bean</strong>：</p>
<ul>
<li>系统级处理器：类加载器BeanClassLoader，表达式解析器BeanExpressionResolver，配置文件处理器PropertyEditorRegistrar等；</li>
<li>两个bean后置处理器：用于解析Aware接口的ApplicationContextAwareProcessor，用于处理自定义监听器注册和销毁的ApplicationListenerDetector。</li>
<li>注册一些特殊Bean和系统级Bean： 如容器本身BeanFactory和ApplicationContext，系统环境environment，系统属性systemProperties等。 （会被放入特殊对象池或单例池）</li>
</ul>
<blockquote>
<p>springboot默认使用ServletWebServerApplicationContext，容器创建时一并创建beanFactory，所以obtainFreshBeanFactory方法是空的，不过原始 spring的上下文容器可能是其他的，所以可以通过obtainFreshBeanFactory重新构造beanFactory，加载bean定义BeanDefinition。</p>
</blockquote>
</li>
<li><p>调用postProcessBeanFactory方法，<strong>对BeanFactory进行额外设置或修改，主要定义Servlet相关作用域Scopes，同时注册与Servlet相关的Bean</strong>，如ServletRequest，ServletResponse，HttpSession等。</p>
</li>
<li><p>调用 invokeBeanFactoryPostProcessors 方法，<strong>逐一执行前面注册的各种 BeanFactoryPostProcessor（BeanFactory后置处理器）</strong>，其中最重要的是用于 <strong>加载所有”Bean定义“的ConfigurationClassPostProcessor</strong>。它会加载所有@Configuration配置类，并检索Bean扫描路径，将所有扫描到的”Bean定义“放到”Bean定义池”中。</p>
</li>
<li><p>通过 registerBeanPostProcessors 方法<strong>检索所有Bean后置处理器，并根据指定的order进行排序，然后放入 “Bean后置处理器池”</strong> 中。（Bean后置处理器会在Bean初始前和后 分别执行逻辑）</p>
</li>
<li><p>调用 initMessageSource和initApplicationEventMulticaster方法<strong>从单例池中获取两个Bean放入ApplicationContext中</strong>：messageSource和applicationEventMulticaster。 前者可自定义名为”messageSource“的Bean结合messages.properties配置文件进行<strong>多语言配置</strong>， 后者是<strong>消息广播器</strong>，用于自定义广播事件。</p>
</li>
<li><p>调用 onRefresh方法 <strong>构造并启动Web服务器</strong>，springboot默认服务器是tomcat，所以会使用一个叫TomcatServletWebServerFactory的应用服务器Bean构造Tomcat对象。</p>
</li>
<li><p>调用RegisterListeners，<strong>查找所有的监听器Bean</strong>，将其<strong>注册到第6步的消息广播器 applicationEventMulticaster中</strong>。</p>
</li>
<li><p>调用 finishBeanFactoryInitialization方法 <strong>生产所有Bean</strong>。（大致步骤：构造对象，填充属性，初始化实例，注册销毁）Bean生成后会放入单例池中。</p>
</li>
<li><p>调用finishRefresh方法，<strong>构造并注册 生命周期管理器lifecycleProcessor，同时调用所有实现了 生命周期接口Lifecycle的Bean中的start方</strong>法（在容器关闭时自动调用stop方法）。</p>
</li>
<li><p><strong>发布【ContextRefreshedEvent】事件</strong>，标志context容器刷新完成。</p>
</li>
</ol>
<h1 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h1><h2 id="Gateway"><a href="#Gateway" class="headerlink" title="Gateway"></a>Gateway</h2><p>为了提升网关的性能，Spring Cloud Gateway 基于 Spring WebFlux 。Spring WebFlux 使用 Reactor 库来实现响应式编程模型，底层基于 Netty 实现同步非阻塞的 I&#x2F;O。</p>
<p>Gateway 提供了统一的路由方式，和基于 Filter 链的网关基本功能。</p>
<p>Gateway的处理流程：</p>
<ol>
<li><strong>路由判断</strong>：客户端的请求到达网关后，先经过 Gateway Handler Mapping 处理，这里面会做断言（Predicate）判断，看下符合哪个路由规则，这个路由映射后端的某个服务。 </li>
<li><strong>请求过滤</strong>：然后请求到达 Gateway Web Handler，这里面有很多过滤器，组成过滤器链（Filter Chain），这些过滤器可以对请求进行拦截和修改，比如添加请求头、参数校验等等，有点像净化污水。然后将请求转发到实际的后端服务。这些过滤器逻辑上可以称作 Pre-Filters，Pre 可以理解为“在…之前”。 </li>
<li><strong>服务处理</strong>：后端服务会对请求进行处理。 </li>
<li><strong>响应过滤</strong>：后端处理完结果后，返回给 Gateway 的过滤器再次做处理，逻辑上可以称作 Post-Filters，Post 可以理解为“在…之后”。 </li>
<li><strong>响应返回</strong>：响应经过过滤处理后，返回给客户端。</li>
</ol>
<p>总结就是：客户端的请求先通过匹配规则找到合适的路由，也就能映射到具体的服务。然后请求经过过滤器处理后转发给具体的服务，服务处理后，再次交给过滤器处理，最后返回给客户端。</p>
<ul>
<li><p>断言（Predicate）</p>
<p>断言可以理解为 对一个表达式进行 if 判断，如果为真则做这件事，否则做那件事。 在 Gateway 中，如果客户端发送的请求满足了断言的条件，则映射到指定的路由器，就能转发到指定的服务上进行处理。 </p>
<p>使用 predicates 可以进行断言配置，如下：当请求 url 中包含 api&#x2F;xxx，就匹配到了该路由 route_first。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">cloud:</span></span><br><span class="line">		<span class="attr">gateway:</span></span><br><span class="line">			<span class="attr">routes:</span></span><br><span class="line">				<span class="bullet">-</span> <span class="attr">id:</span> <span class="string">route_first</span></span><br><span class="line">				  <span class="attr">uri:</span> <span class="string">lb://xxxx</span></span><br><span class="line">				  <span class="attr">predicates:</span></span><br><span class="line">				  	<span class="bullet">-</span> <span class="string">Path=/api/xxx/**</span></span><br><span class="line">				  <span class="attr">filters:</span></span><br><span class="line">				  	<span class="bullet">-</span> </span><br></pre></td></tr></table></figure>

<p>常见的断言规则有：</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/api-gateway/spring-cloud-gateway-predicate-rules.png"></p>
</li>
<li><p>实现动态路由：</p>
<p>可以基于Nacos来做，Gateway可以从注册中心获取服务的元数据（服务名称、路径等），然后根据这些信息自动生成路由规则。这样，当服务实例被添加、移除、更新时，网关会自动感知并调整路由规则。（这些操作通过nacos server和nacos config即可完成）</p>
</li>
<li><p>过滤器</p>
<p>常见局部过滤器如下（标红为常用）：</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/api-gateway/spring-cloud-gateway-gatewayfilters.png"></p>
<p>常见全局过滤器：</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/api-gateway/spring-cloud-gateway-globalfilters.png"></p>
</li>
<li><p>限流：</p>
<p>sentinel1.6引入了gateway适配模块，gateway可以结合sentinel来实现网关流量控制。</p>
</li>
<li><p>自定义全局异常处理：</p>
<p>在 SpringBoot 项目中捕获全局异常只需要在项目中配置 @RestControllerAdvice和 @ExceptionHandler就可以了。不过，这种方式在 Spring Cloud Gateway 下不适用。 </p>
<p>Spring Cloud Gateway 提供了多种全局处理的方式，比较常用的一种是实现ErrorWebExceptionHandler并重写其中的handle方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Order(-1)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalErrorWebExceptionHandler</span> <span class="keyword">implements</span> <span class="title class_">ErrorWebExceptionHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">handle</span><span class="params">(ServerWebExchange exchange, Throwable ex)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><blockquote>
<p>分布式系统的数据一致性问题，以及相关的一致性算法。 	</p>
<p>分布式基本理论——CAP，BASE</p>
<p>分布式数据一致性协议&#x2F;共识算法——2PC，3PC，Paxos算法，Raft算法</p>
<p>分布式发散消息协议——Gossip协议 </p>
</blockquote>
<h3 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h3><ul>
<li><strong>consistency 数据一致性：</strong> 从不同服务器读到的数据是一致的。</li>
<li><strong>availability 系统可用性：</strong> 非故障的节点在合理的时间内返回合理的响应。</li>
<li><strong>partition tolerance 分区容忍性：</strong> 分布式系统出现网络分区的时候，仍然能够对外提供服务。</li>
</ul>
<blockquote>
<p>网络分区是指： 分布式系统中，多个节点之间的网络本来是连通的，但是因为某些故障（比如部分节点网络出了问题）某些节点之间不连通了，整个网络就分成了几块区域，这就叫 <strong>网络分区</strong>。</p>
</blockquote>
<p>一般CAP是不能同时满足的，而P是必要的，只能从A和C中选一个满足，例如Zookeeper实现的是CP， 因为选举leader和同步时系统不能对外提供服务，不满足A。 还有HBase也是 CP 架构，Cassandra、Eureka 就是 AP 架构，Nacos 不仅支持 CP 架构也支持 AP 架构。</p>
<h3 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h3><p>BASE本质上是AP方案的补充，因为没有出现分区故障时，CA是可以满足的，所以BASE要求分区故障时允许部分不可用或数据不一致，但系统恢复后需要数据达到最终一致性。</p>
<ul>
<li><p><strong>Basically Available 基本可用：</strong> 分布式系统在出现不可预知故障的时候，允许损失部分可用性。（如延长响应时间，非核心功能暂停使用）</p>
</li>
<li><p><strong>Soft-state 软状态：</strong> 允许系统中的数据存在中间状态（<strong>CAP 理论中的数据不一致</strong>），并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。</p>
</li>
<li><p><strong>Eventually Consistent 最终一致性：</strong> 最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。</p>
<p>实现最终一致性的方案有：</p>
<ul>
<li><strong>读时修复</strong> : 在读取数据时，检测到不同节点的数据不一致，进行修复。</li>
<li><strong>写时修复</strong>（性能消耗小，推荐） : 在写入数据，检测数据的不一致时，进行修复。比如 Cassandra 的 Hinted Handoff 实现。具体来说，Cassandra 集群的节点之间远程写数据的时候，如果写失败 就将数据缓存下来，然后定时重传，修复数据的不一致性。</li>
<li><strong>异步修复</strong> : 这个是最常用的方式，通过定时对账检测副本数据的一致性，并修复。</li>
</ul>
</li>
</ul>
<h3 id="2PC和3PC"><a href="#2PC和3PC" class="headerlink" title="2PC和3PC"></a>2PC和3PC</h3><p>二阶段提交——2PC（phase commit）</p>
<ul>
<li>协调者： 发送prepare请求。</li>
<li>参与者：YES&#x2F;NO（先执行事务，暂不提交）</li>
<li>协调者：发送commit请求。</li>
<li>参与者：YES&#x2F;NO（提交事务）</li>
</ul>
<p>缺点：</p>
<ul>
<li>单点故障：如果协调者挂了，系统就不可用了。</li>
<li>阻塞：参与者执行了事务，但暂不提交，会一直占着资源不放；一旦协调者此时挂了，这些资源就无法释放。</li>
<li>数据不一致：协调者只发了部分commit就挂了，这样参与者之间的数据就不一致了。</li>
</ul>
<p>三阶段提交——3PC</p>
<ul>
<li><p>CanCommit阶段：</p>
<ul>
<li>协调者：发送CanCommit请求。</li>
<li>参与者：确认是否能执行，发送YES&#x2F;NO。</li>
</ul>
</li>
<li><p>PreCommit阶段：</p>
<ul>
<li>协调者：收到全部的YES，则可以发送PreCommit预提交请求。</li>
<li>参与者：执行事务，并写Undo和Redo日志，事务执行完发送YES。</li>
</ul>
<p>如果协调者在此过程收到任意一个NO，或在一定时间内没有收到全部的响应，则向所有参与者发送中断请求（abort）。</p>
</li>
<li><p>DoCommit阶段：</p>
<ul>
<li>协调者：发送DoCommit请求。</li>
<li>参与者：提交事务，返回YES。</li>
</ul>
<p>如果协调者在此过程收到任意一个NO，或在一定时间内没有收到全部的响应，则向所有参与者发送中断请求，参与者通过Undo回滚。</p>
</li>
</ul>
<p>3PC加入了很多超时中断的处理，可以缓解阻塞问题。但一致性问题仍没解决。—— 解决：Paxos算法</p>
<h3 id="Paxos算法"><a href="#Paxos算法" class="headerlink" title="Paxos算法"></a>Paxos算法</h3><blockquote>
<p> Zookeeper的ZAB协议是根据paxos算法定制，主要支持<strong>崩溃恢复</strong> 和 <strong>消息广播</strong>。</p>
</blockquote>
<p>是一种基于消息传递且具有高度容错特性的一致性算法。 解决的问题是在分布式系统中如何就某个值达成一致。</p>
<p>Paxos中有三个角色：</p>
<ul>
<li>Proposer提案者：每个提案者在提出提案时都会首先获取到一个<strong>具有全局唯一性的、递增的提案编号N</strong>。</li>
<li>Acceptor表决者：仅会接收编号大于本地保存的最大编号的提案，并保存该提案编号N，反馈之前的最大编号给提案者。</li>
<li>Learner学习者。</li>
</ul>
<p>过程：</p>
<ul>
<li>prepare阶段：<ul>
<li>Porposer提案者： 将编号N赋予提案，向所有 表决者 发出提案。</li>
<li>Acceptor表决者：仅会接收编号大于本地保存的最大编号的提案，并保存该提案编号N，反馈之前的最大编号给提案者。</li>
</ul>
</li>
<li>accept阶段：<ul>
<li>Porposer提案者： 收到超过半数 表决者 同意后，提案者会给所有 表决者 发送真正的提案（内容和提案编号）。</li>
<li>Acceptor表决者： 比对编号是否大于本地最大编号，是的话就接收该提案，执行，但不提交，反馈给提案者accept。如果不接受提案或事务出错，则返回NO。</li>
<li>Porposer提案者：收到超过半数的accept，就向所有表决者发送提案的提交请求。（也让有些未批准提案内容的表决者无条件执行并提交）。 如果没有收到超过半数的accept，就会递增提案的编号，重新进入prepare阶段。</li>
</ul>
</li>
</ul>
<p>注意：</p>
<ul>
<li>paxos算法在一段时间内，只能允许一个请求提交，否则会出现死循环。</li>
</ul>
<h3 id="Raft算法"><a href="#Raft算法" class="headerlink" title="Raft算法"></a>Raft算法</h3><blockquote>
<p>Consul 是一个用于服务发现、配置管理和分布式一致性的工具，它使用了 Raft 算法来维护集群状态并保证一致性。</p>
</blockquote>
<p><strong>节点类型：</strong></p>
<p>一个 Raft 集群包括若干服务器，在任意的时间，每个服务器一定会处于以下三个状态中的一个：</p>
<ul>
<li><code>Leader</code>：负责发起心跳，响应客户端，创建日志，同步日志。</li>
<li><code>Candidate</code>：Leader 选举过程中的临时角色，由 Follower 转化而来，发起投票参与竞选。</li>
<li><code>Follower</code>：接受 Leader 的心跳和日志同步数据，投票给 Candidate。</li>
</ul>
<p>在正常的情况下，只有一个服务器是 Leader，剩下的服务器是 Follower。Follower 是被动的，它们不会发送任何请求，只是响应来自 Leader 和 Candidate 的请求。</p>
<p><strong>任期：</strong></p>
<p>raft 算法将时间划分为任意长度的任期（term），任期用连续的数字表示，记作当前 term 号。</p>
<p>每一个任期的开始都是一次选举，在选举开始时，一个或多个 Candidate 会尝试成为 Leader。如果一个 Candidate 赢得了选举，它就会在该任期内担任 Leader。如果没有选出 Leader，将会开启另一个任期，并立刻开始下一次选举。raft 算法保证在给定的一个任期最少要有一个 Leader。</p>
<p>每个节点都会存储当前的 term 号，当服务器之间进行通信时会交换当前的 term 号：</p>
<ul>
<li><p>如果有服务器发现自己的 term 号比其他人小，那么他会更新到较大的 term 值。</p>
</li>
<li><p>如果一个 Candidate 或者 Leader 发现自己的 term 过期了，他会立即退回成 Follower。</p>
</li>
<li><p>如果一台服务器收到的请求的 term 号是过期的，那么它会拒绝此次请求。</p>
</li>
</ul>
<p><strong>Leader选举过程：</strong></p>
<p>raft 使用心跳机制来触发 Leader 的选举：</p>
<p>如果一台服务器能够收到来自 Leader 或者 Candidate 的有效信息，那么它会一直保持为 Follower 状态，并且刷新自己的 electionElapsed，重新计时。</p>
<p>Leader 会向所有的 Follower 周期性发送心跳来保证自己的 Leader 地位。如果一个 Follower 在一个周期内没有收到心跳信息，就叫做选举超时，然后它就会认为此时没有可用的 Leader，并且开始进行一次选举以选出一个新的 Leader。</p>
<p>为了开始新的选举，Follower 会自增自己的 term 号并且转换状态为 Candidate。然后他会向所有节点发起 RequestVoteRPC 请求， Candidate 的状态会持续到以下情况发生：</p>
<ul>
<li>赢得选举</li>
<li>其他节点赢得选举</li>
<li>一轮选举结束，无人胜出</li>
</ul>
<p>赢得选举的条件是：一个 Candidate 在一个任期内收到了来自集群内的超过半数的选票<code>（N/2+1）</code>，就可以成为 Leader。</p>
<p>在 Candidate 等待选票的时候，它可能收到其他节点声明自己是 Leader 的心跳，此时有两种情况：</p>
<ul>
<li>该 Leader 的 term 号大于等于自己的 term 号，说明对方已经成为 Leader，则自己回退为 Follower。</li>
<li>该 Leader 的 term 号小于自己的 term 号，那么会拒绝该请求并让该节点更新 term。</li>
</ul>
<p>由于可能同一时刻出现多个 Candidate，导致没有 Candidate 获得大多数选票，如果没有其他手段来重新分配选票的话，那么可能会无限重复下去。</p>
<p>raft 使用了随机的选举超时时间来避免上述情况。每一个 Candidate 在发起选举后，都会随机化一个新的选举超时时间，这种机制使得各个服务器能够分散开来，在大多数情况下只有一个服务器会率先超时；它会在其他服务器超时之前赢得选举。</p>
<p><strong>数据同步：</strong></p>
<p>当一个数据修改的请求过来，会直接找到 Leader 节点，所有的增删改查都由 Leader 受理。然后同步给各个 Follower。</p>
<p>每次数据同步操作同时也是一个心跳，会更新 Follower 的 election timeout。另外只有当多数节点返回同步成功之后，Leader 才会给客户端返回操作成功。</p>
<p><strong>分布容错：</strong></p>
<p>当出现网络分区时，比如原本五个节点的集群，被分成了双节点和三节点的两个集群。假设原本的 Leader 在双节点的集群里面，那么这个集群会照常运作。而新出现的三个节点的集群，由于没有收到心跳，会开始选举，然后选出新的 Leader。</p>
<p>这时候，如果有客户端发起请求，有可能发送到两个不同的 Leader 上面，如果发送到原来的那个 Leader 上，即双节点的集群中，Leader 把操作同步给 Follower，会发现收不到足够多的 Follower 响应（因为这个 Follower 还以为自己的集群是五个节点），然后就没办法同步数据。而三节点的新集群，就可以顺利更新数据。</p>
<p>如果这时候网络恢复了，各个节点又可以正常通信，三节点集群中的 Leader 和 双节点集群中的 Leader 会互相通信，然后会发现三节点的 Leader 由于一直正常运行，term 值会不断增大，所以大家会采信他的数据。于是双节点的两台机器会回滚，然后全部接受新 Leader 的数据同步。</p>
<h3 id="Gossip协议-TODO"><a href="#Gossip协议-TODO" class="headerlink" title="Gossip协议-TODO"></a>Gossip协议-TODO</h3><h2 id="分布式ID"><a href="#分布式ID" class="headerlink" title="分布式ID"></a>分布式ID</h2><p>常见解决方案：</p>
<h3 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h3><p>UUID 可以做到全局唯一性，但是一般很少会使用它。</p>
<p>因为UUID 作为 MySQL 数据库主键的时候就非常不合适： </p>
<ul>
<li>数据库主键要尽量越短越好，而 UUID 的消耗的存储空间比较大（32 个字符串，128 位）。 </li>
<li>UUID 是无顺序的，InnoDB 引擎下，数据库主键的无序性会严重影响数据库性能。</li>
</ul>
<p>优缺点 : </p>
<ul>
<li>优点：生成速度比较快、简单易用 </li>
<li>缺点：<ul>
<li>存储消耗空间大（32 个字符串，128 位）</li>
<li>不安全（基于 MAC 地址生成 UUID 的算法会造成 MAC 地址泄露)</li>
<li>无序（非自增）</li>
<li>没有具体业务含义</li>
<li>需要解决重复 ID 问题（当机器时间不对的情况下，可能导致会产生重复 ID）</li>
</ul>
</li>
</ul>
<h3 id="Snowflake"><a href="#Snowflake" class="headerlink" title="Snowflake"></a>Snowflake</h3><p>即雪花算法，Snowflake 由 64 bit 的二进制数字组成，这 64bit 的二进制被分成了几部分，每一部分存储的数据都有特定的含义： </p>
<ul>
<li>第 0 位：符号位（标识正负），始终为 0，没有用，不用管。 </li>
<li><strong>第 1~41 位</strong>：一共 41 位，用来表示<strong>时间戳</strong>，单位是毫秒，可以支撑 2 ^41 毫秒（约 69 年） </li>
<li><strong>第 42~52 位</strong>：一共 10 位，一般来说，前 5 位表示机房 ID，后 5 位表示机器 ID（实际项目中可以根据实际情况调整）。这样就可以<strong>区分不同集群&#x2F;机房的节点</strong>。 </li>
<li><strong>第 53~64 位</strong>：一共 12 位，用来表示<strong>序列号</strong>。 序列号为自增值，代表单台机器每毫秒能够产生的最大 ID 数(2^12 &#x3D; 4096),也就是说单台机器每毫秒最多可以生成 4096 个 唯一 ID。</li>
</ul>
<p>使用：现在有很多基于 Snowflake 算法的开源实现比如美团 的 Leaf、百度的 UidGenerator，并且这些开源实现对原有的 Snowflake 算法进行了优化。 </p>
<p>另外，在实际项目中，我们一般也会对 Snowflake 算法进行改造，最常见的就是在 Snowflake 算法生成的 ID 中加入业务类型信息。</p>
<p>Snowflake 算法的优缺点：</p>
<ul>
<li>优点：生成速度比较快、生成的 ID 有序递增、比较灵活（可以对 Snowflake 算法进行简单的改造比如加入业务 ID） </li>
<li>缺点：需要解决重复 ID 问题（依赖时间，当机器时间不对的情况下，可能导致会产生重复 ID）。</li>
</ul>
<h3 id="开源框架"><a href="#开源框架" class="headerlink" title="开源框架"></a>开源框架</h3><p>如 美团的 Leaf、百度的 UidGenerator，滴滴的 Tinyid 等。</p>
<p>而Zookeeper这类的中间件也可以用于生成唯一id。</p>
<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>对于单机多线程来说，在 Java 中通常使用 ReetrantLock 类、synchronized 关键字这类 JDK 自带的本地锁 来控制一个JVM进程内的多个线程对本地共享资源的访问。</p>
<p>而在分布式系统下，不同的服务&#x2F;客户端通常运行在独立的 JVM 进程上。如果多个 JVM 进程共享同一份资源的话，就需要分布式锁来实现互斥访问了。</p>
<p>一个最基本的分布式锁需要满足： </p>
<ul>
<li><strong>互斥</strong>：任意一个时刻，锁只能被一个线程持有。 </li>
<li><strong>高可用</strong>：锁服务是高可用的，当一个锁服务出现问题，能够自动切换到另外一个锁服务。并且，即使客户端的释放锁的代码逻辑出现问题，锁最终一定还是会被释放，不会影响其他线程对共享资源的访问。这一般是通过超时机制实现的。 </li>
<li><strong>可重入</strong>：一个节点获取了锁之后，还可以再次获取锁。</li>
</ul>
<p>除了上面这三个基本条件之外，一个好的分布式锁还需要满足下面这些条件： </p>
<ul>
<li><strong>高性能</strong>：获取和释放锁的操作应该快速完成，并且不应该对整个系统的性能造成过大影响。 </li>
<li><strong>非阻塞</strong>：如果获取不到锁，不能无限期等待，避免对系统正常运行造成影响。</li>
</ul>
<blockquote>
<p>实现方案中，Redis实现分布式锁 性能较高，ZooKeeper实现分布式锁 可靠性更高。</p>
</blockquote>
<h3 id="基于Redis"><a href="#基于Redis" class="headerlink" title="基于Redis"></a>基于Redis</h3><ol>
<li><p>使用SETNX命令</p>
<p>锁的核心在于互斥，Redis中可用SETNX来实现互斥，如果key不存在才会设置值，如果存在则什么也不做。 要释放锁则直接删除对应的key即可。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SETNX lockKey uniqueValue</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">SETNX lockKey uniqueValue</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">DEL lockKey</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>

<ul>
<li><p>为了防止误删，应该使用lua脚本判断key对应的唯一值，lua脚本可以保证操作的原子性；</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 释放锁时，先比较锁对应的 value 值是否相等，避免锁的误释放</span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;get&quot;</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&quot;del&quot;</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>为了防止线程突然挂掉而无法释放锁，应该给锁设置一个过期时间；</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET lockKey uniqueValue EX 3 NX</span><br></pre></td></tr></table></figure>

<p>不过有个问题就是，如果操作资源的时间大于过期时间，锁会提前过期，导致无法发挥分布式锁的功能； 如果过期时间设置太大，又会影响性能。 —— 解决办法是： 操作共享资源的操作还未完成时，锁过期时间能够自己续期；（使用Redisson）</p>
</li>
</ul>
</li>
<li><p>使用Redisson分布式锁</p>
<p>Redisson 中的分布式锁自带自动续期机制，其原理是：使用一个专门用来监控和续期锁的 Watch Dog（ 看门狗），如果操作共享资源的线程还未执行完成的话，Watch Dog 会不断地延长锁的过期时间，进而保证锁不会因为超时而被释放。</p>
<ul>
<li><p>默认情况下，每过 10 秒，看门狗就会执行续期操作，将锁的超时时间设置为 30 秒。看门狗续期前也会先判断是否需要执行续期操作，需要才会执行续期，否则取消续期操作。</p>
</li>
<li><p>Redisson内置多种锁类型：可重入锁（Reentrant Lock）、自旋锁（Spin Lock）、公平锁（Fair Lock）、多重锁（MultiLock）、 红锁（RedLock）、 读写锁（ReadWriteLock）</p>
</li>
</ul>
<p>使用：</p>
<ul>
<li><p>以 Redisson 的分布式可重入锁 RLock 为例来设置分布式锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.获取指定的分布式锁对象</span></span><br><span class="line"><span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line"><span class="comment">// 2.拿锁且不设置锁超时时间，具备 Watch Dog 自动续期机制</span></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="comment">// 3.执行业务</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// 4.释放锁</span></span><br><span class="line">lock.unlock();</span><br></pre></td></tr></table></figure>

<p>只有未指定锁超时时间，才会使用到 Watch Dog 自动续期机制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手动给锁设置过期时间，不具备 Watch Dog 自动续期机制</span></span><br><span class="line">lock.lock(<span class="number">10</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>源码：</p>
<p>renewExpiration() 方法包含了看门狗的主要逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">renewExpiration</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="type">Timeout</span> <span class="variable">task</span> <span class="operator">=</span> commandExecutor.getConnectionManager().newTimeout(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(Timeout timeout)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="comment">//......</span></span><br><span class="line">            <span class="comment">// 异步续期，基于 Lua 脚本</span></span><br><span class="line">            CompletionStage&lt;Boolean&gt; future = renewExpirationAsync(threadId);</span><br><span class="line">            future.whenComplete((res, e) -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 无法续期</span></span><br><span class="line">                    log.error(<span class="string">&quot;Can&#x27;t update lock &quot;</span> + getRawName() + <span class="string">&quot; expiration&quot;</span>, e);</span><br><span class="line">                    EXPIRATION_RENEWAL_MAP.remove(getEntryName());</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (res) &#123;</span><br><span class="line">                    <span class="comment">// 递归调用实现续期</span></span><br><span class="line">                    renewExpiration();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 取消续期</span></span><br><span class="line">                    cancelExpirationRenewal(<span class="literal">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 延迟 internalLockLeaseTime/3（默认 10s，也就是 30/3） 再调用</span></span><br><span class="line">    &#125;, internalLockLeaseTime / <span class="number">3</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">    ee.setTimeout(task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Watch Dog 通过调用 renewExpirationAsync() 方法实现锁的异步续期：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> CompletionStage&lt;Boolean&gt; <span class="title function_">renewExpirationAsync</span><span class="params">(<span class="type">long</span> threadId)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> evalWriteAsync(</span><br><span class="line">        getRawName(), </span><br><span class="line">        LongCodec.INSTANCE, </span><br><span class="line">        RedisCommands.EVAL_BOOLEAN,</span><br><span class="line">        <span class="comment">// 判断是否为持锁线程，如果是就执行续期操作，就锁的过期时间设置为 30s（默认）</span></span><br><span class="line">        <span class="string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot;</span> +</span><br><span class="line">            <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">            <span class="string">&quot;return 1; &quot;</span> +</span><br><span class="line">            <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">            <span class="string">&quot;return 0;&quot;</span>,</span><br><span class="line">        Collections.singletonList(getRawName()),</span><br><span class="line">        internalLockLeaseTime, </span><br><span class="line">        getLockName(threadId)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>问题：</p>
<p>Redis 集群数据同步到各个节点时是异步的，如果在 Redis 主节点获取到锁后，在没有同步到其他节点时，Redis 主节点宕机了，此时新的 Redis 主节点依然可以获取锁，所以多个应用服务就可以同时获取到锁。</p>
<p>解决办法是使用Redlock 算法（直接操作 Redis 节点，客户端和半数以上的节点完成加锁操作才认为获得分布式锁），以此保证可靠性，但性能会变差很多，往往不会用。一般单机Redis就够用了。</p>
<h3 id="基于Zookeeper"><a href="#基于Zookeeper" class="headerlink" title="基于Zookeeper"></a>基于Zookeeper</h3><p>ZooKeeper 分布式锁是基于 临时顺序节点 和 Watcher（事件监听器） 实现的。</p>
<p>获取锁： </p>
<ol>
<li>首先我们要有一个<strong>持久节点&#x2F;locks</strong>，客户端获取锁就是在<strong>locks</strong>下创建<strong>临时顺序节点</strong>。 </li>
<li>假设客户端 1 创建了**&#x2F;locks&#x2F;lock1**节点，创建成功之后，会判断 <strong>lock1</strong>是否是 <strong>&#x2F;locks</strong> 下最小的子节点。 </li>
<li>如果 <strong>lock1</strong>是最小的子节点，则获取锁成功。</li>
<li>否则，获取锁失败。 </li>
<li>如果获取锁失败，则说明有其他的客户端已经成功获取锁。客户端 1 不会循环去尝试加锁，而是在前一个节点比如**&#x2F;locks&#x2F;lock0<strong>上注册一个</strong>事件监听器**。这个监听器的作用是在前一个节点释放锁之后通知客户端 1（避免无效自旋），这样客户端 1 就加锁成功了。</li>
</ol>
<p>释放锁： </p>
<ol>
<li>成功获取锁的客户端在执行完业务流程之后，会<strong>将对应的子节点删除</strong>。 </li>
<li>成功获取锁的客户端在出现故障之后，对应的子节点由于是<strong>临时顺序节点</strong>，也会被<strong>自动删除</strong>，避免了锁无法被释放。 （事件监听器监听的就是这个子节点删除事件，子节点删除就意味着锁被释放。）</li>
</ol>
<p>实际项目中，推荐使用 Curator 来实现 ZooKeeper 分布式锁。</p>
<p>Curator主要实现了下面四种锁：</p>
<ul>
<li><strong>InterProcessMutex</strong>：分布式可重入排它锁 </li>
<li><strong>InterProcessSemaphoreMutex</strong>：分布式不可重入排它锁 </li>
<li><strong>InterProcessReadWriteLock</strong>：分布式读写锁 </li>
<li><strong>InterProcessMultiLock</strong>：将多个锁作为单个实体管理的容器，获取锁的时候获取所有锁，释放锁也会释放所有锁资源（忽略释放失败的锁）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CuratorFramework</span> <span class="variable">client</span> <span class="operator">=</span> ZKUtils.getClient();</span><br><span class="line">client.start();</span><br><span class="line"><span class="comment">// 分布式可重入排它锁</span></span><br><span class="line"><span class="type">InterProcessLock</span> <span class="variable">lock1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterProcessMutex</span>(client, lockPath1);</span><br><span class="line"><span class="comment">// 分布式不可重入排它锁</span></span><br><span class="line"><span class="type">InterProcessLock</span> <span class="variable">lock2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterProcessSemaphoreMutex</span>(client, lockPath2);</span><br><span class="line"><span class="comment">// 将多个锁作为一个整体</span></span><br><span class="line"><span class="type">InterProcessMultiLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterProcessMultiLock</span>(Arrays.asList(lock1, lock2));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!lock.acquire(<span class="number">10</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;不能获取多锁&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;已获取多锁&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;是否有第一个锁: &quot;</span> + lock1.isAcquiredInThisProcess());</span><br><span class="line">System.out.println(<span class="string">&quot;是否有第二个锁: &quot;</span> + lock2.isAcquiredInThisProcess());</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 资源操作</span></span><br><span class="line">    resource.use();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;释放多个锁&quot;</span>);</span><br><span class="line">    lock.release();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;是否有第一个锁: &quot;</span> + lock1.isAcquiredInThisProcess());</span><br><span class="line">System.out.println(<span class="string">&quot;是否有第二个锁: &quot;</span> + lock2.isAcquiredInThisProcess());</span><br><span class="line">client.close();</span><br></pre></td></tr></table></figure>



<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="过滤器和拦截器的区别"><a href="#过滤器和拦截器的区别" class="headerlink" title="过滤器和拦截器的区别"></a>过滤器和拦截器的区别</h2><ol>
<li><p>过滤器Filter基于Servlet实现，主要应用场景是对字符编码、跨域等问题进行过滤。原理是拦截配置好的客户端请求，然后对Request和Response进行处理。Filter过滤器随着web应用的启动而启动，只初始化一次。</p>
<p>Filter的使用比较简单，继承Filter 接口，实现对应的init、doFilter以及destroy方法即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="comment">// 在容器启动时调用初始化方法，只会初始化一次</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;初始化拦截器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每次请求都会调用doFilter方法，通过FilterChain 调用后续的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="comment">//做一些处理</span></span><br><span class="line">        chain.doFilter(request,response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当容器销毁时，执行destory方法，只会被调用一次。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;销毁拦截器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>拦截器interceptor 是SpringMVC中的一种基于Java反射（动态代理）机制的方法增强工具。</p>
<p>拦截器的实现是 继承HandlerInterceptor 接口，并实现接口的preHandle、postHandle和afterCompletion方法， 以及配置一个拦截器config类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编写一个拦截器</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="comment">// 请求方法前置拦截，该方法会在Controller处理之前进行调用;</span></span><br><span class="line">    <span class="comment">// Spring中可以有多个Interceptor，这些拦截器会按照设定的Order顺序调用;</span></span><br><span class="line">    <span class="comment">// 当有一个拦截器在preHandle中返回false的时候，请求就会终止。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;preHandle&quot;</span>);</span><br><span class="line">        String userName=request.getParameter(<span class="string">&quot;userName&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (userName==<span class="literal">null</span>||password==<span class="literal">null</span>)&#123;</span><br><span class="line">            response.setStatus(<span class="number">500</span>);</span><br><span class="line">            response.setContentType(<span class="string">&quot;text/html; charset=UTF-8&quot;</span>);</span><br><span class="line">            response.getWriter().print(<span class="string">&quot;参数缺失&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//进行用户校验</span></span><br><span class="line">        <span class="keyword">if</span> (userName.equals(<span class="string">&quot;admin&quot;</span>)&amp;&amp;password.equals(<span class="string">&quot;admin&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            response.setStatus(<span class="number">500</span>);</span><br><span class="line">            response.setContentType(<span class="string">&quot;text/html; charset=UTF-8&quot;</span>);</span><br><span class="line">            response.getWriter().print(<span class="string">&quot;用户名或密码错误&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在Controller方法执行之后，视图渲染之前被调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;postHandle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在整个请求结束之后，执行该方法。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterCompletion&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 拦截器配置类</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserInterceptor userInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(userInterceptor)</span><br><span class="line">                .addPathPatterns(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">                .excludePathPatterns(<span class="string">&quot;/error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>过滤器和拦截器的比较区别：</p>
<ul>
<li><p>相同点： 1.都体现了AOP的思想，对方法实现增强，都可以拦截请求方法； 2.都可以通过Order注解设定执行顺序</p>
</li>
<li><p>不同：</p>
<ol>
<li><p><strong>过滤器属于Servlet级别，拦截器属于Spring级别</strong> </p>
<p>Filter是在javax.servlet包中定义的，要依赖于网络容器，因此只能在web项目中使用。</p>
<p>Interceptor是SpringMVC中实现的，拦截器是一个Spring组件，由Spring容器进行管理。</p>
</li>
<li><p>过滤器基于<strong>函数回调</strong>方式实现，拦截器基于<strong>Java反射机制</strong>实现。</p>
</li>
<li><p>应用场景不同：（实际开发中，拦截器的应用场景会比过滤器要更多）</p>
<ul>
<li>拦截器景：<strong>权限控制，日志打印，参数校验</strong></li>
<li>过滤器：<strong>跨域问题解决，编码转换</strong></li>
</ul>
</li>
<li><p>执行顺序不一样：</p>
<p>首先当一个请求<strong>进入Servlet之前</strong>，先通过过<strong>滤器的doFilter</strong>方法进行过滤；</p>
<p><strong>进入Servlet容器之后，执行Controller方法之前</strong>，<strong>拦截器的preHandle</strong>方法进行拦截；</p>
<p><strong>执行Controller方法之后，视图渲染之前</strong>，<strong>拦截器的postHandle</strong>方法进行拦截；</p>
<p><strong>请求结束</strong>之后，<strong>执行拦截器的postHandle</strong>方法。</p>
<p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202311261022254.png" alt="image-20231126102257033"></p>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<h2 id="Mybatis的一二级缓存"><a href="#Mybatis的一二级缓存" class="headerlink" title="Mybatis的一二级缓存"></a>Mybatis的一二级缓存</h2><ul>
<li><p>一级缓存的作用域是SQlSession, Myabits默认开启一级缓存。</p>
<p>在同一个SqlSession中，执行相同的SQL查询时；第一次会去查询数据库，并写在缓存中，第二次会直接从缓存中取。 当执行SQL时候两次查询中间发生了增删改的操作，则SQLSession的缓存会被清空。</p>
<p>缓存开启时，每次查询会先去缓存中找，如果找不到，再去数据库查询，然后把结果写到缓存中。 Mybatis的内部缓存使用一个HashMap，key为hashcode+statementId+sql语句。Value为查询出来的结果集映射成的java对象。 SqlSession执行insert、update、delete等操作commit后会清空该SQLSession缓存。</p>
<ul>
<li>问题： 不同sqlsession对同一条数据操作，可能会出现数据不一致现象（例： sqlsession-A进行更新操作，则A对应的一级缓存被清空；然后sqlsession-B进行更新操作，此时B的更新对A不可见，A紧接着去查数据，得到的就是过时数据 ）</li>
<li>建议：单个sqlsession的生命周期不能过长； 如果是对同一个语句更新尽量使用同一个sql，也就是同一个sqlsession；</li>
</ul>
</li>
<li><p>Mybatis二级缓存是默认不开启的，二级缓存作用于同一个namespace下的所有操作语句，影响着同一个Cache，是Mapper级别的，即多个SqlSession使用同一个Mapper的sql能够使用二级缓存。</p>
<p>当开启缓存后，查询数据的流程就是 二级缓存 -&gt; 一级缓存 -&gt; 数据库。</p>
<ul>
<li>问题：1. 对某个表的操作和查询必须写在同一个namespace下，不然涉及其他的namespace对该表操作就会有问题，会脏数据；  2. 对表的关联查询，关联的所有表的操作都必须在同一个namespace下（这个就不太现实了）；</li>
</ul>
<blockquote>
<p>SqlSession相当于一个JDBC的Connection对象，在一次请求事务会话后，我们会将它关闭。它可以为我们获得Mapper， 而Mapper用于发送SQL语句并返回执行结果。</p>
</blockquote>
</li>
</ul>
<p>建议： 不建议使用Mybatis的一二级缓存，如果需要缓存热点数据，可以用第三方缓存应用，如redisden</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">ValcanoZz</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/03/15/%E7%9F%A5%E8%AF%86%E7%82%B9%E2%80%94%E6%A1%86%E6%9E%B6/">http://example.com/2023/03/15/%E7%9F%A5%E8%AF%86%E7%82%B9%E2%80%94%E6%A1%86%E6%9E%B6/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">ValcanoZz Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/Notes/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/">知识点</a></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/Notes/2023/03/25/%E9%A1%B9%E7%9B%AE%E2%80%94IM%E5%8D%B3%E6%97%B6%E9%80%9A%E4%BF%A1/"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/Notes/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">IM即时通信</div></div></a></div><div class="next-post pull-right"><a href="/Notes/2023/03/05/%E7%9F%A5%E8%AF%86%E7%82%B9%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/Notes/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">知识点—数据库</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/Notes/2023/03/05/%E7%9F%A5%E8%AF%86%E7%82%B9%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93/" title="知识点—数据库"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-05</div><div class="title">知识点—数据库</div></div></a></div><div><a href="/Notes/2023/02/25/%E7%9F%A5%E8%AF%86%E7%82%B9%E2%80%94Java/" title="知识点—Java"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-25</div><div class="title">知识点—Java</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC81NjA4NS8zMjU0OA=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Sping"><span class="toc-number">1.</span> <span class="toc-text">Sping</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#IoC"><span class="toc-number">1.1.</span> <span class="toc-text">IoC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IoC%E5%AE%B9%E5%99%A8"><span class="toc-number">1.1.1.</span> <span class="toc-text">IoC容器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bean"><span class="toc-number">1.2.</span> <span class="toc-text">Bean</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-number">1.2.1.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.2.2.</span> <span class="toc-text">作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">1.2.3.</span> <span class="toc-text">线程安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.2.4.</span> <span class="toc-text">生命周期</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AOP"><span class="toc-number">1.3.</span> <span class="toc-text">AOP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.4.</span> <span class="toc-text">设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.4.1.</span> <span class="toc-text">工厂模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.4.2.</span> <span class="toc-text">单例设计模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.4.3.</span> <span class="toc-text">代理设计模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.4.</span> <span class="toc-text">模板方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.4.5.</span> <span class="toc-text">观察者模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.4.6.</span> <span class="toc-text">适配器模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-number">1.4.7.</span> <span class="toc-text">装饰者模式？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SpringBoot"><span class="toc-number">2.</span> <span class="toc-text">SpringBoot</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E8%AF%B4%E6%98%8E"><span class="toc-number">2.1.</span> <span class="toc-text">常用注解说明</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SpringBootApplication"><span class="toc-number">2.1.1.</span> <span class="toc-text">@SpringBootApplication</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bean%E7%9B%B8%E5%85%B3"><span class="toc-number">2.1.2.</span> <span class="toc-text">Bean相关</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%B8%B8%E8%A7%81%E7%9A%84HTTP%E8%AF%B7%E6%B1%82"><span class="toc-number">2.1.3.</span> <span class="toc-text">处理常见的HTTP请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BC%A0%E5%80%BC"><span class="toc-number">2.1.4.</span> <span class="toc-text">前后端传值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF"><span class="toc-number">2.1.5.</span> <span class="toc-text">读取配置信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C"><span class="toc-number">2.1.6.</span> <span class="toc-text">参数校验</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%A4%84%E7%90%86Controller%E5%B1%82%E5%BC%82%E5%B8%B8"><span class="toc-number">2.1.7.</span> <span class="toc-text">全局处理Controller层异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JPA%EF%BC%88TODO%EF%BC%89"><span class="toc-number">2.1.8.</span> <span class="toc-text">JPA（TODO）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-number">2.1.9.</span> <span class="toc-text">事务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JSON"><span class="toc-number">2.1.10.</span> <span class="toc-text">JSON</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%9B%B8%E5%85%B3"><span class="toc-number">2.1.11.</span> <span class="toc-text">测试相关</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D"><span class="toc-number">2.2.</span> <span class="toc-text">自动装配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%A6%E5%AE%9A%E5%A4%A7%E4%BA%8E%E9%85%8D%E7%BD%AE"><span class="toc-number">2.3.</span> <span class="toc-text">约定大于配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">2.4.</span> <span class="toc-text">启动流程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SpringCloud"><span class="toc-number">3.</span> <span class="toc-text">SpringCloud</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Gateway"><span class="toc-number">3.1.</span> <span class="toc-text">Gateway</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-number">3.2.</span> <span class="toc-text">分布式事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CAP%E7%90%86%E8%AE%BA"><span class="toc-number">3.2.1.</span> <span class="toc-text">CAP理论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BASE%E7%90%86%E8%AE%BA"><span class="toc-number">3.2.2.</span> <span class="toc-text">BASE理论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2PC%E5%92%8C3PC"><span class="toc-number">3.2.3.</span> <span class="toc-text">2PC和3PC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Paxos%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.4.</span> <span class="toc-text">Paxos算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Raft%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.5.</span> <span class="toc-text">Raft算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Gossip%E5%8D%8F%E8%AE%AE-TODO"><span class="toc-number">3.2.6.</span> <span class="toc-text">Gossip协议-TODO</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8FID"><span class="toc-number">3.3.</span> <span class="toc-text">分布式ID</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#UUID"><span class="toc-number">3.3.1.</span> <span class="toc-text">UUID</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Snowflake"><span class="toc-number">3.3.2.</span> <span class="toc-text">Snowflake</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6"><span class="toc-number">3.3.3.</span> <span class="toc-text">开源框架</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">3.4.</span> <span class="toc-text">分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8ERedis"><span class="toc-number">3.4.1.</span> <span class="toc-text">基于Redis</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EZookeeper"><span class="toc-number">3.4.2.</span> <span class="toc-text">基于Zookeeper</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%AE%E9%A2%98"><span class="toc-number">4.</span> <span class="toc-text">问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E6%8B%A6%E6%88%AA%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.1.</span> <span class="toc-text">过滤器和拦截器的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mybatis%E7%9A%84%E4%B8%80%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="toc-number">4.2.</span> <span class="toc-text">Mybatis的一二级缓存</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2023 By ValcanoZz</div><div class="footer_custom_text"><div><a onclick="window.open('https://beian.miit.gov.cn/#/Integrated/index')" >粤ICP备2022110986号-1</a></div></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/Notes/js/utils.js"></script><script src="/Notes/js/main.js"></script><script src="/Notes/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/Notes/js/search/local-search.js"></script><div class="js-pjax"><script>function loadLivere () {
  if (typeof LivereTower === 'object') {
    window.LivereTower.init()
  }
  else {
    (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
    })(document, 'script');
  }
}

if ('Livere' === 'Livere' || !false) {
  if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
  else loadLivere()
}
else {
  function loadOtherComment () {
    loadLivere()
  }
}</script></div><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>