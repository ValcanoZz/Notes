<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>知识点—Java | ValcanoZz Blog</title><meta name="keywords" content="知识点"><meta name="author" content="ValcanoZz"><meta name="copyright" content="ValcanoZz"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="基础知识基础概念 JDK （Java Development Kit）：Java开发组件  JRE （Java Runtime Environment）：Java运行时环境， 它是运行已编译Java程序所需的所有内容的集合，包括JVM，Java类库，Java命令和其他一些基础构建。但不能用于创建新程序。  JVM（Java Virtual Machine）： Java虚拟机是运行Java字节码的虚">
<meta property="og:type" content="article">
<meta property="og:title" content="知识点—Java">
<meta property="og:url" content="http://example.com/2023/02/25/%E7%9F%A5%E8%AF%86%E7%82%B9%E2%80%94Java/index.html">
<meta property="og:site_name" content="ValcanoZz Blog">
<meta property="og:description" content="基础知识基础概念 JDK （Java Development Kit）：Java开发组件  JRE （Java Runtime Environment）：Java运行时环境， 它是运行已编译Java程序所需的所有内容的集合，包括JVM，Java类库，Java命令和其他一些基础构建。但不能用于创建新程序。  JVM（Java Virtual Machine）： Java虚拟机是运行Java字节码的虚">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7">
<meta property="article:published_time" content="2023-02-25T12:34:28.000Z">
<meta property="article:modified_time" content="2023-11-30T12:30:49.454Z">
<meta property="article:author" content="ValcanoZz">
<meta property="article:tag" content="知识点">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"><link rel="shortcut icon" href="/Notes/./img/favicon7.png"><link rel="canonical" href="http://example.com/2023/02/25/%E7%9F%A5%E8%AF%86%E7%82%B9%E2%80%94Java/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/Notes/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/Notes/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '知识点—Java',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-11-30 20:30:49'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="./css/v_footer.css"><link rel="stylesheet" href="./css/v_blog.css"><link rel="stylesheet" href="./css/v_cursors.css"><link rel="stylesheet" href="./css/v_opacity.css"><link rel="stylesheet" href="./css/v_scrollbar.css"><meta name="generator" content="Hexo 6.1.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/Notes/./img/avatar1.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/Notes/archives/"><div class="headline">文章</div><div class="length-num">33</div></a></div><div class="data-item"><a href="/Notes/tags/"><div class="headline">标签</div><div class="length-num">16</div></a></div><div class="data-item"><a href="/Notes/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/Notes/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/Notes/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/Notes/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/Notes/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/Notes/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/Notes/about/"><i class="fa-fw fas fa- heart"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/Notes/">ValcanoZz Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/Notes/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/Notes/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/Notes/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/Notes/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/Notes/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/Notes/about/"><i class="fa-fw fas fa- heart"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">知识点—Java</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-02-25T12:34:28.000Z" title="发表于 2023-02-25 20:34:28">2023-02-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-11-30T12:30:49.454Z" title="更新于 2023-11-30 20:30:49">2023-11-30</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">40.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>133分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="知识点—Java"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><ul>
<li><p>JDK （Java Development Kit）：Java开发组件</p>
</li>
<li><p>JRE （Java Runtime Environment）：Java运行时环境， 它是运行已编译Java程序所需的所有内容的集合，包括JVM，Java类库，Java命令和其他一些基础构建。但不能用于创建新程序。</p>
</li>
<li><p>JVM（Java Virtual Machine）： Java虚拟机是运行Java字节码的虚拟机，有针对不同系统的特定实现，目的是使用相同的字节码，都会给出相同的结果。（最常用HotSpot VM）</p>
</li>
<li><p>字节码： 即JVM可以理解的代码（.class文件），由于字节码只面向虚拟机，因此Java程序无需重新编译即可在不同操作系统上运行。</p>
</li>
<li><p>Java程序运行流程：</p>
<p>.java文件(源代码)——经过javac编译——得到 .class文件(字节码)——经过 解释器&amp;JIT(即时编译器) 解释&#x2F;编译 —— 得到机器可理解的代码</p>
<blockquote>
<p>在字节码到机器码这一步，JVM类加载器首先加载字节码文件，然后使用解释器逐行解释。 而对于一些热点代码，会使用JIT即时编译器，将字节码对应的机器码保存下来，提高运行效率。</p>
<p>JDK9引入了新编译模式：AOT（Ahead Of Time）运行前编译。</p>
<ul>
<li>JIT优点：<ul>
<li>可以根据当前程序的运行情况生成最优的机器指令序列；</li>
<li>当程序需要<strong>动态链接</strong>时只能用JIT；</li>
<li>可以根据内存情况调整代码，更充分利用内存。</li>
</ul>
</li>
<li>JIT缺点：<ul>
<li>编译需要占用运行时资源；</li>
<li>需要花时间准备编译和识别热点代码，所以初始编译不能达到最高性能。</li>
</ul>
</li>
<li>AOT优点：<ul>
<li>在程序运行前编译，避免运行时性能和内存消耗；</li>
<li>在程序运行初期达到最高性能；</li>
<li>显著加快程序启动。</li>
</ul>
</li>
<li>AOT缺点：<ul>
<li>在程序运行前编译会增加程序安装的时间；</li>
<li>牺牲Java的一致性；</li>
<li>将提前编译的内容保存会占用更多的外存</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li><p>Java语言是编译与解释并存的： 源代码先经过javac编译形成字节码，在交由Java解释器执行。</p>
</li>
</ul>
<h3 id="语法、数据类型"><a href="#语法、数据类型" class="headerlink" title="语法、数据类型"></a>语法、数据类型</h3><ul>
<li><p><strong>成员变量和局部变量的区别</strong>：</p>
<ul>
<li><p>语法形式 ：<br>从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；<br>成员变量可以被 <code>public</code>,<code>private</code>,<code>static</code> 等修饰符修饰，而局部变量不能被访问控制修饰符及 <code>static</code> 所修饰；但是，成员变量和局部变量都能被 <code>final</code> 所修饰。</p>
</li>
<li><p>存储方式 ：</p>
<p>​	从变量在内存中的存储方式来看,如果成员变量是使用 <code>static</code> 修饰的，那么这个成员变量是属于类的，如果没有使用 <code>static</code> 修饰，这个成员变量是属于实例的。<br>​	对象都存在于堆内存，局部变量则存在于栈内存。</p>
</li>
<li><p>生存时间 ：</p>
<p>​	从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。</p>
</li>
<li><p>默认值 ：</p>
<p>​	成员变量没初始化，会自动赋默认值（例外:被 <code>final</code> 修饰的成员变量必须显式地赋值），而局部变量则不会自动赋值。</p>
</li>
</ul>
</li>
<li><p>静态变量：</p>
<p>​	静态变量被类的所有实例共享。<br>​	通常情况下，静态变量会被 <code>final</code> 关键字修饰成为常量。</p>
</li>
<li><p><strong>静态方法不能调用非静态成员</strong>：</p>
<p>​	静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。<br>​	而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。</p>
<p>​	也就是说：调用静态成员时，非静态成员可能还没创建。</p>
</li>
<li><p>重载：</p>
<p>​	方法名一样，参数、返回值、修饰符可以不一样。</p>
</li>
<li><p>重写：</p>
<p>​	重写父类的方法，方法名和参数列表必须一样，返回值类型小于等于父类的，抛出异常小于等于父类的，访问修饰符大于等于父类的。</p>
<p>​	父类方法修饰符为 <code>private/final/static</code> 则子类就不能重写该方法。</p>
<p>​	构造方法不能被重写。</p>
</li>
<li><p>基本类型：</p>
<p>​	基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，成员变量（未被 <code>static</code> 修饰 ）存放在 Java 虚拟机的堆中。</p>
</li>
<li><p>包装类型的缓存机制：</p>
<p>​	<code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，</p>
<p>​	<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，</p>
<p>​	<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。</p>
<blockquote>
<p>如果用new创建新对象, 不能用”&#x3D;&#x3D;”来比较值，对象间用”=&#x3D;”比较的是地址。 </p>
<p>所以，所有包装对象之间的值的比较，应该全部都用equals方法。</p>
</blockquote>
</li>
<li><p>自动装箱：调用包装类的valueOf()</p>
<p>自动拆箱：调用包装类的xxxValue()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自动装箱，等价于 Integer i = Integer.valueOf(10)</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;		</span><br><span class="line"></span><br><span class="line"><span class="comment">//自动拆箱，等价于 int n = i.intValue()</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i;		</span><br></pre></td></tr></table></figure>

<p>频繁装拆箱会影响性能，应尽量避免不必要的装拆箱。</p>
</li>
<li><p>解决浮点数精度丢失：</p>
<p>​	一些小数转化为二进制会无限循环，只能截断，如0.2。</p>
<p>若对精度有要求，应使用<code>BigDecimal</code> 可以实现对浮点数的运算</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1.0f</span> - <span class="number">0.9f</span>;		<span class="comment">// 0.100000024 </span></span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0.9f</span> - <span class="number">0.8f</span>;		<span class="comment">// 0.099999964</span></span><br><span class="line"></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.9&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.8&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">x</span> <span class="operator">=</span> a.subtract(b);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">y</span> <span class="operator">=</span> b.subtract(c);</span><br><span class="line"></span><br><span class="line">System.out.println(x); <span class="comment">/* 0.1 */</span></span><br><span class="line">System.out.println(y); <span class="comment">/* 0.1 */</span></span><br><span class="line">System.out.println(Objects.equals(x, y)); <span class="comment">/* true */</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>超过long整型的数据表示： </p>
<p>使用BigInteger，其内部使用int[]数组来存储任意大小的整型数据。(不过运算效率稍低)</p>
</li>
</ul>
<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><ul>
<li><p>面向过程：把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。</p>
</li>
<li><p>面向对象：会先抽象出对象，然后用对象执行方法的方式解决问题。</p>
<p>面向对象开发的程序一般更易维护、易复用、易扩展。</p>
</li>
<li><p>性能：</p>
<p>​	面向过程性能比面向对象高。 因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux&#x2F;Unix等一般采用面向过程开发。</p>
<p>​	不过面向过程也需要分配内存，计算内存偏移量。</p>
<p>​	Java性能差的主要原因并不是因为它是面向对象语言，而是<strong>Java是半编译语言</strong>，最终的执行代码并不是可以直接被CPU执行的二进制机械码。而面向过程语言大多都是直接编译成机械码在电脑上执行，并且其它一些面向过程的脚本语言性能也并不一定比Java好。</p>
</li>
<li><p>面向对象三大特征：</p>
<ul>
<li><p><strong>封装</strong>：封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些能被外界访问的方法来操作属性。</p>
</li>
<li><p><strong>继承</strong>：不同类型的对象，相互之间经常有一定数量的共同点。继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。</p>
<blockquote>
<p>父类的私有属性和方法子类无法访问。</p>
</blockquote>
</li>
<li><p><strong>多态：</strong> 对象类型和引用类型之间具有继承关系。调用的具体是哪个类的方法只能在运行期间确定。多态不能调用父类不存在的方法。</p>
</li>
</ul>
</li>
<li><p>接口和抽象类：</p>
<p>共同点：</p>
<ul>
<li>不能被实例化。</li>
<li>可以包含抽象方法。</li>
<li>可以有默认实现的方法。（java8可用default在接口中定义默认方法）</li>
</ul>
<p>区别：</p>
<ul>
<li>接口主要用于约束类的行为，实现接口意味着具有相应的行为；抽象类主要用于代码复用，强调所属、继承关系。</li>
<li>类只能单继承，接口可以多继承。</li>
<li>接口中的成员变量只能是public，static，final，不能被修改且要有初始值。</li>
</ul>
</li>
<li><p>对象相等：指内存中 存放的内容 是否相等。</p>
<p>引用相等：指向的 内存地址 是否相等。</p>
</li>
<li><p>浅拷贝：在堆上创建新的对象，而内部中的引用类型属性，只复制引用地址。</p>
<p>深拷贝：完全复制整个对象，包括内部对象。</p>
<blockquote>
<p>被拷贝类要实现Cloneable接口，重写clone方法。</p>
<p>实现 Serializable 接口方式也可以实现深拷贝，还可以解决多层克隆问题（引用类型里又有引用类型）</p>
</blockquote>
</li>
</ul>
<h3 id="常见类"><a href="#常见类" class="headerlink" title="常见类"></a>常见类</h3><h4 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h4><p>Object是所有类的父类。提供了11个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * naitive 方法，用于创建并返回当前对象的一份拷贝。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回类的名字实例的哈希码的 16 进制的字符串。通常建议 Object 所有的子类都重写这个方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多了 nanos 参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 毫秒。。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实例被垃圾回收器回收的时候触发的操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>&#x3D;&#x3D;和equals()：</p>
<p>Java只有值传递，基本类型传递的是值，引用类型传递的是内存地址。</p>
<ul>
<li><p>使用&#x3D;&#x3D;是直接比较两者的值&#x2F;地址。</p>
</li>
<li><p>equals()没有重写时，直接return (this &#x3D;&#x3D; obj)；跟&#x3D;&#x3D;一样。一般重写为比较对象的属性是否相等。</p>
</li>
</ul>
</li>
<li><p>hashCode()：</p>
<p>获取哈希码(int)，通常是将对象的内存地址转换为整数。 hashCode()一般和equals()配合用于比较两个对象，大幅提高比较效率（如HashMap，如果hashCode()的值相等，再调用equals()）。</p>
<p>由于有哈希冲突，所以两个对象的hashCode()值可能相等。</p>
</li>
</ul>
<h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><ul>
<li><p>可变性：</p>
<ul>
<li><p>String不可变： 因为String被final修饰，不能被继承，里面的字符数组也被final修饰且为私有，且String没有提供修改字符数组的方法。</p>
<blockquote>
<p>java9的String的底层实现由char[]改为byte[]。</p>
<p>因为新String支持两个编码方案：Latin-1和UTF-16。</p>
<p>如果串中的汉字都在Latin-1范围内，则可用Latin-1方案：byte占1字节，char占2字节。 </p>
<p>而UTF-16方案：byte和char都占2字节。</p>
</blockquote>
</li>
<li><p>StringBuilder 与 StringBuffer可变： 它们都继承自 <code>AbstractStringBuilder</code> 类，在 AbstractStringBuilder中也是使用字符数组保存字符串，不过没有使用 <code>final</code> 和 <code>private</code> 关键字修饰，最关键的是这个 <code>AbstractStringBuilder</code> 类还提供了很多修改字符串的方法比如 <code>append</code> 方法。</p>
</li>
</ul>
</li>
<li><p>线程安全：</p>
<ul>
<li>String不可变，可看作常量，是线程安全的。</li>
<li>StringBuilder对方法加了同步锁，是线程安全的。</li>
<li>StringBuffer没加锁，是非线程安全的。</li>
</ul>
</li>
<li><p>性能：</p>
<ul>
<li>改变String时需要新建String对象，再将指针指向新对象。性能差。</li>
<li>StringBuilder的性能比Stringffer稍差一点点，但都比String好很多。</li>
</ul>
</li>
<li><p>字符串拼接：</p>
<p>+和+&#x3D;专门为Stirng重载过，是Java中仅有的两个重载过的运算符。</p>
<p>Stirng使用+进行拼接时，会新建一个StringBuilder对象进行拼接，最后在toStirng()返回String对象。</p>
<blockquote>
<p>注：在循环中，编译器不会创建单个StringBuilder对象，而是每一次循环都创建一次StringBuilder对象。</p>
<p>建议在循环外新建StringBuilder对象（IDEA的代码检查也会提示）。</p>
</blockquote>
</li>
<li><p>字符常量池：</p>
<p>String创建的字符串会保存在字符串常量池中，避免字符串的重复创建。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在堆中新建对象&quot;ab&quot;，并将&quot;ab&quot;的引用保存在字符串常量池</span></span><br><span class="line"><span class="type">String</span> <span class="variable">aa</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="comment">// 直接返回字符串常量池中 字符串对象”ab“的引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">bb</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="comment">// 新建String对象，一开始未初始化，</span></span><br><span class="line"><span class="comment">// 如果常量池中&quot;ab&quot;不存在，则会在堆中新建对象&quot;ab&quot;并保存到常量池，最后String对象调用构造方法进行赋值。</span></span><br><span class="line"><span class="comment">// 如果常量池中&quot;ab&quot;存在, 则直接调用构造方法赋值。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>对于编译截断能确定值的字符串，jvm会字节放入字符串常量池，包括字符串常量拼接得到的字符串常量。</p>
<p>这种叫常量折叠，基本数据类型及其算数运算和位运算、字符串常量都会进行常量折叠。（引用的值在编译器无法确定，不能进行优化）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;ing&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span> + <span class="string">&quot;ing&quot;</span>; <span class="comment">// 优化成 String str3 = &quot;string&quot;;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> str1 + str2;</span><br><span class="line"><span class="type">String</span> <span class="variable">str5</span> <span class="operator">=</span> <span class="string">&quot;string&quot;</span>;</span><br><span class="line">System.out.println(str3 == str4);	<span class="comment">//false</span></span><br><span class="line">System.out.println(str3 == str5);	<span class="comment">//true</span></span><br><span class="line">System.out.println(str4 == str5);	<span class="comment">//false</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><ul>
<li><p>层次：</p>
<p>Throwable</p>
<ul>
<li>Exception <ul>
<li>Checked Exception： …</li>
<li>Unchecked Exception：…</li>
</ul>
</li>
<li>Error：…</li>
</ul>
</li>
<li><p><strong><code>Exception</code></strong> :<strong>程序本身可以处理的异常</strong>，可以通过 <code>catch</code> 来进行捕获。Exception 又可以分为 <strong>Checked Exception (受检查异常，必须处理)</strong> 和 **Unchecked Exception (不受检查异常，可以不处理)**。</p>
<ul>
<li>除了<code>RuntimeException</code>及其子类以外，其他的Exception类及其子类都属于受检查异常 。常见的受检查异常有： IO 相关的异常、ClassNotFoundException 、SQLException…</li>
<li><code>RuntimeException</code> 及其子类都统称为非受检查异常，常见的有（建议记下来）：<ul>
<li><code>NullPointerException</code>(空指针错误)</li>
<li><code>IllegalArgumentException</code>(参数错误比如方法入参类型错误)</li>
<li><code>NumberFormatException</code>（字符串转换为数字格式错误，是<code>IllegalArgumentException</code>的子类）</li>
<li><code>ArrayIndexOutOfBoundsException</code>（数组越界错误）</li>
<li><code>ClassCastException</code>（类型转换错误）</li>
<li><code>ArithmeticException</code>（算术错误）</li>
<li><code>SecurityException</code> （安全错误比如权限不够）</li>
<li><code>UnsupportedOperationException</code>(不支持的操作错误比如重复创建同一用户)</li>
</ul>
</li>
</ul>
</li>
<li><p><strong><code>Error</code></strong> ：Error 属于<strong>程序无法处理的错误</strong> ，不建议通过catch捕获 。例如 Java 虚拟机运行错误（Virtual MachineError）、虚拟机内存不够错误(OutOfMemoryError)、类定义错误（NoClassDefFoundError）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</p>
</li>
<li><p>常用方法：</p>
<ul>
<li><p>String getMessage(): 返回异常发生时的简要描述</p>
</li>
<li><p>String toString(): 返回异常发生时的详细信息</p>
</li>
<li><p>String getLocalizedMessage(): 返回异常对象的本地化信息。使用 Throwable 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 getMessage()返回的结果相同</p>
</li>
<li><p>void printStackTrace(): 在控制台上打印 Throwable 对象封装的异常信息</p>
</li>
</ul>
</li>
<li><p>异常使用注意事项：</p>
<ul>
<li>不要把异常定义为静态变量，因为这样会导致异常栈信息错乱。每次手动抛出异常，我们都需要手动 new 一个异常对象抛出。</li>
<li>建议抛出更加具体的异常，比如字符串转换为数字格式错误的时候应该抛出NumberFormatException而不是其父类IllegalArgumentException。</li>
<li>使用日志打印异常之后就不要再抛出异常了</li>
</ul>
</li>
</ul>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>泛型提供了编译时的 <strong>类型安全检测</strong>机制，泛型的本质是<strong>参数化类型</strong>，也就是说所操作的数据类型被指定为一个参数。</p>
<p>使用方式，一般有三种：泛型类，泛型接口，泛型方法。</p>
<ul>
<li><p>泛型类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span></span><br><span class="line"><span class="comment">//在实例化泛型类时，必须指定T的具体类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Generic</span>&lt;T&gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Generic</span><span class="params">(T key)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getKey</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实例化泛型类，必须指定类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Generic&lt;Integer&gt; genericInteger = <span class="keyword">new</span> <span class="title class_">Generic</span>&lt;Integer&gt;(<span class="number">123456</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>泛型接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Generator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现泛型接口，可以指定也可以不指定类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不指定类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GeneratorImpl</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Generator</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GeneratorImpl</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Generator</span>&lt;String&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>泛型方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">(E[] inputArray)</span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (E element : inputArray)&#123;</span><br><span class="line">         System.out.printf(<span class="string">&quot;%s &quot;</span>, element);</span><br><span class="line">      &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建不同类型数组：Integer, Double 和 Character</span></span><br><span class="line">Integer[] intArray = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">String[] stringArray = &#123;<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span> &#125;;</span><br><span class="line">printArray(intArray);</span><br><span class="line">printArray(stringArray);</span><br></pre></td></tr></table></figure>

<p>由于以上是静态方法，先于实例对象加载，而类在实例化时才能使用传递类型参数，所以<strong>静态方法无法使用类上声明的泛型参数，只能使用自己声明的 &lt;E&gt;;</strong></p>
</li>
</ul>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>通过反射，可以操作字节码文件，可以获取任意一个类的所有属性和方法，并调用。</p>
<ul>
<li><p>反射赋予了我们在运行时分析类以及执行类中方法的能力。</p>
</li>
<li><p>反射相关的类在 java.lang.reflect.* 下。</p>
</li>
</ul>
<p>反射相关的类：</p>
<table>
<thead>
<tr>
<th>类</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>java.lang.Class</td>
<td>代表整个字节码，即一个类型，整个类</td>
</tr>
<tr>
<td>java.lang.reflect.Method</td>
<td>代表字节码中的方法字节码，即类中的方法</td>
</tr>
<tr>
<td>java.lang.reflect.Constructor</td>
<td>代表字节码中的构造字节码，即类中的构造方法</td>
</tr>
<tr>
<td>java.lang.reflect.Field</td>
<td>代表字节码中的属性字节码，即类中的成员变量（静态变量 + 实例变量）</td>
</tr>
</tbody></table>
<ul>
<li><p>必须先获取Class才能获取Method、Constructor、Field</p>
<blockquote>
<p>属性Field重要的是<strong>名字</strong></p>
<p>实例方法Method重要的是<strong>名字</strong>和<strong>形参列表</strong></p>
<p>构造方法Constructor重要的是<strong>形参列表</strong></p>
</blockquote>
</li>
</ul>
<h4 id="反射操作"><a href="#反射操作" class="headerlink" title="反射操作"></a>反射操作</h4><ul>
<li><p>获取Class的方法，三种（返回值都是Class类型）：</p>
<ul>
<li>Class.forName(“完整类名带包名”) —— 是静态方法</li>
<li>对象.getClass()</li>
<li>任何类型.class</li>
</ul>
</li>
<li><p>通过反射实例化对象： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class对象.newInstance()</span><br><span class="line"><span class="comment">// newInstance()实际调用的是无参构造方法, 如果没有无参构造方法, 会抛 java.lang.InstantiationException异常</span></span><br></pre></td></tr></table></figure>

<p>例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReflectTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        <span class="comment">// 通过反射机制，获取Class，通过Class来实例化对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.reflectBean.User&quot;</span>);</span><br><span class="line">        <span class="comment">// newInstance() 这个方法会调用User这个类的无参数构造方法，完成对象的创建。</span></span><br><span class="line">        <span class="comment">// 重点是：newInstance()调用的是无参构造，必须保证无参构造是存在的！</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> c.newInstance();</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过反射，反编译获得一个类的属性Field：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReflectTest06</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">studentClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.util.ArrayList&quot;</span>);</span><br><span class="line">        s.append(Modifier.toString(studentClass.getModifiers()) + <span class="string">&quot; class &quot;</span> + studentClass.getSimpleName() + <span class="string">&quot; &#123;\n&quot;</span>);<span class="comment">// Class类的getName方法</span></span><br><span class="line">        <span class="comment">//获取所有的属性</span></span><br><span class="line">        Field[] fields = studentClass.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field f : fields)&#123;</span><br><span class="line">            s.append(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            <span class="comment">// 获取属性的修饰符列表,返回的修饰符是一个数字，每个数字是修饰符的代号</span></span><br><span class="line">            <span class="comment">// 用Modifier类的toString转换成字符串</span></span><br><span class="line">            s.append(Modifier.toString(f.getModifiers()));</span><br><span class="line">            <span class="keyword">if</span> (f.getModifiers() != <span class="number">0</span>) s.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            s.append(f.getType().getSimpleName());<span class="comment">// 获取属性的类型</span></span><br><span class="line">            s.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            s.append(f.getName());<span class="comment">// 获取属性的名字</span></span><br><span class="line">            s.append(<span class="string">&quot;;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        s.append(<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行得到结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayList &#123;</span><br><span class="line">	private static final long serialVersionUID;</span><br><span class="line">	private static final int DEFAULT_CAPACITY;</span><br><span class="line">	private static final Object[] EMPTY_ELEMENTDATA;</span><br><span class="line">	private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">	transient Object[] elementData;</span><br><span class="line">	private int size;</span><br><span class="line">	private static final int MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过反射访问java对象的属性，并赋值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   注意：反射机制让代码复杂了，但是为了一个“灵活”，这也是值得的。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReflectTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchFieldException &#123;</span><br><span class="line">        <span class="comment">//使用反射机制给属性赋值</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">studentClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;javase.reflectBean.Student&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> studentClass.newInstance();<span class="comment">// obj就是Student对象。（底层调用无参数构造方法）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取no属性（根据属性的名称来获取Field）</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">noField</span> <span class="operator">=</span> studentClass.getDeclaredField(<span class="string">&quot;no&quot;</span>);</span><br><span class="line">        <span class="comment">// 给obj对象(Student对象)的no属性赋值</span></span><br><span class="line">        noField.set(obj, <span class="number">22222</span>);</span><br><span class="line">        <span class="comment">// 读取属性的值</span></span><br><span class="line">        System.out.println(noField.get(obj));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// set()默认不可以为私有属性赋值, 需要打破封装才行: setAccessible(true)</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">nameField</span> <span class="operator">=</span> studentClass.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="comment">// 打破封装（反射机制的缺点：打破封装，可能会给不法分子留下机会！！！）</span></span><br><span class="line">nameField.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 给name属性赋值并访问</span></span><br><span class="line">nameField.set(obj, <span class="string">&quot;xiaowu&quot;</span>);</span><br><span class="line">System.out.println(nameField.get(obj));</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过反射调用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReflectTest10</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 不使用反射机制时，调用方法的过程: </span></span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserService</span>();</span><br><span class="line">        <span class="comment">// 调用方法</span></span><br><span class="line">        System.out.println(userService.login(<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;123&quot;</span>) ? <span class="string">&quot;登入成功！&quot;</span> : <span class="string">&quot;登入失败！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用反射机制调用方法: </span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">userServiceClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;javase.reflectBean.UserService&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> userServiceClass.newInstance();</span><br><span class="line">        <span class="comment">// 获取Method</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">loginMethod</span> <span class="operator">=</span> userServiceClass.getDeclaredMethod(<span class="string">&quot;login&quot;</span>, String.class, String.class);</span><br><span class="line"><span class="comment">//        Method loginMethod = userServiceClass.getDeclaredMethod(&quot;login&quot;);//注：没有形参就不传</span></span><br><span class="line">        <span class="comment">// 调用方法</span></span><br><span class="line">        <span class="comment">// 调用方法有几个要素？ 也需要4要素。</span></span><br><span class="line">        <span class="comment">// 反射机制中最最最最最重要的一个方法，必须记住。</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            四要素：</span></span><br><span class="line"><span class="comment">            方法对象: loginMethod</span></span><br><span class="line"><span class="comment">            实例对象: obj</span></span><br><span class="line"><span class="comment">            实参: &quot;admin&quot;, &quot;123&quot;</span></span><br><span class="line"><span class="comment">            返回值: resValues</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">resValues</span> <span class="operator">=</span> loginMethod.invoke(obj, <span class="string">&quot;admin&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">        System.out.println(resValues);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过反射获取构造方法，再调用构造方法实例化对象：</p>
<ol>
<li>获取构造方法：Class对象的getDeclaredConstructor()方法</li>
<li>调用构造方法new对象：Constructor对象的newInstance()方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReflectTest12</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//使用反射机制创建对象（以前）</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">vipClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;javase.reflectBean.Vip&quot;</span>);</span><br><span class="line">        <span class="comment">// 调用无参数构造方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj1</span> <span class="operator">=</span> vipClass.newInstance();<span class="comment">//Class类的newInstance方法</span></span><br><span class="line">        System.out.println(obj1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用反射机制创建对象（现在）</span></span><br><span class="line">        <span class="comment">// 调用有参数的构造方法: </span></span><br><span class="line">        <span class="comment">// 1. 先获取到这个有参数的构造方法</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">c1</span> <span class="operator">=</span> vipClass.getDeclaredConstructor(<span class="type">int</span>.class, String.class, String.class, <span class="type">boolean</span>.class);</span><br><span class="line">        <span class="comment">// 2. 调用构造方法new对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj2</span> <span class="operator">=</span> c1.newInstance(<span class="number">321</span>, <span class="string">&quot;lsi&quot;</span>, <span class="string">&quot;1999-10-11&quot;</span>, <span class="literal">true</span>);<span class="comment">//Constructor类的newInstance方法</span></span><br><span class="line">        System.out.println(obj2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取无参数构造方法</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">c2</span> <span class="operator">=</span> vipClass.getDeclaredConstructor();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj3</span> <span class="operator">=</span> c2.newInstance();</span><br><span class="line">        System.out.println(obj3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取一个类的的父类和实现的接口：</p>
<ul>
<li><strong>getSuperclass</strong>()</li>
<li><strong>getInterfaces</strong>()</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReflectTest13</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">// String举例</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">vipClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取String的父类</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">superclass</span> <span class="operator">=</span> vipClass.getSuperclass();</span><br><span class="line">        <span class="comment">// 获取String类实现的所有接口（一个类可以实现多个接口。）</span></span><br><span class="line">        Class[] interfaces = vipClass.getInterfaces();</span><br><span class="line">        System.out.println(superclass.getName());</span><br><span class="line">        <span class="keyword">for</span> (Class i : interfaces) &#123;</span><br><span class="line">            System.out.println(i.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><ul>
<li><p>Class类方法：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>public T <strong>newInstance</strong>()</td>
<td>创建对象</td>
</tr>
<tr>
<td>public String <strong>getName</strong>()</td>
<td>返回完整类名带包名</td>
</tr>
<tr>
<td>public String <strong>getSimpleName</strong>()</td>
<td>返回类名</td>
</tr>
<tr>
<td>public Field[] <strong>getFields</strong>()</td>
<td>返回类中public修饰的属性</td>
</tr>
<tr>
<td>public Field[] <strong>getDeclaredFields</strong>()</td>
<td>返回类中所有的属性</td>
</tr>
<tr>
<td>public Field <strong>getDeclaredField</strong>(String name)</td>
<td>根据属性名name获取指定的属性</td>
</tr>
<tr>
<td>public Method[] <strong>getDeclaredMethods</strong>()</td>
<td>返回类中所有的实例方法</td>
</tr>
<tr>
<td>public Method <strong>getDeclaredMethod</strong>(String name, Class&lt;?&gt;… parameterTypes)</td>
<td>根据方法名name和方法形参获取指定方法</td>
</tr>
<tr>
<td>public Constructor <strong>getDeclaredConstructor</strong>(Class&lt;?&gt;… parameterTypes)</td>
<td>根据方法形参获取指定的构造方法</td>
</tr>
<tr>
<td>public native int <strong>getModifiers</strong>()</td>
<td>获取属性的修饰符列表,返回的修饰符是一个数字【一般配合Modifier类的toString(int x)方法使用】</td>
</tr>
<tr>
<td>public Annotation[] <strong>getAnnotations</strong>() {}</td>
<td>获取元素上所有注解</td>
</tr>
<tr>
<td>….</td>
<td>….</td>
</tr>
<tr>
<td>public native Class&lt;? super T&gt; <strong>getSuperclass</strong>()</td>
<td>返回调用类的父类</td>
</tr>
<tr>
<td>public Class&lt;?&gt;[] <strong>getInterfaces</strong>()</td>
<td>返回调用类实现的接口集合</td>
</tr>
</tbody></table>
</li>
<li><p>Field类方法：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>public String <strong>getName</strong>()</td>
<td>返回属性名</td>
</tr>
<tr>
<td>public int <strong>getModifiers</strong>()</td>
<td>获取属性的修饰符列表,返回的修饰符是一个数字【一般配合Modifier类的toString(int x)方法使用】</td>
</tr>
<tr>
<td>public Class&lt;?&gt; <strong>getType</strong>()</td>
<td>以Class类型，返回属性类型【一般配合Class类的getSimpleName()方法使用】</td>
</tr>
<tr>
<td>public void <strong>set</strong>(Object obj, Object value)</td>
<td>设置属性值</td>
</tr>
<tr>
<td>public Object <strong>get</strong>(Object obj)</td>
<td>读取属性值</td>
</tr>
<tr>
<td>public void <strong>setAccessible</strong>(boolean flag)</td>
<td>默认false，设置为true可以打破封装，如设置私有属性</td>
</tr>
</tbody></table>
</li>
<li><p>Method类方法：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>public String <strong>getName</strong>()</td>
<td>返回方法名</td>
</tr>
<tr>
<td>public int <strong>getModifiers</strong>()</td>
<td>获取方法的修饰符列表【一般配合Modifier类的toString(int x)方法使用】</td>
</tr>
<tr>
<td>public Class&lt;?&gt; <strong>getReturnType</strong>()</td>
<td>以Class类型，返回方法类型【一般配合Class类的getSimpleName()方法使用】</td>
</tr>
<tr>
<td>public Class&lt;?&gt;[] <strong>getParameterTypes</strong>()</td>
<td>返回方法的修饰符列表</td>
</tr>
<tr>
<td>public Object <strong>invoke</strong>(Object obj, Object… args)</td>
<td>调用方法</td>
</tr>
</tbody></table>
</li>
<li><p>Constructor类方法：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>public String <strong>getName</strong>()</td>
<td>返回构造方法名</td>
</tr>
<tr>
<td>public int <strong>getModifiers</strong>()</td>
<td>获取构造方法的修饰符列表【一般配合Modifier类的toString(int x)方法使用】</td>
</tr>
<tr>
<td>public Class&lt;?&gt;[] <strong>getParameterTypes</strong>()</td>
<td>返回构造方法的修饰符列表（一个方法的参数可能会有多个）</td>
</tr>
<tr>
<td>public T <strong>newInstance</strong>(Object … initargs)</td>
<td>创建对象【参数为创建对象的数据】</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p><code>Annotation</code> （注解） 是 Java5 开始引入的新特性，可以看作是一种特殊的注释，主要用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用。</p>
<p>注解本质是一个继承了<code>Annotation</code> 的特殊接口，如@Override：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Override</span> <span class="keyword">extends</span> <span class="title class_">Annotation</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>常见注解有两种：</p>
<ul>
<li><strong>编译期直接扫描</strong> ：编译器在编译 Java 代码的时候扫描对应的注解并处理，比如某个方法使用@Override 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。</li>
<li><strong>运行期通过反射处理</strong> ：像框架中自带的注解(比如 Spring 框架的 @Value 、@Component)都是通过反射来进行处理的。</li>
</ul>
<p>创建注解：通过@interface关键字进行定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestAnnotation &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h4><p>元注解是可以注解到注解上的注解，或者说元注解是一种基本注解，但是它能够应用到其它的注解上面。 元注解有5种：@Retention、@Documented、@Target、@Inherited、@Repeatable</p>
<ul>
<li><p><strong>@Retention</strong>： 意为保留，是指注解的存活时间。</p>
<p>取值有3种： </p>
<ul>
<li>RetentionPolicy.SOURCE：注解只在源码解码保留，在编译时会被忽略丢弃。</li>
<li>RetentionPolicy.CLASS：注解只保留到编译进行时，不会被加载到JVM中。</li>
<li>RetentionPolicy.RUNTIME：注解可保留到程序运行时，会被加载到 JVM中。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestAnnotation &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>@Documented</strong>： 能够将注解中的元素包含到 Javadoc 中去。</p>
</li>
<li><p><strong>@Target</strong>： 指定注解运用的场景。取值有：</p>
<ul>
<li>ElementType.ANNOTATION_TYPE 可以给一个注解进行注解</li>
<li>ElementType.CONSTRUCTOR 可以给构造方法进行注解</li>
<li>ElementType.FIELD 可以给属性进行注解</li>
<li>ElementType.LOCAL_VARIABLE 可以给局部变量进行注解</li>
<li>ElementType.METHOD 可以给方法进行注解</li>
<li>ElementType.PACKAGE 可以给一个包进行注解</li>
<li>ElementType.PARAMETER 可以给一个方法内的参数进行注解</li>
<li>ElementType.TYPE 可以给一个类型进行注解，比如类、接口、枚举</li>
</ul>
</li>
<li><p><strong>@Inherited</strong>：继承的意思，如果当前类的超类有@Inherited，且当前类没有被任何注解应用，则当前类继承超类的注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> Test &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>如上，类B能继承类A的注解。</p>
</li>
<li><p><strong>@Repeatable</strong>：可重复的意思，通常指注解的值可以同时取多个。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@interface</span> Persons &#123;</span><br><span class="line">    Person[]  value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repeatable(Persons.class)</span></span><br><span class="line"><span class="meta">@interface</span> Person&#123;</span><br><span class="line">    String role <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Person(role=&quot;artist&quot;)</span></span><br><span class="line"><span class="meta">@Person(role=&quot;coder&quot;)</span></span><br><span class="line"><span class="meta">@Person(role=&quot;PM&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SuperMan</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="注解属性"><a href="#注解属性" class="headerlink" title="注解属性"></a>注解属性</h4><p>注解的属性也叫做成员变量。注解只有成员变量，没有方法。</p>
<ul>
<li><p>例：定义注解有两个属性，默认值用default关键字指定</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestAnnotation &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">id</span><span class="params">()</span> <span class="keyword">default</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">msg</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;Hi&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用时赋值（有默认值的属性也可以不赋值）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TestAnnotation(id=3, msg=&quot;hello annotation&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>例：注解仅有一个属性时，使用时可以省略属性名：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Check &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Check(&quot;hi&quot;)</span></span><br><span class="line"><span class="type">int</span> a;</span><br></pre></td></tr></table></figure>
</li>
<li><p>例：注解没有任何属性，使用时不用加括号</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Perform &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Perform</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMethod</span><span class="params">()</span>&#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Java预置注解"><a href="#Java预置注解" class="headerlink" title="Java预置注解"></a>Java预置注解</h4><p> Java 语言本身提供了几个现成的注解：</p>
<ul>
<li><p><strong>@Deprecated</strong>：用于标记过时的元素。在idea中使用过时元素，会划上删除线。</p>
</li>
<li><p><strong>@Override</strong>：提示子类要复写父类中被 @Override 修饰的方法</p>
</li>
<li><p><strong>@SuppressWarnings</strong>：阻止警告。如调用@Deprecated标记的元素的地方，可以使用@SuppressWarnings来忽略警告。</p>
</li>
<li><p><strong>@SafeVarargs</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SafeVarargs</span> <span class="comment">// 实际上并不安全！</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">(List&lt;String&gt;... stringLists)</span> &#123;</span><br><span class="line">    Object[] array = stringLists;</span><br><span class="line">    List&lt;Integer&gt; tmpList = Arrays.asList(<span class="number">42</span>);</span><br><span class="line">    array[<span class="number">0</span>] = tmpList; <span class="comment">// 语义上是无效的，但编译时没有警告。 </span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> stringLists[<span class="number">0</span>].get(<span class="number">0</span>); <span class="comment">// 在运行时出现ClassCastException!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>@FunctionalInterface</strong>： 函数式接口注解。 函数式接口就是一个只具有一个方抽象法的普通接口。 它主要用在Lambda表达式和方法引用上。</p>
<ul>
<li>函数式接口只能有一个抽象方法，但可以有默认方法，也可以有静态方法。</li>
</ul>
<p>比如，在线程开发中常用的Runnable就是一个典型的函数式接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        当使用对象实现接口Runnable创建线程时，启动线程会导致在该单独执行的线程中调用对象的方法run</span></span><br><span class="line"><span class="comment">        该方法run的一般约定是它可以采取任何行动。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h3><p>Service Provider Interface ，即服务提供者的接口，可以理解为 专门提供给服务提供者或框架开发者去使用的接口。 SPI将服务调用方和服务实现者解耦，修改或替换服务不需要修改调用方。</p>
<ul>
<li><p>SPI和API的区别：</p>
<p>API调用的接口是由实现方提供的，而SPI调用的接口是自己规定的，再交由实现方实现。</p>
</li>
<li><p>缺点：</p>
<ul>
<li>需要遍历加载所有的实现类，不能做到按需加载，这样效率还是相对较低的。</li>
<li>当多个 <code>ServiceLoader</code> 同时 <code>load</code> 时，会有并发问题。</li>
</ul>
</li>
</ul>
<p>使用 Java 的 SPI 机制是需要依赖 <code>ServiceLoader</code> 来实现的，<strong>ServiceLoader加载服务的流程</strong>大致是：</p>
<ol>
<li>通过 URL 工具类从 jar 包的 <code>/META-INF/services</code> 目录下面找到对应的文件，</li>
<li>读取这个文件的名称找到对应的 spi 接口，</li>
<li>通过 <code>InputStream</code> 流将文件里面的具体实现类的全类名读取出来，</li>
<li>根据获取到的全类名，先判断跟 spi 接口是否为同一类型，如果是的，那么就通过反射的机制构造对应的实例对象，</li>
<li>将构造出来的实例对象添加到 <code>Providers</code> 的列表中。</li>
</ol>
<h4 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h4><p>利用SPI机制，实现一个简易日志框架。</p>
<h5 id="调用方"><a href="#调用方" class="headerlink" title="调用方"></a>调用方</h5><p>首先在调用方，新建一个Java项目（不用Maven项目，因为涉及到一些编译配置，较麻烦），结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">│  service-provider-interface.iml</span><br><span class="line">│</span><br><span class="line">├─.idea</span><br><span class="line">│  │  .gitignore</span><br><span class="line">│  │  misc.xml</span><br><span class="line">│  │  modules.xml</span><br><span class="line">│  └─ workspace.xml</span><br><span class="line">│</span><br><span class="line">└─src</span><br><span class="line">    └─edu</span><br><span class="line">        └─jiangxuan</span><br><span class="line">            └─up</span><br><span class="line">                └─spi</span><br><span class="line">                        Logger.java</span><br><span class="line">                        LoggerService.java</span><br><span class="line">                        Main.class</span><br></pre></td></tr></table></figure>

<p>首先实现一个Logger接口，这个就是SPI，后面的服务提供者就要针对这个接口进行实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> edu.jiangxuan.up.spi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">info</span><span class="params">(String msg)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">debug</span><span class="params">(String msg)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着实现一个LoggerService类，主要用于加载实现方提供的服务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> edu.jiangxuan.up.spi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.ServiceLoader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggerService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">LoggerService</span> <span class="variable">SERVICE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoggerService</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Logger&gt; loggerList;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LoggerService</span><span class="params">()</span> &#123;</span><br><span class="line">        ServiceLoader&lt;Logger&gt; loader = ServiceLoader.load(Logger.class);</span><br><span class="line">        List&lt;Logger&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Logger log : loader) &#123;</span><br><span class="line">            list.add(log);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// LoggerList 是所有 ServiceProvider</span></span><br><span class="line">        loggerList = list;</span><br><span class="line">        <span class="keyword">if</span> (!list.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// Logger 只取一个</span></span><br><span class="line">            logger = list.get(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LoggerService <span class="title function_">getService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SERVICE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;info 中没有发现 Logger 服务提供者&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.info(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">debug</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (loggerList.isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;debug 中没有发现 Logger 服务提供者&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        loggerList.forEach(log -&gt; log.debug(msg));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后是Main类，查看实现结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.spi.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LoggerService</span> <span class="variable">service</span> <span class="operator">=</span> LoggerService.getService();</span><br><span class="line"></span><br><span class="line">        service.info(<span class="string">&quot;Hello SPI&quot;</span>);</span><br><span class="line">        service.debug(<span class="string">&quot;Hello SPI&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="实现方"><a href="#实现方" class="headerlink" title="实现方"></a>实现方</h5><ol>
<li>将调用方的SPI导出为jar包，然后导入到实现方项目的lib目录中，并添加为库。</li>
<li>在src目录下新建 META-INF&#x2F;services文件夹，然后新建文件，文件名为SPI的全类名，文件内容是实现类的全类名：edu.jiangxuan.up.spi.service.Logback</li>
<li>编写实现了Logger的类Logback。</li>
</ol>
<p>目录结构为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">│  service-provider.iml</span><br><span class="line">│</span><br><span class="line">├─.idea</span><br><span class="line">│  │  .gitignore</span><br><span class="line">│  │  misc.xml</span><br><span class="line">│  │  modules.xml</span><br><span class="line">│  └─ workspace.xml</span><br><span class="line">│</span><br><span class="line">├─lib</span><br><span class="line">│      service-provider-interface.jar</span><br><span class="line">|</span><br><span class="line">└─src</span><br><span class="line">    ├─edu</span><br><span class="line">    │  └─jiangxuan</span><br><span class="line">    │      └─up</span><br><span class="line">    │          └─spi</span><br><span class="line">    │              └─service</span><br><span class="line">    │                      Logback.java</span><br><span class="line">    │</span><br><span class="line">    └─META-INF</span><br><span class="line">        └─services</span><br><span class="line">                edu.jiangxuan.up.spi.Logger</span><br></pre></td></tr></table></figure>

<p>Logback类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> edu.jiangxuan.up.spi.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> edu.jiangxuan.up.spi.Logger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Logback</span> <span class="keyword">implements</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Logback info 打印日志：&quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">debug</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Logback debug 打印日志：&quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样一个简易的SPI实践就完成了，在调用方导入实现方的项目jar包，运行调用方的测试方法（这里是Main方法）即可出结果。</p>
<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><ul>
<li><strong>序列化</strong>：将数据结构或对象转换成二进制字节流的过程。</li>
<li><strong>反序列化</strong>：将在序列化过程中所生成的二进制字节流转换成数据结构或对象的过程。</li>
</ul>
<blockquote>
<p>在Java中，序列化的都是对象。</p>
<p>序列化属于OSI七层协议模型中的表示层，即TCP&#x2F;IP四层模型中的应用层。</p>
</blockquote>
<p>序列化场景：</p>
<ul>
<li>对象在进行<strong>网络传输</strong>（比如远程方法调用 RPC 的时候）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；</li>
<li>将对象<strong>存储到文件</strong>之前需要进行序列化，将对象从文件中读取出来需要进行反序列化；</li>
<li>将对象存储到数据库（如 Redis）之前需要用到序列化，将对象从缓存数据库中读取出来需要反序列化；</li>
<li>将对象存储到内存之前需要进行序列化，从内存中读取出来之后需要进行反序列化</li>
</ul>
<p>设置变量不进行序列化： 添加 transient 关键字修饰。</p>
<ul>
<li><p>注： </p>
<p>transient 只能修饰变量，不能修饰类和方法；</p>
<p>transient 修饰的变量，在反序列化后会被置为默认值；</p>
<p>static变量不属于任何对象，所以无论有没有 transient 修饰，都不会被序列化。</p>
</li>
</ul>
<p>常见的序列化协议： Hessian，Kryo，Protobuf，ProtoStuff。（JDK自带的序列化方式因为不支持跨语言调用、效率和安全问题，一般不用， JSON和XML这种文本类序列化方式，可读性好但性能较差，一般也不用。）</p>
<ul>
<li><p>Kryo： 是一个高性能的序列化&#x2F;反序列化工具，由于其变长存储特性并使用了字节码生成机制，拥有较高的运行速度和较小的字节码体积。（Kryo是专门针对Java语言的序列化方式，其他 Protobuf、 ProtoStuff、hessian 都是跨语言的）</p>
<p>在springboot中使用例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.esotericsoftware.kryo.Kryo;</span><br><span class="line"><span class="keyword">import</span> com.esotericsoftware.kryo.io.Input;</span><br><span class="line"><span class="keyword">import</span> com.esotericsoftware.kryo.io.Output;</span><br><span class="line"><span class="keyword">import</span> github.javaguide.exception.SerializeException;</span><br><span class="line"><span class="keyword">import</span> github.javaguide.remoting.dto.RpcRequest;</span><br><span class="line"><span class="keyword">import</span> github.javaguide.remoting.dto.RpcResponse;</span><br><span class="line"><span class="keyword">import</span> github.javaguide.serialize.Serializer;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KryoSerializer</span> <span class="keyword">implements</span> <span class="title class_">Serializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Because Kryo is not thread safe. So, use ThreadLocal to store Kryo objects</span></span><br><span class="line"><span class="comment">     * 因为 Kryo不是线程安全的。因此，使用 ThreadLocal存储 Kryo对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 因为ThreadLocal只能被当前线程访问, 所以也无法利用其他线程初始化, 需要在此先初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;Kryo&gt; kryoThreadLocal = ThreadLocal.withInitial(() -&gt; &#123;</span><br><span class="line">        <span class="type">Kryo</span> <span class="variable">kryo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Kryo</span>();</span><br><span class="line">        kryo.register(RpcResponse.class);</span><br><span class="line">        kryo.register(RpcRequest.class);</span><br><span class="line">        <span class="keyword">return</span> kryo;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序列化, 其中kryo的Output类继承了java.io.OutputStream</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] serialize(Object obj) &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ByteArrayOutputStream</span> <span class="variable">byteArrayOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">             <span class="type">Output</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Output</span>(byteArrayOutputStream)) &#123;</span><br><span class="line">            <span class="type">Kryo</span> <span class="variable">kryo</span> <span class="operator">=</span> kryoThreadLocal.get();</span><br><span class="line">            <span class="comment">// Object-&gt;byte:将对象序列化为byte数组</span></span><br><span class="line">            kryo.writeObject(output, obj);</span><br><span class="line">            kryoThreadLocal.remove();</span><br><span class="line">            <span class="keyword">return</span> output.toBytes();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SerializeException</span>(<span class="string">&quot;Serialization failed —— 序列化失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反序列化</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">deserialize</span><span class="params">(<span class="type">byte</span>[] bytes, Class&lt;T&gt; clazz)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ByteArrayInputStream</span> <span class="variable">byteArrayInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes);</span><br><span class="line">             <span class="type">Input</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Input</span>(byteArrayInputStream)) &#123;</span><br><span class="line">            <span class="type">Kryo</span> <span class="variable">kryo</span> <span class="operator">=</span> kryoThreadLocal.get();</span><br><span class="line">            <span class="comment">// byte-&gt;Object:从byte数组中反序列化出对对象</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> kryo.readObject(input, clazz);</span><br><span class="line">            kryoThreadLocal.remove();</span><br><span class="line">            <span class="keyword">return</span> clazz.cast(o);   <span class="comment">// cast(): 将对象强制转换为此 Class对象表示的类或接口。</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SerializeException</span>(<span class="string">&quot;Deserialization failed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">kryoSerializerTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 构建要序列化的对象</span></span><br><span class="line">    <span class="type">RpcRequest</span> <span class="variable">target</span> <span class="operator">=</span> RpcRequest.builder().methodName(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">        .parameters(<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;sayhelooloo&quot;</span>, <span class="string">&quot;sayhelooloosayhelooloo&quot;</span>&#125;)</span><br><span class="line">        .interfaceName(<span class="string">&quot;github.javaguide.HelloService&quot;</span>)</span><br><span class="line">        .paramTypes(<span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[]&#123;String.class, String.class&#125;)</span><br><span class="line">        .requestId(UUID.randomUUID().toString())</span><br><span class="line">        .group(<span class="string">&quot;group1&quot;</span>)</span><br><span class="line">        .version(<span class="string">&quot;version1&quot;</span>)</span><br><span class="line">        .build();</span><br><span class="line">    <span class="type">KryoSerializer</span> <span class="variable">kryoSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">KryoSerializer</span>();</span><br><span class="line">    <span class="comment">// 序列化为byte数组</span></span><br><span class="line">    <span class="type">byte</span>[] bytes = kryoSerializer.serialize(target);</span><br><span class="line">    <span class="comment">// 反序列</span></span><br><span class="line">    <span class="type">RpcRequest</span> <span class="variable">actual</span> <span class="operator">=</span> kryoSerializer.deserialize(bytes, RpcRequest.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="I-x2F-O"><a href="#I-x2F-O" class="headerlink" title="I&#x2F;O"></a>I&#x2F;O</h3><p>IO 即 <code>Input/Output</code>，输入和输出。数据输入到计算机内存的过程即输入，反之输出到外部存储（比如数据库，文件，远程主机）的过程即输出。</p>
<ul>
<li>数据传输过程类似于水流，因此称为 IO 流。</li>
<li>IO 流在 Java 中分为输入流和输出流，而根据数据的处理方式又分为字节流和字符流。</li>
<li>Java IO 流的 40 多个类都是从 4 个抽象类基类中派生出来的：字节输入流 InputStream，字符输入流 Reader， 字节输出流 OutputStream， 字符输入流 Writer。</li>
</ul>
<p>问题：不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I&#x2F;O 流操作要分为字节流操作和字符流操作呢？答： </p>
<ul>
<li>字符流是由 Java 虚拟机将字节转换得到的，这个过程还算是比较耗时，而如果转换时编码类型不同，还会出现乱码问题，所以就直接把字符流单独作为一个部分，从而提高字符流的效率；</li>
</ul>
<p>BIO、NIO、AIO：</p>
<ul>
<li><p>BIO（Blocking I&#x2F;O）：同步阻塞的I&#x2F;O模式，数据的读取和写入必须阻塞在一个线程内，直至完成。 并发性能很差。</p>
</li>
<li><p>NIO（Non-blocking I&#x2F;O或New I&#x2F;O）： </p>
<p>同步非阻塞的I&#x2F;O模型，通过java.nio包，提供了Channel，Select，Buffer等抽象，其中Selector可以实现单线程管理多个Channel，当有Channel需要I&#x2F;O操作时，它会将其交给一个独立的线程池（Reactor线程池）去处理。</p>
<p>NIO能够使用单线程（Selector）处理多个请求，从而避免了线程阻塞导致性能低下的问题。但是，NIO还是需要等待I&#x2F;O操作完成，因此虽然减少了线程切换和上下文切换的开销，但是在I&#x2F;O操作较多时，仍然会因为等待I&#x2F;O操作完成而阻塞。</p>
<p>提供了与传统BIO模型中的Socket和ServerSocket相对应的SocketChannnel 和 ServerSocketChannel 两种套接字实现，两种通道都支持阻塞和非阻塞模式。</p>
</li>
<li><p>AIO（Asynchronous I&#x2F;O）：NIO的改进版，异步非阻塞的I&#x2F;O模型。是基于事件和回调机制实现的，I&#x2F;O操作是直接交给操作系统的，当后台处理完，系统会通知对应的线程。</p>
<blockquote>
<p>BIO从发起read调用后，会一直阻塞，直到数据拷贝完成。（发起read调用后，内核过程：准备数据—数据就绪——拷贝数据）</p>
<p>NIO的操作仍是同步的，先发起select调用询问数据是否准备就绪（可以轮询，等告知准备好，用户线程才发起read调用（read调用的过程仍是阻塞的）</p>
</blockquote>
</li>
</ul>
<p>Java IO中的设计模式：</p>
<ul>
<li><p><strong>装饰器模式</strong>：在不改变原有对象的情况下拓展其功能，使用组合，而不是继承。</p>
<ul>
<li>比如，对于输入字节流， <code>FilterInputStream</code> 是装饰器的核心，用于增强 <code>InputStream</code> 的子类。 如常见的BufferedInputStream就是FilterInputStream的子类，可以将InputStream的子类传入 BufferedInputStream 来增强。</li>
</ul>
</li>
<li><p><strong>适配器模式</strong>：主要用于协调接口互不兼容的类。字符流和字节流的接口不同，它们之间的互动就是基于适配器模式来做的，具体说是 对象适配器。</p>
<ul>
<li><p><code>InputStreamReader</code> 和 <code>OutputStreamWriter</code> 就是两个适配器(Adapter)， 同时，它们两个也是字节流和字符流之间的桥梁。<code>InputStreamReader</code> 使用 <code>StreamDecoder</code> （流解码器）对字节进行解码，<strong>实现字节流到字符流的转换</strong>。</p>
<p>而 InputStream 和 OutputStream 的子类就是是被适配者。</p>
</li>
</ul>
</li>
<li><p><strong>工厂模式</strong>：用于创建对象。NIO 中大量用到了工厂模式，比如</p>
<ul>
<li><code>Files</code> 类的 <code>newInputStream</code> 方法用于创建 <code>InputStream</code> 对象（静态工厂）；</li>
<li><code>Paths</code> 类的 <code>get</code> 方法创建 <code>Path</code> 对象（静态工厂）；</li>
<li><code>ZipFileSystem</code> 类（<code>sun.nio</code>包下的类，属于 <code>java.nio</code> 相关的一些内部实现）的 <code>getPath</code> 的方法创建 <code>Path</code> 对象（简单工厂）。</li>
</ul>
</li>
<li><p><strong>观察者模式</strong>：又称 发布 - 订阅 模式，能让多个观察者对象同时监听一个主题对象。</p>
<p>NIO中的文件目录监听服务使用到了观察者模式。</p>
</li>
</ul>
<h3 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h3><p>语法糖是为了方便程序员开发程序而设计的特殊语法，对编程功能无影响。</p>
<p>不过 JVM并不能识别语法糖，所以需要先通过编译器解糖，所以说支持语法糖的是Java编译器。</p>
<p>常见的语法糖：</p>
<ul>
<li><p><strong>for-each</strong>：实际就是普通for循环和迭代器。</p>
</li>
<li><p><strong>switch支持String与枚举</strong>： switch只支持int和char等基本类型，char比较是比较其ascii码，即switch起始只能使用整型。 而switch比较String时，会使用String的 equals() 比较 hashCode()得到的哈希码。</p>
</li>
<li><p><strong>泛型</strong> ：所有泛型类的类型参数在编译时都会被擦除，泛型类并没有自己独有的class对象，比如只有List.class，而没有 List&lt;String&gt;.class之类的。</p>
<ul>
<li><p>不能通过泛型的不同传入参数来进行方法重载，因为泛型在编译阶段会被擦除，使得两个方法的特征变得一样。例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericTypes</span> &#123;</span><br><span class="line">	<span class="comment">// 这样是无法通过编译的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(List&lt;String&gt; list)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;invoke method(List&lt;String&gt; list)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(List&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;invoke method(List&lt;Integer&gt; list)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>泛型的类型参数不能用在 Java 异常处理的 catch 语句中。因为异常处理是由 JVM 在运行时刻来进行的。由于类型信息被擦除，JVM 是无法区分两个异常类型<code>MyException&lt;String&gt;</code>和<code>MyException&lt;Integer&gt;</code>的。</p>
</li>
<li><p>泛型类的静态变量 同样也是共享的。由于经过类型擦除，所有的泛型类实例依然关联到同一份字节码上。</p>
</li>
</ul>
</li>
<li><p><strong>自动装箱与拆箱</strong>： 自动装箱实际调用的是valueOf(xx)，自动拆箱实际调用了 xxxValue()；</p>
</li>
<li><p><strong>可变长参数</strong>：即方法最后一个参数可以有任意数量的值传入。 实际会将这个可变长参数转变为数组。</p>
</li>
<li><p><strong>枚举类</strong>： 当我们使用<code>enum</code>来定义一个枚举类型的时候，编译器会自动帮我们创建一个 final类型的类 继承<code>Enum</code>类，所以枚举类型不能被继承。</p>
</li>
<li><p><strong>数值字面量</strong>：允许在数字间插入任意多个下划线，这些下划线不会对数字产生影响，单纯是为了方便阅读。在编译阶段会删除这些下划线。</p>
</li>
<li><p><strong>try-with-resource</strong>： 对于需要手动关闭的资源，如IO流、数据库连接， 可以在 try 后接一个括号，括号中建立连接对象，在语句块结束后会自动关闭连接，不用再去手动关闭。代码例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;d:\\ hollischuang.xml&quot;</span>))) &#123;</span><br><span class="line">    String line;</span><br><span class="line">    <span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">        System.out.println(line);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="comment">// handle exception</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在编译阶段，仍会转换出关闭资源的代码。</p>
</li>
<li><p><strong>Lambda表达式</strong>： Lambda 表达式不是匿名内部类的语法糖，但是他也是一个语法糖。实现方式其实是依赖了几个 JVM 底层提供的 lambda 相关 api。（内部类在编译之后会有两个 class 文件，但是，包含 lambda 表达式的类编译后只有一个文件）</p>
<p>在编译阶段，会转换成调用内部api的方式。</p>
</li>
<li><p>。。。。。</p>
</li>
</ul>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h3><ul>
<li><p>Collection接口下的集合：</p>
<p>List：</p>
<ul>
<li>ArrayList： Object[] 数组</li>
<li>Vector：Object[] 数组</li>
<li>LinkedList：双向链表</li>
</ul>
<p>Set：</p>
<ul>
<li>HashSet：基于HashMap实现</li>
<li>LinkedHashSet： 是HashSet的子类，内部通过LinkedHashMap实现</li>
<li>TreeSet：红黑树，即自平衡的排序二叉树</li>
</ul>
<p>Queue：</p>
<ul>
<li>PriorityQueue： Object[] 数组实现二叉堆</li>
<li>ArrayQueue：Object[]数组 + 双指针</li>
</ul>
</li>
<li><p>Map接口下的集合：</p>
<ul>
<li>HashMap：jdk1.8以前是 数组 + 链表（数组是主体，链表是解决哈希冲突），jdk1.8以后， 解决哈希冲突的方法变更为：当链表长度大于8，且数组长度大于64，将链表转化为红黑树，以减少搜索时间。</li>
<li>LinkedHashMap：在HashMap的 数组 + 链表&#x2F;红黑树 结构上，增加了一条双向链表，使得能保持键值对的插入顺序。</li>
<li>HashTable：数组 + 链表</li>
<li>TreeMap：红黑树</li>
</ul>
</li>
</ul>
<blockquote>
<p>Vector是List的古老实现类，线程安全，Stack继承自Vector，是一个先进先出的栈，这两者都已经被淘汰，需要并发集合的话，推荐使用 ConcurrentHashMap、CopyOnWriteArrayList等。</p>
</blockquote>
<h3 id="排序接口"><a href="#排序接口" class="headerlink" title="排序接口"></a>排序接口</h3><p>Comparable接口 和 Comparetor接口 都是用于排序的接口。</p>
<ul>
<li><p><strong>Comparable</strong>接口出自 java.lang包，排序方法是 **compareTo(Object obj)**；</p>
<ul>
<li><p>Comparable可以理解为内部比较器，一个类实现了该接口，并实现排序方法compareTo()，那进行排序时默认就是依据这个进行排序。 </p>
<p>例如：Collections.sort() 不指定排序方法时，调用的是 list.sort(null)，此时 list.sort(null) 调用了 Arrays.sort(a, (Comparator) c)， 方法内部实际使用的排序逻辑是泛型参数所实现的compareTo()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;user&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.sort(<span class="literal">null</span>);</span><br><span class="line">    Collections.sort(list);</span><br><span class="line"></span><br><span class="line">    user[] users = <span class="keyword">new</span> <span class="title class_">user</span>[<span class="number">1</span>];</span><br><span class="line">    Arrays.sort(users);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">user</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;user&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(user o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.age - o.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，实现了Comparable接口的类的对象的列表或数组可以通过Collections.sort或Arrays.sort进行自动排序。</p>
</li>
</ul>
</li>
<li><p><strong>Comparator</strong>接口出自 java.util包，排序方法是 **compare(Object o1, Object o2)**；</p>
<ul>
<li><p>可以理解为外部比较器，当要为没有比较方法的类进行排序，或者使用特定比较逻辑时，就需要一个“比较器”，这个“比较器”需实现Comparator接口。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(list, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;user&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(user o1, user o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o1.age - o2.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 或者写成lambda表达式</span></span><br><span class="line">Collections.sort(list, (o1, o2) -&gt; o1.age - o2.age);</span><br><span class="line"><span class="comment">// 或者使用 Comparator.comparingXxx(...)</span></span><br><span class="line">Collections.sort(list, Comparator.comparingInt(o -&gt; o.age));</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="描述与比较"><a href="#描述与比较" class="headerlink" title="描述与比较"></a>描述与比较</h3><p>比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同：</p>
<ul>
<li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 都是 <code>Set</code> 接口的实现类，都能保证元素唯一，并且都不是线程安全的。</li>
<li>底层数据结构不同。<ul>
<li><code>HashSet</code> 的底层数据结构是哈希表（基于 <code>HashMap</code> 实现）。</li>
<li><code>LinkedHashSet</code> 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。</li>
<li><code>TreeSet</code> 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</li>
</ul>
</li>
<li>底层数据结构不同又导致这三者的应用场景不同。<code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景，<code>LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 FIFO 的场景，<code>TreeSet</code> 用于支持对元素自定义排序规则的场景。</li>
</ul>
<p>Queue与Deque的区别：</p>
<ul>
<li><p><code>Queue</code> 是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循 <strong>先进先出（FIFO）</strong> 规则。</p>
<p><code>Queue</code> 扩展了 <code>Collection</code> 的接口，根据 因为容量问题而导致操作失败后处理方式的不同 可以分为两类方法: 一种在操作失败后会抛出异常（add()，remove()，element()），另一种则会返回特殊值（offer()，poll()，peek()）。</p>
</li>
<li><p><code>Deque</code> 是双端队列，在队列的两端均可以插入或删除元素。</p>
<p><code>Deque</code> 扩展了 <code>Queue</code> 的接口, 增加了在队首和队尾进行插入和删除的方法，同样根据失败后处理方式的不同分为两类。</p>
</li>
</ul>
<p>ArrayDeque与LinkedList的区别（两者都实现了Deque接口，都有队列的功能）：</p>
<ul>
<li><code>ArrayDeque</code> 是基于可变长的数组和双指针来实现，而 <code>LinkedList</code> 则通过链表来实现。</li>
<li><code>ArrayDeque</code> 不支持存储 <code>NULL</code> 数据，但 <code>LinkedList</code> 支持。</li>
<li><code>ArrayDeque</code> 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 <code>LinkedList</code> 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</li>
</ul>
<p>从性能的角度上，选用 <code>ArrayDeque</code> 来实现队列要比 <code>LinkedList</code> 更好。此外，<code>ArrayDeque</code> 也可以用于实现栈。</p>
<p>什么是BlockingQueue：</p>
<ul>
<li><p><code>BlockingQueue</code> （阻塞队列）是一个接口，继承自 <code>Queue</code>。<code>BlockingQueue</code>阻塞的原因是其支持当队列没有元素时一直阻塞，直到有有元素；还支持如果队列已满，一直等到队列可以放入新元素时再放入。</p>
</li>
<li><p><code>BlockingQueue</code> 常用于生产者-消费者模型中，生产者线程会向队列中添加数据，而消费者线程会从队列中取出数据进行处理。</p>
</li>
<li><p>实现类有以下几种：</p>
<ul>
<li><p><code>ArrayBlockingQueue</code>：使用数组实现的有界阻塞队列。在创建时需要指定容量大小，并支持公平和非公平两种方式的锁访问机制。</p>
</li>
<li><p><code>LinkedBlockingQueue</code>：使用单向链表实现的可选有界阻塞队列。在创建时可以指定容量大小，如果不指定则默认为<code>Integer.MAX_VALUE</code>。和<code>ArrayBlockingQueue</code>类似， 它也支持公平和非公平的锁访问机制。</p>
</li>
<li><p><code>PriorityBlockingQueue</code>：支持优先级排序的无界阻塞队列。元素必须实现<code>Comparable</code>接口或者在构造函数中传入<code>Comparator</code>对象，并且不能插入 null 元素。</p>
</li>
<li><p><code>SynchronousQueue</code>：同步队列，是一种不存储元素的阻塞队列。每个插入操作都必须等待对应的删除操作，反之删除操作也必须等待插入操作。因此，<code>SynchronousQueue</code>通常用于线程之间的直接传递数据。</p>
</li>
<li><p><code>DelayQueue</code>：延迟队列，其中的元素只有到了其指定的延迟时间，才能够从队列中出队。</p>
</li>
<li><p>……</p>
</li>
</ul>
</li>
</ul>
<p>HashMap 和 Hashtable 的区别：</p>
<ul>
<li><strong>线程是否安全：</strong> <code>HashMap</code> 是非线程安全的，<code>Hashtable</code> 是线程安全的,因为 <code>Hashtable</code> 内部的方法基本都经过<code>synchronized</code> 修饰。（如果要保证线程安全的话就使用 <code>ConcurrentHashMap</code> ）；</li>
<li><strong>效率：</strong> 因为线程安全的问题，<code>HashMap</code> 要比 <code>Hashtable</code> 效率高一点。另外，<code>Hashtable</code> 基本被淘汰，不要在代码中使用它；</li>
<li><strong>对 Null key 和 Null value 的支持：</strong> <code>HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；Hashtable 不允许有 null 键和 null 值，否则会抛出 <code>NullPointerException</code>。</li>
<li><strong>初始容量大小和每次扩充容量大小的不同：</strong><ul>
<li>① 创建时如果不指定容量初始值，<code>Hashtable</code> 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。<code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。</li>
<li>② 创建时如果给定了容量初始值，那么 <code>Hashtable</code> 会直接使用你给定的大小，而 <code>HashMap</code> 会将其扩充为 2 的幂次方大小（<code>HashMap</code> 中的<code>tableSizeFor()</code>方法保证）。也就是说 <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小。</li>
</ul>
</li>
<li><strong>底层数据结构：</strong> JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树），以减少搜索时间。<code>Hashtable</code> 没有这样的机制。</li>
</ul>
<blockquote>
<p>为什么HashMap的容量大小是2的幂次方？</p>
<ul>
<li>因为键值对存放的位置是 根据key计算得到的Hash值 确定的，Hash值int类型，需要对数组长度取模运算，如果直接用 % 符号效率较低，而如果除数n是2的幂次方，则在%操作中等价于 (n - 1) &amp; Hash，位运算效率会更高。 即 n是2的n次方时， Hash % n &#x3D; (n - 1) &amp; Hash。</li>
</ul>
<p>HashMap多线程扩容导致死循环问题：</p>
<ul>
<li>当多个线程同时执行 rehash 进行扩容时，<strong>jdk1.7</strong>以前使用的<strong>链表头插法</strong>可能会导致链表中的节点指向错误的位置，从而形成一个<strong>环形链表</strong>，进而使得查询元素的操作陷入<strong>死循环</strong>无法结束。</li>
<li><strong>jdk1.8</strong>时，HashMap 采用了尾插法而不是头插法来避免链表倒置，使得插入的节点永远都是放在链表的末尾，避免了链表中的环形结构。 不过，多线程下使用还是会出现<strong>数据覆盖</strong>的问题，并发环境下，推荐使用 <code>ConcurrentHashMap</code> 。</li>
</ul>
</blockquote>
<p>JDK 1.7 和 JDK 1.8 的 ConcurrentHashMap 实现有什么不同？</p>
<ul>
<li><strong>线程安全实现方式</strong>：JDK 1.7 采用 <code>Segment</code> 分段锁来保证安全， <code>Segment</code> 是继承自 <code>ReentrantLock</code>。JDK1.8 放弃了 <code>Segment</code> 分段锁的设计，采用 <code>Node + CAS + synchronized</code> 保证线程安全，锁粒度更细，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点。</li>
<li><strong>Hash 碰撞解决方法</strong> : JDK 1.7 采用拉链法，JDK1.8 采用拉链法结合红黑树（链表长度超过一定阈值时，将链表转换为红黑树）。</li>
<li><strong>并发度</strong>：JDK 1.7 最大并发度是 Segment 的个数，默认是 16。JDK 1.8 最大并发度是 Node 数组的大小，并发度更大。</li>
</ul>
<ul>
<li><p>JDK 1.7 的 ConcurrentHashMap 结构图：</p>
<p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202305291108897.png" alt="image-20230529110844783"></p>
<p><code>ConcurrentHashMap</code> 是由 <code>Segment</code> 数组结构和 <code>HashEntry</code> 数组结构组成。（Segment数组不能扩容）</p>
<p><code>Segment</code> 数组中的每个元素包含一个 <code>HashEntry</code> 数组，每个 <code>HashEntry</code> 数组属于链表结构。</p>
</li>
<li><p>JDK 1.8 的 ConcurrentHashMap 结构图：</p>
<p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202305291108102.png" alt="image-20230529110817954"></p>
<p>JDK1.8 的 <code>ConcurrentHashMap</code> 是 <strong>Node 数组 + 链表 &#x2F; 红黑树</strong>。不过，Node 只能用于链表的情况，红黑树的情况需要使用 **<code>TreeNode</code>**。当冲突链表达到一定长度时，链表会转换成红黑树。</p>
<p><code>TreeNode</code>是存储红黑树节点，被<code>TreeBin</code>包装。<code>TreeBin</code>通过<code>root</code>属性维护红黑树的根结点，因为红黑树在旋转的时候，根结点可能会被它原来的子节点替换掉，在这个时间点，如果有其他线程要写这棵红黑树就会发生线程不安全问题，所以在 <code>ConcurrentHashMap</code> 中<code>TreeBin</code>通过<code>waiter</code>属性维护当前使用这棵红黑树的线程，来防止其他线程的进入。</p>
</li>
</ul>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><ul>
<li><p>并发： 两个及两个以上的作业在同一<strong>时间段</strong>内执行。（宏观上的同时执行）</p>
</li>
<li><p>并行：两个及两个以上的作业在同一<strong>时刻</strong>执行。（微观上的同时执行，真的同时执行）</p>
</li>
<li><p>同步：发出一个调用后，在没有得到结果之前，该调用会一直等待。</p>
</li>
<li><p>异步：调用在发出之后，不用等待返回结果，该调用直接返回。</p>
</li>
</ul>
<h3 id="进程、线程、协程"><a href="#进程、线程、协程" class="headerlink" title="进程、线程、协程"></a>进程、线程、协程</h3><p>**进程： **</p>
<p>进程就是程序的一次执行过程，可以视为程序的一个实例，是系统运行程序的基本单位，因此进程是动态的。</p>
<blockquote>
<p>比如：Java中启动main函数就是启动一个JVM的进程，main函数是这个进程中的主线程； 在Windows的任务管理器，可以看到当前运行的应用，也是一个进程（.exe文件的运行）</p>
<p>大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器<br>等），也有的程序只能启动一个实例进程（例如网易云音乐、360 安全卫士等）</p>
</blockquote>
<p><strong>线程：</strong></p>
<p>线程与进程相似，是一个更小的执行单位。进程在执行过程中会产生多个线程。</p>
<p>多个线程共享该进程的堆和方法区（1.8之后的实现是本地内存的元空间），线程各自拥有自己的程序计数器，虚拟机栈，本地方法栈。所以系统生产一个线程或线程间切换工作，负担都比进程小的多，因此线程也可称为轻量级进程。</p>
<p>总结： 线程是进程划分成的更小的运行单位。不同点在于，进程是相互独立的，而同一进程中的线程可能会相互影响。线程执行开销小，但不利于资源管理和保护，进程相反。</p>
<p><strong>协程：</strong></p>
<p>协程，是一种比线程更加轻量级的存在。正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。</p>
<p>最重要的是，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态中执行）。这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。 因为协程拥有自己的寄存器上下文和栈，协程调度切换时，将寄存器上下文和栈保存到其它地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈是基本没有内核切换的开销，</p>
<p>同时，因为线程进程都是同步机制，而协程则是异步机制。 协程可以不加锁的访问全局变量，所以上下文的切换非常快。</p>
<blockquote>
<p>Java原生语法没有实现协程，虽然有某些开源框架实现了，但也很少用。</p>
<p>线程的痛点：</p>
<ul>
<li>涉及到同步锁；</li>
<li>涉及到线程阻塞状态和可运行状态之间的切换；</li>
<li>涉及线程的上下文切换；</li>
</ul>
<p>这三点都是很耗费性能的操作。</p>
</blockquote>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><ul>
<li><p>为什么要使用多线程？</p>
<ul>
<li><strong>从计算机底层来说：</strong> 线程是程序执行的最小单位, 线程间的切换和调度的成本远远小于进程。另外，有多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。而对于单个CPU，多线程可以提高进程利用CPU和IO的效率（线程请求IO而阻塞时可以切换另一个线程继续使用CPU）。</li>
<li><strong>从当代互联网发展趋势来说：</strong> 现在的系统常要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。</li>
</ul>
</li>
<li><p>多线程的问题： 内存泄漏，死锁，线程不安全等</p>
</li>
</ul>
<p><strong>线程的生命周期：</strong> 以下6种</p>
<ul>
<li><code>NEW</code>: 初始状态，线程被创建出来但没有被调用 start() 。</li>
<li><code>RUNNABLE</code>: 运行状态，线程被调用了 start()等待运行的状态。(也就是<code>RUNNING</code>和<code>READY</code>，分别是运行中和就绪状态) </li>
<li><code>BLOCKED</code> ：阻塞状态，需要等待锁释放。</li>
<li><code>WAITING</code>：等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。</li>
<li><code>TIME_WAITING</code>：超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。</li>
<li><code>TERMINATED</code>：终止状态，表示该线程已经运行完毕。</li>
</ul>
<blockquote>
<p>操作系统层面，线程区分READY和RUNNING状态，而JVM并不区分，将两个状态统称为RUNNABLE状态。</p>
<p>因为JVM认为线程单次能运行的时间太短(RUNNING状态，可能就0.01s)，很快就回调用队列了（READY状态），线程切换很快，没必要区分这两种状态。</p>
</blockquote>
<p>当线程执行 wait() 之后，线程就进入 WAITING 状态，此时线程需要依靠其他线程的通知才能回到运行状态。</p>
<p>通过加上超时限制，如sleep(long millis)或wait(long millis) 可以使线程进入 TIME_WAITING 状态。 时间到了线程会回到运行状态。</p>
<p>当线程进入synchronized同步控制的方法或块时，锁被其他线程占用，该线程就会进入BLOCKED状态。</p>
<hr>
<p><strong>上下文切换：</strong></p>
<p>线程在执行过程中 有自己的运行条件和状态，就是上下文。 如线程的程序计数器，栈信息等。</p>
<p>当线程让出CPU并且线程还未终止时，也就是发生线程切换时，就要保存当前线程的上下文(保留现场)，方便下次占用时恢复现场。 </p>
<p>让出CPU的情况有</p>
<ul>
<li>主动让出，如调用了sleep()，wait()。</li>
<li>时间片用完。</li>
<li>调用了阻塞类型的系统中断，如请求IO。</li>
<li>线程终止&#x2F;结束运行</li>
</ul>
<hr>
<p><strong>线程死锁：</strong></p>
<p>多个线程同时被阻塞，它们等待的资源被彼此占有且不释放，这样线程就被无限期地阻塞，因此程序不能正常结束。</p>
<p>死锁发生的四个必要条件：</p>
<ul>
<li>互斥条件：该资源任意一个时刻只由一个线程占用。</li>
<li>请求并保持：一个线程因请求资源而阻塞时，对以获得的资源保持不放。</li>
<li>不剥夺条件：线程以获得的资源在未使用完之前不能被其他线程强行剥夺，只能自己选择释放。</li>
<li>循环等待：若干线程之间形成一种头尾相接的循环等待资源的关系。</li>
</ul>
<p>预防死锁： 只需破坏死锁产生的必要条件即可</p>
<ul>
<li>破坏“请求并保持条件”：一次性申请所有的资源；</li>
<li>破坏“不剥夺条件“：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li>
<li>破坏”循坏等待条件“：按序申请资源，释放资源则反序释放。</li>
</ul>
<p>避免死锁：</p>
<ul>
<li>在资源分配时，使用算法（如银行家算法）对资源分配进行计算评估，保证其进入安全状态（系统按某种顺序为线程分配资源，使所有线程都能顺利完成）。</li>
</ul>
<hr>
<p><strong>sleep()方法和wait()方法对比</strong>：</p>
<ul>
<li><p>共同点：两者都可以暂停线程的执行。</p>
</li>
<li><p>区别：</p>
<ul>
<li><p><code>sleep()</code> 方法没有释放锁，而 <code>wait()</code> 方法释放了锁 。</p>
</li>
<li><p><code>sleep()</code>通常被用于暂停执行。<code>wait() </code>通常被用于线程间交互&#x2F;通信，</p>
</li>
<li><p><code>sleep()</code>方法执行完成后，线程会自动苏醒；<code>wait()</code> 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 <code>notify()</code>或者 <code>notifyAll()</code> 方法。或者也可以使用 <code>wait(long timeout)</code> 超时后线程会自动苏醒。</p>
</li>
<li><p><code>sleep()</code> 是 <code>Thread</code> 类的静态本地方法，<code>wait()</code> 则是 <code>Object</code> 类的本地方法。</p>
</li>
</ul>
</li>
</ul>
<p>为什么wait()方法定义为本地方法？</p>
<ul>
<li>每个对象（<code>Object</code>）都拥有对象锁，而wait()是让获得对象锁的线程实现等待，会自动释放当前线程占有的对象锁。 既然要释放当前线程占有的对象锁并让其进入 WAITING 状态，自然是要操作对应的对象（<code>Object</code>）而非当前的线程（<code>Thread</code>）。</li>
</ul>
<p>为什么sleep()方法定义在Thread中？</p>
<ul>
<li>因为 <code>sleep()</code> 是让当前线程暂停执行，不涉及到对象类，也不需要获得对象锁。</li>
</ul>
<h3 id="Java锁的种类"><a href="#Java锁的种类" class="headerlink" title="Java锁的种类"></a>Java锁的种类</h3><ul>
<li>乐观锁、悲观锁（是一种概念）</li>
<li>独享锁、共享锁（是一种概念）</li>
<li>公平锁、非公平锁（是一种概念）</li>
<li>互斥锁、读写锁（是具体的实现）</li>
<li>可重入锁（是一种概念）</li>
<li>分段锁（是一种涉及）</li>
<li>锁升级（无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁）JDK1.6</li>
</ul>
<p><strong>乐观锁：</strong>乐观锁认为一个线程去拿数据的时候不会有其他线程对数据进行更改，所以不会上锁。 实现方式：CAS机制、版本号机制</p>
<p><strong>悲观锁：</strong>悲观锁认为一个线程去拿数据时一定会有其他线程对数据进行更改。所以一个线程在拿数据的时候都会顺便加锁，这样别的线程此时想拿这个数据就会阻塞。比如Java里面的synchronized关键字的实现就是悲观锁。 实现方式：就是直接加锁。</p>
<p><strong>独享锁：</strong>该锁一次只能被一个线程所持有</p>
<p><strong>共享锁：</strong>该锁可以被多个线程所持有</p>
<ul>
<li><p>独享锁与共享锁通过AQS（AbstractQueuedSynchronizer）来实现的，通过实现不同的方法，来实现独享或者共享。</p>
</li>
<li><p>例子：</p>
<p>synchronized是独享锁；可重入锁ReentrantLock是独享锁；</p>
<p>读写锁ReentrantReadWriteLock中的读锁ReadLock是共享锁，写锁WriteLock是独享锁。</p>
</li>
</ul>
<p><strong>互斥锁：</strong>具体实现就是synchronized、ReentrantLock。 （ReentrantLock是JDK1.5的新特性，采用ReentrantLock可以完全替代替换synchronized传统的锁机制，更加灵活。）</p>
<p><strong>读写锁：</strong>具体实现就是读写锁ReadWriteLock。</p>
<p><strong>可重入锁：</strong>对于同一个线程在外层方法获取锁的时候，在进入内层方法时也会自动获取锁。可以有效避免死锁。 具体实现：ReentrantLock、synchronized</p>
<p><strong>公平锁：</strong>多个线程相互竞争时要排队，多个线程按照申请锁的顺序来获取锁。</p>
<p><strong>非公平锁：</strong>多个线程相互竞争时，先尝试插队，插队失败再排队，比如：synchronized、ReentrantLock</p>
<p><strong>分段锁：</strong> 分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。 例如：CurrentHashMap底层就用了分段锁，使用Segment，就可以进行并发使用了，</p>
<h3 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h3><p><strong>悲观锁</strong>：总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题，所以<strong>每次在获取资源操作的时候都会上锁</strong>。 —— 也就是说，共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程。</p>
<ul>
<li><p><strong>synchronized</strong>和<strong>ReentrantLock</strong>等独占锁就是悲观锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">performSynchronisedTask</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 需要同步的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="comment">// 需要同步的操作</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>缺点：高并发的场景下，激烈的锁竞争会造成线程阻塞，进而增加系统的上下文切换，系统性能开销变大。并且，悲观锁还可能会存在死锁问题。</p>
</li>
</ul>
<p><strong>乐观锁</strong>：总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，<strong>只是在提交修改的时候去验证</strong>对应的资源是否被其它线程修改了。</p>
<ul>
<li><p><strong>版本号机制</strong> 和 <strong>CAS算法</strong> 是乐观锁。（Atomic原子变量类就是使用了CAS算法）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LongAdder</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongAdder</span>();</span><br><span class="line">sum.increment();</span><br></pre></td></tr></table></figure>
</li>
<li><p>优点：高并发的场景下，乐观锁相比悲观锁来说，不存在锁竞争造成线程阻塞，也不会有死锁的问题，在性能上往往会更胜一筹。</p>
</li>
<li><p>缺点：如果冲突频繁发生（写占比非常多的情况），会频繁失败和重试，这样同样会非常影响性能，导致 CPU 飙升。</p>
</li>
</ul>
<p><strong>使用建议：</strong></p>
<ul>
<li><strong>悲观锁</strong>通常多用于<strong>写比较多</strong>的情况下（多写场景，竞争激烈），这样可以避免频繁失败和重试影响性能，悲观锁的开销是固定的。不过，如果乐观锁解决了频繁失败和重试这个问题的话（比如<code>LongAdder</code>），也是可以考虑使用乐观锁的，要视实际情况而定。</li>
<li>乐观锁通常多于写比较少的情况下（多读场景，竞争较少），这样可以避免频繁加锁影响性能。不过，乐观锁主要针对的对象是单个共享变量。</li>
</ul>
<hr>
<p>乐观锁的实现：</p>
<ul>
<li><p>版本号机制：</p>
<p>一般是在数据表中加一个数据版本号 version字段，表示数据被修改的次数。当数据被修改时，version 加一。 </p>
<p>线程要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值&#x3D;&#x3D;当前数据库中的version值 才更新，否则重试整个更新操作，重新读取，直到更新成功。</p>
</li>
<li><p>CAS算法：</p>
<p>Compare And Swap（比较与交换），即用一个预期值和要更新的变量值进行比较，相等时才会进行更新。</p>
<ul>
<li>CAS是一个原子操作，底层依赖于一条CPU的原子指令。</li>
</ul>
<p>CAS的三个操作数：</p>
<ul>
<li>Var：要更新的变量值</li>
<li>Expected：预期值，即一开始Var的值</li>
<li>New：拟写入的新值</li>
</ul>
<p>只有Var等于Expected时，CAS通过原子方式用新值New更新Var的值。如果不等，说明已经有其它线程更新了 Var，则当前线程放弃更新。</p>
</li>
</ul>
<p>乐观锁存在的问题：</p>
<ul>
<li><p>ABA问题：</p>
<p>如果一个变量一开始是A值，它可能被其他线程改为其他值，又改回A值，那 CAS 操作就会误认为它从来没有被修改过。</p>
<ul>
<li>解决：在变量前追加版本号或时间戳。<code>AtomicStampedReference</code> 类可以用来解决 ABA 问题</li>
</ul>
</li>
<li><p>循环时间开销大：</p>
<p>CAS 经常会用到自旋操作来进行重试，如果长时间不成功，会给 CPU 带来非常大的执行开销。</p>
<ul>
<li>如果 JVM 能支持处理器提供的 pause 指令那么效率会有一定的提升，pause 指令有两个作用：<ol>
<li>可以延迟流水线执行指令，使 CPU 不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。</li>
<li>可以避免在退出循环的时候因内存顺序冲而引起 CPU 流水线被清空，从而提高 CPU 的执行效率。</li>
</ol>
</li>
</ul>
</li>
<li><p>只能保证一个共享变量的原子操作：</p>
<p>当操作涉及跨多个共享变量时 CAS 无效。</p>
<p>但是从 JDK 1.5 开始，提供了<code>AtomicReference</code>类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作</p>
</li>
</ul>
<h3 id="常见线程安全类"><a href="#常见线程安全类" class="headerlink" title="常见线程安全类"></a>常见线程安全类</h3><p>线程安全类是指，多个线程调用它们同一个实例的某个方法时，是线程安全的。（每个方法是原子的，但方法组合不是原子的）</p>
<ul>
<li>String</li>
<li>Integer</li>
<li>StringBuffer</li>
<li>Random</li>
<li>Vector</li>
<li>Hashtable</li>
<li>java.util.concurrent 包下的类</li>
</ul>
<h4 id="Atomic原子类"><a href="#Atomic原子类" class="headerlink" title="Atomic原子类"></a>Atomic原子类</h4><p>原子类： 具有原子操作特征的类。 原子类都在 java.util.concurrent.atomic 下。</p>
<p>原理（举例）：</p>
<ul>
<li><p><code>AtomicInteger</code> 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p>
<p>（值是volatile 变量，在内存中可见，因此 JVM 可以保证任何时刻任何线程总能拿到该变量的最新值。）</p>
</li>
</ul>
<p>根据操作的数据类型，可以将 JUC 包中的原子类分为 4 类</p>
<p><strong>基本类型</strong></p>
<p>使用原子的方式更新基本类型</p>
<ul>
<li><code>AtomicInteger</code>：整型原子类</li>
<li><code>AtomicLong</code>：长整型原子类</li>
<li><code>AtomicBoolean</code>：布尔型原子类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常用方法, 以AtomicInteger为例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> <span class="comment">//获取当前的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndSet</span><span class="params">(<span class="type">int</span> newValue)</span><span class="comment">//获取当前的值，并设置新的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span><span class="comment">//获取当前的值，并自增</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndDecrement</span><span class="params">()</span> <span class="comment">//获取当前的值，并自减</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAdd</span><span class="params">(<span class="type">int</span> delta)</span> <span class="comment">//获取当前的值，并加上预期的值</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> <span class="comment">//如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lazySet</span><span class="params">(<span class="type">int</span> newValue)</span><span class="comment">//懒设置为newValue,这可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多线程下和基本数据类型的对比</span></span><br><span class="line"><span class="comment">// 使用基本类型, 需要加锁</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//若要线程安全执行执行count++，需要加锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用原子类, 不需要加锁</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用AtomicInteger之后，不需要加锁，也可以实现线程安全。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>数组类型</strong></p>
<p>使用原子的方式更新数组里的某个元素</p>
<ul>
<li><code>AtomicIntegerArray</code>：整型数组原子类</li>
<li><code>AtomicLongArray</code>：长整型数组原子类</li>
<li><code>AtomicReferenceArray</code>：引用类型数组原子类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常用方法, 以AtomicIntegerArray为例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> i)</span> <span class="comment">//获取 index=i 位置元素的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndSet</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> newValue)</span><span class="comment">//返回 index=i 位置的当前的值，并将其设置为新值：newValue</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">(<span class="type">int</span> i)</span><span class="comment">//获取 index=i 位置元素的值，并让该位置的元素自增</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndDecrement</span><span class="params">(<span class="type">int</span> i)</span> <span class="comment">//获取 index=i 位置元素的值，并让该位置的元素自减</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAdd</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> delta)</span> <span class="comment">//获取 index=i 位置元素的值，并加上预期的值</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> expect, <span class="type">int</span> update)</span> <span class="comment">//如果输入的数值等于预期值，则以原子方式将 index=i 位置的元素值设置为输入值（update）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lazySet</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> newValue)</span><span class="comment">//懒设置 将index=i的元素设为newValue, 之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span></span><br></pre></td></tr></table></figure>

<p><strong>引用类型</strong></p>
<ul>
<li><code>AtomicReference</code>：引用类型原子类</li>
<li><code>AtomicMarkableReference</code>：原子更新带有标记的引用类型。该类将 boolean 标记与引用关联起来，也可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</li>
<li><code>AtomicStampedReference</code>：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用例子</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicReferenceTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建了一个Person对象，然后把Person对象设置进AtomicReference对象中</span></span><br><span class="line">        AtomicReference &lt; Person &gt; ar = <span class="keyword">new</span> <span class="title class_">AtomicReference</span> &lt; Person &gt; ();</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;SnailClimb&quot;</span>, <span class="number">22</span>);</span><br><span class="line">        ar.set(person);</span><br><span class="line">        <span class="comment">// 调用compareAndSet方法更换对象</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">updatePerson</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Daisy&quot;</span>, <span class="number">20</span>);</span><br><span class="line">        ar.compareAndSet(person, updatePerson);</span><br><span class="line"></span><br><span class="line">        System.out.println(ar.get().getName());</span><br><span class="line">        System.out.println(ar.get().getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对象的属性修改类型</strong></p>
<ul>
<li><code>AtomicIntegerFieldUpdater</code>：原子更新整型字段的更新器</li>
<li><code>AtomicLongFieldUpdater</code>：原子更新长整型字段的更新器</li>
<li><code>AtomicReferenceFieldUpdater</code>：原子更新引用类型里的字段</li>
</ul>
<p>使用：</p>
<ol>
<li>因为对象的属性修改类型原子类都是抽象类，所以每次使用都必须使用静态方法 newUpdater()创建一个更新器，并且需要设置想要更新的类和属性。</li>
<li>更新的对象属性必须使用 public volatile 修饰符。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用例子</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicIntegerFieldUpdaterTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        AtomicIntegerFieldUpdater&lt;User&gt; a = AtomicIntegerFieldUpdater.newUpdater(User.class, <span class="string">&quot;age&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Java&quot;</span>, <span class="number">22</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(a.getAndIncrement(user));<span class="comment">// 22</span></span><br><span class="line">        System.out.println(a.get(user));<span class="comment">// 23</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">int</span> age; <span class="comment">// 要更新的属性, 用volatile修饰</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Future类-TODO"><a href="#Future类-TODO" class="headerlink" title="Future类 - TODO"></a>Future类 - TODO</h4><h3 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h3><p><code>volatile</code> 关键字可以<strong>保证变量的可见性</strong>，如果我们将变量声明为 volatile ，这就指示 JVM，这个变量是共享且不稳定的，<strong>每次使用它都到主存中进行读取</strong>。</p>
<ul>
<li><code>volatile</code> 关键字只保证数据的可见性，但<strong>不保证数据的原子性</strong>。<code>synchronized</code> 关键字两者都能保证。</li>
<li><code>volatile</code> 除了可以保证变量的可见性，还有一个重要的作用就是<strong>防止 JVM 的指令重排序</strong>。如果我们将变量声明为 <strong><code>volatile</code></strong> ，在对这个变量进行读写操作的时候，会通过插入特定的 内存屏障 的方式来禁止指令重排序。</li>
</ul>
<p>关于指令重排， 假设new一个使用单例模式的对象实例，它的执行步骤可能为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton T;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> Singleton <span class="title function_">getT</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span></span><br><span class="line">        <span class="keyword">if</span> (T == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//类对象加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (T == <span class="literal">null</span>) &#123;</span><br><span class="line">                    T = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>为 <code>T</code> 分配内存空间</li>
<li>初始化 <code>T</code></li>
<li>将 <code>T</code> 指向分配的内存地址</li>
</ol>
<p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 A 执行了 1 和 3，此时 B 调用 <code>getT</code>() 后发现 <code>T</code> 不为空，因此返回 <code>T</code>，但此时 <code>T</code> 还未被初始化。</p>
<h3 id="锁的使用"><a href="#锁的使用" class="headerlink" title="锁的使用"></a>锁的使用</h3><p><strong>Monitor</strong>：</p>
<ul>
<li><p>Monitor 被翻译为监视器或管程，是一种syncronized的构造，每个 Java 对象都可以关联一个 Monitor 对象，如果使用 synchronized 给对象上锁（重量级）之后，该对象头的 Mark Word 就会被设置指向 Monitor 对象的指针。</p>
</li>
<li><p>Monitor能实现线程间的排斥和协作。排斥相当于竞争锁，协作相当于 生产和消费模式（wait,notify模式）。每个线程进入monitor会经过三个区域： entry set，the owner，wait set。</p>
<p><strong>1. 进入monitor，此时是被分配在entry set 中，等待lock的拥有者释放锁；</strong></p>
<p><strong>2. 当线程获得lock就会成为lock的拥有者（仅有一个线程可以拥有），此时处于 the owner 区域；</strong></p>
<p><strong>3. 当释放lock就会进入wait set ，但是处于wait set 中的线程还是有机会获得lock的拥有权。</strong></p>
</li>
</ul>
<h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h4><p><strong>使用：</strong></p>
<p>synchronized用于多个线程之间访问资源的同步性，让资源在任意时刻只能有一个线程访问。</p>
<p>早期版本，synchronized是重量级锁，效率低。不过Java 6之后，synchronized经过了大量优化，加入了自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。</p>
<p>使用：</p>
<ul>
<li>修饰实例方法</li>
<li>修饰静态方法</li>
<li>修饰代码块</li>
</ul>
<ol>
<li><p>修饰实例方法，锁当前对象实例，进入该同步代码前要获得当前对象实例的锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修饰静态方法，锁当前类，进入同步代码块前要获得当前class的锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修饰代码块，锁括号中的指定对象&#x2F;类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(对象) &#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">synchronized</span>(类.class) &#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>原理：</strong></p>
<p>Synchronized的重量级锁在Java JVM里的实现是基于进入和退出Monitor对象来实现方法同步和代码块同步的。任何对象都有一个monitor与之关联，当且一个monitor被持有后，它将处于锁定状态。（线程执行到monitor enter指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁。）</p>
<p>synchronized用的锁是存在Java对象头里的Mark Word中，在运行期间，Mark Word里存储的数据会随着锁标志位的变化而变化：</p>
<table>
<thead>
<tr>
<th>Mark Word</th>
<th>State</th>
</tr>
</thead>
<tbody><tr>
<td>hash code：25                | age：4    |  biased_lock：0       | 01 （锁标志位）</td>
<td>无锁</td>
</tr>
<tr>
<td>thread_id：23 | epoch：2 | age：4    |  biased_lock：1  | 01</td>
<td>偏向锁</td>
</tr>
<tr>
<td>ptr_to_lock_record：30 （指向栈中锁记录的指针）            | 00</td>
<td>轻量级锁</td>
</tr>
<tr>
<td>ptr_to_heavyweight_monitor：30  （指向monitor对象的指针）   | 10</td>
<td>重量级锁</td>
</tr>
<tr>
<td>为空                                                                                              | 11</td>
<td>GC标记</td>
</tr>
</tbody></table>
<p>锁一共有4种状态，级别从低到高依次是：<strong>无锁状态</strong>、<strong>偏向锁状态</strong>、<strong>轻量级锁状态</strong>和<strong>重量级锁状态</strong>，这几个状态会随着竞争情况逐渐升级， 且只能升级但不能降级。</p>
<ul>
<li><p><strong>偏向锁</strong></p>
<p>在锁不存在多线程竞争情况下，为了减小线程获取锁的代价而引入了偏向锁。</p>
<p>当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID（CAS设置偏向锁指向自己），以后该线程再进入同步块时只需简单判断下对象头的Mark Word里是否存储着的偏向锁指向的线程id是不是自己的就行。</p>
<ul>
<li>升级为轻量级锁：由于持有偏向锁的线程使用完毕后不会主动释放锁，所以当有另一个线程判断当前对象是偏向锁，且偏向的线程还存在，则会进行锁升级： 暂停拥有偏向锁的线程A，设置锁标志位为00，并将对象头中的 Mark Word 和 线程A的栈帧中的锁记录交换位置（即CAS操作），然后持有锁的线程A会继续运行，竞争者会开始自选尝试获取该对象的锁。</li>
</ul>
<p>显然，偏向锁只适用于从始至终都只有一个线程在运行的情况，省略掉了自旋获取锁，以及重量级锁互斥的开销，这种锁的开销最低，性能最好接近于无锁状态。但是如果线程之间存在竞争的话，就需要频繁的去暂停拥有偏向锁的线程然后检查状态，决定是否重新偏向还是升级为轻量级别锁，性能就会大打折扣了，如果事先能够知道可能会存在竞争那么可以选择关掉偏向锁。</p>
</li>
<li><p><strong>轻量级锁</strong></p>
<p>线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。</p>
<ul>
<li>升级为重量级锁：自旋次数超过n次（默认为10，可通过 -XX:PreBlockSpin 来更改），锁会升级为重量级锁，过程为：竞争者会设置锁标志位为10，并将对象头的 Mark Word 修改为指向Monitor对象的指针，然后将自己阻塞在该Monitor上。 当持有锁的线程要释放时，发现锁升级为重量级锁了，此时解锁失败，会直接将对象的monitor中的owner置为null，让通知竞争者去竞争该锁。</li>
</ul>
</li>
<li><p><strong>重量级锁</strong></p>
<p>重量级锁也就是普通的悲观锁，即竞争锁失败会阻塞，然后等待唤醒再次竞争。  获得锁的线程会将该对象指向的Monitor中的owner设为自己，运行完后放入Monitor的wait set， 而竞争者则放在Monitor的entry set中，等待锁的释放。</p>
</li>
</ul>
<h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><p><code>ReentrantLock</code>实现了 <code>Lock</code> 接口，是一个可重入且独占式的锁，和synchronized类似，但更灵活。其中增加了轮询，超时，中断，公平锁和非公平锁等高级功能。</p>
<p>ReentrantLock里面有一个内部类 <code>Sync</code>，Sync 继承 AQS（AbstractQueuedSynchronizer），添加锁和释放锁的大部分操作实际上都是在 Sync 中实现的。Sync 有公平锁 <code>FairSync</code> 和非公平锁 <code>NonfairSync</code> 两个子类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReentrantLock 默认使用非公平锁, 可以通过构造器来指定使用公平锁。</span></span><br><span class="line"><span class="comment">// 传入一个 boolean 值，true 时为公平锁，false 时为非公平锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>公平锁和非公平锁的底层都是使用AQS进行排队的，区别在于线程使用lock()加锁时：公平锁检查到有线程排队，会跟着排队；非公平锁则不会检查排队，而是直接竞争锁， 而没能竞争到锁时，非公平锁也会去排队。 在唤醒时，两者都只是唤醒队列前排的线程，是一样的。</li>
</ul>
<p><strong>使用：</strong></p>
<ol>
<li><p>加锁，释放锁： 释放锁的操作要放在finally块中，保证锁释放。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">lock.lock();	<span class="comment">// 获取锁</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 业务代码...</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();	<span class="comment">// 释放锁</span></span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<p>ReentrantLock的加锁方式有：</p>
<ul>
<li><strong>lock()</strong> —— 拿不到lock就不罢休，不然线程就一直阻塞。 </li>
<li><strong>tryLock()</strong> —— 马上返回，拿到 lock就返回true，不然返回false。 </li>
<li><strong>tryLock(long,TimeUnit)</strong> —— 带时间限制的tryLock()，拿不到lock，就等一段时间，超时返回false。</li>
<li><strong>lockInterruptibly()</strong> —— 调用后一直阻塞到获得锁，但是接受中断信号，此时会放弃获取锁。 <ul>
<li>在代码运行过程中抛出了<strong>InterruptedException，</strong>不论当前线程是否拥有锁，都会继续运行**run()**方法中捕获到异常部分代码块。</li>
<li>对一个线程，调用 interrupt() 时，1.  如果线程处于正常运行状态，只会将该线程的中断标志设为true，线程继续运行； 2. 如果线程处于阻塞状态（sleep，wait，join等），则立即退出阻塞状态，并抛出 InterruptedException 异常；</li>
</ul>
</li>
</ul>
<p>释放锁方式：</p>
<ul>
<li><strong>unlock()</strong></li>
</ul>
</li>
<li><p>使用公平锁： 构造器传入true即为公平锁， 默认不传则为false，是非公平锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>其他方法：</p>
<p><strong>getHoldCount()：</strong>当前线程调用 lock() 方法的次数。</p>
<p><strong>getQueueLength()：</strong>当前正在等待获取 Lock 锁的线程的估计数。</p>
<p><strong>getWaitQueueLength(Condition condition)：</strong>当前正在等待状态的线程的估计数，需要传入 Condition 对象。</p>
<p><strong>hasWaiters(Condition condition)：</strong>查询是否有线程正在等待与 Lock 锁有关的 Condition 条件。</p>
<p><strong>hasQueuedThread(Thread thread)：</strong>查询指定的线程是否正在等待获取 Lock 锁。</p>
<p><strong>hasQueuedThreads()：</strong>查询是否有线程正在等待获取此锁定。</p>
<p><strong>isFair()：</strong>判断当前 Lock 锁是不是公平锁。</p>
<p><strong>isHeldByCurrentThread()：</strong>查询当前线程是否保持此锁定。</p>
<p><strong>isLocked()：</strong>查询此锁定是否由任意线程保持。</p>
</li>
</ol>
<h4 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h4><p><code>ReentrantReadWriteLock</code> 实现了 <code>ReadWriteLock</code> ，是一个可重入的读写锁，既可以保证多个线程同时读的效率，同时又可以保证有写入操作时的线程安全。（一般锁的并发控制会读读互斥，而读写锁是 读读不互斥； 两种锁的读写，写写都是互斥的）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantReadWriteLock</span></span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">ReadWriteLock</span>, java.io.Serializable&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ReadWriteLock</span> &#123;</span><br><span class="line">    Lock <span class="title function_">readLock</span><span class="params">()</span>;</span><br><span class="line">    Lock <span class="title function_">writeLock</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReentrantReadWriteLock 其实是两把锁，一把是 <code>WriteLock</code> (写锁)，一把是 <code>ReadLock</code>（读锁） 。读锁是共享锁，写锁是独占锁。读锁可以被同时读，可以同时被多个线程持有，而写锁最多只能同时被一个线程持有。</p>
<ul>
<li>在线程持有读锁的情况下，该线程不能取得写锁；</li>
<li>在线程持有写锁的情况下，该线程可以继续获取读锁（获取读锁时如果发现写锁被占用，只有写锁没有被当前线程占用的情况才会获取失败）；</li>
</ul>
<p>和 <code>ReentrantLock</code> 一样，<code>ReentrantReadWriteLock</code> 底层也是基于 AQS 实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReentrantReadWriteLock 也支持公平锁和非公平锁，默认使用非公平锁。</span></span><br><span class="line"><span class="comment">// 可以通过构造器来显示的指定: 传入一个 boolean 值，true 时为公平锁，false 时为非公平锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantReadWriteLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">    readerLock = <span class="keyword">new</span> <span class="title class_">ReadLock</span>(<span class="built_in">this</span>);</span><br><span class="line">    writerLock = <span class="keyword">new</span> <span class="title class_">WriteLock</span>(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>通常情况下，我们创建的变量是可以被任何一个线程访问并修改的，不过可以使用<strong>ThreadLocal，来让每一个线程都有自己的专属本地变量</strong>。</p>
<p>创建一个<code>ThreadLocal</code>变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是<code>ThreadLocal</code>变量名的由来。各线程可以使用ThreadLocal变量的 <strong>get()</strong> 和 <strong>set(xxx)</strong> 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。</p>
<ul>
<li>使用： 可以将ThreadLocal变量包装进一个工具类，然后让线程调用。</li>
</ul>
<p><strong>原理</strong>：</p>
<p>从源代码可以看到，<code>Thread</code> 类中有一个 <code>threadLocals</code> 和 一个 <code>inheritableThreadLocals</code> 变量，它们都是 <strong>ThreadLocalMap</strong> 类型的变量，默认情况下这两个变量都是 null，只有当前线程调用 ThreadLocal 类的 <code>set</code>或<code>get</code>方法时才创建它们，实际上调用这两个方法的时候，我们调用的就是<code>ThreadLocalMap</code>类对应的 <code>get()</code>、<code>set()</code>方法。</p>
<p>所以，最终的变量是放在了当前线程的 <code>ThreadLocalMap</code> 中，并不是存在 <code>ThreadLocal</code> 上。<code>ThrealLocal</code> 类中可以通过<code>Thread.currentThread()</code>获取到当前线程对象后，直接通过<code>getMap(Thread t)</code>可以访问到该线程的<code>ThreadLocalMap</code>对象。</p>
<ul>
<li><p>ThreadLocalMap 是 ThreadLocal 的静态内部类，底层是一个Entry的键值对数组，key是ThreadLocal对象，且是一个弱引用（弱引用，生命周期只能存活到下次GC前），value是要存放的变量；</p>
</li>
<li><p><strong>一个线程最多只有一个ThreadLocalMap， 但是可以有多个ThreadLocal</strong>；</p>
</li>
<li><p><strong>一个ThreadLocal对应一个变量数据</strong>，封装成Entry存到ThreadLocalMap中，所以就有多个Entry。比如有两个变量，就要建两个ThreadLocal对象；</p>
</li>
<li><p>ThreadLocal 内存泄露问题： 由于ThreadLocalMap中的key是弱引用，value是强引用，所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。</p>
<p>这样一来，<code>ThreadLocalMap</code> 中就会出现 key 为 null 的 Entry。假如不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。（尽管ThreadLocalMap会在get、set、remove时会清理key为null的记录，还是建议使用完 ThreadLocal 后手动调用remove方法）</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//与此线程有关的ThreadLocal值。由ThreadLocal类维护</span></span><br><span class="line">    ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">threadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护</span></span><br><span class="line">    ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">inheritableThreadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocal</span>&lt;T&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//获取当前请求的线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="comment">//取出 Thread 类内部的 threadLocals 变量(哈希表结构)</span></span><br><span class="line">        <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">            ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果threadLocals还未创建, 则调用初始化方法</span></span><br><span class="line">        <span class="keyword">return</span> setInitialValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        <span class="comment">//获取当前请求的线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="comment">//取出 Thread 类内部的 threadLocals 变量(哈希表结构)</span></span><br><span class="line">        <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">// 将需要存储的值放入到这个哈希表中</span></span><br><span class="line">            map.set(<span class="built_in">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">        t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>线程池就是管理一系列线程的资源池。当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是等待下一个任务。</p>
<p>使用线程池的好处：</p>
<ul>
<li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程 创建和销毁造成的消耗。</li>
<li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>
<li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ul>
<p>阿里巴巴开发手册要求： </p>
<ul>
<li>线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。 </li>
<li>线程池不允许使用 <code>Executors</code> 去创建，而是通过 <code>ThreadPoolExecutor</code> 构造函数的方式，这样的处理方式让开发人员更加明确线程池的运行规则，规避资源耗尽的风险。</li>
</ul>
<p>线程池处理任务的流程：</p>
<ol>
<li>提交任务</li>
<li>判断<strong>核心线程池是否已满</strong> —— 未满，则<strong>创建线程</strong>；</li>
<li>核心线程池已满，判断<strong>等待队列是否已满</strong> —— 未满，把任务<strong>加入队列</strong>；</li>
<li>等待队列已满，判断<strong>线程池是否已满</strong> —— 未满，则<strong>创建线程</strong>；</li>
<li>线程池已满，则会拒绝任务，并则根据 饱和策略 来处理。</li>
</ol>
<p><strong>使用</strong>：</p>
<p>方式1. <strong>通过 ThreadPoolExecutor 构造函数来创建（推荐）。</strong></p>
<p>方式2. 使用 Executors 来创建 （不推荐）</p>
<h4 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h4><ul>
<li><p>构造函数如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用给定的初始参数创建一个新的ThreadPoolExecutor。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">int</span> corePoolSize,//线程池的核心线程数量</span></span><br><span class="line"><span class="params">    <span class="type">int</span> maximumPoolSize,//线程池的最大线程数</span></span><br><span class="line"><span class="params">    <span class="type">long</span> keepAliveTime,//当线程数大于核心线程数时，多余的空闲线程存活的最长时间</span></span><br><span class="line"><span class="params">    TimeUnit unit,//时间单位</span></span><br><span class="line"><span class="params">    BlockingQueue&lt;Runnable&gt; workQueue,//任务队列，用来储存等待执行任务的队列</span></span><br><span class="line"><span class="params">    ThreadFactory threadFactory,//线程工厂，用来创建线程，一般默认即可</span></span><br><span class="line"><span class="params">    RejectedExecutionHandler handler//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="literal">null</span> || threadFactory == <span class="literal">null</span> || handler == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="built_in">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="built_in">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="built_in">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="built_in">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="built_in">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>饱和策略&#x2F;拒绝策略</strong>：</p>
<p>如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，ThreadPoolTaskExecutor 定义一些策略：</p>
<ul>
<li><strong>ThreadPoolExecutor.AbortPolicy：</strong> 抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。</li>
<li><strong>ThreadPoolExecutor.CallerRunsPolicy：</strong> 将任务回退给调用者，使用调用者的线程来执行任务，也就是直接在调用 execute方法的线程中运行(<code>run</code>)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。<ul>
<li>这种策略会降低对于新任务提交速度，影响程序的整体性能。如果程序可以承受此延迟并且要求任何一个任务请求都要被执行的话，可以选择这个策略。</li>
</ul>
</li>
<li><strong>ThreadPoolExecutor.DiscardPolicy：</strong> 不处理新任务，直接丢弃掉。</li>
<li><strong>ThreadPoolExecutor.DiscardOldestPolicy：</strong> 此策略将丢弃最早的未处理的任务请求。</li>
</ul>
</li>
<li><p><strong>阻塞队列</strong>：</p>
<p>新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</p>
<ul>
<li><p>BlockingQueue 阻塞队列，它的实现有：</p>
<ul>
<li>ArrayBlockingQueue， 是一个由<strong>数组实现</strong>的<strong>容量固定</strong>的有界阻塞队列。</li>
<li>SynchronousQueue，是一个同步队列，消费者调用take()会发生阻塞，直到生产者产生一个元素，消费者才可以拿走并返回，同样的，生产者调用put()也会发生阻塞，直到有消费者消费了该元素，生产者才会返回。</li>
<li>LinkedBlockingQueue，是一个单链表实现的无界阻塞队列，也提供了一个可选有界的构造参数。</li>
</ul>
</li>
<li><p>其他队列：</p>
<p>DelayQueue 和 PriorityBlockingQueue底层都是使用二叉堆实现的优先级阻塞队列。</p>
<p>区别在于：</p>
<ul>
<li>前者要求队列中的元素实现Delayed接口，通过执行时延从队列中提取任务，时间没到任务取不出来；</li>
<li>后者对元素没有要求，可以实现Comparable接口也可以提供Comparator来对队列中的元素进行比较，跟时间没有任何关系，仅仅是按照优先级取任务。</li>
</ul>
</li>
</ul>
</li>
<li><p>使用例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个简单的Runnable类，需要大约5秒钟来执行其任务。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String command;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyRunnable</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.command = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; Start. Time = &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        processCommand();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; End. Time = &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processCommand</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.command;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExecutorDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CORE_POOL_SIZE</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_POOL_SIZE</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">QUEUE_CAPACITY</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Long</span> <span class="variable">KEEP_ALIVE_TIME</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用阿里巴巴推荐的创建线程池的方式</span></span><br><span class="line">        <span class="comment">//通过ThreadPoolExecutor构造函数自定义参数创建</span></span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">            CORE_POOL_SIZE,</span><br><span class="line">            MAX_POOL_SIZE,</span><br><span class="line">            KEEP_ALIVE_TIME,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(QUEUE_CAPACITY),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//创建WorkerThread对象（WorkerThread类实现了Runnable 接口）</span></span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>(<span class="string">&quot;&quot;</span> + i);</span><br><span class="line">            <span class="comment">//执行Runnable</span></span><br><span class="line">            executor.execute(worker);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//终止线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">        <span class="keyword">while</span> (!executor.isTerminated()) &#123;</span><br><span class="line">        	</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Finished all threads&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h4><p>使用 Executors 可以创建多种类型的ThreadPoolExecutor：</p>
<ul>
<li>**<code>FixedThreadPool</code>**：该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li>
<li><strong><code>SingleThreadExecutor</code>：</strong> 该方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</li>
<li><strong><code>CachedThreadPool</code>：</strong> 该方法返回一个可根据实际情况调整线程数量的线程池。初始大小为0。当有新任务提交时，如果当前线程池中没有线程可用，它会创建一个新的线程来处理该任务。如果在一段时间内（默认为60秒）没有新任务提交，核心线程会超时并被销毁，从而缩小线程池的大小。</li>
<li>**<code>ScheduledThreadPool</code>**：该方法返回一个用来在给定的延迟后运行任务或者定期执行任务的线程池。</li>
</ul>
<p>弊端：</p>
<ul>
<li>FixedThreadPool 和 SingleThreadExecutor 的任务队列是无界的LinkedBlockingQueue，最大长度Integer.MAX_VALUE， 如果堆积大量请求，可能会OOM。</li>
<li>CachedThreadPool 使用的是同步队列 SynchronousQueue ，允许最多创建的线程数为Integer.MAX_VALUE， 当任务过多且执行速度较慢，会创建大量线程，导致OOM。</li>
<li>ScheduledThreadPool 和 SingleThreadScheduledExecutor 使用的是无界的延迟阻塞队列 DelayedWorkQueue，最大长度Integer.MAX_VALUE， 同样会因为堆积大量请求，导致OOM。</li>
</ul>
<h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><p>AQS，即 AbstractQueuedSynchronizer ，翻译过来的意思就是抽象队列同步器。这个类在 java.util.concurrent.locks 包下面。 是一个抽象类，主要用来构建<strong>锁和同步器</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractQueuedSynchronizer</span> <span class="keyword">extends</span> <span class="title class_">AbstractOwnableSynchronizer</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>AQS 为构建锁和同步器提供了一些通用功能的实现，因此，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如 ReentrantLock，Semaphore，ReentrantReadWriteLock，SynchronousQueue 都是基于AQS的。</p>
</blockquote>
<p><strong>AQS 核心思想</strong>：</p>
<ul>
<li>如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。</li>
<li>如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 <strong>CLH 队列锁</strong> 实现的，即将暂时获取不到锁的线程加入到队列中。<ul>
<li>CLH（Craig，Landin，Hagersten，是作者名）队列是一个虚拟的双向队列（即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配。在 CLH 同步队列中，一个节点表示一个线程，它保存着线程的引用（thread）、 当前节点在队列中的状态（waitStatus）、前驱节点（prev）、后继节点（next）。</li>
</ul>
</li>
</ul>
<p><strong>同步状态表示：</strong></p>
<ul>
<li><p>AQS使用 volatile 修饰的 int型成员变量 <strong>state</strong> 表示同步状态，通过内置的 <strong>线程等待队列</strong> 来完成 等待线程的排队工作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 共享变量，使用volatile修饰保证线程可见性</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br></pre></td></tr></table></figure>

<p>state 可以通过 getState()，setState()，compareAndSetState() 进行操作，这几个方法被 protected 和 finally 修饰，在之类中无法被重写。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回同步状态的当前值</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 设置同步状态的值</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">int</span> newState)</span> &#123;</span><br><span class="line">     state = newState;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetState</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>以 <code>ReentrantLock</code> 为例，<code>state</code> 初始值为 0，表示未锁定状态。A 线程 <code>lock()</code> 时，会调用 tryAcquire() 独占该锁并将 <strong>state+1</strong> 。此后，其他线程再 tryAcquire() 时就会失败，直到 A 线程 <strong>unlock() 到 state&#x3D;0</strong>（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A 线程自己是可以重复获取此锁的（<code>state</code> 会累加），这就是可重入。但要注意，获取多少次就要释放多少次，这样才能保证 state 是能回到零态的。</p>
</li>
</ul>
<h4 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h4><p>Semaphore（信号量）是共享锁的一种实现，可以用来控制同时访问特定资源的线程数量。它将 AQS的state值构造为 <code>permits</code>，表示许可证的数量，只有拿到许可证的线程才能执行。</p>
<ul>
<li><p>调用<code>semaphore.acquire()</code> ，线程尝试获取许可证，如果 <code>state &gt;= 0</code> 的话，则表示可以获取成功。如果获取成功的话，使用 CAS 操作去修改 state 的值 <code>state=state-1</code>。如果 <code>state&lt;0</code> 的话，则表示许可证数量不足。此时会创建一个 Node 节点加入阻塞队列，挂起当前线程。</p>
</li>
<li><p>调用<code>semaphore.release();</code> ，线程尝试释放许可证，并使用 CAS 操作去修改 state 的值 <code>state=state+1</code>。释放许可证成功之后，同时会唤醒同步队列中的一个线程。被唤醒的线程会重新尝试去修改 state 的值 <code>state=state-1</code> ，如果 <code>state&gt;=0</code> 则获取令牌成功，否则重新进入阻塞队列，挂起线程。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始共享资源数量</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 获取1个许可</span></span><br><span class="line">semaphore.acquire();</span><br><span class="line"><span class="comment">// 释放1个许可</span></span><br><span class="line">semaphore.release();</span><br></pre></td></tr></table></figure>

<p>当初始的资源个数为 1 的时候，<code>Semaphore</code> 退化为排他锁。</p>
<p>Semaphore的构造方法可以选择公平和非公平模式，而许可数量 permits 是必填的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Semaphore</span><span class="params">(<span class="type">int</span> permits)</span> &#123;</span><br><span class="line">  	sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>(permits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Semaphore</span><span class="params">(<span class="type">int</span> permits, <span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">  	sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>(permits) : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h4><p>CountDownLatch 允许 <code>count</code> 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。 它是一次性的，计数器的值只能在构造方法中初始化一次。</p>
<p><strong>原理：</strong></p>
<p>CountDownLatch 是共享锁的一种实现,它默认构造 AQS 的 <code>state</code> 值为 <code>count</code>。当线程使用 <code>countDown()</code> 方法时,其实使用了<code>tryReleaseShared</code>方法以 CAS 的操作来减少 <code>state</code>，直至 <code>state</code> 为 0 。</p>
<p>当调用 <code>await()</code> 方法的时候，如果 <code>state</code> 不为 0，那就证明任务还没有执行完毕，<code>await()</code> 方法就会一直阻塞，也就是说 <code>await()</code> 方法之后的语句不会被执行。直到<code>count</code> 个线程调用了<code>countDown()</code>使state值被减为0，或者调用<code>await()</code>的线程被中断，该线程才会从阻塞中被唤醒，<code>await()</code> 方法之后的语句得到执行。</p>
<p>使用例子：</p>
<p>读取处理 6 个文件，这 6 个任务都是没有执行顺序依赖的任务，但是要求返回给用户的时候将这几个文件的处理的结果进行统计整理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchExample1</span> &#123;</span><br><span class="line">    <span class="comment">// 处理文件的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadCount</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建一个具有固定线程数量的线程池对象（推荐使用构造方法创建）</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(threadCount);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadnum</span> <span class="operator">=</span> i;</span><br><span class="line">            threadPool.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//处理文件的业务操作</span></span><br><span class="line">                    <span class="comment">//......</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//表示一个文件已经被完成</span></span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">        System.out.println(<span class="string">&quot;finish&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h4><p>CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待。</p>
<p>CyclicBarrier，字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是：让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。</p>
<blockquote>
<p>CycliBarrier 是基于 ReentrantLock和 Condition 的。（ReentrantLock 也属于 AQS 同步器）</p>
</blockquote>
<p>原理：</p>
<p>CyclicBarrier 内部通过一个 <code>count</code> 变量作为计数器，count 的初始值为 <code>parties</code> 属性的初始化值，每当一个线程到了栅栏这里了，那么就将计数器减 1。如果 count 值为 0 了，表示这是这一代最后一个线程到达栅栏，就尝试执行我们构造方法中输入的任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//每次拦截的线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> parties;</span><br><span class="line"><span class="comment">//计数器</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> count;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>JavaGuide那里有一些源码分析</p>
</blockquote>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><p>Java虚拟机（Java Virtual Machine，JVM）是Java语言的核心组成部分，它是一种能够<strong>运行Java字节码的虚拟计算机</strong>。Java程序在运行时，首先需要将Java源代码编译成Java字节码文件（.class文件），然后由JVM进行解释和执行。</p>
<p>JVM具有独立于硬件平台的特点，它提供了一种抽象的计算机模型，使得Java程序可以在任何支持Java虚拟机的计算机上运行。JVM的主要作用是将Java字节码转换为本地机器指令，同时还提供了一些重要的功能，如<strong>内存管理、垃圾回收</strong>、线程管理、安全性管理等，以保证Java程序的安全性和稳定性。</p>
<p>JVM的工作原理可以简单概括为以下几个步骤：</p>
<ol>
<li>加载：JVM通过类加载器（ClassLoader）从磁盘或网络中加载Java字节码文件，并将字节码转换为JVM内部的数据结构。</li>
<li>验证：JVM对字节码进行验证，检查字节码是否符合Java虚拟机规范，是否包含安全漏洞等。</li>
<li>准备：JVM为类变量（静态变量）分配内存，并设置默认值。</li>
<li>解析：JVM将符号引用转换为直接引用，即将类、方法和变量的引用解析为具体的内存地址。</li>
<li>初始化：JVM执行类的初始化代码，包括静态代码块和静态变量的赋值操作等。</li>
<li>执行：JVM执行Java字节码，将Java字节码解释为机器指令并执行，同时提供一些基本的服务，如垃圾回收、异常处理等。</li>
</ol>
<p>除了上述基本功能，JVM还提供了一些高级功能，如动态编译、代码优化、多线程支持、远程调试等，这些功能为Java程序的开发和调试提供了重要的支持。</p>
<h3 id="Java内存区域详解"><a href="#Java内存区域详解" class="headerlink" title="Java内存区域详解"></a>Java内存区域详解</h3><blockquote>
<p>JVM能自动管理内存，使得Java不容易发生内存泄漏和内存溢出，但如果真出现内存问题，就需要我们对JVM对内存的管理有一定的了解才能排错。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202303242335495.png" alt="image-20230324233542331"></p>
<h4 id="内存划分"><a href="#内存划分" class="headerlink" title="内存划分"></a>内存划分</h4><p>JVM在运行Java程序时会对管理的内存区进行划分：</p>
<hr>
<ul>
<li><p>运行时数据区域，<strong>每一个进程都有：</strong></p>
<ul>
<li><strong>堆</strong> （1.8及以后，字符串常量和静态变量放在这里）</li>
<li><strong>方法区</strong>：内含运行时常量池（1.8及以后移除方法区,用元空间替代）</li>
<li><strong>每个线程的私有区域</strong>：<ul>
<li><strong>虚拟机栈</strong></li>
<li><strong>本地方法栈</strong></li>
<li><strong>程序计数器</strong></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>本地内存：</strong></p>
<p><strong>元空间</strong>（1.8及以后才有，用于替代方法区）</p>
<p><strong>直接内存</strong>（是非运行时数据区的一部分）</p>
</li>
</ul>
<hr>
<p>其中<code>堆</code>，<code>方法区/元空间</code>，<code>直接内存</code>都是线程共享的。</p>
<h4 id="线程区域"><a href="#线程区域" class="headerlink" title="线程区域"></a>线程区域</h4><ul>
<li><p><strong>程序计数器</strong></p>
<p>是当前线程执行的字节码的行号指示器， 通过改变计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。</p>
<p>作用： 代码流程控制，线程切换后恢复。</p>
<p>（程序计数器是唯一不会发生<code>OutOfMemoryError</code>的内存区域，因为它的生命和线程一致，且不需要拓展空间）</p>
</li>
<li><p><strong>虚拟机栈</strong></p>
<p>栈是JVM运行时数据区域的一个核心，基本所有的Java方法调用都是通过栈来实现的。</p>
<blockquote>
<p>虚拟机栈和本地方法栈为线程私有，是为了保证线程中的局部变量不被别的线程访问到。</p>
</blockquote>
<p>方法调用的数据需要通过栈进行传递，<code>每一次方法调用都会有一个对应的栈帧</code>被压入栈中，每一个方法调用结束后，都会有一个栈帧被弹出。</p>
<p>&#x3D;&#x3D;<strong>栈帧</strong>&#x3D;&#x3D;的组成：</p>
<ul>
<li><strong>局部变量表</strong></li>
<li><strong>操作数栈</strong></li>
<li><strong>动态链接</strong></li>
<li><strong>方法</strong></li>
</ul>
<blockquote>
<ul>
<li><p><strong>局部变量表</strong></p>
<p>​	主要存放了编译期可知的各种<strong>基本数据类型</strong>、<strong>对象引用</strong>（reference 类型，它不是对象本身，而是一个指向对象起始地址的引用指针，或者是指向一个代表对象的句柄）。</p>
</li>
<li><p><strong>操作数栈</strong></p>
<p>​	作为方法调用的中转站使用，用于存放方法执行过程中产生的<strong>中间计算结果</strong>和<strong>临时变量</strong>。</p>
</li>
<li><p><strong>动态链接</strong></p>
<p>​	当方法内需要调用其他方法，就需要用到动态链接。首先，Java程序编译后会得到每个类和接口各自的Class文件，里面包含了该类所有变量和方法的<strong>符号引用</strong>。 动态链接的作用就是将<strong>符号引用</strong>转换为<strong>调用目标方法的直接引用</strong>。</p>
</li>
<li><p><strong>方法返回地址</strong></p>
<p>​	Java 方法有两种返回方式，一种是 return 语句正常返回，一种是抛出异常。两者都会让栈帧被弹出。</p>
</li>
</ul>
</blockquote>
<p>虚拟机栈可能会出现的错误：</p>
<ul>
<li><p><strong><code>StackOverFlowError</code>：</strong> 若栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。</p>
<p><strong><code>OutOfMemoryError</code>：</strong> 如果栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。</p>
</li>
</ul>
</li>
<li><p><strong>本地方法栈</strong></p>
<p>本地方法栈和虚拟机栈类似，区别在于：虚拟机栈为虚拟机执行 Java 方法 (也就是字节码）服务，而<strong>本地方法栈则为虚拟机使用到的 Native 方法服务</strong>。</p>
<p>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</p>
<p>同样可能出现两种错误： StackOverFlowError 和 OutOfMemoryError。</p>
</li>
</ul>
<h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>堆是Java 虚拟机所管理的内存中最大的一块，是所有线程共享的内存区域，在虚拟机启动时创建。<strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</strong></p>
<blockquote>
<p>JIT有一个重要的优化，叫逃逸分析。JDK1.7默认开启逃逸分析，即方法中的对象引用没有被返回或未被外界使用(未逃逸出去),那么对象可以直接在栈上分配内存。</p>
</blockquote>
<p>因为Java堆是垃圾收集器管理的主要区域，所以也被叫做GC堆（Garbage Collected Heap）。垃圾收集器一般都采用分代收集算法，即分为新生代和老年代。</p>
<p>Hotspot VM 的堆结构：</p>
<ul>
<li>新生代内存： Eden + S0 + S1</li>
<li>老年代内存：Tenured</li>
<li>永久代：MetaSpace，即元空间 （JDK1.7及以前是PermGen，永久代内存空间）</li>
</ul>
<p>– Tenured的内存空间要比新生代内存大的多；</p>
<p>– 新生代中Eden占80%的空间，Survivor0和Survivor1用于交换复制在Minor GC后还存活的对象。在16次Minor GC还存活的对象将送至老年代。（即进行minor GC时，会将Eden和其中一个Survivor的存活对象移动到另一个Survivor）</p>
<p>– 如果新对象在分配新生代空间时，空间不够并且立即进行一次minor GC后还是没有足够空间进行分配，就会通过 <code>分配担保机制</code> 把新生代的对象提前转移到老年代中去。</p>
<p>– 大对象（字符串、数组）因为需要大量连续内存空间，会直接进入老年代。</p>
<hr>
<p>堆中最容易出现的错误：OutOfMemoryError。</p>
<h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>方法区是JVM运行时数据区域的一块逻辑区域，是各个线程共享的内存区域。</p>
<p>方法区是一个抽象概念&#x2F;规范，在JDK1.7，方法区的具体实现是永久代，在JDK1.8，方法区的实现是元空间。(它们的关系类似于接口和类）</p>
<ul>
<li>方法区的作用： 当JVM要使用一个类时，它需要读取并解析 Class 文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的 <strong>类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据</strong>。</li>
</ul>
<blockquote>
<p>为什么永久代会被替换：</p>
<ul>
<li><p>永久代受JVM设置的固定大小所限，无法调节大小；</p>
<p>元空间使用的是本地内存，受本机可用内存限制；</p>
<p>—— 元空间内存溢出的几率比永久代小的多。</p>
</li>
<li><p>元空间存放的是类的元数据，这样加载多少类的元数据就不由 MaxPermSize 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了。</p>
</li>
</ul>
<p>（元数据：指描述数据的数据。在Java中元数据以标签(Annotation，注解)的形式存在于Java代码中，让文件或针在运行时知道被运行代码的描述信息。 元数据可以用于说明数据的名称、类型、范围、所属等）</p>
</blockquote>
<ul>
<li><p><strong>运行时常量池</strong>：</p>
<p>Class文件中有存放编译期生成的各种字面量（Literal）和符号引用（Symbolic Reference）的 <strong>常量池表</strong> (Constant Pool Table) 。</p>
<p>常量池表 会在类加载后存放到 方法区的运行时常量池中。</p>
<blockquote>
<p>字面量：通过直面能直接知道 值，包括整数、浮点数、字符串字面量。</p>
<p>符号引用：用一组符号来描述引用的目标，能无歧义地定位到目标，与虚拟机的内存布局无关。（直接引用受虚拟机内存布局影响）</p>
</blockquote>
</li>
<li><p><strong>字符串常量池</strong>：</p>
<p>为了避免字符串重复创建而开辟的内存区域。</p>
<blockquote>
<p>HotSpot 虚拟机中字符串常量池的实现是 src&#x2F;hotspot&#x2F;share&#x2F;classfile&#x2F;stringTable.cpp,  <code>StringTable</code>本质上就是一个<code>HashSet&lt;String&gt;</code> ,容量为 StringTableSize。</p>
<ul>
<li>StringTable保存的是字符串对象的引用，指向堆中的字符串对象。</li>
<li>1.7以前字符串常量放在方法区的永久代中，<code>1.8以后字符串常量和静态变量放到Java堆中</code>。（因为永久代只有在整堆收集Full GC时才会被执行垃圾回收，而通常有许多被创建的字符串需要被回收，所以将字符串常量放到Java堆中，能高效回收字符串）</li>
</ul>
</blockquote>
</li>
</ul>
<hr>
<p>运行时常量池 和 字符串常量池 的变迁：</p>
<ul>
<li>JDK1.7 之前运行时常量池 逻辑包含 字符串常量池存放在方法区, 此时 hotspot 虚拟机对方法区的实现为永久代。</li>
<li>JDK1.7 字符串常量池和静态变量被单独从方法区拿到了堆中, 而运行时常量池剩下的东西（即永久代）还在方法区。</li>
<li>JDK1.8 hotspot 移除了永久代，用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)</li>
</ul>
<hr>
<p>— 运行时常量池、方法区、字符串常量池 这些都是不随虚拟机实现而改变的逻辑概念，是公共且抽象的;</p>
<p>— Metaspace、Heap 是与具体某种虚拟机实现相关的物理概念，是私有且具体的。</p>
<hr>
<h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h4><p>直接内存并不在 Java 堆或方法区中分配的，而是通过 JNI (Java Native Interface，java本地接口）的方式在本地内存上分配的。</p>
<blockquote>
<p>java的<code>NIO</code>类，是一种基于<code>通道（Channel）与缓存区（Buffer）的 I/O 方式</code>，它可以直接<code>使用 Native 函数库直接分配堆外内存</code>，然后通过一个存储在 Java 堆中的 <code>DirectByteBuffer 对象</code>作为这块内存的<code>引用</code>进行操作。这样就能在一些场景中显著提高性能，因为<code>避免了在 Java 堆和 Native 堆之间来回复制数据</code>。</p>
</blockquote>
<h3 id="对象创建过程"><a href="#对象创建过程" class="headerlink" title="对象创建过程"></a>对象创建过程</h3><ol>
<li><p><strong>&#x3D;&#x3D;类加载检查&#x3D;&#x3D;</strong></p>
<p>虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p>
</li>
<li><p><strong>&#x3D;&#x3D;分配内存&#x3D;&#x3D;</strong></p>
<p>类加载过后，对象所需的内存大小确定了，可以开始分配内存。 有两种方式：</p>
<ul>
<li><strong>指针碰撞</strong> ： <ul>
<li>适用场合：堆内存规整（即没有内存碎片）的情况下。（GC收集器使用“标记-整理”算法）</li>
<li>原理 ：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。</li>
<li>使用该分配方式的 GC 收集器：Serial, ParNew</li>
</ul>
</li>
<li><strong>空闲列表</strong> ： <ul>
<li>适用场合：堆内存不规整的情况下。（GC收集器使用“标记-清除”算法）</li>
<li>原理 ：虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。</li>
<li>使用该分配方式的 GC 收集器：CMS</li>
</ul>
</li>
</ul>
<blockquote>
<p>内存分配有线程安全问题，一般采用CAS+失败重试，或使用TLAB分配</p>
</blockquote>
</li>
<li><p><strong>&#x3D;&#x3D;初始化零值&#x3D;&#x3D;</strong></p>
<p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头）。</p>
<p>这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p>
</li>
<li><p><strong>&#x3D;&#x3D;设置对象头&#x3D;&#x3D;</strong></p>
<p>初始化零值后，虚拟机还需要为对象设置一些必要信息，这些信息存放在对象头中，如：对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p>
</li>
<li><p><strong>&#x3D;&#x3D;执行init方法&#x3D;&#x3D;</strong></p>
<p>对虚拟机来说，此时对象已经产生，不过对于Java程序来说，对象创建才刚开始，一般来说，new指令之后会接着执行init方法，按程序逻辑进行初始化，这样一个对象才算真正产生。</p>
</li>
</ol>
<hr>
<p><strong>对象的内存布局：</strong></p>
<p>分为三部分：</p>
<ul>
<li>对象头：<ul>
<li>存储对象的运行时数据（哈希码，GC分代年龄，锁状态标志等）</li>
<li>存储类型指针（指向它的类元数据，能确定对象是哪个类的实例）</li>
</ul>
</li>
<li>实例数据： 程序中定义的字段内容。</li>
<li>对齐填充： 仅起占位作为，因为Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍。</li>
</ul>
<blockquote>
<p>Java对象头，以32位虚拟机为例：</p>
<ul>
<li><p>普通对象： Mark Word存储运行时数据或锁指针，Klass Word存储类型指针</p>
<table>
<thead>
<tr>
<th>Mark Word（32 bits）</th>
<th>Klass Word（32bits）</th>
</tr>
</thead>
</table>
</li>
<li><p>数组对象</p>
<table>
<thead>
<tr>
<th>Mark Word（32 bits）</th>
<th>Klass Word（32bits）</th>
<th>array length（32bits）</th>
</tr>
</thead>
</table>
</li>
</ul>
<p>其中Mark Word结构如下：</p>
<ul>
<li><table>
<thead>
<tr>
<th>Mark Word</th>
<th>State</th>
</tr>
</thead>
<tbody><tr>
<td>hash code：25                | age：4    |  biased_lock：0  | 01 （锁标记位）</td>
<td>Normal</td>
</tr>
<tr>
<td>thread：23 | epoch：2 | age：4    |  biased_lock：0  | 01</td>
<td>Biased</td>
</tr>
<tr>
<td>ptr_to_lock_record：30 （指向栈中锁记录的指针）      | 00</td>
<td>Lightweight Locked</td>
</tr>
<tr>
<td>ptr_to_heavyweight_monitor：30  （指向互斥量&#x2F;重量级锁的指针）   | 10</td>
<td>Heavyweight Locked</td>
</tr>
<tr>
<td>为空                                                                                       | 11</td>
<td>Marked for GC</td>
</tr>
</tbody></table>
</li>
</ul>
</blockquote>
<hr>
<p><strong>对象的访问定位：</strong></p>
<p>Java程序通过栈上的 reference 数据来操作堆上的具体对象。 具体的访问形式，当前主流的有两种方式：</p>
<ul>
<li><p><strong>直接指针</strong></p>
<p>reference 中存储的直接就是对象的内存地址（这块内存中，也包含有 到对象类型数据的指针。）</p>
<ul>
<li>特点：速度快，只用定位一次即可访问实例数据。</li>
</ul>
</li>
<li><p><strong>使用句柄</strong></p>
<p>Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的是对象的句柄地址，而句柄中包含了 对象实例数据与对象类型数据 各自的具体地址信息。</p>
<ul>
<li>特点： reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。（需要定位两次指针才能访问到实例数据）</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202303211649720.png" alt="image-20230321164901535"></p>
<h3 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h3><p>针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：</p>
<ul>
<li><p>部分收集 (Partial GC)：</p>
<ul>
<li>新生代收集（Minor GC &#x2F; Young GC）：只对新生代进行垃圾收集；</li>
<li>老年代收集（Major GC &#x2F; Old GC）：只对老年代进行垃圾收集。（注： Major GC 在一些语境中也用于指代整堆收集）</li>
<li>混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。</li>
</ul>
</li>
<li><p>整堆收集 (Full GC)：收集整个 Java 堆和方法区。</p>
</li>
</ul>
<blockquote>
<p>Partial: 部分的,局部的; minor: 较小的,次要的; major: 主要的 </p>
</blockquote>
<hr>
<p><strong>空间分配担保：</strong></p>
<p>确保在 Minor GC 之前，老年代还有容纳新生代所有对象的剩余空间。</p>
<p>规则： 只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行 Minor GC，否则将进行 Full GC。</p>
<h4 id="死亡对象判断"><a href="#死亡对象判断" class="headerlink" title="死亡对象判断"></a>死亡对象判断</h4><p>对堆的垃圾回收第一步：判断哪些对象已经死亡（不再被任何途径使用）。</p>
<ul>
<li><p>引用计数法：</p>
<p>只需在对象中添加一个引用计数器：</p>
<ul>
<li>每当有一个地方引用它，计数器就加1；</li>
<li>当一个引用失效，计数器就减1；</li>
<li>计数器为0的对象不可能再被使用。</li>
</ul>
<p>引用计数法实现简单、效率高，但有个致命问题：不能解决对象间的相互循环引用问题。</p>
<blockquote>
<p>对象间的相互循环引用问题：除了对象A和对象B相互引用对方之外，无其他任何引用。这样它两的引用计数器都不为0，导致无法被回收。</p>
</blockquote>
</li>
<li><p><strong>可达性算法：</strong></p>
<p>以<strong>“GC Roots”</strong>对象为起点形成的引用链中的节点对象都是可用的，如果有对象与任何GC Roots没有引用链相连的话，这个对象就是不可用的，需要被回收。</p>
<p>可以被作为GC Roots的对象有：</p>
<ul>
<li>虚拟机栈(栈帧中的本地变量表) 中引用的对象</li>
<li>本地方法栈(Native 方法) 中引用的对象</li>
<li>方法区中类静态属性 引用的对象</li>
<li>方法区中常量 引用的对象</li>
<li>所有被同步锁持有的对象</li>
</ul>
</li>
</ul>
<hr>
<p><strong>如何判断一个常量是废弃常量？</strong></p>
<p>如果字符串常量池中的一个字符串”abc”，没有任何String对象引用该字符串常量，那么常量”abc”就是废弃常量，可被回收。</p>
<p><strong>如何判断一个类是无用类？</strong> 需要满足以下3各条件才行：</p>
<ul>
<li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li>
<li>加载该类的 <code>ClassLoader</code> 已经被回收。</li>
<li>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
<hr>
<h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><p>Java判定对象的存活与”引用”相关。引用分为 强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱）</p>
<ul>
<li><p>强引用：</p>
<p>平时使用的大部分引用都是强引用，这是默认的引用类型。当创建一个对象并赋值给一个变量时，这个变量就是该对象的强引用。</p>
<p>一个对象具有强引用，说明它是必不可少的，垃圾回收器就不会进行回收。（就算内存不足也不会回收，而是抛出OutOfMemoryError 错误让程序终止）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello, world!&quot;</span>);	<span class="comment">// 一般使用的变量赋值都是强引用</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>软引用：</p>
<p>一个对象只具有软引用，说明是可有可无的，垃圾回收器在内存足够时不会回收，在内存不足时会回收。</p>
<p>（平时很少用弱引用与虚引用，而使用软引用的情况较多，这是因为<strong>软引用可以加速 JVM 对垃圾内存的回收速度</strong>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个字符串对象并创建一个软引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">SoftReference&lt;String&gt; softRef = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(str);</span><br><span class="line"></span><br><span class="line">str = <span class="literal">null</span>;	  <span class="comment">// 此时str只有软引用，当内存不足时，垃圾回收器会尽可能回收只被软引用指向的对象</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>弱引用：</p>
<p>一个对象只具有弱引用，说明是可有可无的，它的生命周期比软引用的对象更断。垃圾回收器如果发现只有弱引用的对象会直接进行回收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个字符串对象并创建一个弱引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">WeakReference&lt;String&gt; weakRef = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(str);</span><br><span class="line"></span><br><span class="line">str = <span class="literal">null</span>;	 <span class="comment">// 当对象只被弱引用所指向时，被垃圾回收器发现就会回收它</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>虚引用：</p>
<p>虚引用几乎不对对象的生命周期产生影响。与软引用和弱引用不同，虚引用并不会影响对象的可达性和垃圾回收时机。虚引用主要用于跟踪对象被垃圾回收活动。</p>
<p>虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p>
<p>（软引用和弱引用同样可以关联一个引用队列，来看对象是否被回收或在回收前采取行动）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个字符串对象并创建一个虚引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">ReferenceQueue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br><span class="line">PhantomReference&lt;String&gt; phantomRef = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;&gt;(str, queue);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当垃圾回收器回收被虚引用所指向的对象时，虚引用将被放入引用队列</span></span><br><span class="line">str = <span class="literal">null</span>;</span><br><span class="line">System.gc(); <span class="comment">// 手动触发垃圾回收器</span></span><br><span class="line">Reference&lt;? <span class="keyword">extends</span> <span class="title class_">String</span>&gt; ref = queue.poll();</span><br><span class="line"><span class="keyword">if</span> (ref != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 对象已被回收</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h4><ul>
<li><p><strong>标记-清除</strong> 算法</p>
<p>首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。</p>
<p>不足： 效率问题， 空间问题（会产生大量碎片空间）</p>
</li>
<li><p><strong>标记-复制</strong> 算法</p>
<p>标记-复制算法 可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</p>
<p>（只需遍历一半内存空间，不会产生碎片空间）</p>
</li>
<li><p><strong>标记-整理</strong> 算法</p>
<p>标记过程仍然与“标记-清除”算法一样，但后续步骤是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</p>
</li>
</ul>
<p>当前虚拟机的垃圾收集都采用<strong>分代收集算法</strong>，可以根据不同年代的特点选择合适的垃圾收集算法。</p>
<p>比如在<strong>新生代</strong>中，每次收集都会有大量对象死去，所以可以选择”<strong>标记-复制</strong>“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。</p>
<p>而<strong>老年代</strong>的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“<strong>标记-整理</strong>”算法进行垃圾收集。</p>
<h4 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h4><ul>
<li><p><strong>Serial收集器</strong></p>
<p>Serial（串行）收集器是一个单线程收集器。这意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，并且在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ <strong>“Stop The World”</strong> ），直到它收集结束。</p>
<p>Serial 收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。对于运行在 Client 模式下的虚拟机来说是个不错的选择。</p>
</li>
<li><p><strong>ParNew收集器</strong></p>
<p>是Serial收集器的多线程版本。（工作线程仍要暂停）</p>
<p>ParNew收集器是许多运行在 Server 模式下的虚拟机的首要选择，除了 Serial 收集器外，只有它能与 CMS 收集器（真正意义上的并发收集器）配合工作。</p>
</li>
<li><p><strong>Parallel Scavenge收集器</strong> （并行清理收集器）（JDK1.8默认收集器）</p>
<p>Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。</p>
<p>所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。 Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量。</p>
</li>
<li><p>Serial Old收集器 ：Serial收集器的老年代版本</p>
</li>
<li><p>Parallel Old收集器 ：Parallel Scavenge收集器的老年代版本。</p>
</li>
<li><p><strong>CMS收集器</strong></p>
<p><strong>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。</strong> </p>
<p>（ 是HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。）</p>
<p>采用“标记-清除”算法实现，运行过程分四步：</p>
<ol>
<li><strong>初始标记：</strong> 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；</li>
<li><strong>并发标记：</strong> 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但因为用户线程可能会不断的更新引用域，所以这个闭包结构并不能保证包含当前所有的可达对象。所以此算法在这阶段会跟踪记录这些发生引用更新的地方。</li>
<li><strong>重新标记：</strong> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，比并发标记阶段时间短很多。</li>
<li><strong>并发清除：</strong> 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。</li>
</ol>
<p>优点： 并发收集，低停顿</p>
<p>缺点：对CPU资源敏感；无法处理浮动垃圾；会产生碎片空间。</p>
</li>
<li><p><strong>G1收集器</strong></p>
<p>G1 (Garbage-First) 是一款面向服务器的垃圾收集器, 主要针对配备多颗处理器及大容量内存的机器。 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征。</p>
<p>特点：并行＋并发（利用多个CPU优势），空间整合（标记－整理算法），可预测停顿时间</p>
<p>步骤：初始标记——并发标记——最终标记——筛选回收</p>
<blockquote>
<p><strong>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)</strong> 。</p>
<p>这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）</p>
</blockquote>
</li>
</ul>
<h3 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h3><p>根据 Java 虚拟机规范，Class 文件通过 <code>ClassFile</code> 定义，有点类似 C 语言的结构体。</p>
<p>ClassFile 的结构如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4             		magic;	 <span class="comment">//Class 文件的标志(魔数)</span></span><br><span class="line">    u2             		minor_version;	<span class="comment">//Class 的小版本号</span></span><br><span class="line">    u2             		major_version;	<span class="comment">//Class 的大版本号</span></span><br><span class="line">    u2             		constant_pool_count;	<span class="comment">//常量池的数量</span></span><br><span class="line">    cp_info        	  constant_pool[constant_pool_count-<span class="number">1</span>];	<span class="comment">//常量池</span></span><br><span class="line">    u2             		access_flags;	<span class="comment">//Class 的访问标记</span></span><br><span class="line">    u2             		this_class;	<span class="comment">//当前类</span></span><br><span class="line">    u2             		super_class;	<span class="comment">//父类</span></span><br><span class="line">    u2             		interfaces_count;	<span class="comment">//接口</span></span><br><span class="line">    u2             		interfaces[interfaces_count];	<span class="comment">//一个类可以实现多个接口</span></span><br><span class="line">    u2             		fields_count;	<span class="comment">//Class 文件的字段属性</span></span><br><span class="line">    field_info 		  fields[fields_count];	<span class="comment">//一个类可以有多个字段</span></span><br><span class="line">    u2             		methods_count;	<span class="comment">//Class 文件的方法数量</span></span><br><span class="line">    method_info    methods[methods_count];	<span class="comment">//一个类可以有个多个方法</span></span><br><span class="line">    u2             		attributes_count;	<span class="comment">//此类的属性表中的属性数</span></span><br><span class="line">    attribute_info  attributes[attributes_count];	<span class="comment">//属性表集合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>魔数 Magic Number</p>
<p>每个 Class 文件的头 4 个字节称为魔数（Magic Number）,它的唯一作用是<strong>确定这个文件是否为一个能被虚拟机接收的 Class 文件</strong>。</p>
</li>
<li><p>Class文件版本号 Minor&amp;Major Version</p>
<p>紧接着魔数的四个字节存储的是 Class 文件的版本号：第 5 和第 6 位是<strong>次版本号</strong>，第 7 和第 8 位是<strong>主版本号</strong>。</p>
<p>当 Java 发布大版本（比如 Java 8，Java9）的时候，主版本号都会加 1。使用 <code>javap -v</code> 命令可以快速查看 Class 文件的版本号信息。</p>
<blockquote>
<p>高版本的 Java 虚拟机可以执行低版本编译器生成的 Class 文件，但是低版本的 Java 虚拟机不能执行高版本编译器生成的 Class 文件。</p>
</blockquote>
</li>
<li><p>常量池 Constant Pool</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             constant_pool_count;<span class="comment">//常量池的数量</span></span><br><span class="line">cp_info      constant_pool[constant_pool_count-<span class="number">1</span>];<span class="comment">//常量池</span></span><br></pre></td></tr></table></figure>

<p>注：常量池计数器是从 1 开始计数的，索引值为 0 代表“不引用任何一个常量池项”。</p>
<p>常量池存放两大常量： <strong>字面量</strong>和<strong>符号引用</strong>， </p>
<ul>
<li>字面量： 可以说是常量，如文本字符串，声明为final的常量值等。</li>
<li>符号引用：属于编译原理方面的概念，有三类：<ul>
<li>类和接口 的全限定名</li>
<li>字段 的名称和描述符</li>
<li>方法 的名称和描述符</li>
</ul>
</li>
</ul>
<blockquote>
<p><code>.class</code> 文件可以通过<code>javap -v class类名</code> 指令来看一下其常量池中的信息(<code>javap -v class类名-&gt; temp.txt</code> ：将结果输出到 temp.txt 文件)。</p>
</blockquote>
</li>
<li><p>访问标志 Access Flags</p>
<p>这个标志用于识别一些类或接口层次的访问信息，如：这个 Class 是类还是接口，是否为 public 或者 abstract 类型，如果是类的话是否声明为 final 等等。</p>
<blockquote>
<p>通过<code>javap -v class类名</code> 指令来看一下类的访问标志。</p>
</blockquote>
</li>
<li><p>当前类（This Class）、父类（Super Class）、接口（Interfaces）索引集合</p>
<p>Java 类的<code>继承关系</code>由类索引、父类索引和接口索引集合三项确定。</p>
<p>类索引确定这个类的全限定名，父类索引确定这个类的父类的全限定名，由于 Java 语言的单继承，所以父类索引只有一个，除了 <code>java.lang.Object</code> 之外，所有的 Java 类都有父类，因此除了 <code>java.lang.Object</code> 外，所有 Java 类的父类索引都不为 0。</p>
<p>接口索引集合用来描述这个类实现了那些接口。</p>
</li>
<li><p>字段表集合 Fields</p>
<p>用于描述 接口或类 中声明的变量。包括类的变量和实例变量，不包括方法内的局部变量。</p>
<p>field info（字段表）的结构：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">field_info &#123;</span><br><span class="line">    u2					access_flags;	<span class="comment">// 作用域</span></span><br><span class="line">    u2					name_index;		<span class="comment">// 字段名称(引用)</span></span><br><span class="line">    u2					descriptor_index;	<span class="comment">// 字段和方法的描述符(引用)</span></span><br><span class="line">    u2					attributes_count;	<span class="comment">// 属性个数</span></span><br><span class="line">    attribute_info	attributes[attributes_count];	<span class="comment">//属性集合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>access_flags:</strong> 字段的作用域（<code>public</code> ,<code>private</code>,<code>protected</code>修饰符），是实例变量还是类变量（<code>static</code>修饰符）,可否被序列化（transient 修饰符）,可变性（final）,可见性（volatile 修饰符，是否强制从主内存读写）。</li>
<li><strong>name_index:</strong> 对常量池的引用，表示的字段的名称；</li>
<li><strong>descriptor_index:</strong> 对常量池的引用，表示字段和方法的描述符；</li>
<li><strong>attributes_count:</strong> 一个字段还会拥有一些额外的属性，attributes_count 存放属性的个数；</li>
<li><strong>attributes[attributes_count]:</strong> 存放具体属性具体内容。</li>
</ul>
</li>
<li><p>方法集合 Methods</p>
<p>Class文件中对方法的描述和字段的描述几乎一致。</p>
</li>
<li><p>属性表集合 Attributes</p>
<p>在 Class 文件，字段表，方法表中都可以携带自己的属性表集合，以用于描述某些场景专有的信息。</p>
<p>Class 文件中不要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复即可。</p>
</li>
</ul>
<h3 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h3><p>从加载到虚拟机内存开始，到卸载出内存，类的生命周期为：</p>
<ul>
<li><strong>加载</strong></li>
<li>链接<ul>
<li><strong>验证</strong></li>
<li><strong>准备</strong></li>
<li><strong>解析</strong></li>
</ul>
</li>
<li><strong>初始化</strong></li>
<li>使用</li>
<li>卸载</li>
</ul>
<p>Class文件需要加载到虚拟机中才能运行和使用，系统加载Class文件的步骤： 加载——链接(验证, 准备, 解析)——初始化</p>
<hr>
<ul>
<li><p><strong>加载</strong> ：</p>
<p>主要完成3件事：</p>
<ol>
<li>通过全类名获取定义此类的二进制字节流</li>
<li>将字节流所代表的静态存储结构 转换为 方法区的运行时数据结构。</li>
<li>在内存中生成一个代表该类的Class对象，作为访问入口。</li>
</ol>
<p>这个过程是由类加载器完成的， 每个Java类都有一个引用指向自己的ClassLoader。  不过，数组类不是ClassLoader创建的，而是JVM在需要时自动创建，且数组通过 getClassLoader() 获取到的是数组内元素的类加载器</p>
</li>
<li><p>**验证： **</p>
<p>确保Class文件中的字节流信息符合《Java虚拟机规范》的全部要求。</p>
<p>验证阶段在整个类加载过程中耗费的资源较多，但从程序安全来讲是有必要的。（如果程序已经被反复使用或验证过，可以使用<code>-Xverify:none</code> 参数来关闭大部分的类验证措施，以缩短类加载时间）</p>
<p>主要由四个验证阶段组成：</p>
<ol>
<li>文件格式验证 —— Class文件格式检查</li>
<li>元数据验证 —— 字节码语义检查（是否有父类，是否继承了final修饰的类。。）</li>
<li>字节码验证 —— 程序语义检查（函数参数正确性，对象类型转换是否合理。。）</li>
<li>符号引用验证 —— 类的正确性检查（类中使用的其他类、方法、字段是否存在，访问权限是否正确）</li>
</ol>
<blockquote>
<p><code>第一步的文件格式是基于类的二进制字节流进行的， 保证输入的字节流能正确解析并存储到方法区。</code></p>
<p>其他三个阶段的验证都是在方法区的存储结构上进行的，不再读取、操作字节流。</p>
</blockquote>
</li>
<li><p><strong>准备：</strong></p>
<p>为类变量分配内存并设置初始值，这些内存都在方法区中分配。要注意的是：</p>
<ul>
<li><p>进行内存分配的仅有 类变量（static修饰的静态变量），不包括实例变量。（实例变量会随对象实例化一起分配到Java堆中）</p>
</li>
<li><p>理论上，类变量的内存都应该在方法区中分配。</p>
<p>JDK1.7之前，用永久代实现方法区时，确实是在方法区中分配类变量的内存的。</p>
<p>JDK1.7及之后，HotSpot把永久代中的字符串常量池，静态变量移到堆中，此时，类变量是随Class对象一起放在Java堆中的。</p>
</li>
</ul>
</li>
<li><p><strong>解析：</strong></p>
<p>虚拟机将 常量池中的符号引用替换为直接引用的过程。解析动作主要针对 类和接口、字段、类方法、接口方法、方法类型、方法句柄、调用限定符 这7种符号引用进行的。</p>
<blockquote>
<ul>
<li>符号引用： 用符号&#x2F;文字描述目标，是一种抽象的引用方式，只描述名字，不指明在内存中的具体位置。</li>
<li>直接引用：具体的引用方式，包含了目标在内存中的地址或偏移量等信息，可以直接访问具体内存或执行代码。</li>
</ul>
<p>所以，Java虚拟机在执行Java代码时，需要将符号引用解析为直接引用，才能真正地访问数据和执行代码。</p>
</blockquote>
</li>
<li><p><strong>初始化：</strong></p>
<p>此阶段执行初始化方法 &lt;clinit&gt;()，是类加载的最后一步，此时JVM开始真正执行类中定义的Java程序代码（字节码）。（&lt;clinit&gt;()是编译后自动生成的）</p>
<p>JVM严格规范了只有以下5种情况，才会进行初始化：</p>
<ol>
<li>遇到 new，getstatic，putstatic，invokestatic 这4条直接指令码时。</li>
</ol>
<ul>
<li>new指令： 创建一个类的实例对象。</li>
<li>getstatic指令：程序访问类的静态变量。（不是静态常量，常量是加载到运行时常量池）</li>
<li>putstatic指令：程序给类的静态变量赋值。</li>
<li>invokestatic指令：程序调用类的静态方法。</li>
</ul>
<ol start="2">
<li>使用 java.lang.reflect 包的方法对类进行反射调用，如Class.forname(“…”)，newInstance()等， 需要初始化。</li>
<li>初始化时，如果父类还未初始化，则先进行父类的初始化。</li>
<li>当虚拟机启动时，用户需要定义一个要执行的主类（要有main方法），虚拟机会先初始化这个类。</li>
<li>MethodHandle 和 VarHandle 可以看作是轻量级的反射调用机制，而要想使用这 2 个调用， 就必须先使用 findStaticVarHandle 来初始化要调用的类。</li>
</ol>
</li>
<li><p>类卸载：</p>
<p>满足以下3个要求，类才可被卸载：</p>
<ul>
<li>该类的所有实例对象都已被GC。</li>
<li>该类没有在其他地方被引用。</li>
<li>该类的类加载器的实例已被GC。</li>
</ul>
<p>注：在JVM的生命周期内，JVM自带的类加载器 BootstrapClassLoader, ExtClassLoader, AppClassLoader 负责加载 JDK 提供的类，这几个类加载器的实例是不会被回收的，所以它们加载的类是不会被卸载的。</p>
</li>
</ul>
<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>类加载器是一个负责加载类的对象，用于实现类加载过程中的”加载”。每个Java类都有一个引用指向加载它的ClassLoader。（数组类没有对应的二进制字节流，不是由ClassLoader创建的，而是由JVM直接生成）</p>
<ul>
<li>主要作用：加载Java类的字节码文件到JVM中（在内存中生成一个代表该类的Class对象）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Class</span>&lt;T&gt; &#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader classLoader;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@CallerSensitive</span></span><br><span class="line">    <span class="keyword">public</span> ClassLoader <span class="title function_">getClassLoader</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其实除了加载类之外，类加载器还可以加载 Java 应用所需的资源如文本、图像、配置文件、视频等等文件资源。</p>
</blockquote>
<ul>
<li><p>类加载器的加载规则</p>
<p>JVM启动的时候，并不会一次性加载所有类，而是按需加载。</p>
<p>对于已经加载的类会被放在 <code>ClassLoader</code> 中。在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。也就是说，对于一个类加载器来说，相同二进制名称的类只会被加载一次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 由这个类加载器加载的类。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Vector&lt;Class&lt;?&gt;&gt; classes = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 由VM调用，用此类加载器记录每个已加载类。</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addClass</span><span class="params">(Class&lt;?&gt; c)</span> &#123;</span><br><span class="line">        classes.addElement(c);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>JVM内置的三个重要的ClassLoader：</p>
<ul>
<li><p><strong><code>BootstrapClassLoader</code>(启动类加载器)</strong> ：</p>
<p>最顶层的加载类，由 C++实现，通常表示为 null，并且没有父级，主要用来加载 JDK 内部的核心类库 以及被 -Xbootclasspath参数指定的路径下的所有类。</p>
<blockquote>
<p>JDK内部的核心类库指 %JAVA_HOME%&#x2F;lib目录下的 rt.jar 、resources.jar 、charsets.jar等 jar 包和类。</p>
<p>rt.jar：是Java基础类库，包含java doc里看到的所有类的类文件，即常用的内置库都在里面，如java.util.*, java.io.*, java.lang.*, java.nio.*等。（rt指RunTime）</p>
</blockquote>
</li>
<li><p><strong><code>ExtensionClassLoader</code>(扩展类加载器)</strong> ：</p>
<p>主要负责加载 %JRE_HOME%&#x2F;lib&#x2F;ext 目录下的 jar 包和类以及被 java.ext.dirs 系统变量所指定的路径下的所有类。</p>
</li>
<li><p><strong><code>AppClassLoader</code>(应用程序类加载器)</strong> ：</p>
<p>面向用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。</p>
</li>
</ul>
</li>
<li><p>加载方式：</p>
<p>ClassLoader有两个关键方法：</p>
<ul>
<li><p><code>protected Class loadClass(String name, boolean resolve)</code>：</p>
<p>加载指定二进制名称的类，实现了双亲委派机制 。<code>name</code> 为类的二进制名称，resove 如果为 true，在加载时调用 resolveClass(Class&lt;?&gt; c) 方法解析该类。</p>
</li>
<li><p><code>protected Class findClass(String name)</code>：</p>
<p>根据类的二进制名称来查找类，默认实现是空方法。</p>
</li>
</ul>
<p>当我们自定义类加载器时，如果不想打破双亲委派模型，就只重写findClass()方法即可，使无法被父类加载器加载的类通过这个方法加载。 要打破双亲委派模型就要重写 loadClass()方法。</p>
<p>—— <strong>双亲委派模型</strong></p>
<p>ClassLoader类使用委托模型来搜索类和资源， ClassLoader实例在自己搜索类和资源前，会先将搜索任务委托给父类加载器，一直往上委托直到顶层启动类加载器。 然后从顶层开始往下，各加载器会返回自己能加载的类。</p>
<ul>
<li>大致逻辑：每当一个类加载器接收到加载请求时，它会先将请求转发给父类加载器。在父类加载器没有找到所请求的类的情况下，该类加载器才会尝试去加载。</li>
</ul>
<ul>
<li>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。</li>
</ul>
<ul>
<li><p>类加载器之间的父子关系一般不是以继承的关系来实现的，而是通常使用组合关系来复用父加载器的代码。（设计原则：组合优于继承）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="comment">// 组合</span></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br><span class="line">    </span><br><span class="line">      <span class="keyword">protected</span> <span class="title function_">ClassLoader</span><span class="params">(ClassLoader parent)</span> &#123;</span><br><span class="line">           <span class="built_in">this</span>(checkCreateClassLoader(), parent);</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>好处：可以避免类的重复加载（JVM根据类名，类加载器区分不同的类。相同的类文件如果被不同类加载器加载，产生的也是不同的类，会造成混乱。）</p>
</li>
</ul>
<p>双亲委派模型的执行流程（java.lang.ClassLoader的loadClass()方法）：</p>
<ol>
<li>在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载（每个父类加载器都会走一遍这个流程）。</li>
<li>类加载器在进行类加载的时候，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成（调用父加载器 <code>loadClass()</code>方法来加载类）。这样的话，所有的请求最终都会传送到顶层的启动类加载器 BootstrapClassLoader 中。</li>
<li>只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载（调用自己的 <code>findClass()</code> 方法来加载类）。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">//首先，检查该类是否已经加载过</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果 c 为 null，则说明该类没有被加载过</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//当父类的加载器不为空，则通过父类的loadClass来加载该类</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//当父类的加载器为空，则调用启动类加载器来加载该类</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">//非空父类的类加载器无法找到相应的类，则抛出异常</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//当父类加载器无法加载时，则调用findClass方法来加载该类</span></span><br><span class="line">                <span class="comment">//用户可通过覆写该方法，来自定义类加载器</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//用于统计类加载器相关的信息</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            <span class="comment">//对类进行link操作</span></span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="OOM"><a href="#OOM" class="headerlink" title="OOM"></a>OOM</h3><ul>
<li><p><strong>java堆内存溢出</strong></p>
<p>当出现java.lang.OutOfMemoryError:Java heap space异常时，就是堆内存溢出了。</p>
<p>问题描述</p>
<ul>
<li>设置的jvm内存太小，对象所需内存太大，创建对象时分配空间，就会抛出这个异常。</li>
<li>流量&#x2F;数据峰值，应用程序自身的处理存在一定的限额，比如一定数量的用户或一定数量的数据。而当用户数量或数据量突然激增并超过预期的阈值时，那么就会峰值停止前正常运行的操作将停止并触发java . lang.OutOfMemoryError:Java堆空间错误</li>
</ul>
<p>解决方法</p>
<ol>
<li>首先，如果代码没有什么问题的情况下，可以适当调整-Xms和-Xmx两个jvm参数，使用压力测试来调整这两个参数达到最优值。</li>
<li>其次，尽量避免大的对象的申请，像文件上传，大批量从数据库中获取，这是需要避免的，尽量分块或者分批处理，有助于系统的正常稳定的执行。</li>
<li>最后，尽量提高一次请求的执行速度，垃圾回收越早越好，否则，大量的并发来了的时候，再来新的请求就无法分配内存了，就容易造成系统的雪崩。</li>
</ol>
</li>
<li><p><strong>java堆内存泄漏</strong></p>
<p>问题描述</p>
<ul>
<li>Java中的内存泄漏是一些对象不再被应用程序使用但垃圾收集无法识别的情况。因此，这些未使用的对象仍然在Java堆空间中无限期地存在。不停的堆积最终会触发java . lang.OutOfMemoryError。</li>
</ul>
</li>
<li><p><strong>垃圾回收超时内存溢出</strong></p>
<p>问题描述</p>
<ul>
<li><p>当应用程序耗尽所有可用内存时，GC开销限制超过了错误，而GC多次未能清除它，这时便会引发java.lang.OutOfMemoryError。</p>
</li>
<li><p>当JVM花费大量的时间执行GC，而收效甚微，而一旦整个GC的过程超过限制便会触发错误(默认的jvm配置GC的时间超过98%，回收堆内存低于2%)<br>解决方法<br>要减少对象生命周期，尽量能快速的进行垃圾回收。</p>
</li>
</ul>
</li>
<li><p><strong>Metaspace内存溢出</strong></p>
<p>问题描述</p>
<ul>
<li>元空间的溢出，系统会抛出java.lang.OutOfMemoryError: Metaspace。出现这个异常的问题的原因是 系统的代码非常多，或引用的第三方包非常多，或者通过动态代码生成类加载等方法，导致元空间的内存占用很大。</li>
</ul>
<p>解决办法</p>
<p>默认情况下，元空间的大小仅受本地内存限制。但是为了整机的性能，尽量还是要对该项进行设置，以免造成整机的服务停机。</p>
<ol>
<li><p>优化参数配置，避免影响其他JVM进程</p>
<p>-XX:MetaspaceSize，初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。</p>
<p>-XX:MaxMetaspaceSize，最大空间，默认是没有限制的。<br>除了上面两个指定大小的选项以外，还有两个与 GC 相关的属性：</p>
<p>-XX:MinMetaspaceFreeRatio，在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集 。</p>
<p>-XX:MaxMetaspaceFreeRatio，在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集。</p>
</li>
<li><p>慎重引用第三方包 </p>
<p>对第三方包，一定要慎重选择，不需要的包就去掉。这样既有助于提高编译打包的速度，也有助于提高远程部署的速度。</p>
</li>
<li><p>关注动态生成类的框架</p>
<p>对于使用大量动态生成类的框架，要做好压力测试，验证动态生成的类是否超出内存的需求会抛出异常。</p>
</li>
</ol>
</li>
<li><p><strong>直接内存内存溢出</strong></p>
<p>问题描述</p>
<ul>
<li><p>在使用ByteBuffer中的allocateDirect()的时候会用到，很多javaNIO(像netty)的框架中被封装为其他的方法，出现该问题时会抛出java.lang.OutOfMemoryError: Direct buffer memory异常。</p>
<p>如果你在直接或间接使用了ByteBuffer中的allocateDirect方法的时候，而不做clear的时候就会出现类似的问题。</p>
</li>
</ul>
</li>
<li><p><strong>栈内存溢出</strong></p>
<p>问题描述</p>
<ul>
<li>当一个线程执行一个Java方法时，JVM将创建一个新的栈帧并且把它push到栈顶。此时新的栈帧就变成了当前栈帧，方法执行时，使用栈帧来存储参数、局部变量、中间指令以及其他数据。</li>
<li>当一个方法递归调用自己时，新的方法所产生的数据(也可以理解为新的栈帧)将会被push到栈顶，方法每次调用自己时，会拷贝一份当前方法的数据并push到栈中。因此，递归的每层调用都需要创建一个新的栈帧。这样的结果是，栈中越来越多的内存将随着递归调用而被消耗，如果递归调用自己一百万次，那么将会产生一百万个栈帧。这样就会造成栈的内存溢出。</li>
</ul>
<p>解决办法</p>
<ul>
<li>如果程序中确实有递归调用，出现栈溢出时，可以调高-Xss大小，就可以解决栈内存溢出的问题了。递归调用防止形成死循环，否则就会出现栈内存溢出。</li>
</ul>
</li>
<li><p><strong>创建本地线程内存溢出</strong></p>
<p>问题描述</p>
<ul>
<li>线程基本只占用heap以外的内存区域，也就是这个错误说明除了heap以外的区域，无法为线程分配一块内存区域了，这个要么是内存本身就不够，要么heap的空间设置得太大了，导致了剩余的内存已经不多了，而由于线程本身要占用内存，所以就不够用了。</li>
</ul>
<p>解决方法</p>
<ul>
<li>首先检查操作系统是否有线程数的限制，使用shell也无法创建线程，如果是这个问题就需要调整系统的最大可支持的文件数。</li>
<li>日常开发中尽量保证线程最大数的可控制的，不要随意使用线程池。不能无限制的增长下去。</li>
</ul>
</li>
<li><p><strong>超出交换区内存溢出</strong></p>
<p>问题描述</p>
<ul>
<li>在Java应用程序启动过程中，可以通过-Xmx和其他类似的启动参数限制指定的所需的内存。而当JVM所请求的总内存大于可用物理内存的情况下，操作系统开始将内容从内存转换为硬盘。</li>
<li>一般来说JVM会抛出Out of swap space错误，代表应用程序向JVM native heap请求分配内存失败并且native heap也即将耗尽时，错误消息中包含分配失败的大小（以字节为单位）和请求失败的原因。</li>
</ul>
<p>解决办法</p>
<ul>
<li>增加系统交换区的大小，我个人认为，如果使用了交换区，性能会大大降低，不建议采用这种方式，生产环境尽量避免最大内存超过系统的物理内存。</li>
<li>其次，去掉系统交换区，只使用系统的内存，保证应用的性能。</li>
</ul>
</li>
<li><p><strong>数组超限内存溢出</strong></p>
<p>问题描述</p>
<ul>
<li>有的时候会碰到这种内存溢出的描述Requested array size exceeds VM limit，一般来说java对应用程序所能分配数组最大大小是有限制的，只不过不同的平台限制有所不同，但通常在1到21亿个元素之间。当Requested array size exceeds VM limit错误出现时，意味着应用程序试图分配大于Java虚拟机可以支持的数组。JVM在为数组分配内存之前，会执行特定平台的检查：分配的数据结构是否在此平台是可寻址的。</li>
</ul>
<p>解决方法</p>
<ul>
<li>因此数组长度要在平台允许的长度范围之内。不过这个错误一般少见的，主要是由于Java数组的索引是int类型。 Java中的最大正整数为2 ^ 31 - 1 &#x3D; 2,147,483,647。 并且平台特定的限制可以非常接近这个数字，例如：我的环境上(64位macOS，运行Jdk1.8)可以初始化数组的长度高达2,147,483,645（Integer.MAX_VALUE-2）。若是在将数组的长度再增加1达到nteger.MAX_VALUE-1会出现的OutOfMemoryError。</li>
</ul>
</li>
<li><p><strong>系统杀死进程内存溢出</strong></p>
<p>问题概述</p>
<ul>
<li><p>在描述该问题之前，先熟悉一点操作系统的知识：操作系统是建立在进程的概念之上，这些进程在内核中作业，其中有一个非常特殊的进程，称为“内存杀手（Out of memory killer）”。当内核检测到系统内存不足时，OOM killer被激活，检查当前谁占用内存最多然后将该进程杀掉。</p>
<p>一般Out of memory:Kill process or sacrifice child错会在当可用虚拟虚拟内存(包括交换空间)消耗到让整个操作系统面临风险时，会被触发。在这种情况下，OOM Killer会选择“流氓进程”并杀死它。</p>
<p>虽然增加交换空间的方式可以缓解Java heap space异常，还是建议最好的方案就是升级系统内存，让java应用有足够的内存可用，就不会出现这种问题。</p>
</li>
</ul>
</li>
</ul>
<p>总结，在实际编码中要记得：</p>
<ol>
<li>第三方jar包要慎重引入，坚决去掉没有用的jar包，提高编译的速度和系统的占用内存。</li>
<li>对于大的对象或者大量的内存申请，要进行优化，大的对象要分片处理，提高处理性能，减少对象生命周期。</li>
<li>尽量固定线程的数量，保证线程占用内存可控，同时需要大量线程时，要优化好操作系统的最大可打开的连接数。</li>
<li>对于递归调用，也要控制好递归的层级，不要太高，超过栈的深度。</li>
<li>分配给栈的内存并不是越大越好，因为栈内存越大，线程多，留给堆的空间就不多了，容易抛出OOM。JVM的默认参数一般情况没有问题（包括递归）。</li>
</ol>
<h3 id="JVM调优"><a href="#JVM调优" class="headerlink" title="JVM调优"></a>JVM调优</h3><p>什么是调优：</p>
<ol>
<li>根据需求进行JVM规划和预调优；</li>
<li>优化 JVM运行环境（慢，卡顿）</li>
<li>解决 JVM运行过程中出现的各种问题（OOM）</li>
</ol>
<p>常用命令：</p>
<ul>
<li>jps</li>
<li>jinfo</li>
<li>jstat</li>
<li>jstack</li>
<li>jmap</li>
</ul>
<p>​	</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">ValcanoZz</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/02/25/%E7%9F%A5%E8%AF%86%E7%82%B9%E2%80%94Java/">http://example.com/2023/02/25/%E7%9F%A5%E8%AF%86%E7%82%B9%E2%80%94Java/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">ValcanoZz Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/Notes/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/">知识点</a></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/Notes/2023/03/05/%E7%9F%A5%E8%AF%86%E7%82%B9%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93/"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/Notes/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">知识点—数据库</div></div></a></div><div class="next-post pull-right"><a href="/Notes/2022/12/25/%E9%A1%B9%E7%9B%AE%E2%80%94RPC%E6%A1%86%E6%9E%B6/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/Notes/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">RPC框架</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/Notes/2023/03/05/%E7%9F%A5%E8%AF%86%E7%82%B9%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93/" title="知识点—数据库"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-05</div><div class="title">知识点—数据库</div></div></a></div><div><a href="/Notes/2023/03/15/%E7%9F%A5%E8%AF%86%E7%82%B9%E2%80%94%E6%A1%86%E6%9E%B6/" title="知识点—框架"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-15</div><div class="title">知识点—框架</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC81NjA4NS8zMjU0OA=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">1.</span> <span class="toc-text">基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">基础概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.</span> <span class="toc-text">语法、数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.3.</span> <span class="toc-text">面向对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%B1%BB"><span class="toc-number">1.4.</span> <span class="toc-text">常见类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Object"><span class="toc-number">1.4.1.</span> <span class="toc-text">Object</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String"><span class="toc-number">1.4.2.</span> <span class="toc-text">String</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">1.5.</span> <span class="toc-text">异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">1.6.</span> <span class="toc-text">泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-number">1.7.</span> <span class="toc-text">反射</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E6%93%8D%E4%BD%9C"><span class="toc-number">1.7.1.</span> <span class="toc-text">反射操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.7.2.</span> <span class="toc-text">常用方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.8.</span> <span class="toc-text">注解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%83%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.8.1.</span> <span class="toc-text">元注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%E5%B1%9E%E6%80%A7"><span class="toc-number">1.8.2.</span> <span class="toc-text">注解属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E9%A2%84%E7%BD%AE%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.8.3.</span> <span class="toc-text">Java预置注解</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SPI"><span class="toc-number">1.9.</span> <span class="toc-text">SPI</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E8%B7%B5"><span class="toc-number">1.9.1.</span> <span class="toc-text">实践</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E6%96%B9"><span class="toc-number">1.9.1.1.</span> <span class="toc-text">调用方</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9"><span class="toc-number">1.9.1.2.</span> <span class="toc-text">实现方</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">1.10.</span> <span class="toc-text">序列化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I-x2F-O"><span class="toc-number">1.11.</span> <span class="toc-text">I&#x2F;O</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E7%B3%96"><span class="toc-number">1.12.</span> <span class="toc-text">语法糖</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-number">2.</span> <span class="toc-text">集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.</span> <span class="toc-text">底层数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.2.</span> <span class="toc-text">排序接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%8F%E8%BF%B0%E4%B8%8E%E6%AF%94%E8%BE%83"><span class="toc-number">2.3.</span> <span class="toc-text">描述与比较</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91"><span class="toc-number">3.</span> <span class="toc-text">并发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B"><span class="toc-number">3.1.</span> <span class="toc-text">进程、线程、协程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">3.2.</span> <span class="toc-text">多线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E9%94%81%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="toc-number">3.3.</span> <span class="toc-text">Java锁的种类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">3.4.</span> <span class="toc-text">乐观锁和悲观锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%B1%BB"><span class="toc-number">3.5.</span> <span class="toc-text">常见线程安全类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Atomic%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="toc-number">3.5.1.</span> <span class="toc-text">Atomic原子类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Future%E7%B1%BB-TODO"><span class="toc-number">3.5.2.</span> <span class="toc-text">Future类 - TODO</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">3.6.</span> <span class="toc-text">volatile关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">3.7.</span> <span class="toc-text">锁的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#synchronized"><span class="toc-number">3.7.1.</span> <span class="toc-text">synchronized</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ReentrantLock"><span class="toc-number">3.7.2.</span> <span class="toc-text">ReentrantLock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ReentrantReadWriteLock"><span class="toc-number">3.7.3.</span> <span class="toc-text">ReentrantReadWriteLock</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLocal"><span class="toc-number">3.8.</span> <span class="toc-text">ThreadLocal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">3.9.</span> <span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ThreadPoolExecutor"><span class="toc-number">3.9.1.</span> <span class="toc-text">ThreadPoolExecutor</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Executors"><span class="toc-number">3.9.2.</span> <span class="toc-text">Executors</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS"><span class="toc-number">3.10.</span> <span class="toc-text">AQS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Semaphore"><span class="toc-number">3.10.1.</span> <span class="toc-text">Semaphore</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CountDownLatch"><span class="toc-number">3.10.2.</span> <span class="toc-text">CountDownLatch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CyclicBarrier"><span class="toc-number">3.10.3.</span> <span class="toc-text">CyclicBarrier</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM"><span class="toc-number">4.</span> <span class="toc-text">JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E8%AF%A6%E8%A7%A3"><span class="toc-number">4.1.</span> <span class="toc-text">Java内存区域详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%92%E5%88%86"><span class="toc-number">4.1.1.</span> <span class="toc-text">内存划分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%8C%BA%E5%9F%9F"><span class="toc-number">4.1.2.</span> <span class="toc-text">线程区域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86"><span class="toc-number">4.1.3.</span> <span class="toc-text">堆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="toc-number">4.1.4.</span> <span class="toc-text">方法区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98"><span class="toc-number">4.1.5.</span> <span class="toc-text">直接内存</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="toc-number">4.2.</span> <span class="toc-text">对象创建过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">4.3.</span> <span class="toc-text">垃圾回收机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E4%BA%A1%E5%AF%B9%E8%B1%A1%E5%88%A4%E6%96%AD"><span class="toc-number">4.3.1.</span> <span class="toc-text">死亡对象判断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.3.2.</span> <span class="toc-text">引用类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="toc-number">4.3.3.</span> <span class="toc-text">垃圾收集算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">4.3.4.</span> <span class="toc-text">垃圾收集器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">4.4.</span> <span class="toc-text">类文件结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">4.5.</span> <span class="toc-text">类的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">4.6.</span> <span class="toc-text">类加载器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OOM"><span class="toc-number">4.7.</span> <span class="toc-text">OOM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM%E8%B0%83%E4%BC%98"><span class="toc-number">4.8.</span> <span class="toc-text">JVM调优</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2024 By ValcanoZz</div><div class="footer_custom_text"><div><a onclick="window.open('https://beian.miit.gov.cn/#/Integrated/index')" >粤ICP备2022110986号-1</a></div></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/Notes/js/utils.js"></script><script src="/Notes/js/main.js"></script><script src="/Notes/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/Notes/js/search/local-search.js"></script><div class="js-pjax"><script>function loadLivere () {
  if (typeof LivereTower === 'object') {
    window.LivereTower.init()
  }
  else {
    (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
    })(document, 'script');
  }
}

if ('Livere' === 'Livere' || !false) {
  if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
  else loadLivere()
}
else {
  function loadOtherComment () {
    loadLivere()
  }
}</script></div><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>