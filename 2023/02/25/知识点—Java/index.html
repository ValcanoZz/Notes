<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>知识点—Java | ValcanoZz Blog</title><meta name="keywords" content="知识点"><meta name="author" content="ValcanoZz"><meta name="copyright" content="ValcanoZz"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Java知识点基础知识基础概念 JVM（Java Virtual Machine）： Java虚拟机是运行Java字节码的虚拟机，有针对不同系统的特定实现，目的是使用相同的字节码，都会给出相同的结果。（最常用HotSpot VM）  JDK （Java Development Kit）：Java开发组件  JRE （Java Runtime Environment）：Java运行时环境， 它是运行">
<meta property="og:type" content="article">
<meta property="og:title" content="知识点—Java">
<meta property="og:url" content="http://example.com/2023/02/25/%E7%9F%A5%E8%AF%86%E7%82%B9%E2%80%94Java/index.html">
<meta property="og:site_name" content="ValcanoZz Blog">
<meta property="og:description" content="Java知识点基础知识基础概念 JVM（Java Virtual Machine）： Java虚拟机是运行Java字节码的虚拟机，有针对不同系统的特定实现，目的是使用相同的字节码，都会给出相同的结果。（最常用HotSpot VM）  JDK （Java Development Kit）：Java开发组件  JRE （Java Runtime Environment）：Java运行时环境， 它是运行">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7">
<meta property="article:published_time" content="2023-02-25T12:34:28.000Z">
<meta property="article:modified_time" content="2023-05-29T12:05:38.987Z">
<meta property="article:author" content="ValcanoZz">
<meta property="article:tag" content="知识点">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"><link rel="shortcut icon" href="/Notes/./img/favicon7.png"><link rel="canonical" href="http://example.com/2023/02/25/%E7%9F%A5%E8%AF%86%E7%82%B9%E2%80%94Java/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/Notes/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/Notes/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '知识点—Java',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-05-29 20:05:38'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="./css/v_footer.css"><link rel="stylesheet" href="./css/v_blog.css"><link rel="stylesheet" href="./css/v_cursors.css"><link rel="stylesheet" href="./css/v_opacity.css"><link rel="stylesheet" href="./css/v_scrollbar.css"><meta name="generator" content="Hexo 6.1.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/Notes/./img/avatar1.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/Notes/archives/"><div class="headline">文章</div><div class="length-num">33</div></a></div><div class="data-item"><a href="/Notes/tags/"><div class="headline">标签</div><div class="length-num">16</div></a></div><div class="data-item"><a href="/Notes/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/Notes/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/Notes/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/Notes/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/Notes/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/Notes/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/Notes/about/"><i class="fa-fw fas fa- heart"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/Notes/">ValcanoZz Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/Notes/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/Notes/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/Notes/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/Notes/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/Notes/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/Notes/about/"><i class="fa-fw fas fa- heart"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">知识点—Java</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-02-25T12:34:28.000Z" title="发表于 2023-02-25 20:34:28">2023-02-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-05-29T12:05:38.987Z" title="更新于 2023-05-29 20:05:38">2023-05-29</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">26.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>87分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="知识点—Java"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Java知识点"><a href="#Java知识点" class="headerlink" title="Java知识点"></a>Java知识点</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><ul>
<li><p>JVM（Java Virtual Machine）： Java虚拟机是运行Java字节码的虚拟机，有针对不同系统的特定实现，目的是使用相同的字节码，都会给出相同的结果。（最常用HotSpot VM）</p>
</li>
<li><p>JDK （Java Development Kit）：Java开发组件</p>
</li>
<li><p>JRE （Java Runtime Environment）：Java运行时环境， 它是运行已编译Java程序程序所需的所有内容的集合，包括JVM，Java类库，Java命令和其他一些基础构建。但不能用于创建新程序。</p>
</li>
<li><p>字节码： 即JVM可以理解的代码（.class文件），由于字节码只面向虚拟机，因此Java程序无需重新编译即可在不同操作系统上运行。</p>
</li>
<li><p>Java程序运行流程：</p>
<p>.java文件(源代码)——经过javac编译——得到 .class文件(字节码)——经过 解释器&amp;JIT(即时编译器) 解释&#x2F;编译 —— 得到机器可理解的代码</p>
<blockquote>
<p>在字节码到机器码这一步，JVM类加载器首先加载字节码文件，然后使用解释器逐行解释。 而对于一些热点代码，会使用JIT即时编译器，将字节码对应的机器码保存下来，提高运行效率。</p>
<p>JDK9引入了新编译模式：AOT（Ahead Of Time）运行前编译。</p>
<ul>
<li>JIT优点：<ul>
<li>可以根据当前程序的运行情况生成最优的机器指令序列；</li>
<li>当程序需要<strong>动态链接</strong>时只能用JIT；</li>
<li>可以根据内存情况调整代码，更充分利用内存。</li>
</ul>
</li>
<li>JIT缺点：<ul>
<li>编译需要占用运行时资源；</li>
<li>需要花时间准备编译和识别热点代码，所以初始编译不能达到最高性能。</li>
</ul>
</li>
<li>AOT优点：<ul>
<li>在程序运行前编译，避免运行时性能和内存消耗；</li>
<li>在程序运行初期达到最高性能；</li>
<li>显著加快程序启动。</li>
</ul>
</li>
<li>AOT缺点：<ul>
<li>在程序运行前编译会增加程序安装的时间；</li>
<li>牺牲Java的一致性；</li>
<li>将提前编译的内容保存会占用更多的外存</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li><p>Java语言是编译与解释并存的： 源代码先经过javac编译形成字节码，在交由Java解释器执行。</p>
</li>
</ul>
<h3 id="语法、数据类型"><a href="#语法、数据类型" class="headerlink" title="语法、数据类型"></a>语法、数据类型</h3><ul>
<li><p><strong>成员变量和局部变量的区别</strong>：</p>
<ul>
<li><p>语法形式 ：<br>从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；<br>成员变量可以被 <code>public</code>,<code>private</code>,<code>static</code> 等修饰符所修饰，而局部变量不能被访问控制修饰符及 <code>static</code> 所修饰；<br>但是，成员变量和局部变量都能被 <code>final</code> 所修饰。</p>
</li>
<li><p>存储方式 ：</p>
<p>​	从变量在内存中的存储方式来看,如果成员变量是使用 <code>static</code> 修饰的，那么这个成员变量是属于类的，如果没有使用 <code>static</code> 修饰，这个成员变量是属于实例的。<br>​	对象都存在于堆内存，局部变量则存在于栈内存。</p>
</li>
<li><p>生存时间 ：</p>
<p>​	从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。</p>
</li>
<li><p>默认值 ：</p>
<p>​	成员变量没初始化，会自动赋默认值（例外:被 <code>final</code> 修饰的成员变量必须显式地赋值），而局部变量则不会自动赋值。</p>
</li>
</ul>
</li>
<li><p>静态变量：</p>
<p>​	静态变量被类的所有实例共享。<br>​	通常情况下，静态变量会被 <code>final</code> 关键字修饰成为常量。</p>
</li>
<li><p><strong>静态方法不能调用非静态成员</strong>：</p>
<p>​	静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。<br>​	而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。</p>
<p>​	也就是说：调用静态成员时，非静态成员可能还没创建。</p>
</li>
<li><p>重载：</p>
<p>​	方法名一样，参数、返回值、修饰符可以不一样。</p>
</li>
<li><p>重写：</p>
<p>​	重写父类的方法，方法名和参数列表必须一样，返回值类型小于等于父类的，抛出异常小于等于父类的，访问修饰符大于等于父类的。</p>
<p>​	父类方法修饰符为 <code>private/final/static</code> 则子类就不能重写该方法。</p>
<p>​	构造方法不能被重写。</p>
</li>
<li><p>基本类型：</p>
<p>​	基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，成员变量（未被 <code>static</code> 修饰 ）存放在 Java 虚拟机的堆中。</p>
</li>
<li><p>包装类型的缓存机制：</p>
<p>​	<code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，</p>
<p>​	<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，</p>
<p>​	<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。</p>
<blockquote>
<p>如果用new创建新对象, 不能用”&#x3D;&#x3D;”来比较值，对象间用”=&#x3D;”比较的是地址。 </p>
<p>所以，所有包装对象之间的值的比较，应该全部都用equals方法。</p>
</blockquote>
</li>
<li><p>自动装箱：调用包装类的valueOf()</p>
<p>自动拆箱：调用包装类的xxxValue()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自动装箱，等价于 Integer i = Integer.valueOf(10)</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;		</span><br><span class="line"></span><br><span class="line"><span class="comment">//自动拆箱，等价于 int n = i.intValue()</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i;		</span><br></pre></td></tr></table></figure>

<p>频繁装拆箱会影响性能，应尽量避免不必要的装拆箱。</p>
</li>
<li><p>解决浮点数精度丢失：</p>
<p>​	一些小数转化为二进制会无限循环，只能截断，如0.2。</p>
<p>若对精度有要求，应使用<code>BigDecimal</code> 可以实现对浮点数的运算</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1.0f</span> - <span class="number">0.9f</span>;		<span class="comment">// 0.100000024 </span></span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0.9f</span> - <span class="number">0.8f</span>;		<span class="comment">// 0.099999964</span></span><br><span class="line"></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.9&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.8&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">x</span> <span class="operator">=</span> a.subtract(b);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">y</span> <span class="operator">=</span> b.subtract(c);</span><br><span class="line"></span><br><span class="line">System.out.println(x); <span class="comment">/* 0.1 */</span></span><br><span class="line">System.out.println(y); <span class="comment">/* 0.1 */</span></span><br><span class="line">System.out.println(Objects.equals(x, y)); <span class="comment">/* true */</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>超过long整型的数据表示： </p>
<p>使用BigInteger，其内部使用int[]数组来存储任意大小的整型数据。(不过运算效率稍低)</p>
</li>
</ul>
<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><ul>
<li><p>面向过程：把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。</p>
</li>
<li><p>面向对象：会先抽象出对象，然后用对象执行方法的方式解决问题。</p>
<p>面向对象开发的程序一般更易维护、易复用、易扩展。</p>
</li>
<li><p>性能：</p>
<p>​	面向过程性能比面向对象高。 因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux&#x2F;Unix等一般采用面向过程开发。</p>
<p>​	不过面向过程也需要分配内存，计算内存偏移量。</p>
<p>​	Java性能差的主要原因并不是因为它是面向对象语言，而是<strong>Java是半编译语言</strong>，最终的执行代码并不是可以直接被CPU执行的二进制机械码。而面向过程语言大多都是直接编译成机械码在电脑上执行，并且其它一些面向过程的脚本语言性能也并不一定比Java好。</p>
</li>
<li><p>面向对象三大特征：</p>
<ul>
<li><p><strong>封装</strong>：封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。</p>
</li>
<li><p><strong>继承</strong>：不同类型的对象，相互之间经常有一定数量的共同点。继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。</p>
<blockquote>
<p>父类的私有属性和方法子类无法访问。</p>
</blockquote>
</li>
<li><p><strong>多态：</strong> 对象类型和引用类型之间具有继承关系。调用的具体是哪个类的方法只能在运行期间确定。多态不能调用父类不存在的方法。</p>
</li>
</ul>
</li>
<li><p>接口和抽象类：</p>
<p>共同点：</p>
<ul>
<li>不能被实例化。</li>
<li>可以包含抽象方法。</li>
<li>可以有默认实现的方法。（java8可用default在接口中定义默认方法）</li>
</ul>
<p>区别：</p>
<ul>
<li>接口主要用于约束类的行为，实现接口意味着具有相应的行为；抽象类主要用于代码复用，强调所属、继承关系。</li>
<li>类只能单继承，接口可以多继承。</li>
<li>接口中的成员变量只能是public，static，final，不能被修改且要有初始值。</li>
</ul>
</li>
<li><p>对象相等：指内存中 存放的内容 是否相等。</p>
<p>引用相等：指向的 内存地址 是否相等。</p>
</li>
<li><p>浅拷贝：在堆上创建新的对象，而内部中的引用类型属性，只复制引用地址。</p>
<p>深拷贝：完全复制整个对象，包括内部对象。</p>
<blockquote>
<p>被拷贝类要实现Cloneable接口，重写clone方法。</p>
<p>实现 Serializable 接口方式也可以实现深拷贝，还可以解决多层克隆问题（引用类型里又有引用类型）</p>
</blockquote>
</li>
</ul>
<h3 id="常见类"><a href="#常见类" class="headerlink" title="常见类"></a>常见类</h3><h4 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h4><p>Object是所有类的父类。提供了11个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * naitive 方法，用于创建并返回当前对象的一份拷贝。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回类的名字实例的哈希码的 16 进制的字符串。通常建议 Object 所有的子类都重写这个方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多了 nanos 参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 毫秒。。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实例被垃圾回收器回收的时候触发的操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>&#x3D;&#x3D;和equals()：</p>
<p>Java只有值传递，基本类型传递的值，引用类型传递的是内存地址。</p>
<ul>
<li><p>使用&#x3D;&#x3D;是直接比较两者的值&#x2F;地址。</p>
</li>
<li><p>equals()没有重写时，直接return (this &#x3D;&#x3D; obj)；跟&#x3D;&#x3D;一样。一般重写为比较对象的属性是否相等。</p>
</li>
</ul>
</li>
<li><p>hashCode()：</p>
<p>获取哈希码(int)，通常是将对象的内存地址转换为整数。 hashCode()一般和equals()配合用于比价两个对象，大幅提高比较效率（如HashMap，如果hashCode()的值相等，再调用equals()）。</p>
<p>由于有哈希冲突，所以两个对象的hashCode()值可能相等。</p>
</li>
</ul>
<h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><ul>
<li><p>可变性：</p>
<ul>
<li><p>String不可变： 因为String被final修饰，不能被继承，里面的字符数组也被final修饰且为私有，且String没有提供修改字符数组的方法。</p>
<blockquote>
<p>java9的String的底层实现由char[]改为byte[]。</p>
<p>因为新String支持两个编码方案：Latin-1和UTF-16。</p>
<p>如果串中的汉字都在Latin-1范围内，则可用Latin-1方案：byte占1字节，char占2字节。 </p>
<p>而UTF-16方案：byte和char都占2字节。</p>
</blockquote>
</li>
<li><p>StringBuilder 与 StringBuffer可变： 它们都继承自 <code>AbstractStringBuilder</code> 类，在 AbstractStringBuilder中也是使用字符数组保存字符串，不过没有使用 <code>final</code> 和 <code>private</code> 关键字修饰，最关键的是这个 <code>AbstractStringBuilder</code> 类还提供了很多修改字符串的方法比如 <code>append</code> 方法。</p>
</li>
</ul>
</li>
<li><p>线程安全：</p>
<ul>
<li>String不可变，可看作常量，是线程安全的。</li>
<li>StringBuilder对方法加了同步锁，是线程安全的。</li>
<li>StringBuffer没加锁，是非线程安全的。</li>
</ul>
</li>
<li><p>性能：</p>
<ul>
<li>改变String时需要新建String对象，再将指针指向性对象。性能差。</li>
<li>StringBuilder的性能比Stringffer稍差一点点，但都比String好很多。</li>
</ul>
</li>
<li><p>字符串拼接：</p>
<p>+和+&#x3D;专门为Stirng重载过，是Java中仅有的两个重载过的运算符。</p>
<p>Stirng使用+进行拼接时，会新建一个StringBuilder对象进行拼接，最后在toStirng()返回String对象。</p>
<blockquote>
<p>注：在循环中，编译器不会创建单个StringBuilder对象，而是每一次循环都创建一次StringBuilder对象。</p>
<p>建议在循环外新建StringBuilder对象（IDEA的代码检查也会提示）。</p>
</blockquote>
</li>
<li><p>字符常量池：</p>
<p>String创建的字符串会保存在字符串常量池中，避免字符串的重复创建。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在堆中新建对象&quot;ab&quot;，并将&quot;ab&quot;的引用保存在字符串常量池</span></span><br><span class="line"><span class="type">String</span> <span class="variable">aa</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="comment">// 直接返回字符串常量池中 字符串对象”ab“的引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">bb</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="comment">// 新建String对象，一开始未初始化，</span></span><br><span class="line"><span class="comment">// 如果常量池中&quot;ab&quot;不存在，则会在堆中新建对象&quot;ab&quot;并保存到常量池，最后String对象调用构造方法进行赋值。</span></span><br><span class="line"><span class="comment">// 如果常量池中&quot;ab&quot;存在, 则直接调用构造方法赋值。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>对于编译截断能确定值的字符串，jvm会字节放入字符串常量池，包括字符串常量拼接得到的字符串常量。</p>
<p>这种叫常量折叠，基本数据类型及其算数运算和位运算、字符串常量都会进行常量折叠。（引用的值在编译器无法确定，不能进行优化）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;ing&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span> + <span class="string">&quot;ing&quot;</span>; <span class="comment">// 优化成 String str3 = &quot;string&quot;;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> str1 + str2;</span><br><span class="line"><span class="type">String</span> <span class="variable">str5</span> <span class="operator">=</span> <span class="string">&quot;string&quot;</span>;</span><br><span class="line">System.out.println(str3 == str4);	<span class="comment">//false</span></span><br><span class="line">System.out.println(str3 == str5);	<span class="comment">//true</span></span><br><span class="line">System.out.println(str4 == str5);	<span class="comment">//false</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><ul>
<li><p>层次：</p>
<p>Throwable</p>
<ul>
<li>Exception<ul>
<li>Checked Exception： …</li>
<li>Unchecked Exception：…</li>
</ul>
</li>
<li>Error：…</li>
</ul>
</li>
<li><p><strong><code>Exception</code></strong> :<strong>程序本身可以处理的异常</strong>，可以通过 <code>catch</code> 来进行捕获。Exception 又可以分为 <strong>Checked Exception (受检查异常，必须处理)</strong> 和 **Unchecked Exception (不受检查异常，可以不处理)**。</p>
<ul>
<li>除了<code>RuntimeException</code>及其子类以外，其他的Exception类及其子类都属于受检查异常 。常见的受检查异常有： IO 相关的异常、ClassNotFoundException 、SQLException…</li>
<li><code>RuntimeException</code> 及其子类都统称为非受检查异常，常见的有（建议记下来）：<ul>
<li><code>NullPointerException</code>(空指针错误)</li>
<li><code>IllegalArgumentException</code>(参数错误比如方法入参类型错误)</li>
<li><code>NumberFormatException</code>（字符串转换为数字格式错误，是<code>IllegalArgumentException</code>的子类）</li>
<li><code>ArrayIndexOutOfBoundsException</code>（数组越界错误）</li>
<li><code>ClassCastException</code>（类型转换错误）</li>
<li><code>ArithmeticException</code>（算术错误）</li>
<li><code>SecurityException</code> （安全错误比如权限不够）</li>
<li><code>UnsupportedOperationException</code>(不支持的操作错误比如重复创建同一用户)</li>
</ul>
</li>
</ul>
</li>
<li><p><strong><code>Error</code></strong> ：Error 属于<strong>程序无法处理的错误</strong> ，不建议通过catch捕获 。例如 Java 虚拟机运行错误（Virtual MachineError）、虚拟机内存不够错误(OutOfMemoryError)、类定义错误（NoClassDefFoundError）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</p>
</li>
<li><p>常用方法：</p>
<ul>
<li><p>String getMessage(): 返回异常发生时的简要描述</p>
</li>
<li><p>String toString(): 返回异常发生时的详细信息</p>
</li>
<li><p>String getLocalizedMessage(): 返回异常对象的本地化信息。使用 Throwable 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 getMessage()返回的结果相同</p>
</li>
<li><p>void printStackTrace(): 在控制台上打印 Throwable 对象封装的异常信息</p>
</li>
</ul>
</li>
<li><p>异常使用注意事项：</p>
<ul>
<li>不要把异常定义为静态变量，因为这样会导致异常栈信息错乱。每次手动抛出异常，我们都需要手动 new 一个异常对象抛出。</li>
<li>建议抛出更加具体的异常，比如字符串转换为数字格式错误的时候应该抛出NumberFormatException而不是其父类IllegalArgumentException。</li>
<li>使用日志打印异常之后就不要再抛出异常了</li>
</ul>
</li>
</ul>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>泛型提供了编译时的 <strong>类型安全检测</strong>机制，泛型的本质是<strong>参数化类型</strong>，也就是说所操作的数据类型被指定为一个参数。</p>
<p>使用方式，一般有三种：泛型类，泛型接口，泛型方法。</p>
<ul>
<li><p>泛型类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span></span><br><span class="line"><span class="comment">//在实例化泛型类时，必须指定T的具体类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Generic</span>&lt;T&gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Generic</span><span class="params">(T key)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getKey</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实例化泛型类，必须指定类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Generic&lt;Integer&gt; genericInteger = <span class="keyword">new</span> <span class="title class_">Generic</span>&lt;Integer&gt;(<span class="number">123456</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>泛型接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Generator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现泛型接口，可以指定也可以不指定类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不指定类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GeneratorImpl</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Generator</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GeneratorImpl</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Generator</span>&lt;String&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>泛型方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">(E[] inputArray)</span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (E element : inputArray)&#123;</span><br><span class="line">         System.out.printf(<span class="string">&quot;%s &quot;</span>, element);</span><br><span class="line">      &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建不同类型数组：Integer, Double 和 Character</span></span><br><span class="line">Integer[] intArray = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">String[] stringArray = &#123;<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span> &#125;;</span><br><span class="line">printArray(intArray);</span><br><span class="line">printArray(stringArray);</span><br></pre></td></tr></table></figure>

<p>由于以上是静态方法，先于实例对象加载，而类在实例化时才能使用传递类型参数，所以<strong>静态方法无法使用类上声明的泛型参数，只能使用自己声明的 &lt;E&gt;;</strong></p>
</li>
</ul>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>通过反射，可以操作字节码文件，可以获取任意一个类的所有属性和方法，并调用。</p>
<ul>
<li><p>反射赋予了我们在运行时分析类以及执行类中方法的能力。</p>
</li>
<li><p>反射相关的类在 java.lang.reflect.* 下。</p>
</li>
</ul>
<p>反射相关的类：</p>
<table>
<thead>
<tr>
<th>类</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>java.lang.Class</td>
<td>代表整个字节码，即一个类型，整个类</td>
</tr>
<tr>
<td>java.lang.reflect.Method</td>
<td>代表字节码中的方法字节码，即类中的方法</td>
</tr>
<tr>
<td>java.lang.reflect.Constructor</td>
<td>代表字节码中的构造字节码，即类中的构造方法</td>
</tr>
<tr>
<td>java.lang.reflect.Field</td>
<td>代表字节码中的属性字节码，即类中的成员变量（静态变量 + 实例变量）</td>
</tr>
</tbody></table>
<ul>
<li><p>必须先获取Class才能获取Method、Constructor、Field</p>
<blockquote>
<p>属性Field重要的是<strong>名字</strong></p>
<p>实例方法Method重要的是<strong>名字</strong>和<strong>形参列表</strong></p>
<p>构造方法Constructor重要的是<strong>形参列表</strong></p>
</blockquote>
</li>
</ul>
<h4 id="反射操作"><a href="#反射操作" class="headerlink" title="反射操作"></a>反射操作</h4><ul>
<li><p>获取Class的方法，三种（返回值都是Class类型）：</p>
<ul>
<li>Class.forName(“完整类名带包名”) —— 是静态方法</li>
<li>对象.getClass()</li>
<li>任何类型.class</li>
</ul>
</li>
<li><p>通过反射实例化对象： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class对象.newInstance()</span><br><span class="line"><span class="comment">// newInstance()实际调用的是无参构造方法, 如果没有无参构造方法, 会抛 java.lang.InstantiationException异常</span></span><br></pre></td></tr></table></figure>

<p>例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReflectTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        <span class="comment">// 通过反射机制，获取Class，通过Class来实例化对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.reflectBean.User&quot;</span>);</span><br><span class="line">        <span class="comment">// newInstance() 这个方法会调用User这个类的无参数构造方法，完成对象的创建。</span></span><br><span class="line">        <span class="comment">// 重点是：newInstance()调用的是无参构造，必须保证无参构造是存在的！</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> c.newInstance();</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过反射，反编译获得一个类的属性Field：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReflectTest06</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">studentClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.util.ArrayList&quot;</span>);</span><br><span class="line">        s.append(Modifier.toString(studentClass.getModifiers()) + <span class="string">&quot; class &quot;</span> + studentClass.getSimpleName() + <span class="string">&quot; &#123;\n&quot;</span>);<span class="comment">// Class类的getName方法</span></span><br><span class="line">        <span class="comment">//获取所有的属性</span></span><br><span class="line">        Field[] fields = studentClass.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field f : fields)&#123;</span><br><span class="line">            s.append(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            <span class="comment">// 获取属性的修饰符列表,返回的修饰符是一个数字，每个数字是修饰符的代号</span></span><br><span class="line">            <span class="comment">// 用Modifier类的toString转换成字符串</span></span><br><span class="line">            s.append(Modifier.toString(f.getModifiers()));</span><br><span class="line">            <span class="keyword">if</span> (f.getModifiers() != <span class="number">0</span>) s.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            s.append(f.getType().getSimpleName());<span class="comment">// 获取属性的类型</span></span><br><span class="line">            s.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            s.append(f.getName());<span class="comment">// 获取属性的名字</span></span><br><span class="line">            s.append(<span class="string">&quot;;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        s.append(<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行得到结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayList &#123;</span><br><span class="line">	private static final long serialVersionUID;</span><br><span class="line">	private static final int DEFAULT_CAPACITY;</span><br><span class="line">	private static final Object[] EMPTY_ELEMENTDATA;</span><br><span class="line">	private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">	transient Object[] elementData;</span><br><span class="line">	private int size;</span><br><span class="line">	private static final int MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过反射访问java对象的属性，并赋值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   注意：反射机制让代码复杂了，但是为了一个“灵活”，这也是值得的。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReflectTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchFieldException &#123;</span><br><span class="line">        <span class="comment">//使用反射机制给属性赋值</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">studentClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;javase.reflectBean.Student&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> studentClass.newInstance();<span class="comment">// obj就是Student对象。（底层调用无参数构造方法）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取no属性（根据属性的名称来获取Field）</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">noField</span> <span class="operator">=</span> studentClass.getDeclaredField(<span class="string">&quot;no&quot;</span>);</span><br><span class="line">        <span class="comment">// 给obj对象(Student对象)的no属性赋值</span></span><br><span class="line">        noField.set(obj, <span class="number">22222</span>);</span><br><span class="line">        <span class="comment">// 读取属性的值</span></span><br><span class="line">        System.out.println(noField.get(obj));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// set()默认不可以为私有属性赋值, 需要打破封装才行: setAccessible(true)</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">nameField</span> <span class="operator">=</span> studentClass.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="comment">// 打破封装（反射机制的缺点：打破封装，可能会给不法分子留下机会！！！）</span></span><br><span class="line">nameField.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 给name属性赋值并访问</span></span><br><span class="line">nameField.set(obj, <span class="string">&quot;xiaowu&quot;</span>);</span><br><span class="line">System.out.println(nameField.get(obj));</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过反射调用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReflectTest10</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 不使用反射机制时，调用方法的过程: </span></span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserService</span>();</span><br><span class="line">        <span class="comment">// 调用方法</span></span><br><span class="line">        System.out.println(userService.login(<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;123&quot;</span>) ? <span class="string">&quot;登入成功！&quot;</span> : <span class="string">&quot;登入失败！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用反射机制调用方法: </span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">userServiceClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;javase.reflectBean.UserService&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> userServiceClass.newInstance();</span><br><span class="line">        <span class="comment">// 获取Method</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">loginMethod</span> <span class="operator">=</span> userServiceClass.getDeclaredMethod(<span class="string">&quot;login&quot;</span>, String.class, String.class);</span><br><span class="line"><span class="comment">//        Method loginMethod = userServiceClass.getDeclaredMethod(&quot;login&quot;);//注：没有形参就不传</span></span><br><span class="line">        <span class="comment">// 调用方法</span></span><br><span class="line">        <span class="comment">// 调用方法有几个要素？ 也需要4要素。</span></span><br><span class="line">        <span class="comment">// 反射机制中最最最最最重要的一个方法，必须记住。</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            四要素：</span></span><br><span class="line"><span class="comment">            方法对象: loginMethod</span></span><br><span class="line"><span class="comment">            实例对象: obj</span></span><br><span class="line"><span class="comment">            实参: &quot;admin&quot;, &quot;123&quot;</span></span><br><span class="line"><span class="comment">            返回值: resValues</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">resValues</span> <span class="operator">=</span> loginMethod.invoke(obj, <span class="string">&quot;admin&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">        System.out.println(resValues);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过反射获取构造方法，再调用构造方法实例化对象：</p>
<ol>
<li>获取构造方法：Class对象的getDeclaredConstructor()方法</li>
<li>调用构造方法new对象：Constructor对象的newInstance()方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReflectTest12</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//使用反射机制创建对象（以前）</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">vipClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;javase.reflectBean.Vip&quot;</span>);</span><br><span class="line">        <span class="comment">// 调用无参数构造方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj1</span> <span class="operator">=</span> vipClass.newInstance();<span class="comment">//Class类的newInstance方法</span></span><br><span class="line">        System.out.println(obj1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用反射机制创建对象（现在）</span></span><br><span class="line">        <span class="comment">// 调用有参数的构造方法: </span></span><br><span class="line">        <span class="comment">// 1. 先获取到这个有参数的构造方法</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">c1</span> <span class="operator">=</span> vipClass.getDeclaredConstructor(<span class="type">int</span>.class, String.class, String.class, <span class="type">boolean</span>.class);</span><br><span class="line">        <span class="comment">// 2. 调用构造方法new对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj2</span> <span class="operator">=</span> c1.newInstance(<span class="number">321</span>, <span class="string">&quot;lsi&quot;</span>, <span class="string">&quot;1999-10-11&quot;</span>, <span class="literal">true</span>);<span class="comment">//Constructor类的newInstance方法</span></span><br><span class="line">        System.out.println(obj2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取无参数构造方法</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">c2</span> <span class="operator">=</span> vipClass.getDeclaredConstructor();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj3</span> <span class="operator">=</span> c2.newInstance();</span><br><span class="line">        System.out.println(obj3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取一个类的的父类和实现的接口：</p>
<ul>
<li><strong>getSuperclass</strong>()</li>
<li><strong>getInterfaces</strong>()</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReflectTest13</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">// String举例</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">vipClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取String的父类</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">superclass</span> <span class="operator">=</span> vipClass.getSuperclass();</span><br><span class="line">        <span class="comment">// 获取String类实现的所有接口（一个类可以实现多个接口。）</span></span><br><span class="line">        Class[] interfaces = vipClass.getInterfaces();</span><br><span class="line">        System.out.println(superclass.getName());</span><br><span class="line">        <span class="keyword">for</span> (Class i : interfaces) &#123;</span><br><span class="line">            System.out.println(i.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><ul>
<li><p>Class类方法：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>public T <strong>newInstance</strong>()</td>
<td>创建对象</td>
</tr>
<tr>
<td>public String <strong>getName</strong>()</td>
<td>返回完整类名带包名</td>
</tr>
<tr>
<td>public String <strong>getSimpleName</strong>()</td>
<td>返回类名</td>
</tr>
<tr>
<td>public Field[] <strong>getFields</strong>()</td>
<td>返回类中public修饰的属性</td>
</tr>
<tr>
<td>public Field[] <strong>getDeclaredFields</strong>()</td>
<td>返回类中所有的属性</td>
</tr>
<tr>
<td>public Field <strong>getDeclaredField</strong>(String name)</td>
<td>根据属性名name获取指定的属性</td>
</tr>
<tr>
<td>public Method[] <strong>getDeclaredMethods</strong>()</td>
<td>返回类中所有的实例方法</td>
</tr>
<tr>
<td>public Method <strong>getDeclaredMethod</strong>(String name, Class&lt;?&gt;… parameterTypes)</td>
<td>根据方法名name和方法形参获取指定方法</td>
</tr>
<tr>
<td>public Constructor <strong>getDeclaredConstructor</strong>(Class&lt;?&gt;… parameterTypes)</td>
<td>根据方法形参获取指定的构造方法</td>
</tr>
<tr>
<td>public native int <strong>getModifiers</strong>()</td>
<td>获取属性的修饰符列表,返回的修饰符是一个数字【一般配合Modifier类的toString(int x)方法使用】</td>
</tr>
<tr>
<td>public Annotation[] <strong>getAnnotations</strong>() {}</td>
<td>获取元素上所有注解</td>
</tr>
<tr>
<td>….</td>
<td>….</td>
</tr>
<tr>
<td>public native Class&lt;? super T&gt; <strong>getSuperclass</strong>()</td>
<td>返回调用类的父类</td>
</tr>
<tr>
<td>public Class&lt;?&gt;[] <strong>getInterfaces</strong>()</td>
<td>返回调用类实现的接口集合</td>
</tr>
</tbody></table>
</li>
<li><p>Field类方法：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>public String <strong>getName</strong>()</td>
<td>返回属性名</td>
</tr>
<tr>
<td>public int <strong>getModifiers</strong>()</td>
<td>获取属性的修饰符列表,返回的修饰符是一个数字【一般配合Modifier类的toString(int x)方法使用】</td>
</tr>
<tr>
<td>public Class&lt;?&gt; <strong>getType</strong>()</td>
<td>以Class类型，返回属性类型【一般配合Class类的getSimpleName()方法使用】</td>
</tr>
<tr>
<td>public void <strong>set</strong>(Object obj, Object value)</td>
<td>设置属性值</td>
</tr>
<tr>
<td>public Object <strong>get</strong>(Object obj)</td>
<td>读取属性值</td>
</tr>
<tr>
<td>public void <strong>setAccessible</strong>(boolean flag)</td>
<td>默认false，设置为true可以打破封装，如设置私有属性</td>
</tr>
</tbody></table>
</li>
<li><p>Method类方法：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>public String <strong>getName</strong>()</td>
<td>返回方法名</td>
</tr>
<tr>
<td>public int <strong>getModifiers</strong>()</td>
<td>获取方法的修饰符列表【一般配合Modifier类的toString(int x)方法使用】</td>
</tr>
<tr>
<td>public Class&lt;?&gt; <strong>getReturnType</strong>()</td>
<td>以Class类型，返回方法类型【一般配合Class类的getSimpleName()方法使用】</td>
</tr>
<tr>
<td>public Class&lt;?&gt;[] <strong>getParameterTypes</strong>()</td>
<td>返回方法的修饰符列表</td>
</tr>
<tr>
<td>public Object <strong>invoke</strong>(Object obj, Object… args)</td>
<td>调用方法</td>
</tr>
</tbody></table>
</li>
<li><p>Constructor类方法：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>public String <strong>getName</strong>()</td>
<td>返回构造方法名</td>
</tr>
<tr>
<td>public int <strong>getModifiers</strong>()</td>
<td>获取构造方法的修饰符列表【一般配合Modifier类的toString(int x)方法使用】</td>
</tr>
<tr>
<td>public Class&lt;?&gt;[] <strong>getParameterTypes</strong>()</td>
<td>返回构造方法的修饰符列表（一个方法的参数可能会有多个）</td>
</tr>
<tr>
<td>public T <strong>newInstance</strong>(Object … initargs)</td>
<td>创建对象【参数为创建对象的数据】</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p><code>Annotation</code> （注解） 是 Java5 开始引入的新特性，可以看作是一种特殊的注释，主要用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用。</p>
<p>注解本质是一个继承了<code>Annotation</code> 的特殊接口，如@Override：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Override</span> <span class="keyword">extends</span> <span class="title class_">Annotation</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>常见注解有两种：</p>
<ul>
<li><strong>编译期直接扫描</strong> ：编译器在编译 Java 代码的时候扫描对应的注解并处理，比如某个方法使用@Override 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。</li>
<li><strong>运行期通过反射处理</strong> ：像框架中自带的注解(比如 Spring 框架的 @Value 、@Component)都是通过反射来进行处理的。</li>
</ul>
<p>创建注解：通过@interface关键字进行定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestAnnotation &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h4><p>元注解是可以注解到注解上的注解，或者说元注解是一种基本注解，但是它能够应用到其它的注解上面。 元注解有5种：@Retention、@Documented、@Target、@Inherited、@Repeatable</p>
<ul>
<li><p><strong>@Retention</strong>： 意为保留，是指注解的存活时间。</p>
<p>取值有3种： </p>
<ul>
<li>RetentionPolicy.SOURCE：注解只在源码解码保留，在编译时会被忽略丢弃。</li>
<li>RetentionPolicy.CLASS：注解只保留到编译进行时，不会被加载到JVM中。</li>
<li>RetentionPolicy.RUNTIME：注解可保留到程序运行时，会被加载到 JVM中。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestAnnotation &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>@Documented</strong>： 能够将注解中的元素包含到 Javadoc 中去。</p>
</li>
<li><p><strong>@Target</strong>： 指定注解运用的场景。取值有：</p>
<ul>
<li>ElementType.ANNOTATION_TYPE 可以给一个注解进行注解</li>
<li>ElementType.CONSTRUCTOR 可以给构造方法进行注解</li>
<li>ElementType.FIELD 可以给属性进行注解</li>
<li>ElementType.LOCAL_VARIABLE 可以给局部变量进行注解</li>
<li>ElementType.METHOD 可以给方法进行注解</li>
<li>ElementType.PACKAGE 可以给一个包进行注解</li>
<li>ElementType.PARAMETER 可以给一个方法内的参数进行注解</li>
<li>ElementType.TYPE 可以给一个类型进行注解，比如类、接口、枚举</li>
</ul>
</li>
<li><p><strong>@Inherited</strong>：继承的意思，如果当前类的超类有@Inherited，且当前类没有被任何注解应用，则当前类继承超类的注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> Test &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>如上，类B能继承类A的注解。</p>
</li>
<li><p><strong>@Repeatable</strong>：可重复的意思，通常指注解的值可以同时取多个。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@interface</span> Persons &#123;</span><br><span class="line">    Person[]  value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repeatable(Persons.class)</span></span><br><span class="line"><span class="meta">@interface</span> Person&#123;</span><br><span class="line">    String role <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Person(role=&quot;artist&quot;)</span></span><br><span class="line"><span class="meta">@Person(role=&quot;coder&quot;)</span></span><br><span class="line"><span class="meta">@Person(role=&quot;PM&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SuperMan</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="注解属性"><a href="#注解属性" class="headerlink" title="注解属性"></a>注解属性</h4><p>注解的属性也叫做成员变量。注解只有成员变量，没有方法。</p>
<ul>
<li><p>例：定义注解有两个属性，默认值用default关键字指定</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestAnnotation &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">id</span><span class="params">()</span> <span class="keyword">default</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">msg</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;Hi&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用时赋值（有默认值的属性也可以不赋值）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TestAnnotation(id=3, msg=&quot;hello annotation&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>例：注解仅有一个属性时，使用时可以省略属性名：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Check &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Check(&quot;hi&quot;)</span></span><br><span class="line"><span class="type">int</span> a;</span><br></pre></td></tr></table></figure>
</li>
<li><p>例：注解没有任何属性，使用时不用加括号</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Perform &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Perform</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMethod</span><span class="params">()</span>&#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Java预置注解"><a href="#Java预置注解" class="headerlink" title="Java预置注解"></a>Java预置注解</h4><p> Java 语言本身提供了几个现成的注解：</p>
<ul>
<li><p><strong>@Deprecated</strong>：用于标记过时的元素。在idea中使用过时元素，会划上删除线。</p>
</li>
<li><p><strong>@Override</strong>：提示子类要复写父类中被 @Override 修饰的方法</p>
</li>
<li><p><strong>@SuppressWarnings</strong>：阻止警告。如调用@Deprecated标记的元素的地方，可以使用@SuppressWarnings来忽略警告。</p>
</li>
<li><p><strong>@SafeVarargs</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SafeVarargs</span> <span class="comment">// 实际上并不安全！</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">(List&lt;String&gt;... stringLists)</span> &#123;</span><br><span class="line">    Object[] array = stringLists;</span><br><span class="line">    List&lt;Integer&gt; tmpList = Arrays.asList(<span class="number">42</span>);</span><br><span class="line">    array[<span class="number">0</span>] = tmpList; <span class="comment">// 语义上是无效的，但编译时没有警告。 </span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> stringLists[<span class="number">0</span>].get(<span class="number">0</span>); <span class="comment">// 在运行时出现ClassCastException!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>@FunctionalInterface</strong>： 函数式接口注解。 函数式接口就是一个只具有一个方抽象法的普通接口。 它主要用在Lambda表达式和方法引用上。</p>
<ul>
<li>函数式接口只能有一个抽象方法，但可以有默认方法，也可以有静态方法。</li>
</ul>
<p>比如，在线程开发中常用的Runnable就是一个典型的函数式接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        当使用对象实现接口Runnable创建线程时，启动线程会导致在该单独执行的线程中调用对象的方法run</span></span><br><span class="line"><span class="comment">        该方法run的一般约定是它可以采取任何行动。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h3><p>Service Provider Interface ，即服务提供者的接口，可以理解为 专门提供给服务提供者或框架开发者去使用的接口。 SPI将服务调用方和服务实现者解耦，修改或替换服务不需要修改调用方。</p>
<ul>
<li><p>SPI和API的区别：</p>
<p>API调用的接口是由实现方提供的，而SPI调用的接口是自己规定的，再交由实现方实现。</p>
</li>
<li><p>缺点：</p>
<ul>
<li>需要遍历加载所有的实现类，不能做到按需加载，这样效率还是相对较低的。</li>
<li>当多个 <code>ServiceLoader</code> 同时 <code>load</code> 时，会有并发问题。</li>
</ul>
</li>
</ul>
<p>使用 Java 的 SPI 机制是需要依赖 <code>ServiceLoader</code> 来实现的，<strong>ServiceLoader加载服务的流程</strong>大致是：</p>
<ol>
<li>通过 URL 工具类从 jar 包的 <code>/META-INF/services</code> 目录下面找到对应的文件，</li>
<li>读取这个文件的名称找到对应的 spi 接口，</li>
<li>通过 <code>InputStream</code> 流将文件里面的具体实现类的全类名读取出来，</li>
<li>根据获取到的全类名，先判断跟 spi 接口是否为同一类型，如果是的，那么就通过反射的机制构造对应的实例对象，</li>
<li>将构造出来的实例对象添加到 <code>Providers</code> 的列表中。</li>
</ol>
<h4 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h4><p>利用SPI机制，实现一个简易日志框架。</p>
<h5 id="调用方"><a href="#调用方" class="headerlink" title="调用方"></a>调用方</h5><p>首先在调用方，新建一个Java项目（不用Maven项目，因为涉及到一些编译配置，较麻烦），结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">│  service-provider-interface.iml</span><br><span class="line">│</span><br><span class="line">├─.idea</span><br><span class="line">│  │  .gitignore</span><br><span class="line">│  │  misc.xml</span><br><span class="line">│  │  modules.xml</span><br><span class="line">│  └─ workspace.xml</span><br><span class="line">│</span><br><span class="line">└─src</span><br><span class="line">    └─edu</span><br><span class="line">        └─jiangxuan</span><br><span class="line">            └─up</span><br><span class="line">                └─spi</span><br><span class="line">                        Logger.java</span><br><span class="line">                        LoggerService.java</span><br><span class="line">                        Main.class</span><br></pre></td></tr></table></figure>

<p>首先实现一个Logger接口，这个就是SPI，后面的服务提供者就要针对这个接口进行实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> edu.jiangxuan.up.spi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">info</span><span class="params">(String msg)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">debug</span><span class="params">(String msg)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着实现一个LoggerService类，主要用于加载实现方提供的服务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> edu.jiangxuan.up.spi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.ServiceLoader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggerService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">LoggerService</span> <span class="variable">SERVICE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoggerService</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Logger&gt; loggerList;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LoggerService</span><span class="params">()</span> &#123;</span><br><span class="line">        ServiceLoader&lt;Logger&gt; loader = ServiceLoader.load(Logger.class);</span><br><span class="line">        List&lt;Logger&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Logger log : loader) &#123;</span><br><span class="line">            list.add(log);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// LoggerList 是所有 ServiceProvider</span></span><br><span class="line">        loggerList = list;</span><br><span class="line">        <span class="keyword">if</span> (!list.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// Logger 只取一个</span></span><br><span class="line">            logger = list.get(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LoggerService <span class="title function_">getService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SERVICE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;info 中没有发现 Logger 服务提供者&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.info(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">debug</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (loggerList.isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;debug 中没有发现 Logger 服务提供者&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        loggerList.forEach(log -&gt; log.debug(msg));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后是Main类，查看实现结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.spi.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LoggerService</span> <span class="variable">service</span> <span class="operator">=</span> LoggerService.getService();</span><br><span class="line"></span><br><span class="line">        service.info(<span class="string">&quot;Hello SPI&quot;</span>);</span><br><span class="line">        service.debug(<span class="string">&quot;Hello SPI&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="实现方"><a href="#实现方" class="headerlink" title="实现方"></a>实现方</h5><ol>
<li>将调用方的SPI导出为jar包，然后导入到实现方项目的lib目录中，并添加为库。</li>
<li>在src目录下新建 META-INF&#x2F;services文件夹，然后新建文件，文件名为SPI的全类名，文件内容是实现类的全类名：edu.jiangxuan.up.spi.service.Logback</li>
<li>编写实现了Logger的类Logback。</li>
</ol>
<p>目录结构为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">│  service-provider.iml</span><br><span class="line">│</span><br><span class="line">├─.idea</span><br><span class="line">│  │  .gitignore</span><br><span class="line">│  │  misc.xml</span><br><span class="line">│  │  modules.xml</span><br><span class="line">│  └─ workspace.xml</span><br><span class="line">│</span><br><span class="line">├─lib</span><br><span class="line">│      service-provider-interface.jar</span><br><span class="line">|</span><br><span class="line">└─src</span><br><span class="line">    ├─edu</span><br><span class="line">    │  └─jiangxuan</span><br><span class="line">    │      └─up</span><br><span class="line">    │          └─spi</span><br><span class="line">    │              └─service</span><br><span class="line">    │                      Logback.java</span><br><span class="line">    │</span><br><span class="line">    └─META-INF</span><br><span class="line">        └─services</span><br><span class="line">                edu.jiangxuan.up.spi.Logger</span><br></pre></td></tr></table></figure>

<p>Logback类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> edu.jiangxuan.up.spi.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> edu.jiangxuan.up.spi.Logger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Logback</span> <span class="keyword">implements</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Logback info 打印日志：&quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">debug</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Logback debug 打印日志：&quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样一个简易的SPI实践就完成了，在调用方导入实现方的项目jar包，运行调用方的测试方法（这里是Main方法）即可出结果。</p>
<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><ul>
<li><strong>序列化</strong>：将数据结构或对象转换成二进制字节流的过程。</li>
<li><strong>反序列化</strong>：将在序列化过程中所生成的二进制字节流转换成数据结构或对象的过程。</li>
</ul>
<blockquote>
<p>在Java中，序列化的都是对象。</p>
<p>序列化属于OSI七层协议模型中的表示层，即TCP&#x2F;IP四层模型中的应用层。</p>
</blockquote>
<p>序列化场景：</p>
<ul>
<li>对象在进行<strong>网络传输</strong>（比如远程方法调用 RPC 的时候）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；</li>
<li>将对象<strong>存储到文件</strong>之前需要进行序列化，将对象从文件中读取出来需要进行反序列化；</li>
<li>将对象存储到数据库（如 Redis）之前需要用到序列化，将对象从缓存数据库中读取出来需要反序列化；</li>
<li>将对象存储到内存之前需要进行序列化，从内存中读取出来之后需要进行反序列化</li>
</ul>
<p>设置变量不进行序列化： 添加 transient 关键字修饰。</p>
<ul>
<li><p>注： </p>
<p>transient 只能修饰变量，不能修饰类和方法；</p>
<p>transient 修饰的变量，在反序列化后会被置为默认值；</p>
<p>static变量不属于任何对象，所以无论有没有 transient 修饰，都不会被序列化。</p>
</li>
</ul>
<p>常见的序列化协议： Hessian，Kryo，Protobuf，ProtoStuff。（JDK自带的序列化方式因为不支持跨语言调用、效率和安全问题，一般不用， JSON和XML这种文本类序列化方式，可读性好但性能较差，一般也不用。）</p>
<ul>
<li><p>Kryo： 是一个高性能的序列化&#x2F;反序列化工具，由于其变长存储特性并使用了字节码生成机制，拥有较高的运行速度和较小的字节码体积。（Kryo是专门针对Java语言的序列化方式，其他 Protobuf、 ProtoStuff、hessian 都是跨语言的）</p>
<p>在springboot中使用例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.esotericsoftware.kryo.Kryo;</span><br><span class="line"><span class="keyword">import</span> com.esotericsoftware.kryo.io.Input;</span><br><span class="line"><span class="keyword">import</span> com.esotericsoftware.kryo.io.Output;</span><br><span class="line"><span class="keyword">import</span> github.javaguide.exception.SerializeException;</span><br><span class="line"><span class="keyword">import</span> github.javaguide.remoting.dto.RpcRequest;</span><br><span class="line"><span class="keyword">import</span> github.javaguide.remoting.dto.RpcResponse;</span><br><span class="line"><span class="keyword">import</span> github.javaguide.serialize.Serializer;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KryoSerializer</span> <span class="keyword">implements</span> <span class="title class_">Serializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Because Kryo is not thread safe. So, use ThreadLocal to store Kryo objects</span></span><br><span class="line"><span class="comment">     * 因为 Kryo不是线程安全的。因此，使用 ThreadLocal存储 Kryo对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 因为ThreadLocal只能被当前线程访问, 所以也无法利用其他线程初始化, 需要在此先初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;Kryo&gt; kryoThreadLocal = ThreadLocal.withInitial(() -&gt; &#123;</span><br><span class="line">        <span class="type">Kryo</span> <span class="variable">kryo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Kryo</span>();</span><br><span class="line">        kryo.register(RpcResponse.class);</span><br><span class="line">        kryo.register(RpcRequest.class);</span><br><span class="line">        <span class="keyword">return</span> kryo;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序列化, 其中kryo的Output类继承了java.io.OutputStream</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] serialize(Object obj) &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ByteArrayOutputStream</span> <span class="variable">byteArrayOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">             <span class="type">Output</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Output</span>(byteArrayOutputStream)) &#123;</span><br><span class="line">            <span class="type">Kryo</span> <span class="variable">kryo</span> <span class="operator">=</span> kryoThreadLocal.get();</span><br><span class="line">            <span class="comment">// Object-&gt;byte:将对象序列化为byte数组</span></span><br><span class="line">            kryo.writeObject(output, obj);</span><br><span class="line">            kryoThreadLocal.remove();</span><br><span class="line">            <span class="keyword">return</span> output.toBytes();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SerializeException</span>(<span class="string">&quot;Serialization failed —— 序列化失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反序列化</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">deserialize</span><span class="params">(<span class="type">byte</span>[] bytes, Class&lt;T&gt; clazz)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ByteArrayInputStream</span> <span class="variable">byteArrayInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes);</span><br><span class="line">             <span class="type">Input</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Input</span>(byteArrayInputStream)) &#123;</span><br><span class="line">            <span class="type">Kryo</span> <span class="variable">kryo</span> <span class="operator">=</span> kryoThreadLocal.get();</span><br><span class="line">            <span class="comment">// byte-&gt;Object:从byte数组中反序列化出对对象</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> kryo.readObject(input, clazz);</span><br><span class="line">            kryoThreadLocal.remove();</span><br><span class="line">            <span class="keyword">return</span> clazz.cast(o);   <span class="comment">// cast(): 将对象强制转换为此 Class对象表示的类或接口。</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SerializeException</span>(<span class="string">&quot;Deserialization failed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">kryoSerializerTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 构建要序列化的对象</span></span><br><span class="line">    <span class="type">RpcRequest</span> <span class="variable">target</span> <span class="operator">=</span> RpcRequest.builder().methodName(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">        .parameters(<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;sayhelooloo&quot;</span>, <span class="string">&quot;sayhelooloosayhelooloo&quot;</span>&#125;)</span><br><span class="line">        .interfaceName(<span class="string">&quot;github.javaguide.HelloService&quot;</span>)</span><br><span class="line">        .paramTypes(<span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[]&#123;String.class, String.class&#125;)</span><br><span class="line">        .requestId(UUID.randomUUID().toString())</span><br><span class="line">        .group(<span class="string">&quot;group1&quot;</span>)</span><br><span class="line">        .version(<span class="string">&quot;version1&quot;</span>)</span><br><span class="line">        .build();</span><br><span class="line">    <span class="type">KryoSerializer</span> <span class="variable">kryoSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">KryoSerializer</span>();</span><br><span class="line">    <span class="comment">// 序列化为byte数组</span></span><br><span class="line">    <span class="type">byte</span>[] bytes = kryoSerializer.serialize(target);</span><br><span class="line">    <span class="comment">// 反序列</span></span><br><span class="line">    <span class="type">RpcRequest</span> <span class="variable">actual</span> <span class="operator">=</span> kryoSerializer.deserialize(bytes, RpcRequest.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="I-x2F-O"><a href="#I-x2F-O" class="headerlink" title="I&#x2F;O"></a>I&#x2F;O</h3><p>IO 即 <code>Input/Output</code>，输入和输出。数据输入到计算机内存的过程即输入，反之输出到外部存储（比如数据库，文件，远程主机）的过程即输出。</p>
<ul>
<li>数据传输过程类似于水流，因此称为 IO 流。</li>
<li>IO 流在 Java 中分为输入流和输出流，而根据数据的处理方式又分为字节流和字符流。</li>
<li>Java IO 流的 40 多个类都是从 4 个抽象类基类中派生出来的：字节输入流 InputStream，字符输入流 Reader， 字节输出流 OutputStream， 字符输入流 Writer。</li>
</ul>
<p>问题：不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I&#x2F;O 流操作要分为字节流操作和字符流操作呢？答： </p>
<ul>
<li>字符流是由 Java 虚拟机将字节转换得到的，这个过程还算是比较耗时，而如果转换时编码类型不同，还会出现乱码问题，所以就直接把字符流单独作为一个部分，从而提高字符流的效率；</li>
</ul>
<p>BIO、NIO、AIO：</p>
<ul>
<li><p>BIO（Blocking I&#x2F;O）：同步阻塞的I&#x2F;O模式，数据的读取和写入必须阻塞在一个线程内，直至完成。 并发性能很差。</p>
</li>
<li><p>NIO（Non-blocking I&#x2F;O或New I&#x2F;O）： </p>
<p>同步非阻塞的I&#x2F;O模型，通过java.nio包，提供了Channel，Select，Buffer等抽象，其中Selector可以实现单线程管理多个Channel，当有Channel需要I&#x2F;O操作时，它会将其交给一个独立的线程池（Reactor线程池）去处理。</p>
<p>NIO能够使用单线程（Selector）处理多个请求，从而避免了线程阻塞导致性能低下的问题。但是，NIO还是需要等待I&#x2F;O操作完成，因此虽然减少了线程切换和上下文切换的开销，但是在I&#x2F;O操作较多时，仍然会因为等待I&#x2F;O操作完成而阻塞。</p>
<p>提供了与传统BIO模型中的Socket和ServerSocket相对应的SocketChannnel 和 ServerSocketChannel 两种套接字实现，两种通道都支持阻塞和非阻塞模式。</p>
</li>
<li><p>AIO（Asynchronous I&#x2F;O）：NIO的改进版，异步非阻塞的I&#x2F;O模型。是基于事件和回调机制实现的，I&#x2F;O操作是直接交给操作系统的，当后台处理完，系统会通知对应的线程。</p>
<blockquote>
<p>BIO从发起read调用后，会一直阻塞，直到数据拷贝完成。（发起read调用后，内核过程：准备数据—数据就绪——拷贝数据）</p>
<p>NIO的操作仍是同步的，先发起select调用询问数据是否准备就绪（可以轮询，等告知准备好，用户线程才发起read调用（read调用的过程仍是阻塞的）</p>
</blockquote>
</li>
</ul>
<p>Java IO中的设计模式：</p>
<ul>
<li><p><strong>装饰器模式</strong>：在不改变原有对象的情况下拓展其功能，使用组合，而不是继承。</p>
<ul>
<li>比如，对于输入字节流， <code>FilterInputStream</code> 是装饰器的核心，用于增强 <code>InputStream</code> 的子类。 如常见的BufferedInputStream就是FilterInputStream的子类，可以将InputStream的子类传入 BufferedInputStream 来增强。</li>
</ul>
</li>
<li><p><strong>适配器模式</strong>：主要用于协调接口互不兼容的类。字符流和字节流的接口不同，它们之间的互动就是基于适配器模式来做的，具体说是 对象适配器。</p>
<ul>
<li><p><code>InputStreamReader</code> 和 <code>OutputStreamWriter</code> 就是两个适配器(Adapter)， 同时，它们两个也是字节流和字符流之间的桥梁。<code>InputStreamReader</code> 使用 <code>StreamDecoder</code> （流解码器）对字节进行解码，<strong>实现字节流到字符流的转换</strong>。</p>
<p>而 InputStream 和 OutputStream 的子类就是是被适配者。</p>
</li>
</ul>
</li>
<li><p><strong>工厂模式</strong>：用于创建对象。NIO 中大量用到了工厂模式，比如</p>
<ul>
<li><code>Files</code> 类的 <code>newInputStream</code> 方法用于创建 <code>InputStream</code> 对象（静态工厂）；</li>
<li><code>Paths</code> 类的 <code>get</code> 方法创建 <code>Path</code> 对象（静态工厂）；</li>
<li><code>ZipFileSystem</code> 类（<code>sun.nio</code>包下的类，属于 <code>java.nio</code> 相关的一些内部实现）的 <code>getPath</code> 的方法创建 <code>Path</code> 对象（简单工厂）。</li>
</ul>
</li>
<li><p><strong>观察者模式</strong>：又称 发布 - 订阅 模式，能让多个观察者对象同时监听一个主题对象。</p>
<p>NIO中的文件目录监听服务使用到了观察者模式。</p>
</li>
</ul>
<h3 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h3><p>语法糖是为了方便程序员开发程序而设计的特殊语法，对编程功能无影响。</p>
<p>不过 JVM并不能识别语法糖，所以需要先通过编译器解糖，所以说支持语法糖的是Java编译器。</p>
<p>常见的语法糖：</p>
<ul>
<li><p><strong>for-each</strong>：实际就是普通for循环和迭代器。</p>
</li>
<li><p><strong>switch支持String与枚举</strong>： switch只支持int和char等基本类型，char比较是比较其ascii码，即switch起始只能使用整型。 而switch比较String时，会使用String的 equals() 比较 hashCode()得到的哈希码。</p>
</li>
<li><p><strong>泛型</strong> ：所有泛型类的类型参数在编译时都会被擦除，泛型类并没有自己独有的class对象，比如只有List.class，而没有 List&lt;String&gt;.class之类的。</p>
<ul>
<li><p>不能通过泛型的不同传入参数来进行方法重载，因为泛型在编译阶段会被擦除，使得两个方法的特征变得一样。例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericTypes</span> &#123;</span><br><span class="line">	<span class="comment">// 这样是无法通过编译的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(List&lt;String&gt; list)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;invoke method(List&lt;String&gt; list)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(List&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;invoke method(List&lt;Integer&gt; list)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>泛型的类型参数不能用在 Java 异常处理的 catch 语句中。因为异常处理是由 JVM 在运行时刻来进行的。由于类型信息被擦除，JVM 是无法区分两个异常类型<code>MyException&lt;String&gt;</code>和<code>MyException&lt;Integer&gt;</code>的。</p>
</li>
<li><p>泛型类的静态变量 同样也是共享的。由于经过类型擦除，所有的泛型类实例依然关联到同一份字节码上。</p>
</li>
</ul>
</li>
<li><p><strong>自动装箱与拆箱</strong>： 自动装箱实际调用的是valueOf(xx)，自动拆箱实际调用了 xxxValue()；</p>
</li>
<li><p><strong>可变长参数</strong>：即方法最后一个参数可以有任意数量的值传入。 实际会将这个可变长参数转变为数组。</p>
</li>
<li><p><strong>枚举类</strong>： 当我们使用<code>enum</code>来定义一个枚举类型的时候，编译器会自动帮我们创建一个 final类型的类 继承<code>Enum</code>类，所以枚举类型不能被继承。</p>
</li>
<li><p><strong>数值字面量</strong>：允许在数字间插入任意多个下划线，这些下划线不会对数字产生影响，单纯是为了方便阅读。在编译阶段会删除这些下划线。</p>
</li>
<li><p><strong>try-with-resource</strong>： 对于需要手动关闭的资源，如IO流、数据库连接， 可以在 try 后接一个括号，括号中建立连接对象，在语句块结束后会自动关闭连接，不用再去手动关闭。代码例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;d:\\ hollischuang.xml&quot;</span>))) &#123;</span><br><span class="line">    String line;</span><br><span class="line">    <span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">        System.out.println(line);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="comment">// handle exception</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在编译阶段，仍会转换出关闭资源的代码。</p>
</li>
<li><p><strong>Lambda表达式</strong>： Lambda 表达式不是匿名内部类的语法糖，但是他也是一个语法糖。实现方式其实是依赖了几个 JVM 底层提供的 lambda 相关 api。（内部类在编译之后会有两个 class 文件，但是，包含 lambda 表达式的类编译后只有一个文件）</p>
<p>在编译阶段，会转换成调用内部api的方式。</p>
</li>
<li><p>。。。。。</p>
</li>
</ul>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h3><ul>
<li><p>Collection接口下的集合：</p>
<p>List：</p>
<ul>
<li>ArrayList： Object[] 数组</li>
<li>Vector：Object[] 数组</li>
<li>LinkedList：双向链表</li>
</ul>
<p>Set：</p>
<ul>
<li>HashSet：基于HashMap实现</li>
<li>LinkedHashSet： 是HashSet的之类，内部通过LinkedHashMap实现</li>
<li>TreeSet：红黑树，即自平衡的排序二叉树</li>
</ul>
<p>Queue：</p>
<ul>
<li>PriorityQueue： Object[] 数组实现二叉堆</li>
<li>ArrayQueue：Object[]数组 + 双指针</li>
</ul>
</li>
<li><p>Map接口下的集合：</p>
<ul>
<li>HashMap：jdk1.8以前是 数组 + 链表（数组是主体，链表是解决哈希冲突），jdk1.8以后， 解决哈希冲突的方法变更为：当链表长度大于8，且数组长度大于64，将链表转化为红黑树，以减少搜索时间。</li>
<li>LinkedHashMap：在HashMap的 数组 + 链表&#x2F;红黑树 结构上，增加了一条双向链表，使得能保持键值对的插入顺序。</li>
<li>HashTable：数组 + 链表</li>
<li>TreeMap：红黑树</li>
</ul>
</li>
</ul>
<blockquote>
<p>Vector是List的古老实现类，线程安全，Stack继承自Vector，是一个先进先出的栈，这两者都已经被淘汰，需要并发集合的话，推荐使用 ConcurrentHashMap、CopyOnWriteArrayList等。</p>
</blockquote>
<h3 id="排序接口"><a href="#排序接口" class="headerlink" title="排序接口"></a>排序接口</h3><p>Comparable接口 和 Comparetor接口 都是用于排序的接口。</p>
<ul>
<li><p><strong>Comparable</strong>接口出自 java.lang包，排序方法是 **compareTo(Object obj)**；</p>
<ul>
<li><p>Comparable可以理解为内部比较器，一个类实现了该接口，并实现排序方法compareTo()，那进行排序时默认就是依据这个进行排序。 </p>
<p>例如：Collections.sort() 不指定排序方法时，调用的是 list.sort(null)，此时 list.sort(null) 调用了 Arrays.sort(a, (Comparator) c)， 方法内部实际使用的排序逻辑是泛型参数所实现的compareTo()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;user&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.sort(<span class="literal">null</span>);</span><br><span class="line">    Collections.sort(list);</span><br><span class="line"></span><br><span class="line">    user[] users = <span class="keyword">new</span> <span class="title class_">user</span>[<span class="number">1</span>];</span><br><span class="line">    Arrays.sort(users);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">user</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;user&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(user o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.age - o.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，实现了Comparable接口的类的对象的列表或数组可以通过Collections.sort或Arrays.sort进行自动排序。</p>
</li>
</ul>
</li>
<li><p><strong>Comparator</strong>接口出自 java.util包，排序方法是 **compare(Object o1, Object o2)**；</p>
<ul>
<li><p>可以理解为外部比较器，当要为没有比较方法的类进行排序，或者使用特定比较逻辑时，就需要一个“比较器”，这个“比较器”需实现Comparator接口。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(list, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;user&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(user o1, user o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o1.age - o2.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 或者写成lambda表达式</span></span><br><span class="line">Collections.sort(list, (o1, o2) -&gt; o1.age - o2.age);</span><br><span class="line"><span class="comment">// 或者使用 Comparator.comparingXxx(...)</span></span><br><span class="line">Collections.sort(list, Comparator.comparingInt(o -&gt; o.age));</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="描述与比较"><a href="#描述与比较" class="headerlink" title="描述与比较"></a>描述与比较</h3><p>比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同：</p>
<ul>
<li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 都是 <code>Set</code> 接口的实现类，都能保证元素唯一，并且都不是线程安全的。</li>
<li>底层数据结构不同。<ul>
<li><code>HashSet</code> 的底层数据结构是哈希表（基于 <code>HashMap</code> 实现）。</li>
<li><code>LinkedHashSet</code> 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。</li>
<li><code>TreeSet</code> 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</li>
</ul>
</li>
<li>底层数据结构不同又导致这三者的应用场景不同。<code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景，<code>LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 FIFO 的场景，<code>TreeSet</code> 用于支持对元素自定义排序规则的场景。</li>
</ul>
<p>Queue与Deque的区别：</p>
<ul>
<li><p><code>Queue</code> 是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循 <strong>先进先出（FIFO）</strong> 规则。</p>
<p><code>Queue</code> 扩展了 <code>Collection</code> 的接口，根据 因为容量问题而导致操作失败后处理方式的不同 可以分为两类方法: 一种在操作失败后会抛出异常（add()，remove()，element()），另一种则会返回特殊值（offer()，poll()，peek()）。</p>
</li>
<li><p><code>Deque</code> 是双端队列，在队列的两端均可以插入或删除元素。</p>
<p><code>Deque</code> 扩展了 <code>Queue</code> 的接口, 增加了在队首和队尾进行插入和删除的方法，同样根据失败后处理方式的不同分为两类。</p>
</li>
</ul>
<p>ArrayDeque与LinkedList的区别（两者都实现了Deque接口，都有队列的功能）：</p>
<ul>
<li><code>ArrayDeque</code> 是基于可变长的数组和双指针来实现，而 <code>LinkedList</code> 则通过链表来实现。</li>
<li><code>ArrayDeque</code> 不支持存储 <code>NULL</code> 数据，但 <code>LinkedList</code> 支持。</li>
<li><code>ArrayDeque</code> 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 <code>LinkedList</code> 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</li>
</ul>
<p>从性能的角度上，选用 <code>ArrayDeque</code> 来实现队列要比 <code>LinkedList</code> 更好。此外，<code>ArrayDeque</code> 也可以用于实现栈。</p>
<p>什么是BlockingQueue：</p>
<ul>
<li><p><code>BlockingQueue</code> （阻塞队列）是一个接口，继承自 <code>Queue</code>。<code>BlockingQueue</code>阻塞的原因是其支持当队列没有元素时一直阻塞，直到有有元素；还支持如果队列已满，一直等到队列可以放入新元素时再放入。</p>
</li>
<li><p><code>BlockingQueue</code> 常用于生产者-消费者模型中，生产者线程会向队列中添加数据，而消费者线程会从队列中取出数据进行处理。</p>
</li>
<li><p>实现类有以下几种：</p>
<ul>
<li><p><code>ArrayBlockingQueue</code>：使用数组实现的有界阻塞队列。在创建时需要指定容量大小，并支持公平和非公平两种方式的锁访问机制。</p>
</li>
<li><p><code>LinkedBlockingQueue</code>：使用单向链表实现的可选有界阻塞队列。在创建时可以指定容量大小，如果不指定则默认为<code>Integer.MAX_VALUE</code>。和<code>ArrayBlockingQueue</code>类似， 它也支持公平和非公平的锁访问机制。</p>
</li>
<li><p><code>PriorityBlockingQueue</code>：支持优先级排序的无界阻塞队列。元素必须实现<code>Comparable</code>接口或者在构造函数中传入<code>Comparator</code>对象，并且不能插入 null 元素。</p>
</li>
<li><p><code>SynchronousQueue</code>：同步队列，是一种不存储元素的阻塞队列。每个插入操作都必须等待对应的删除操作，反之删除操作也必须等待插入操作。因此，<code>SynchronousQueue</code>通常用于线程之间的直接传递数据。</p>
</li>
<li><p><code>DelayQueue</code>：延迟队列，其中的元素只有到了其指定的延迟时间，才能够从队列中出队。</p>
</li>
<li><p>……</p>
</li>
</ul>
</li>
</ul>
<p>HashMap 和 Hashtable 的区别：</p>
<ul>
<li><strong>线程是否安全：</strong> <code>HashMap</code> 是非线程安全的，<code>Hashtable</code> 是线程安全的,因为 <code>Hashtable</code> 内部的方法基本都经过<code>synchronized</code> 修饰。（如果要保证线程安全的话就使用 <code>ConcurrentHashMap</code> ）；</li>
<li><strong>效率：</strong> 因为线程安全的问题，<code>HashMap</code> 要比 <code>Hashtable</code> 效率高一点。另外，<code>Hashtable</code> 基本被淘汰，不要在代码中使用它；</li>
<li><strong>对 Null key 和 Null value 的支持：</strong> <code>HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；Hashtable 不允许有 null 键和 null 值，否则会抛出 <code>NullPointerException</code>。</li>
<li><strong>初始容量大小和每次扩充容量大小的不同：</strong><ul>
<li>① 创建时如果不指定容量初始值，<code>Hashtable</code> 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。<code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。</li>
<li>② 创建时如果给定了容量初始值，那么 <code>Hashtable</code> 会直接使用你给定的大小，而 <code>HashMap</code> 会将其扩充为 2 的幂次方大小（<code>HashMap</code> 中的<code>tableSizeFor()</code>方法保证）。也就是说 <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小。</li>
</ul>
</li>
<li><strong>底层数据结构：</strong> JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树），以减少搜索时间。<code>Hashtable</code> 没有这样的机制。</li>
</ul>
<blockquote>
<p>为什么HashMap的容量大小是2的幂次方？</p>
<ul>
<li>因为键值对存放的位置是 根据key计算得到的Hash值 确定的，Hash值int类型，需要对数组长度取模运算，如果直接用 % 符号效率较低，而如果除数n是2的幂次方，则在%操作中等价于 (n - 1) &amp; Hash，位运算效率会更高。 即 n是2的n次方时， Hash % n &#x3D; (n - 1) &amp; Hash。</li>
</ul>
<p>HashMap多线程扩容导致死循环问题：</p>
<ul>
<li>当多个线程同时执行 rehash 进行扩容时，<strong>jdk1.7</strong>以前使用的<strong>链表头插法</strong>可能会导致链表中的节点指向错误的位置，从而形成一个<strong>环形链表</strong>，进而使得查询元素的操作陷入<strong>死循环</strong>无法结束。</li>
<li><strong>jdk1.8</strong>时，HashMap 采用了尾插法而不是头插法来避免链表倒置，使得插入的节点永远都是放在链表的末尾，避免了链表中的环形结构。 不过，多线程下使用还是会出现<strong>数据覆盖</strong>的问题，并发环境下，推荐使用 <code>ConcurrentHashMap</code> 。</li>
</ul>
</blockquote>
<p>JDK 1.7 和 JDK 1.8 的 ConcurrentHashMap 实现有什么不同？</p>
<ul>
<li><strong>线程安全实现方式</strong>：JDK 1.7 采用 <code>Segment</code> 分段锁来保证安全， <code>Segment</code> 是继承自 <code>ReentrantLock</code>。JDK1.8 放弃了 <code>Segment</code> 分段锁的设计，采用 <code>Node + CAS + synchronized</code> 保证线程安全，锁粒度更细，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点。</li>
<li><strong>Hash 碰撞解决方法</strong> : JDK 1.7 采用拉链法，JDK1.8 采用拉链法结合红黑树（链表长度超过一定阈值时，将链表转换为红黑树）。</li>
<li><strong>并发度</strong>：JDK 1.7 最大并发度是 Segment 的个数，默认是 16。JDK 1.8 最大并发度是 Node 数组的大小，并发度更大。</li>
</ul>
<ul>
<li><p>JDK 1.7 的 ConcurrentHashMap 结构图：</p>
<p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202305291108897.png" alt="image-20230529110844783"></p>
<p><code>ConcurrentHashMap</code> 是由 <code>Segment</code> 数组结构和 <code>HashEntry</code> 数组结构组成。（Segment数组不能扩容）</p>
<p><code>Segment</code> 数组中的每个元素包含一个 <code>HashEntry</code> 数组，每个 <code>HashEntry</code> 数组属于链表结构。</p>
</li>
<li><p>JDK 1.8 的 ConcurrentHashMap 结构图：</p>
<p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202305291108102.png" alt="image-20230529110817954"></p>
<p>JDK1.8 的 <code>ConcurrentHashMap</code> 是 <strong>Node 数组 + 链表 &#x2F; 红黑树</strong>。不过，Node 只能用于链表的情况，红黑树的情况需要使用 **<code>TreeNode</code>**。当冲突链表达到一定长度时，链表会转换成红黑树。</p>
<p><code>TreeNode</code>是存储红黑树节点，被<code>TreeBin</code>包装。<code>TreeBin</code>通过<code>root</code>属性维护红黑树的根结点，因为红黑树在旋转的时候，根结点可能会被它原来的子节点替换掉，在这个时间点，如果有其他线程要写这棵红黑树就会发生线程不安全问题，所以在 <code>ConcurrentHashMap</code> 中<code>TreeBin</code>通过<code>waiter</code>属性维护当前使用这棵红黑树的线程，来防止其他线程的进入。</p>
</li>
</ul>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><ul>
<li><p>并发： 两个及两个以上的作业在同一<strong>时间段</strong>内执行。（宏观上的同时执行）</p>
</li>
<li><p>并行：两个及两个以上的作业在同一<strong>时刻</strong>执行。（微观上的同时执行，真的同时执行）</p>
</li>
<li><p>同步：发出一个调用后，在没有得到结果之前，该调用会一直等待。</p>
</li>
<li><p>异步：调用在发出之后，不用等待返回结果，该调用直接返回。</p>
</li>
</ul>
<h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><p>**进程： **</p>
<p>进程就是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。</p>
<blockquote>
<p>比如：Java中启动main函数就是启动一个JVM的进程，main函数是这个进程中的主线程； 在Windows的任务管理器，可以看到当前运行的应用，也是一个进程(.exe文件的运行)</p>
</blockquote>
<p><strong>线程：</strong></p>
<p>线程与进程相似，是一个更小的执行单位。进程在执行过程中会产生多个线程。</p>
<p>多个线程共享该进程的堆和方法区（1.8之后的实现是本地内存的元空间），线程各自拥有自己的程序计数器，虚拟机栈，本地方法栈。所以系统生产一个线程或线程间切换工作，负担都比进程小的多，因此线程也可称为轻量级进程。</p>
<p>总结： 线程是进程划分成的更小的运行单位。不同点在于，进程是相互独立的，而同一进程中的线程可能会相互影响。线程执行开销小，但不利于资源管理和保护，进程相反。</p>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><ul>
<li><p>为什么要使用多线程？</p>
<ul>
<li><strong>从计算机底层来说：</strong> 线程是程序执行的最小单位, 线程间的切换和调度的成本远远小于进程。另外，有多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。而对于单个CPU，多线程可以提高进程利用CPU和IO的效率（线程请求IO而阻塞时可以切换另一个线程继续使用CPU）。</li>
<li><strong>从当代互联网发展趋势来说：</strong> 现在的系统常要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。</li>
</ul>
</li>
<li><p>多线程的问题： 内存泄漏，死锁，线程不安全等</p>
</li>
</ul>
<p><strong>线程的生命周期：</strong> 以下6种</p>
<ul>
<li><code>NEW</code>: 初始状态，线程被创建出来但没有被调用 start() 。</li>
<li><code>RUNNABLE</code>: 运行状态，线程被调用了 start()等待运行的状态。(也就是<code>RUNNING</code>和<code>READY</code>，分别是运行中和就绪状态)</li>
<li><code>BLOCKED</code> ：阻塞状态，需要等待锁释放。</li>
<li><code>WAITING</code>：等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。</li>
<li><code>TIME_WAITING</code>：超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。</li>
<li><code>TERMINATED</code>：终止状态，表示该线程已经运行完毕。</li>
</ul>
<blockquote>
<p>操作系统层面，线程区分READY和RUNNING状态，而JVM并不区分，将两个状态统称为RUNNABLE状态。</p>
<p>因为JVM认为线程单次能运行的时间太短(RUNNING状态，可能就0.01s)，很快就回调用队列了（READY状态），线程切换很快，没必要区分这两种状态。</p>
</blockquote>
<p>当线程执行 wait() 之后，线程就进入 WAITING 状态，此时线程需要依靠其他线程的通知才能回到运行状态。</p>
<p>通过加上超时限制，如sleep(long millis)或wait(long millis) 可以使线程进入 TIME_WAITING 状态。 时间到了线程会回到运行状态。</p>
<p>当线程进入synchronized同步控制的方法或块时，锁被其他线程占用，该线程就会进入BLOCKED状态。</p>
<hr>
<p><strong>上下文切换：</strong></p>
<p>线程在执行过程中 有自己的运行条件和状态，就是上下文。 如线程的程序计数器，栈信息等。</p>
<p>当线程让出CPU并且线程还未终止时，也就是发生线程切换时，就要保存当前线程的上下文(保留现场)，方便下次占用时恢复现场。 </p>
<p>让出CPU的情况有</p>
<ul>
<li>主动让出，如调用了sleep()，wait()。</li>
<li>时间片用完。</li>
<li>调用了阻塞类型的系统中断，如请求IO。</li>
<li>线程终止&#x2F;结束运行</li>
</ul>
<hr>
<p><strong>线程死锁：</strong></p>
<h3 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h3><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><p>Java虚拟机（Java Virtual Machine，JVM）是Java语言的核心组成部分，它是一种能够<strong>运行Java字节码的虚拟计算机</strong>。Java程序在运行时，首先需要将Java源代码编译成Java字节码文件（.class文件），然后由JVM进行解释和执行。</p>
<p>JVM具有独立于硬件平台的特点，它提供了一种抽象的计算机模型，使得Java程序可以在任何支持Java虚拟机的计算机上运行。JVM的主要作用是将Java字节码转换为本地机器指令，同时还提供了一些重要的功能，如<strong>内存管理、垃圾回收</strong>、线程管理、安全性管理等，以保证Java程序的安全性和稳定性。</p>
<p>JVM的工作原理可以简单概括为以下几个步骤：</p>
<ol>
<li>加载：JVM通过类加载器（ClassLoader）从磁盘或网络中加载Java字节码文件，并将字节码转换为JVM内部的数据结构。</li>
<li>验证：JVM对字节码进行验证，检查字节码是否符合Java虚拟机规范，是否包含安全漏洞等。</li>
<li>准备：JVM为类变量（静态变量）分配内存，并设置默认值。</li>
<li>解析：JVM将符号引用转换为直接引用，即将类、方法和变量的引用解析为具体的内存地址。</li>
<li>初始化：JVM执行类的初始化代码，包括静态代码块和静态变量的赋值操作等。</li>
<li>执行：JVM执行Java字节码，将Java字节码解释为机器指令并执行，同时提供一些基本的服务，如垃圾回收、异常处理等。</li>
</ol>
<p>除了上述基本功能，JVM还提供了一些高级功能，如动态编译、代码优化、多线程支持、远程调试等，这些功能为Java程序的开发和调试提供了重要的支持。</p>
<h3 id="Java内存区域详解"><a href="#Java内存区域详解" class="headerlink" title="Java内存区域详解"></a>Java内存区域详解</h3><blockquote>
<p>JVM能自动管理内存，使得Java不容易发生内存泄漏和内存溢出，但如果真出现内存问题，就需要我们对JVM对内存的管理有一定的了解才能排错。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202303242335495.png" alt="image-20230324233542331"></p>
<h4 id="内存划分"><a href="#内存划分" class="headerlink" title="内存划分"></a>内存划分</h4><p>JVM在运行Java程序时会对管理的内存区进行划分：</p>
<hr>
<ul>
<li><p>运行时数据区域，<strong>每一个进程都有：</strong></p>
<ul>
<li><strong>堆</strong> （1.8及以后，字符串常量和静态变量放在这里）</li>
<li><strong>方法区</strong>：内含运行时常量池（1.8及以后移除方法区,用元空间替代）</li>
<li><strong>每个线程的私有区域</strong>：<ul>
<li><strong>虚拟机栈</strong></li>
<li><strong>本地方法栈</strong></li>
<li><strong>程序计数器</strong></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>本地内存：</strong></p>
<p><strong>元空间</strong>（1.8及以后才有，用于替代方法区）</p>
<p><strong>直接内存</strong>（是非运行时数据区的一部分）</p>
</li>
</ul>
<hr>
<p>其中<code>堆</code>，<code>方法区/元空间</code>，<code>直接内存</code>都是线程共享的。</p>
<h4 id="线程区域"><a href="#线程区域" class="headerlink" title="线程区域"></a>线程区域</h4><ul>
<li><p><strong>程序计数器</strong></p>
<p>是当前线程执行的字节码的行号指示器， 通过改变计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。</p>
<p>作用： 代码流程控制，线程切换后恢复。</p>
<p>（程序计数器是唯一不会发生<code>OutOfMemoryError</code>的内存区域，因为它的生命和线程一致，且不需要拓展空间）</p>
</li>
<li><p><strong>虚拟机栈</strong></p>
<p>栈是JVM运行时数据区域的一个核心，基本所有的Java方法调用都是通过栈来实现的。</p>
<blockquote>
<p>虚拟机栈和本地方法栈为线程私有，是为了保证线程中的局部变量不被别的线程访问到。</p>
</blockquote>
<p>方法调用的数据需要通过栈进行传递，<code>每一次方法调用都会有一个对应的栈帧</code>被压入栈中，每一个方法调用结束后，都会有一个栈帧被弹出。</p>
<p>&#x3D;&#x3D;<strong>栈帧</strong>&#x3D;&#x3D;的组成：</p>
<ul>
<li><strong>局部变量表</strong></li>
<li><strong>操作数栈</strong></li>
<li><strong>动态链接</strong></li>
<li><strong>方法</strong></li>
</ul>
<blockquote>
<ul>
<li><p><strong>局部变量表</strong></p>
<p>​	主要存放了编译期可知的各种<strong>基本数据类型</strong>、<strong>对象引用</strong>（reference 类型，它不是对象本身，而是一个指向对象起始地址的引用指针，或者是指向一个代表对象的句柄）。</p>
</li>
<li><p><strong>操作数栈</strong></p>
<p>​	作为方法调用的中转站使用，用于存放方法执行过程中产生的<strong>中间计算结果</strong>和<strong>临时变量</strong>。</p>
</li>
<li><p><strong>动态链接</strong></p>
<p>​	当方法内需要调用其他方法，就需要用到动态链接。首先，Java程序编译后会得到每个类和接口各自的Class文件，里面包含了该类所有变量和方法的<strong>符号引用</strong>。 动态链接的作用就是将<strong>符号引用</strong>转换为<strong>调用目标方法的直接引用</strong>。</p>
</li>
<li><p><strong>方法返回地址</strong></p>
<p>​	Java 方法有两种返回方式，一种是 return 语句正常返回，一种是抛出异常。两者都会让栈帧被弹出。</p>
</li>
</ul>
</blockquote>
<p>虚拟机栈可能会出现的错误：</p>
<ul>
<li><p><strong><code>StackOverFlowError</code>：</strong> 若栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。</p>
<p><strong><code>OutOfMemoryError</code>：</strong> 如果栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。</p>
</li>
</ul>
</li>
<li><p><strong>本地方法栈</strong></p>
<p>本地方法栈和虚拟机栈类似，区别在于：虚拟机栈为虚拟机执行 Java 方法 (也就是字节码）服务，而<strong>本地方法栈则为虚拟机使用到的 Native 方法服务</strong>。</p>
<p>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</p>
<p>同样可能出现两种错误： StackOverFlowError 和 OutOfMemoryError。</p>
</li>
</ul>
<h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>堆是Java 虚拟机所管理的内存中最大的一块，是所有线程共享的内存区域，在虚拟机启动时创建。<strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</strong></p>
<blockquote>
<p>JIT有一个重要的优化，叫逃逸分析。JDK1.7默认开启逃逸分析，即方法中的对象引用没有被返回或未被外界使用(未逃逸出去),那么对象可以直接在栈上分配内存。</p>
</blockquote>
<p>因为Java堆是垃圾收集器管理的主要区域，所以也被叫做GC堆（Garbage Collected Heap）。垃圾收集器一般都采用分代收集算法，即分为新生代和老年代。</p>
<p>Hotspot VM 的堆结构：</p>
<ul>
<li>新生代内存： Eden + S0 + S1</li>
<li>老年代内存：Tenured</li>
<li>永久代：MetaSpace，即元空间 （JDK1.7及以前是PermGen，永久代内存空间）</li>
</ul>
<p>– Tenured的内存空间要比新生代内存大的多；</p>
<p>– 新生代中Eden占80%的空间，Survivor0和Survivor1用于交换复制在Minor GC后还存活的对象。在16次Minor GC还存活的对象将送至老年代。（即进行minor GC时，会将Eden和其中一个Survivor的存活对象移动到另一个Survivor）</p>
<p>– 如果新对象在分配新生代空间时，空间不够并且立即进行一次minor GC后还是没有足够空间进行分配，就会通过 <code>分配担保机制</code> 把新生代的对象提前转移到老年代中去。</p>
<p>– 大对象（字符串、数组）因为需要大量连续内存空间，会直接进入老年代。</p>
<hr>
<p>堆中最容易出现的错误：OutOfMemoryError。</p>
<h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>方法区是JVM运行时数据区域的一块逻辑区域，是各个线程共享的内存区域。</p>
<p>方法区是一个抽象概念&#x2F;规范，在JDK1.7，方法区的具体实现是永久代，在JDK1.8，方法区的实现是元空间。(它们的关系类似于接口和类）</p>
<ul>
<li>方法区的作用： 当JVM要使用一个类时，它需要读取并解析 Class 文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的 <strong>类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据</strong>。</li>
</ul>
<blockquote>
<p>为什么永久代会被替换：</p>
<ul>
<li><p>永久代受JVM设置的固定大小所限，无法调节大小；</p>
<p>元空间使用的是本地内存，受本机可用内存限制；</p>
<p>—— 元空间内存溢出的几率比永久代小的多。</p>
</li>
<li><p>元空间存放的是类的元数据，这样加载多少类的元数据就不由 MaxPermSize 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了。</p>
</li>
</ul>
<p>（元数据：指描述数据的数据。在Java中元数据以标签(Annotation，注解)的形式存在于Java代码中，让文件或针在运行时知道被运行代码的描述信息。 元数据可以用于说明数据的名称、类型、范围、所属等）</p>
</blockquote>
<ul>
<li><p><strong>运行时常量池</strong>：</p>
<p>Class文件中有存放编译期生成的各种字面量（Literal）和符号引用（Symbolic Reference）的 <strong>常量池表</strong> (Constant Pool Table) 。</p>
<p>常量池表 会在类加载后存放到 方法区的运行时常量池中。</p>
<blockquote>
<p>字面量：通过直面能直接知道 值，包括整数、浮点数、字符串字面量。</p>
<p>符号引用：用一组符号来描述引用的目标，能无歧义地定位到目标，与虚拟机的内存布局无关。（直接引用受虚拟机内存布局影响）</p>
</blockquote>
</li>
<li><p><strong>字符串常量池</strong>：</p>
<p>为了避免字符串重复创建而开辟的内存区域。</p>
<blockquote>
<p>HotSpot 虚拟机中字符串常量池的实现是 src&#x2F;hotspot&#x2F;share&#x2F;classfile&#x2F;stringTable.cpp,  <code>StringTable</code>本质上就是一个<code>HashSet&lt;String&gt;</code> ,容量为 StringTableSize。</p>
<ul>
<li>StringTable保存的是字符串对象的引用，指向堆中的字符串对象。</li>
<li>1.7以前字符串常量放在方法区的永久代中，<code>1.8以后字符串常量和静态变量放到Java堆中</code>。（因为永久代只有在整堆收集Full GC时才会被执行垃圾回收，而通常有许多被创建的字符串需要被回收，所以将字符串常量放到Java堆中，能高效回收字符串）</li>
</ul>
</blockquote>
</li>
</ul>
<hr>
<p>运行时常量池 和 字符串常量池 的变迁：</p>
<ul>
<li>JDK1.7 之前运行时常量池 逻辑包含 字符串常量池存放在方法区, 此时 hotspot 虚拟机对方法区的实现为永久代。</li>
<li>JDK1.7 字符串常量池和静态变量被单独从方法区拿到了堆中, 而运行时常量池剩下的东西（即永久代）还在方法区。</li>
<li>JDK1.8 hotspot 移除了永久代，用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)</li>
</ul>
<hr>
<p>— 运行时常量池、方法区、字符串常量池 这些都是不随虚拟机实现而改变的逻辑概念，是公共且抽象的;</p>
<p>— Metaspace、Heap 是与具体某种虚拟机实现相关的物理概念，是私有且具体的。</p>
<hr>
<h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h4><p>直接内存并不在 Java 堆或方法区中分配的，而是通过 JNI (Java Native Interface，java本地接口）的方式在本地内存上分配的。</p>
<blockquote>
<p>java的<code>NIO</code>类，是一种基于<code>通道（Channel）与缓存区（Buffer）的 I/O 方式</code>，它可以直接<code>使用 Native 函数库直接分配堆外内存</code>，然后通过一个存储在 Java 堆中的 <code>DirectByteBuffer 对象</code>作为这块内存的<code>引用</code>进行操作。这样就能在一些场景中显著提高性能，因为<code>避免了在 Java 堆和 Native 堆之间来回复制数据</code>。</p>
</blockquote>
<h3 id="对象创建过程"><a href="#对象创建过程" class="headerlink" title="对象创建过程"></a>对象创建过程</h3><ol>
<li><p><strong>&#x3D;&#x3D;类加载检查&#x3D;&#x3D;</strong></p>
<p>虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p>
</li>
<li><p><strong>&#x3D;&#x3D;分配内存&#x3D;&#x3D;</strong></p>
<p>类加载过后，对象所需的内存大小确定了，可以开始分配内存。 有两种方式：</p>
<ul>
<li><strong>指针碰撞</strong> ： <ul>
<li>适用场合：堆内存规整（即没有内存碎片）的情况下。（GC收集器使用“标记-整理”算法）</li>
<li>原理 ：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。</li>
<li>使用该分配方式的 GC 收集器：Serial, ParNew</li>
</ul>
</li>
<li><strong>空闲列表</strong> ： <ul>
<li>适用场合：堆内存不规整的情况下。（GC收集器使用“标记-清除”算法）</li>
<li>原理 ：虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。</li>
<li>使用该分配方式的 GC 收集器：CMS</li>
</ul>
</li>
</ul>
<blockquote>
<p>内存分配有线程安全问题，一般采用CAS+失败重试，或使用TLAB分配</p>
</blockquote>
</li>
<li><p><strong>&#x3D;&#x3D;初始化零值&#x3D;&#x3D;</strong></p>
<p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头）。</p>
<p>这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p>
</li>
<li><p><strong>&#x3D;&#x3D;设置对象头&#x3D;&#x3D;</strong></p>
<p>初始化零值后，虚拟机还需要为对象设置一些必要信息，这些信息存放在对象头中，如：对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p>
</li>
<li><p><strong>&#x3D;&#x3D;执行init方法&#x3D;&#x3D;</strong></p>
<p>对虚拟机来说，此时对象已经产生，不过对于Java程序来说，对象创建才刚开始，一般来说，new指令之后会接着执行init方法，按程序逻辑进行初始化，这样一个对象才算真正产生。</p>
</li>
</ol>
<hr>
<p><strong>对象的内存布局：</strong></p>
<p>分为三部分：</p>
<ul>
<li>对象头：<ul>
<li>存储对象的运行时数据（哈希码，GC分代年龄，锁状态标志等）</li>
<li>存储类型指针（指向它的类元数据，能确定对象是哪个类的实例）</li>
</ul>
</li>
<li>实例数据： 程序中定义的字段内容。</li>
<li>对齐填充： 仅起占位作为，因为Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍。</li>
</ul>
<hr>
<p><strong>对象的访问定位：</strong></p>
<p>Java程序通过栈上的 reference 数据来操作堆上的具体对象。 具体的访问形式，当前主流的有两种方式：</p>
<ul>
<li><p><strong>直接指针</strong></p>
<p>reference 中存储的直接就是对象的内存地址（这块内存中，也包含有 到对象类型数据的指针。）</p>
<ul>
<li>特点：速度快，只用定位一次即可访问实例数据。</li>
</ul>
</li>
<li><p><strong>使用句柄</strong></p>
<p>Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的是对象的句柄地址，而句柄中包含了 对象实例数据与对象类型数据 各自的具体地址信息。</p>
<ul>
<li>特点： reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。（需要定位两次指针才能访问到实例数据）</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202303211649720.png" alt="image-20230321164901535"></p>
<h3 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h3><p>针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：</p>
<ul>
<li><p>部分收集 (Partial GC)：</p>
<ul>
<li>新生代收集（Minor GC &#x2F; Young GC）：只对新生代进行垃圾收集；</li>
<li>老年代收集（Major GC &#x2F; Old GC）：只对老年代进行垃圾收集。（注： Major GC 在一些语境中也用于指代整堆收集）</li>
<li>混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。</li>
</ul>
</li>
<li><p>整堆收集 (Full GC)：收集整个 Java 堆和方法区。</p>
</li>
</ul>
<blockquote>
<p>Partial: 部分的,局部的; minor: 较小的,次要的; major: 主要的 </p>
</blockquote>
<hr>
<p><strong>空间分配担保：</strong></p>
<p>确保在 Minor GC 之前，老年代还有容纳新生代所有对象的剩余空间。</p>
<p>规则： 只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行 Minor GC，否则将进行 Full GC。</p>
<h4 id="死亡对象判断"><a href="#死亡对象判断" class="headerlink" title="死亡对象判断"></a>死亡对象判断</h4><p>对堆的垃圾回收第一步：判断哪些对象已经死亡（不再被任何途径使用）。</p>
<ul>
<li><p>引用计数法：</p>
<p>只需在对象中添加一个引用计数器：</p>
<ul>
<li>每当有一个地方引用它，计数器就加1；</li>
<li>当一个引用失效，计数器就减1；</li>
<li>计数器为0的对象不可能再被使用。</li>
</ul>
<p>引用计数法实现简单、效率高，但有个致命问题：不能解决对象间的相互循环引用问题。</p>
<blockquote>
<p>对象间的相互循环引用问题：除了对象A和对象B相互引用对方之外，无其他任何引用。这样它两的引用计数器都不为0，导致无法被回收。</p>
</blockquote>
</li>
<li><p><strong>可达性算法：</strong></p>
<p>以<strong>“GC Roots”</strong>对象为起点形成的引用链中的节点对象都是可用的，如果有对象与任何GC Roots没有引用链相连的话，这个对象就是不可用的，需要被回收。</p>
<p>可以被作为GC Roots的对象有：</p>
<ul>
<li>虚拟机栈(栈帧中的本地变量表) 中引用的对象</li>
<li>本地方法栈(Native 方法) 中引用的对象</li>
<li>方法区中类静态属性 引用的对象</li>
<li>方法区中常量 引用的对象</li>
<li>所有被同步锁持有的对象</li>
</ul>
</li>
</ul>
<hr>
<p><strong>如何判断一个常量是废弃常量？</strong></p>
<p>如果字符串常量池中的一个字符串”abc”，没有任何String对象引用该字符串常量，那么常量”abc”就是废弃常量，可被回收。</p>
<p><strong>如何判断一个类是无用类？</strong> 需要满足以下3各条件才行：</p>
<ul>
<li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li>
<li>加载该类的 <code>ClassLoader</code> 已经被回收。</li>
<li>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
<hr>
<h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><p>Java判定对象的存活与”引用”相关。引用分为 强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱）</p>
<ul>
<li><p>强引用：</p>
<p>平时使用的大部分引用都是强引用，这是默认的引用类型。当创建一个对象并赋值给一个变量时，这个变量就是该对象的强引用。</p>
<p>一个对象具有强引用，说明它是必不可少的，垃圾回收器就不会进行回收。（就算内存不足也不会回收，而是抛出OutOfMemoryError 错误让程序终止）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello, world!&quot;</span>);	<span class="comment">// 一般使用的变量赋值都是强引用</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>软引用：</p>
<p>一个对象只具有软引用，说明是可有可无的，垃圾回收器在内存足够时不会回收，在内存不足时会回收。</p>
<p>（平时很少用弱引用与虚引用，而使用软引用的情况较多，这是因为<strong>软引用可以加速 JVM 对垃圾内存的回收速度</strong>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个字符串对象并创建一个软引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">SoftReference&lt;String&gt; softRef = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(str);</span><br><span class="line"></span><br><span class="line">str = <span class="literal">null</span>;	  <span class="comment">// 此时str只有软引用，当内存不足时，垃圾回收器会尽可能回收只被软引用指向的对象</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>弱引用：</p>
<p>一个对象只具有弱引用，说明是可有可无的，它的生命周期比软引用的对象更断。垃圾回收器如果发现只有弱引用的对象会直接进行回收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个字符串对象并创建一个弱引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">WeakReference&lt;String&gt; weakRef = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(str);</span><br><span class="line"></span><br><span class="line">str = <span class="literal">null</span>;	 <span class="comment">// 当对象只被弱引用所指向时，被垃圾回收器发现就会回收它</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>虚引用：</p>
<p>虚引用几乎不对对象的生命周期产生影响。与软引用和弱引用不同，虚引用并不会影响对象的可达性和垃圾回收时机。虚引用主要用于跟踪对象被垃圾回收活动。</p>
<p>虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p>
<p>（软引用和弱引用同样可以关联一个引用队列，来看对象是否被回收或在回收前采取行动）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个字符串对象并创建一个虚引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">ReferenceQueue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br><span class="line">PhantomReference&lt;String&gt; phantomRef = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;&gt;(str, queue);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当垃圾回收器回收被虚引用所指向的对象时，虚引用将被放入引用队列</span></span><br><span class="line">str = <span class="literal">null</span>;</span><br><span class="line">System.gc(); <span class="comment">// 手动触发垃圾回收器</span></span><br><span class="line">Reference&lt;? <span class="keyword">extends</span> <span class="title class_">String</span>&gt; ref = queue.poll();</span><br><span class="line"><span class="keyword">if</span> (ref != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 对象已被回收</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h4><ul>
<li><p><strong>标记-清除</strong> 算法</p>
<p>首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。</p>
<p>不足： 效率问题， 空间问题（会产生大量碎片空间）</p>
</li>
<li><p><strong>标记-复制</strong> 算法</p>
<p>标记-复制算法 可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</p>
<p>（只需遍历一半内存空间，不会产生碎片空间）</p>
</li>
<li><p><strong>标记-整理</strong> 算法</p>
<p>标记过程仍然与“标记-清除”算法一样，但后续步骤是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</p>
</li>
</ul>
<p>当前虚拟机的垃圾收集都采用<strong>分代收集算法</strong>，可以根据不同年代的特点选择合适的垃圾收集算法。</p>
<p>比如在<strong>新生代</strong>中，每次收集都会有大量对象死去，所以可以选择”<strong>标记-复制</strong>“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。</p>
<p>而<strong>老年代</strong>的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“<strong>标记-整理</strong>”算法进行垃圾收集。</p>
<h4 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h4><ul>
<li><p><strong>Serial收集器</strong></p>
<p>Serial（串行）收集器是一个单线程收集器。这意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，并且在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ <strong>“Stop The World”</strong> ），直到它收集结束。</p>
<p>Serial 收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。对于运行在 Client 模式下的虚拟机来说是个不错的选择。</p>
</li>
<li><p><strong>ParNew收集器</strong></p>
<p>是Serial收集器的多线程版本。（工作线程仍要暂停）</p>
<p>ParNew收集器是许多运行在 Server 模式下的虚拟机的首要选择，除了 Serial 收集器外，只有它能与 CMS 收集器（真正意义上的并发收集器）配合工作。</p>
</li>
<li><p><strong>Parallel Scavenge收集器</strong> （并行清理收集器）（JDK1.8默认收集器）</p>
<p>Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。</p>
<p>所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。 Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量。</p>
</li>
<li><p>Serial Old收集器 ：Serial收集器的老年代版本</p>
</li>
<li><p>Parallel Old收集器 ：Parallel Scavenge收集器的老年代版本。</p>
</li>
<li><p><strong>CMS收集器</strong></p>
<p><strong>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。</strong> </p>
<p>（ 是HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。）</p>
<p>采用“标记-清除”算法实现，运行过程分四步：</p>
<ol>
<li><strong>初始标记：</strong> 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；</li>
<li><strong>并发标记：</strong> 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但因为用户线程可能会不断的更新引用域，所以这个闭包结构并不能保证包含当前所有的可达对象。所以此算法在这阶段会跟踪记录这些发生引用更新的地方。</li>
<li><strong>重新标记：</strong> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，比并发标记阶段时间短很多。</li>
<li><strong>并发清除：</strong> 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。</li>
</ol>
<p>优点： 并发收集，低停顿</p>
<p>缺点：对CPU资源敏感；无法处理浮动垃圾；会产生碎片空间。</p>
</li>
<li><p><strong>G1收集器</strong></p>
<p>G1 (Garbage-First) 是一款面向服务器的垃圾收集器, 主要针对配备多颗处理器及大容量内存的机器。 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征。</p>
<p>特点：并行＋并发（利用多个CPU优势），空间整合（标记－整理算法），可预测停顿时间</p>
<p>步骤：初始标记——并发标记——最终标记——筛选回收</p>
<blockquote>
<p><strong>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)</strong> 。</p>
<p>这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）</p>
</blockquote>
</li>
</ul>
<h3 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h3><p>根据 Java 虚拟机规范，Class 文件通过 <code>ClassFile</code> 定义，有点类似 C 语言的结构体。</p>
<p>ClassFile 的结构如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4             		magic;	 <span class="comment">//Class 文件的标志(魔数)</span></span><br><span class="line">    u2             		minor_version;	<span class="comment">//Class 的小版本号</span></span><br><span class="line">    u2             		major_version;	<span class="comment">//Class 的大版本号</span></span><br><span class="line">    u2             		constant_pool_count;	<span class="comment">//常量池的数量</span></span><br><span class="line">    cp_info        	  constant_pool[constant_pool_count-<span class="number">1</span>];	<span class="comment">//常量池</span></span><br><span class="line">    u2             		access_flags;	<span class="comment">//Class 的访问标记</span></span><br><span class="line">    u2             		this_class;	<span class="comment">//当前类</span></span><br><span class="line">    u2             		super_class;	<span class="comment">//父类</span></span><br><span class="line">    u2             		interfaces_count;	<span class="comment">//接口</span></span><br><span class="line">    u2             		interfaces[interfaces_count];	<span class="comment">//一个类可以实现多个接口</span></span><br><span class="line">    u2             		fields_count;	<span class="comment">//Class 文件的字段属性</span></span><br><span class="line">    field_info 		  fields[fields_count];	<span class="comment">//一个类可以有多个字段</span></span><br><span class="line">    u2             		methods_count;	<span class="comment">//Class 文件的方法数量</span></span><br><span class="line">    method_info    methods[methods_count];	<span class="comment">//一个类可以有个多个方法</span></span><br><span class="line">    u2             		attributes_count;	<span class="comment">//此类的属性表中的属性数</span></span><br><span class="line">    attribute_info  attributes[attributes_count];	<span class="comment">//属性表集合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>魔数 Magic Number</p>
<p>每个 Class 文件的头 4 个字节称为魔数（Magic Number）,它的唯一作用是<strong>确定这个文件是否为一个能被虚拟机接收的 Class 文件</strong>。</p>
</li>
<li><p>Class文件版本号 Minor&amp;Major Version</p>
<p>紧接着魔数的四个字节存储的是 Class 文件的版本号：第 5 和第 6 位是<strong>次版本号</strong>，第 7 和第 8 位是<strong>主版本号</strong>。</p>
<p>当 Java 发布大版本（比如 Java 8，Java9）的时候，主版本号都会加 1。使用 <code>javap -v</code> 命令可以快速查看 Class 文件的版本号信息。</p>
<blockquote>
<p>高版本的 Java 虚拟机可以执行低版本编译器生成的 Class 文件，但是低版本的 Java 虚拟机不能执行高版本编译器生成的 Class 文件。</p>
</blockquote>
</li>
<li><p>常量池 Constant Pool</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             constant_pool_count;<span class="comment">//常量池的数量</span></span><br><span class="line">cp_info      constant_pool[constant_pool_count-<span class="number">1</span>];<span class="comment">//常量池</span></span><br></pre></td></tr></table></figure>

<p>注：常量池计数器是从 1 开始计数的，索引值为 0 代表“不引用任何一个常量池项”。</p>
<p>常量池存放两大常量： <strong>字面量</strong>和<strong>符号引用</strong>， </p>
<ul>
<li>字面量： 可以说是常量，如文本字符串，声明为final的常量值等。</li>
<li>符号引用：属于编译原理方面的概念，有三类：<ul>
<li>类和接口 的全限定名</li>
<li>字段 的名称和描述符</li>
<li>方法 的名称和描述符</li>
</ul>
</li>
</ul>
<blockquote>
<p><code>.class</code> 文件可以通过<code>javap -v class类名</code> 指令来看一下其常量池中的信息(<code>javap -v class类名-&gt; temp.txt</code> ：将结果输出到 temp.txt 文件)。</p>
</blockquote>
</li>
<li><p>访问标志 Access Flags</p>
<p>这个标志用于识别一些类或接口层次的访问信息，如：这个 Class 是类还是接口，是否为 public 或者 abstract 类型，如果是类的话是否声明为 final 等等。</p>
<blockquote>
<p>通过<code>javap -v class类名</code> 指令来看一下类的访问标志。</p>
</blockquote>
</li>
<li><p>当前类（This Class）、父类（Super Class）、接口（Interfaces）索引集合</p>
<p>Java 类的<code>继承关系</code>由类索引、父类索引和接口索引集合三项确定。</p>
<p>类索引确定这个类的全限定名，父类索引确定这个类的父类的全限定名，由于 Java 语言的单继承，所以父类索引只有一个，除了 <code>java.lang.Object</code> 之外，所有的 Java 类都有父类，因此除了 <code>java.lang.Object</code> 外，所有 Java 类的父类索引都不为 0。</p>
<p>接口索引集合用来描述这个类实现了那些接口。</p>
</li>
<li><p>字段表集合 Fields</p>
<p>用于描述 接口或类 中声明的变量。包括类的变量和实例变量，不包括方法内的局部变量。</p>
<p>field info（字段表）的结构：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">field_info &#123;</span><br><span class="line">    u2					access_flags;	<span class="comment">// 作用域</span></span><br><span class="line">    u2					name_index;		<span class="comment">// 字段名称(引用)</span></span><br><span class="line">    u2					descriptor_index;	<span class="comment">// 字段和方法的描述符(引用)</span></span><br><span class="line">    u2					attributes_count;	<span class="comment">// 属性个数</span></span><br><span class="line">    attribute_info	attributes[attributes_count];	<span class="comment">//属性集合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>access_flags:</strong> 字段的作用域（<code>public</code> ,<code>private</code>,<code>protected</code>修饰符），是实例变量还是类变量（<code>static</code>修饰符）,可否被序列化（transient 修饰符）,可变性（final）,可见性（volatile 修饰符，是否强制从主内存读写）。</li>
<li><strong>name_index:</strong> 对常量池的引用，表示的字段的名称；</li>
<li><strong>descriptor_index:</strong> 对常量池的引用，表示字段和方法的描述符；</li>
<li><strong>attributes_count:</strong> 一个字段还会拥有一些额外的属性，attributes_count 存放属性的个数；</li>
<li><strong>attributes[attributes_count]:</strong> 存放具体属性具体内容。</li>
</ul>
</li>
<li><p>方法集合 Methods</p>
<p>Class文件中对方法的描述和字段的描述几乎一致。</p>
</li>
<li><p>属性表集合 Attributes</p>
<p>在 Class 文件，字段表，方法表中都可以携带自己的属性表集合，以用于描述某些场景专有的信息。</p>
<p>Class 文件中不要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复即可。</p>
</li>
</ul>
<h3 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h3><p>从加载到虚拟机内存开始，到卸载出内存，类的生命周期为：</p>
<ul>
<li><strong>加载</strong></li>
<li>链接<ul>
<li><strong>验证</strong></li>
<li><strong>准备</strong></li>
<li><strong>解析</strong></li>
</ul>
</li>
<li><strong>初始化</strong></li>
<li>使用</li>
<li>卸载</li>
</ul>
<p>Class文件需要加载到虚拟机中才能运行和使用，系统加载Class文件的步骤： 加载——链接(验证, 准备, 解析)——初始化</p>
<hr>
<ul>
<li><p><strong>加载</strong> ：</p>
<p>主要完成3件事：</p>
<ol>
<li>通过全类名获取定义此类的二进制字节流</li>
<li>将字节流所代表的静态存储结构 转换为 方法区的运行时数据结构。</li>
<li>在内存中生成一个代表该类的Class对象，作为访问入口。</li>
</ol>
<p>这个过程是由类加载器完成的， 每个Java类都有一个引用指向自己的ClassLoader。  不过，数组类不是ClassLoader创建的，而是JVM在需要时自动创建，且数组通过 getClassLoader() 获取到的是数组内元素的类加载器</p>
</li>
<li><p>**验证： **</p>
<p>确保Class文件中的字节流信息符合《Java虚拟机规范》的全部要求。</p>
<p>验证阶段在整个类加载过程中耗费的资源较多，但从程序安全来讲是有必要的。（如果程序已经被反复使用或验证过，可以使用<code>-Xverify:none</code> 参数来关闭大部分的类验证措施，以缩短类加载时间）</p>
<p>主要由四个验证阶段组成：</p>
<ol>
<li>文件格式验证 —— Class文件格式检查</li>
<li>元数据验证 —— 字节码语义检查（是否有父类，是否继承了final修饰的类。。）</li>
<li>字节码验证 —— 程序语义检查（函数参数正确性，对象类型转换是否合理。。）</li>
<li>符号引用验证 —— 类的正确性检查（类中使用的其他类、方法、字段是否存在，访问权限是否正确）</li>
</ol>
<blockquote>
<p><code>第一步的文件格式是基于类的二进制字节流进行的， 保证输入的字节流能正确解析并存储到方法区。</code></p>
<p>其他三个阶段的验证都是在方法区的存储结构上进行的，不再读取、操作字节流。</p>
</blockquote>
</li>
<li><p><strong>准备：</strong></p>
<p>为类变量分配内存并设置初始值，这些内存都在方法区中分配。要注意的是：</p>
<ul>
<li><p>进行内存分配的仅有 类变量（static修饰的静态变量），不包括实例变量。（实例变量会随对象实例化一起分配到Java堆中）</p>
</li>
<li><p>理论上，类变量的内存都应该在方法区中分配。</p>
<p>JDK1.7之前，用永久代实现方法区时，确实是在方法区中分配类变量的内存的。</p>
<p>JDK1.7及之后，HotSpot把永久代中的字符串常量池，静态变量移到堆中，此时，类变量是随Class对象一起放在Java堆中的。</p>
</li>
</ul>
</li>
<li><p><strong>解析：</strong></p>
<p>虚拟机将 常量池中的符号引用替换为直接引用的过程。解析动作主要针对 类和接口、字段、类方法、接口方法、方法类型、方法句柄、调用限定符 这7种符号引用进行的。</p>
<blockquote>
<ul>
<li>符号引用： 用符号&#x2F;文字描述目标，是一种抽象的引用方式，只描述名字，不指明在内存中的具体位置。</li>
<li>直接引用：具体的引用方式，包含了目标在内存中的地址或偏移量等信息，可以直接访问具体内存或执行代码。</li>
</ul>
<p>所以，Java虚拟机在执行Java代码时，需要将符号引用解析为直接引用，才能真正地访问数据和执行代码。</p>
</blockquote>
</li>
<li><p><strong>初始化：</strong></p>
<p>此阶段执行初始化方法 &lt;clinit&gt;()，是类加载的最后一步，此时JVM开始真正执行类中定义的Java程序代码（字节码）。（&lt;clinit&gt;()是编译后自动生成的）</p>
<p>JVM严格规范了只有以下5种情况，才会进行初始化：</p>
<ol>
<li>遇到 new，getstatic，putstatic，invokestatic 这4条直接指令码时。</li>
</ol>
<ul>
<li>new指令： 创建一个类的实例对象。</li>
<li>getstatic指令：程序访问类的静态变量。（不是静态常量，常量是加载到运行时常量池）</li>
<li>putstatic指令：程序给类的静态变量赋值。</li>
<li>invokestatic指令：程序调用类的静态方法。</li>
</ul>
<ol start="2">
<li>使用 java.lang.reflect 包的方法对类进行反射调用，如Class.forname(“…”)，newInstance()等， 需要初始化。</li>
<li>初始化时，如果父类还未初始化，则先进行父类的初始化。</li>
<li>当虚拟机启动时，用户需要定义一个要执行的主类（要有main方法），虚拟机会先初始化这个类。</li>
<li>MethodHandle 和 VarHandle 可以看作是轻量级的反射调用机制，而要想使用这 2 个调用， 就必须先使用 findStaticVarHandle 来初始化要调用的类。</li>
</ol>
</li>
<li><p>类卸载：</p>
<p>满足以下3个要求，类才可被卸载：</p>
<ul>
<li>该类的所有实例对象都已被GC。</li>
<li>该类没有在其他地方被引用。</li>
<li>该类的类加载器的实例已被GC。</li>
</ul>
<p>注：在JVM的生命周期内，JVM自带的类加载器 BootstrapClassLoader, ExtClassLoader, AppClassLoader 负责加载 JDK 提供的类，这几个类加载器的实例是不会被回收的，所以它们加载的类是不会被卸载的。</p>
</li>
</ul>
<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>类加载器是一个负责加载类的对象，用于实现类加载过程中的”加载”。每个Java类都有一个引用指向加载它的ClassLoader。（数组类没有对应的二进制字节流，不是由ClassLoader创建的，而是由JVM直接生成）</p>
<ul>
<li>主要作用：加载Java类的字节码文件到JVM中（在内存中生成一个代表该类的Class对象）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Class</span>&lt;T&gt; &#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader classLoader;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@CallerSensitive</span></span><br><span class="line">    <span class="keyword">public</span> ClassLoader <span class="title function_">getClassLoader</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其实除了加载类之外，类加载器还可以加载 Java 应用所需的资源如文本、图像、配置文件、视频等等文件资源。</p>
</blockquote>
<ul>
<li><p>类加载器的加载规则</p>
<p>JVM启动的时候，并不会一次性加载所有类，而是按需加载。</p>
<p>对于已经加载的类会被放在 <code>ClassLoader</code> 中。在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。也就是说，对于一个类加载器来说，相同二进制名称的类只会被加载一次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 由这个类加载器加载的类。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Vector&lt;Class&lt;?&gt;&gt; classes = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 由VM调用，用此类加载器记录每个已加载类。</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addClass</span><span class="params">(Class&lt;?&gt; c)</span> &#123;</span><br><span class="line">        classes.addElement(c);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>JVM内置的三个重要的ClassLoader：</p>
<ul>
<li><p><strong><code>BootstrapClassLoader</code>(启动类加载器)</strong> ：</p>
<p>最顶层的加载类，由 C++实现，通常表示为 null，并且没有父级，主要用来加载 JDK 内部的核心类库 以及被 -Xbootclasspath参数指定的路径下的所有类。</p>
<blockquote>
<p>JDK内部的核心类库指 %JAVA_HOME%&#x2F;lib目录下的 rt.jar 、resources.jar 、charsets.jar等 jar 包和类。</p>
<p>rt.jar：是Java基础类库，包含java doc里看到的所有类的类文件，即常用的内置库都在里面，如java.util.*, java.io.*, java.lang.*, java.nio.*等。（rt指RunTime）</p>
</blockquote>
</li>
<li><p><strong><code>ExtensionClassLoader</code>(扩展类加载器)</strong> ：</p>
<p>主要负责加载 %JRE_HOME%&#x2F;lib&#x2F;ext 目录下的 jar 包和类以及被 java.ext.dirs 系统变量所指定的路径下的所有类。</p>
</li>
<li><p><strong><code>AppClassLoader</code>(应用程序类加载器)</strong> ：</p>
<p>面向用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。</p>
</li>
</ul>
</li>
<li><p>加载方式：</p>
<p>ClassLoader有两个关键方法：</p>
<ul>
<li><p><code>protected Class loadClass(String name, boolean resolve)</code>：</p>
<p>加载指定二进制名称的类，实现了双亲委派机制 。<code>name</code> 为类的二进制名称，resove 如果为 true，在加载时调用 resolveClass(Class&lt;?&gt; c) 方法解析该类。</p>
</li>
<li><p><code>protected Class findClass(String name)</code>：</p>
<p>根据类的二进制名称来查找类，默认实现是空方法。</p>
</li>
</ul>
<p>当我们自定义类加载器时，如果不想打破双亲委派模型，就只重写findClass()方法即可，使无法被父类加载器加载的类通过这个方法加载。 要打破双亲委派模型就要重写 loadClass()方法。</p>
<p>—— <strong>双亲委派模型</strong></p>
<p>ClassLoader类使用委托模型来搜索类和资源， ClassLoader实例在自己搜索类和资源前，会先将搜索任务委托给父类加载器，一直往上委托直到顶层启动类加载器。 然后从顶层开始往下，各加载器会返回自己能加载的类。</p>
<ul>
<li>大致逻辑：每当一个类加载器接收到加载请求时，它会先将请求转发给父类加载器。在父类加载器没有找到所请求的类的情况下，该类加载器才会尝试去加载。</li>
</ul>
<ul>
<li>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。</li>
</ul>
<ul>
<li><p>类加载器之间的父子关系一般不是以继承的关系来实现的，而是通常使用组合关系来复用父加载器的代码。（设计原则：组合优于继承）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="comment">// 组合</span></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br><span class="line">    </span><br><span class="line">      <span class="keyword">protected</span> <span class="title function_">ClassLoader</span><span class="params">(ClassLoader parent)</span> &#123;</span><br><span class="line">           <span class="built_in">this</span>(checkCreateClassLoader(), parent);</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>好处：可以避免类的重复加载（JVM根据类名，类加载器区分不同的类。相同的类文件如果被不同类加载器加载，产生的也是不同的类，会造成混乱。）</p>
</li>
</ul>
<p>双亲委派模型的执行流程（java.lang.ClassLoader的loadClass()方法）：</p>
<ol>
<li>在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载（每个父类加载器都会走一遍这个流程）。</li>
<li>类加载器在进行类加载的时候，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成（调用父加载器 <code>loadClass()</code>方法来加载类）。这样的话，所有的请求最终都会传送到顶层的启动类加载器 BootstrapClassLoader 中。</li>
<li>只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载（调用自己的 <code>findClass()</code> 方法来加载类）。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">//首先，检查该类是否已经加载过</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果 c 为 null，则说明该类没有被加载过</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//当父类的加载器不为空，则通过父类的loadClass来加载该类</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//当父类的加载器为空，则调用启动类加载器来加载该类</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">//非空父类的类加载器无法找到相应的类，则抛出异常</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//当父类加载器无法加载时，则调用findClass方法来加载该类</span></span><br><span class="line">                <span class="comment">//用户可通过覆写该方法，来自定义类加载器</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//用于统计类加载器相关的信息</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            <span class="comment">//对类进行link操作</span></span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">ValcanoZz</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/02/25/%E7%9F%A5%E8%AF%86%E7%82%B9%E2%80%94Java/">http://example.com/2023/02/25/%E7%9F%A5%E8%AF%86%E7%82%B9%E2%80%94Java/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">ValcanoZz Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/Notes/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/">知识点</a></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/Notes/2023/03/05/%E7%9F%A5%E8%AF%86%E7%82%B9%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93/"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/Notes/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">知识点—数据库</div></div></a></div><div class="next-post pull-right"><a href="/Notes/2022/12/25/%E9%A1%B9%E7%9B%AE%E2%80%94RPC%E6%A1%86%E6%9E%B6/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/Notes/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">RPC框架</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/Notes/2023/03/15/%E7%9F%A5%E8%AF%86%E7%82%B9%E2%80%94%E6%A1%86%E6%9E%B6/" title="知识点—框架"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-15</div><div class="title">知识点—框架</div></div></a></div><div><a href="/Notes/2023/03/05/%E7%9F%A5%E8%AF%86%E7%82%B9%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93/" title="知识点—数据库"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-05</div><div class="title">知识点—数据库</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC81NjA4NS8zMjU0OA=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">1.</span> <span class="toc-text">Java知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">1.1.</span> <span class="toc-text">基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.1.</span> <span class="toc-text">基础概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.2.</span> <span class="toc-text">语法、数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.1.3.</span> <span class="toc-text">面向对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%B1%BB"><span class="toc-number">1.1.4.</span> <span class="toc-text">常见类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Object"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">Object</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">String</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">1.1.5.</span> <span class="toc-text">异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">1.1.6.</span> <span class="toc-text">泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-number">1.1.7.</span> <span class="toc-text">反射</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.7.1.</span> <span class="toc-text">反射操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.7.2.</span> <span class="toc-text">常用方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.1.8.</span> <span class="toc-text">注解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%83%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.1.8.1.</span> <span class="toc-text">元注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%E5%B1%9E%E6%80%A7"><span class="toc-number">1.1.8.2.</span> <span class="toc-text">注解属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E9%A2%84%E7%BD%AE%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.1.8.3.</span> <span class="toc-text">Java预置注解</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SPI"><span class="toc-number">1.1.9.</span> <span class="toc-text">SPI</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E8%B7%B5"><span class="toc-number">1.1.9.1.</span> <span class="toc-text">实践</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E6%96%B9"><span class="toc-number">1.1.9.1.1.</span> <span class="toc-text">调用方</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9"><span class="toc-number">1.1.9.1.2.</span> <span class="toc-text">实现方</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">1.1.10.</span> <span class="toc-text">序列化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I-x2F-O"><span class="toc-number">1.1.11.</span> <span class="toc-text">I&#x2F;O</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E7%B3%96"><span class="toc-number">1.1.12.</span> <span class="toc-text">语法糖</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-number">1.2.</span> <span class="toc-text">集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.1.</span> <span class="toc-text">底层数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.2.2.</span> <span class="toc-text">排序接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%8F%E8%BF%B0%E4%B8%8E%E6%AF%94%E8%BE%83"><span class="toc-number">1.2.3.</span> <span class="toc-text">描述与比较</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91"><span class="toc-number">1.3.</span> <span class="toc-text">并发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.3.1.</span> <span class="toc-text">进程和线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.3.2.</span> <span class="toc-text">多线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">1.3.3.</span> <span class="toc-text">乐观锁和悲观锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized"><span class="toc-number">1.3.4.</span> <span class="toc-text">synchronized</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLocal"><span class="toc-number">1.3.5.</span> <span class="toc-text">ThreadLocal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">1.3.6.</span> <span class="toc-text">线程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS"><span class="toc-number">1.3.7.</span> <span class="toc-text">AQS</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM"><span class="toc-number">1.4.</span> <span class="toc-text">JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.4.1.</span> <span class="toc-text">Java内存区域详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%92%E5%88%86"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">内存划分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%8C%BA%E5%9F%9F"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">线程区域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">堆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="toc-number">1.4.1.4.</span> <span class="toc-text">方法区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98"><span class="toc-number">1.4.1.5.</span> <span class="toc-text">直接内存</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="toc-number">1.4.2.</span> <span class="toc-text">对象创建过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">1.4.3.</span> <span class="toc-text">垃圾回收机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E4%BA%A1%E5%AF%B9%E8%B1%A1%E5%88%A4%E6%96%AD"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">死亡对象判断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">引用类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="toc-number">1.4.3.3.</span> <span class="toc-text">垃圾收集算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">1.4.3.4.</span> <span class="toc-text">垃圾收集器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.4.</span> <span class="toc-text">类文件结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.4.5.</span> <span class="toc-text">类的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">1.4.6.</span> <span class="toc-text">类加载器</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2023 By ValcanoZz</div><div class="footer_custom_text"><div><a onclick="window.open('https://beian.miit.gov.cn/#/Integrated/index')" >粤ICP备2022110986号-1</a></div></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/Notes/js/utils.js"></script><script src="/Notes/js/main.js"></script><script src="/Notes/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/Notes/js/search/local-search.js"></script><div class="js-pjax"><script>function loadLivere () {
  if (typeof LivereTower === 'object') {
    window.LivereTower.init()
  }
  else {
    (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
    })(document, 'script');
  }
}

if ('Livere' === 'Livere' || !false) {
  if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
  else loadLivere()
}
else {
  function loadOtherComment () {
    loadLivere()
  }
}</script></div><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>